"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-model";
exports.ids = ["vendor-chunks/prosemirror-model"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* binding */ ContentMatch),\n/* harmony export */   DOMParser: () => (/* binding */ DOMParser),\n/* harmony export */   DOMSerializer: () => (/* binding */ DOMSerializer),\n/* harmony export */   Fragment: () => (/* binding */ Fragment),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   MarkType: () => (/* binding */ MarkType),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodeRange: () => (/* binding */ NodeRange),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   ReplaceError: () => (/* binding */ ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* binding */ ResolvedPos),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   Slice: () => (/* binding */ Slice)\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ \"(ssr)/./node_modules/orderedmap/dist/index.js\");\n\nfunction findDiffStart(a, b, pos) {\n    for(let i = 0;; i++){\n        if (i == a.childCount || i == b.childCount) return a.childCount == b.childCount ? null : pos;\n        let childA = a.child(i), childB = b.child(i);\n        if (childA == childB) {\n            pos += childA.nodeSize;\n            continue;\n        }\n        if (!childA.sameMarkup(childB)) return pos;\n        if (childA.isText && childA.text != childB.text) {\n            for(let j = 0; childA.text[j] == childB.text[j]; j++)pos++;\n            return pos;\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffStart(childA.content, childB.content, pos + 1);\n            if (inner != null) return inner;\n        }\n        pos += childA.nodeSize;\n    }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n    for(let iA = a.childCount, iB = b.childCount;;){\n        if (iA == 0 || iB == 0) return iA == iB ? null : {\n            a: posA,\n            b: posB\n        };\n        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n        if (childA == childB) {\n            posA -= size;\n            posB -= size;\n            continue;\n        }\n        if (!childA.sameMarkup(childB)) return {\n            a: posA,\n            b: posB\n        };\n        if (childA.isText && childA.text != childB.text) {\n            let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n            while(same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]){\n                same++;\n                posA--;\n                posB--;\n            }\n            return {\n                a: posA,\n                b: posB\n            };\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n            if (inner) return inner;\n        }\n        posA -= size;\n        posB -= size;\n    }\n}\n/**\nA fragment represents a node's collection of child nodes.\n\nLike nodes, fragments are persistent data structures, and you\nshould not mutate them or their content. Rather, you create new\ninstances whenever needed. The API tries to make this easy.\n*/ class Fragment {\n    /**\n    @internal\n    */ constructor(/**\n    The child nodes in this fragment.\n    */ content, size){\n        this.content = content;\n        this.size = size || 0;\n        if (size == null) for(let i = 0; i < content.length; i++)this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn't descend\n    into a node when the callback returns `false`.\n    */ nodesBetween(from, to, f, nodeStart = 0, parent) {\n        for(let i = 0, pos = 0; pos < to; i++){\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n                let start = pos + 1;\n                child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n            }\n            pos = end;\n        }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */ descendants(f) {\n        this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */ textBetween(from, to, blockSeparator, leafText) {\n        let text = \"\", first = true;\n        this.nodesBetween(from, to, (node, pos)=>{\n            let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos) : !node.isLeaf ? \"\" : leafText ? typeof leafText === \"function\" ? leafText(node) : leafText : node.type.spec.leafText ? node.type.spec.leafText(node) : \"\";\n            if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n                if (first) first = false;\n                else text += blockSeparator;\n            }\n            text += nodeText;\n        }, 0);\n        return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */ append(other) {\n        if (!other.size) return this;\n        if (!this.size) return other;\n        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n        if (last.isText && last.sameMarkup(first)) {\n            content[content.length - 1] = last.withText(last.text + first.text);\n            i = 1;\n        }\n        for(; i < other.content.length; i++)content.push(other.content[i]);\n        return new Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */ cut(from, to = this.size) {\n        if (from == 0 && to == this.size) return this;\n        let result = [], size = 0;\n        if (to > from) for(let i = 0, pos = 0; pos < to; i++){\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from) {\n                if (pos < from || end > to) {\n                    if (child.isText) child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n                    else child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n                }\n                result.push(child);\n                size += child.nodeSize;\n            }\n            pos = end;\n        }\n        return new Fragment(result, size);\n    }\n    /**\n    @internal\n    */ cutByIndex(from, to) {\n        if (from == to) return Fragment.empty;\n        if (from == 0 && to == this.content.length) return this;\n        return new Fragment(this.content.slice(from, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */ replaceChild(index, node) {\n        let current = this.content[index];\n        if (current == node) return this;\n        let copy = this.content.slice();\n        let size = this.size + node.nodeSize - current.nodeSize;\n        copy[index] = node;\n        return new Fragment(copy, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */ addToStart(node) {\n        return new Fragment([\n            node\n        ].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */ addToEnd(node) {\n        return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */ eq(other) {\n        if (this.content.length != other.content.length) return false;\n        for(let i = 0; i < this.content.length; i++)if (!this.content[i].eq(other.content[i])) return false;\n        return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */ get firstChild() {\n        return this.content.length ? this.content[0] : null;\n    }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */ get lastChild() {\n        return this.content.length ? this.content[this.content.length - 1] : null;\n    }\n    /**\n    The number of child nodes in this fragment.\n    */ get childCount() {\n        return this.content.length;\n    }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */ child(index) {\n        let found = this.content[index];\n        if (!found) throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n        return found;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */ maybeChild(index) {\n        return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */ forEach(f) {\n        for(let i = 0, p = 0; i < this.content.length; i++){\n            let child = this.content[i];\n            f(child, p, i);\n            p += child.nodeSize;\n        }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */ findDiffStart(other, pos = 0) {\n        return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */ findDiffEnd(other, pos = this.size, otherPos = other.size) {\n        return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. @internal\n    */ findIndex(pos) {\n        if (pos == 0) return retIndex(0, pos);\n        if (pos == this.size) return retIndex(this.content.length, pos);\n        if (pos > this.size || pos < 0) throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n        for(let i = 0, curPos = 0;; i++){\n            let cur = this.child(i), end = curPos + cur.nodeSize;\n            if (end >= pos) {\n                if (end == pos) return retIndex(i + 1, end);\n                return retIndex(i, curPos);\n            }\n            curPos = end;\n        }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */ toString() {\n        return \"<\" + this.toStringInner() + \">\";\n    }\n    /**\n    @internal\n    */ toStringInner() {\n        return this.content.join(\", \");\n    }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */ toJSON() {\n        return this.content.length ? this.content.map((n)=>n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */ static fromJSON(schema, value) {\n        if (!value) return Fragment.empty;\n        if (!Array.isArray(value)) throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n        return new Fragment(value.map(schema.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */ static fromArray(array) {\n        if (!array.length) return Fragment.empty;\n        let joined, size = 0;\n        for(let i = 0; i < array.length; i++){\n            let node = array[i];\n            size += node.nodeSize;\n            if (i && node.isText && array[i - 1].sameMarkup(node)) {\n                if (!joined) joined = array.slice(0, i);\n                joined[joined.length - 1] = node.withText(joined[joined.length - 1].text + node.text);\n            } else if (joined) {\n                joined.push(node);\n            }\n        }\n        return new Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */ static from(nodes) {\n        if (!nodes) return Fragment.empty;\n        if (nodes instanceof Fragment) return nodes;\n        if (Array.isArray(nodes)) return this.fromArray(nodes);\n        if (nodes.attrs) return new Fragment([\n            nodes\n        ], nodes.nodeSize);\n        throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" + (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n}\n/**\nAn empty fragment. Intended to be reused whenever a node doesn't\ncontain anything (rather than allocating a new empty fragment for\neach leaf node).\n*/ Fragment.empty = new Fragment([], 0);\nconst found = {\n    index: 0,\n    offset: 0\n};\nfunction retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n}\nfunction compareDeep(a, b) {\n    if (a === b) return true;\n    if (!(a && typeof a == \"object\") || !(b && typeof b == \"object\")) return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array) return false;\n    if (array) {\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++)if (!compareDeep(a[i], b[i])) return false;\n    } else {\n        for(let p in a)if (!(p in b) || !compareDeep(a[p], b[p])) return false;\n        for(let p in b)if (!(p in a)) return false;\n    }\n    return true;\n}\n/**\nA mark is a piece of information that can be attached to a node,\nsuch as it being emphasized, in code font, or a link. It has a\ntype and optionally a set of attributes that provide further\ninformation (such as the target of the link). Marks are created\nthrough a `Schema`, which controls which types exist and which\nattributes they have.\n*/ class Mark {\n    /**\n    @internal\n    */ constructor(/**\n    The type of this mark.\n    */ type, /**\n    The attributes associated with this mark.\n    */ attrs){\n        this.type = type;\n        this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */ addToSet(set) {\n        let copy, placed = false;\n        for(let i = 0; i < set.length; i++){\n            let other = set[i];\n            if (this.eq(other)) return set;\n            if (this.type.excludes(other.type)) {\n                if (!copy) copy = set.slice(0, i);\n            } else if (other.type.excludes(this.type)) {\n                return set;\n            } else {\n                if (!placed && other.type.rank > this.type.rank) {\n                    if (!copy) copy = set.slice(0, i);\n                    copy.push(this);\n                    placed = true;\n                }\n                if (copy) copy.push(other);\n            }\n        }\n        if (!copy) copy = set.slice();\n        if (!placed) copy.push(this);\n        return copy;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */ removeFromSet(set) {\n        for(let i = 0; i < set.length; i++)if (this.eq(set[i])) return set.slice(0, i).concat(set.slice(i + 1));\n        return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */ isInSet(set) {\n        for(let i = 0; i < set.length; i++)if (this.eq(set[i])) return true;\n        return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */ eq(other) {\n        return this == other || this.type == other.type && compareDeep(this.attrs, other.attrs);\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */ toJSON() {\n        let obj = {\n            type: this.type.name\n        };\n        for(let _ in this.attrs){\n            obj.attrs = this.attrs;\n            break;\n        }\n        return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */ static fromJSON(schema, json) {\n        if (!json) throw new RangeError(\"Invalid input for Mark.fromJSON\");\n        let type = schema.marks[json.type];\n        if (!type) throw new RangeError(`There is no mark type ${json.type} in this schema`);\n        let mark = type.create(json.attrs);\n        type.checkAttrs(mark.attrs);\n        return mark;\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */ static sameSet(a, b) {\n        if (a == b) return true;\n        if (a.length != b.length) return false;\n        for(let i = 0; i < a.length; i++)if (!a[i].eq(b[i])) return false;\n        return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */ static setFrom(marks) {\n        if (!marks || Array.isArray(marks) && marks.length == 0) return Mark.none;\n        if (marks instanceof Mark) return [\n            marks\n        ];\n        let copy = marks.slice();\n        copy.sort((a, b)=>a.type.rank - b.type.rank);\n        return copy;\n    }\n}\n/**\nThe empty set of marks.\n*/ Mark.none = [];\n/**\nError type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when\ngiven an invalid replacement.\n*/ class ReplaceError extends Error {\n}\n/*\nReplaceError = function(this: any, message: string) {\n  let err = Error.call(this, message)\n  ;(err as any).__proto__ = ReplaceError.prototype\n  return err\n} as any\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n*/ /**\nA slice represents a piece cut out of a larger document. It\nstores not only a fragment, but also the depth up to which nodes on\nboth side are ‘open’ (cut through).\n*/ class Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can't be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema's content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */ constructor(/**\n    The slice's content.\n    */ content, /**\n    The open depth at the start of the fragment.\n    */ openStart, /**\n    The open depth at the end.\n    */ openEnd){\n        this.content = content;\n        this.openStart = openStart;\n        this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */ get size() {\n        return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */ insertAt(pos, fragment) {\n        let content = insertInto(this.content, pos + this.openStart, fragment);\n        return content && new Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */ removeBetween(from, to) {\n        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */ eq(other) {\n        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */ toString() {\n        return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */ toJSON() {\n        if (!this.content.size) return null;\n        let json = {\n            content: this.content.toJSON()\n        };\n        if (this.openStart > 0) json.openStart = this.openStart;\n        if (this.openEnd > 0) json.openEnd = this.openEnd;\n        return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */ static fromJSON(schema, json) {\n        if (!json) return Slice.empty;\n        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n        if (typeof openStart != \"number\" || typeof openEnd != \"number\") throw new RangeError(\"Invalid input for Slice.fromJSON\");\n        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */ static maxOpen(fragment, openIsolating = true) {\n        let openStart = 0, openEnd = 0;\n        for(let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)openStart++;\n        for(let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)openEnd++;\n        return new Slice(fragment, openStart, openEnd);\n    }\n}\n/**\nThe empty slice.\n*/ Slice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from || child.isText) {\n        if (offsetTo != to && !content.child(indexTo).isText) throw new RangeError(\"Removing non-flat range\");\n        return content.cut(0, from).append(content.cut(to));\n    }\n    if (index != indexTo) throw new RangeError(\"Removing non-flat range\");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n        if (parent && !parent.canReplace(index, index, insert)) return null;\n        return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert, child);\n    return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n    if (slice.openStart > $from.depth) throw new ReplaceError(\"Inserted content deeper than insertion position\");\n    if ($from.depth - slice.openStart != $to.depth - slice.openEnd) throw new ReplaceError(\"Inconsistent open depths\");\n    return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n        let inner = replaceOuter($from, $to, slice, depth + 1);\n        return node.copy(node.content.replaceChild(index, inner));\n    } else if (!slice.content.size) {\n        return close(node, replaceTwoWay($from, $to, depth));\n    } else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) {\n        let parent = $from.parent, content = parent.content;\n        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n    } else {\n        let { start, end } = prepareSliceForReplace(slice, $from);\n        return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n}\nfunction checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type)) throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n}\nfunction addNode(child, target) {\n    let last = target.length - 1;\n    if (last >= 0 && child.isText && child.sameMarkup(target[last])) target[last] = child.withText(target[last].text + child.text);\n    else target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n        startIndex = $start.index(depth);\n        if ($start.depth > depth) {\n            startIndex++;\n        } else if ($start.textOffset) {\n            addNode($start.nodeAfter, target);\n            startIndex++;\n        }\n    }\n    for(let i = startIndex; i < endIndex; i++)addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset) addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n        checkJoin(openStart, openEnd);\n        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    } else {\n        if (openStart) addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n        addRange($start, $end, depth, content);\n        if (openEnd) addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n        let type = joinable($from, $to, depth + 1);\n        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n    let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice.content);\n    for(let i = extra - 1; i >= 0; i--)node = $along.node(i).copy(Fragment.from(node));\n    return {\n        start: node.resolveNoCache(slice.openStart + extra),\n        end: node.resolveNoCache(node.content.size - slice.openEnd - extra)\n    };\n}\n/**\nYou can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more\ninformation about it. Objects of this class represent such a\nresolved position, providing various pieces of context\ninformation, and some helper methods.\n\nThroughout this interface, methods that take an optional `depth`\nparameter will interpret undefined as `this.depth` and negative\nnumbers as `this.depth + value`.\n*/ class ResolvedPos {\n    /**\n    @internal\n    */ constructor(/**\n    The position that was resolved.\n    */ pos, /**\n    @internal\n    */ path, /**\n    The offset this position has into its parent node.\n    */ parentOffset){\n        this.pos = pos;\n        this.path = path;\n        this.parentOffset = parentOffset;\n        this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */ resolveDepth(val) {\n        if (val == null) return this.depth;\n        if (val < 0) return this.depth + val;\n        return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */ get parent() {\n        return this.node(this.depth);\n    }\n    /**\n    The root node in which the position was resolved.\n    */ get doc() {\n        return this.node(0);\n    }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */ node(depth) {\n        return this.path[this.resolveDepth(depth) * 3];\n    }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */ index(depth) {\n        return this.path[this.resolveDepth(depth) * 3 + 1];\n    }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */ indexAfter(depth) {\n        depth = this.resolveDepth(depth);\n        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */ start(depth) {\n        depth = this.resolveDepth(depth);\n        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */ end(depth) {\n        depth = this.resolveDepth(depth);\n        return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */ before(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth) throw new RangeError(\"There is no position before the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */ after(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth) throw new RangeError(\"There is no position after the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */ get textOffset() {\n        return this.pos - this.path[this.path.length - 1];\n    }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */ get nodeAfter() {\n        let parent = this.parent, index = this.index(this.depth);\n        if (index == parent.childCount) return null;\n        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n        return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */ get nodeBefore() {\n        let index = this.index(this.depth);\n        let dOff = this.pos - this.path[this.path.length - 1];\n        if (dOff) return this.parent.child(index).cut(0, dOff);\n        return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */ posAtIndex(index, depth) {\n        depth = this.resolveDepth(depth);\n        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n        for(let i = 0; i < index; i++)pos += node.child(i).nodeSize;\n        return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */ marks() {\n        let parent = this.parent, index = this.index();\n        // In an empty parent, return the empty array\n        if (parent.content.size == 0) return Mark.none;\n        // When inside a text node, just return the text node's marks\n        if (this.textOffset) return parent.child(index).marks;\n        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n        // If the `after` flag is true of there is no node before, make\n        // the node after this position the main reference.\n        if (!main) {\n            let tmp = main;\n            main = other;\n            other = tmp;\n        }\n        // Use all marks in the main node, except those that have\n        // `inclusive` set to false and are not present in the other node.\n        let marks = main.marks;\n        for(var i = 0; i < marks.length; i++)if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks))) marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */ marksAcross($end) {\n        let after = this.parent.maybeChild(this.index());\n        if (!after || !after.isInline) return null;\n        let marks = after.marks, next = $end.parent.maybeChild($end.index());\n        for(var i = 0; i < marks.length; i++)if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks))) marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */ sharedDepth(pos) {\n        for(let depth = this.depth; depth > 0; depth--)if (this.start(depth) <= pos && this.end(depth) >= pos) return depth;\n        return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */ blockRange(other = this, pred) {\n        if (other.pos < this.pos) return other.blockRange(this);\n        for(let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)if (other.pos <= this.end(d) && (!pred || pred(this.node(d)))) return new NodeRange(this, other, d);\n        return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */ sameParent(other) {\n        return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */ max(other) {\n        return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */ min(other) {\n        return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */ toString() {\n        let str = \"\";\n        for(let i = 1; i <= this.depth; i++)str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n        return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */ static resolve(doc, pos) {\n        if (!(pos >= 0 && pos <= doc.content.size)) throw new RangeError(\"Position \" + pos + \" out of range\");\n        let path = [];\n        let start = 0, parentOffset = pos;\n        for(let node = doc;;){\n            let { index, offset } = node.content.findIndex(parentOffset);\n            let rem = parentOffset - offset;\n            path.push(node, index, start + offset);\n            if (!rem) break;\n            node = node.child(index);\n            if (node.isText) break;\n            parentOffset = rem - 1;\n            start += offset + 1;\n        }\n        return new ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */ static resolveCached(doc, pos) {\n        let cache = resolveCache.get(doc);\n        if (cache) {\n            for(let i = 0; i < cache.elts.length; i++){\n                let elt = cache.elts[i];\n                if (elt.pos == pos) return elt;\n            }\n        } else {\n            resolveCache.set(doc, cache = new ResolveCache);\n        }\n        let result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);\n        cache.i = (cache.i + 1) % resolveCacheSize;\n        return result;\n    }\n}\nclass ResolveCache {\n    constructor(){\n        this.elts = [];\n        this.i = 0;\n    }\n}\nconst resolveCacheSize = 12, resolveCache = new WeakMap();\n/**\nRepresents a flat range of content, i.e. one that starts and\nends in the same node.\n*/ class NodeRange {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */ constructor(/**\n    A resolved position along the start of the content. May have a\n    `depth` greater than this object's `depth` property, since\n    these are the positions that were used to compute the range,\n    not re-resolved positions directly at its boundaries.\n    */ $from, /**\n    A position along the end of the content. See\n    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).\n    */ $to, /**\n    The depth of the node that this range points into.\n    */ depth){\n        this.$from = $from;\n        this.$to = $to;\n        this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */ get start() {\n        return this.$from.before(this.depth + 1);\n    }\n    /**\n    The position at the end of the range.\n    */ get end() {\n        return this.$to.after(this.depth + 1);\n    }\n    /**\n    The parent node that the range points into.\n    */ get parent() {\n        return this.$from.node(this.depth);\n    }\n    /**\n    The start index of the range in the parent node.\n    */ get startIndex() {\n        return this.$from.index(this.depth);\n    }\n    /**\n    The end index of the range in the parent node.\n    */ get endIndex() {\n        return this.$to.indexAfter(this.depth);\n    }\n}\nconst emptyAttrs = Object.create(null);\n/**\nThis class represents a node in the tree that makes up a\nProseMirror document. So a document is an instance of `Node`, with\nchildren that are also instances of `Node`.\n\nNodes are persistent data structures. Instead of changing them, you\ncreate new ones with the content you want. Old ones keep pointing\nat the old document shape. This is made cheaper by sharing\nstructure between the old and new data as much as possible, which a\ntree shape like this (without back pointers) makes easy.\n\n**Do not** directly mutate the properties of a `Node` object. See\n[the guide](https://prosemirror.net/docs/guide/#doc) for more information.\n*/ class Node {\n    /**\n    @internal\n    */ constructor(/**\n    The type of node that this is.\n    */ type, /**\n    An object mapping attribute names to values. The kind of\n    attributes allowed and required are\n    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.\n    */ attrs, // A fragment holding the node's children.\n    content, /**\n    The marks (things like whether it is emphasized or part of a\n    link) applied to this node.\n    */ marks = Mark.none){\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.content = content || Fragment.empty;\n    }\n    /**\n    The array of this node's child nodes.\n    */ get children() {\n        return this.content.content;\n    }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */ get nodeSize() {\n        return this.isLeaf ? 1 : 2 + this.content.size;\n    }\n    /**\n    The number of children that the node has.\n    */ get childCount() {\n        return this.content.childCount;\n    }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */ child(index) {\n        return this.content.child(index);\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */ maybeChild(index) {\n        return this.content.maybeChild(index);\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */ forEach(f) {\n        this.content.forEach(f);\n    }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */ nodesBetween(from, to, f, startPos = 0) {\n        this.content.nodesBetween(from, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */ descendants(f) {\n        this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */ get textContent() {\n        return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.\n    */ textBetween(from, to, blockSeparator, leafText) {\n        return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */ get firstChild() {\n        return this.content.firstChild;\n    }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */ get lastChild() {\n        return this.content.lastChild;\n    }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */ eq(other) {\n        return this == other || this.sameMarkup(other) && this.content.eq(other.content);\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */ sameMarkup(other) {\n        return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */ hasMarkup(type, attrs, marks) {\n        return this.type == type && compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) && Mark.sameSet(this.marks, marks || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */ copy(content = null) {\n        if (content == this.content) return this;\n        return new Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */ mark(marks) {\n        return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */ cut(from, to = this.content.size) {\n        if (from == 0 && to == this.content.size) return this;\n        return this.copy(this.content.cut(from, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */ slice(from, to = this.content.size, includeParents = false) {\n        if (from == to) return Slice.empty;\n        let $from = this.resolve(from), $to = this.resolve(to);\n        let depth = includeParents ? 0 : $from.sharedDepth(to);\n        let start = $from.start(depth), node = $from.node(depth);\n        let content = node.content.cut($from.pos - start, $to.pos - start);\n        return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */ replace(from, to, slice) {\n        return replace(this.resolve(from), this.resolve(to), slice);\n    }\n    /**\n    Find the node directly after the given position.\n    */ nodeAt(pos) {\n        for(let node = this;;){\n            let { index, offset } = node.content.findIndex(pos);\n            node = node.maybeChild(index);\n            if (!node) return null;\n            if (offset == pos || node.isText) return node;\n            pos -= offset + 1;\n        }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */ childAfter(pos) {\n        let { index, offset } = this.content.findIndex(pos);\n        return {\n            node: this.content.maybeChild(index),\n            index,\n            offset\n        };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */ childBefore(pos) {\n        if (pos == 0) return {\n            node: null,\n            index: 0,\n            offset: 0\n        };\n        let { index, offset } = this.content.findIndex(pos);\n        if (offset < pos) return {\n            node: this.content.child(index),\n            index,\n            offset\n        };\n        let node = this.content.child(index - 1);\n        return {\n            node,\n            index: index - 1,\n            offset: offset - node.nodeSize\n        };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */ resolve(pos) {\n        return ResolvedPos.resolveCached(this, pos);\n    }\n    /**\n    @internal\n    */ resolveNoCache(pos) {\n        return ResolvedPos.resolve(this, pos);\n    }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */ rangeHasMark(from, to, type) {\n        let found = false;\n        if (to > from) this.nodesBetween(from, to, (node)=>{\n            if (type.isInSet(node.marks)) found = true;\n            return !found;\n        });\n        return found;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */ get isBlock() {\n        return this.type.isBlock;\n    }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */ get isTextblock() {\n        return this.type.isTextblock;\n    }\n    /**\n    True when this node allows inline content.\n    */ get inlineContent() {\n        return this.type.inlineContent;\n    }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */ get isInline() {\n        return this.type.isInline;\n    }\n    /**\n    True when this is a text node.\n    */ get isText() {\n        return this.type.isText;\n    }\n    /**\n    True when this is a leaf node.\n    */ get isLeaf() {\n        return this.type.isLeaf;\n    }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */ get isAtom() {\n        return this.type.isAtom;\n    }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */ toString() {\n        if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n        let name = this.type.name;\n        if (this.content.size) name += \"(\" + this.content.toStringInner() + \")\";\n        return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */ contentMatchAt(index) {\n        let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n        if (!match) throw new Error(\"Called contentMatchAt on a node with invalid content\");\n        return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */ canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n        let two = one && one.matchFragment(this.content, to);\n        if (!two || !two.validEnd) return false;\n        for(let i = start; i < end; i++)if (!this.type.allowsMarks(replacement.child(i).marks)) return false;\n        return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */ canReplaceWith(from, to, type, marks) {\n        if (marks && !this.type.allowsMarks(marks)) return false;\n        let start = this.contentMatchAt(from).matchType(type);\n        let end = start && start.matchFragment(this.content, to);\n        return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */ canAppend(other) {\n        if (other.content.size) return this.canReplace(this.childCount, this.childCount, other.content);\n        else return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise an exception when they do not.\n    */ check() {\n        this.type.checkContent(this.content);\n        this.type.checkAttrs(this.attrs);\n        let copy = Mark.none;\n        for(let i = 0; i < this.marks.length; i++){\n            let mark = this.marks[i];\n            mark.type.checkAttrs(mark.attrs);\n            copy = mark.addToSet(copy);\n        }\n        if (!Mark.sameSet(copy, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((m)=>m.type.name)}`);\n        this.content.forEach((node)=>node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */ toJSON() {\n        let obj = {\n            type: this.type.name\n        };\n        for(let _ in this.attrs){\n            obj.attrs = this.attrs;\n            break;\n        }\n        if (this.content.size) obj.content = this.content.toJSON();\n        if (this.marks.length) obj.marks = this.marks.map((n)=>n.toJSON());\n        return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */ static fromJSON(schema, json) {\n        if (!json) throw new RangeError(\"Invalid input for Node.fromJSON\");\n        let marks = undefined;\n        if (json.marks) {\n            if (!Array.isArray(json.marks)) throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n            marks = json.marks.map(schema.markFromJSON);\n        }\n        if (json.type == \"text\") {\n            if (typeof json.text != \"string\") throw new RangeError(\"Invalid text node in JSON\");\n            return schema.text(json.text, marks);\n        }\n        let content = Fragment.fromJSON(schema, json.content);\n        let node = schema.nodeType(json.type).create(json.attrs, content, marks);\n        node.type.checkAttrs(node.attrs);\n        return node;\n    }\n}\nNode.prototype.text = undefined;\nclass TextNode extends Node {\n    /**\n    @internal\n    */ constructor(type, attrs, content, marks){\n        super(type, attrs, null, marks);\n        if (!content) throw new RangeError(\"Empty text nodes are not allowed\");\n        this.text = content;\n    }\n    toString() {\n        if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this);\n        return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() {\n        return this.text;\n    }\n    textBetween(from, to) {\n        return this.text.slice(from, to);\n    }\n    get nodeSize() {\n        return this.text.length;\n    }\n    mark(marks) {\n        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n    withText(text) {\n        if (text == this.text) return this;\n        return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n    cut(from = 0, to = this.text.length) {\n        if (from == 0 && to == this.text.length) return this;\n        return this.withText(this.text.slice(from, to));\n    }\n    eq(other) {\n        return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n        let base = super.toJSON();\n        base.text = this.text;\n        return base;\n    }\n}\nfunction wrapMarks(marks, str) {\n    for(let i = marks.length - 1; i >= 0; i--)str = marks[i].type.name + \"(\" + str + \")\";\n    return str;\n}\n/**\nInstances of this class represent a match state of a node type's\n[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to\nfind out whether further content matches here, and whether a given\nposition is a valid end of the node.\n*/ class ContentMatch {\n    /**\n    @internal\n    */ constructor(/**\n    True when this match state represents a valid end of the node.\n    */ validEnd){\n        this.validEnd = validEnd;\n        /**\n        @internal\n        */ this.next = [];\n        /**\n        @internal\n        */ this.wrapCache = [];\n    }\n    /**\n    @internal\n    */ static parse(string, nodeTypes) {\n        let stream = new TokenStream(string, nodeTypes);\n        if (stream.next == null) return ContentMatch.empty;\n        let expr = parseExpr(stream);\n        if (stream.next) stream.err(\"Unexpected trailing text\");\n        let match = dfa(nfa(expr));\n        checkForDeadEnds(match, stream);\n        return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */ matchType(type) {\n        for(let i = 0; i < this.next.length; i++)if (this.next[i].type == type) return this.next[i].next;\n        return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */ matchFragment(frag, start = 0, end = frag.childCount) {\n        let cur = this;\n        for(let i = start; cur && i < end; i++)cur = cur.matchType(frag.child(i).type);\n        return cur;\n    }\n    /**\n    @internal\n    */ get inlineContent() {\n        return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */ get defaultType() {\n        for(let i = 0; i < this.next.length; i++){\n            let { type } = this.next[i];\n            if (!(type.isText || type.hasRequiredAttrs())) return type;\n        }\n        return null;\n    }\n    /**\n    @internal\n    */ compatible(other) {\n        for(let i = 0; i < this.next.length; i++)for(let j = 0; j < other.next.length; j++)if (this.next[i].type == other.next[j].type) return true;\n        return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */ fillBefore(after, toEnd = false, startIndex = 0) {\n        let seen = [\n            this\n        ];\n        function search(match, types) {\n            let finished = match.matchFragment(after, startIndex);\n            if (finished && (!toEnd || finished.validEnd)) return Fragment.from(types.map((tp)=>tp.createAndFill()));\n            for(let i = 0; i < match.next.length; i++){\n                let { type, next } = match.next[i];\n                if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n                    seen.push(next);\n                    let found = search(next, types.concat(type));\n                    if (found) return found;\n                }\n            }\n            return null;\n        }\n        return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */ findWrapping(target) {\n        for(let i = 0; i < this.wrapCache.length; i += 2)if (this.wrapCache[i] == target) return this.wrapCache[i + 1];\n        let computed = this.computeWrapping(target);\n        this.wrapCache.push(target, computed);\n        return computed;\n    }\n    /**\n    @internal\n    */ computeWrapping(target) {\n        let seen = Object.create(null), active = [\n            {\n                match: this,\n                type: null,\n                via: null\n            }\n        ];\n        while(active.length){\n            let current = active.shift(), match = current.match;\n            if (match.matchType(target)) {\n                let result = [];\n                for(let obj = current; obj.type; obj = obj.via)result.push(obj.type);\n                return result.reverse();\n            }\n            for(let i = 0; i < match.next.length; i++){\n                let { type, next } = match.next[i];\n                if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n                    active.push({\n                        match: type.contentMatch,\n                        type,\n                        via: current\n                    });\n                    seen[type.name] = true;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */ get edgeCount() {\n        return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */ edge(n) {\n        if (n >= this.next.length) throw new RangeError(`There's no ${n}th edge in this content match`);\n        return this.next[n];\n    }\n    /**\n    @internal\n    */ toString() {\n        let seen = [];\n        function scan(m) {\n            seen.push(m);\n            for(let i = 0; i < m.next.length; i++)if (seen.indexOf(m.next[i].next) == -1) scan(m.next[i].next);\n        }\n        scan(this);\n        return seen.map((m, i)=>{\n            let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n            for(let i = 0; i < m.next.length; i++)out += (i ? \", \" : \"\") + m.next[i].type.name + \"->\" + seen.indexOf(m.next[i].next);\n            return out;\n        }).join(\"\\n\");\n    }\n}\n/**\n@internal\n*/ ContentMatch.empty = new ContentMatch(true);\nclass TokenStream {\n    constructor(string, nodeTypes){\n        this.string = string;\n        this.nodeTypes = nodeTypes;\n        this.inline = null;\n        this.pos = 0;\n        this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n        if (this.tokens[this.tokens.length - 1] == \"\") this.tokens.pop();\n        if (this.tokens[0] == \"\") this.tokens.shift();\n    }\n    get next() {\n        return this.tokens[this.pos];\n    }\n    eat(tok) {\n        return this.next == tok && (this.pos++ || true);\n    }\n    err(str) {\n        throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\");\n    }\n}\nfunction parseExpr(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSeq(stream));\n    }while (stream.eat(\"|\"));\n    return exprs.length == 1 ? exprs[0] : {\n        type: \"choice\",\n        exprs\n    };\n}\nfunction parseExprSeq(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSubscript(stream));\n    }while (stream.next && stream.next != \")\" && stream.next != \"|\");\n    return exprs.length == 1 ? exprs[0] : {\n        type: \"seq\",\n        exprs\n    };\n}\nfunction parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for(;;){\n        if (stream.eat(\"+\")) expr = {\n            type: \"plus\",\n            expr\n        };\n        else if (stream.eat(\"*\")) expr = {\n            type: \"star\",\n            expr\n        };\n        else if (stream.eat(\"?\")) expr = {\n            type: \"opt\",\n            expr\n        };\n        else if (stream.eat(\"{\")) expr = parseExprRange(stream, expr);\n        else break;\n    }\n    return expr;\n}\nfunction parseNum(stream) {\n    if (/\\D/.test(stream.next)) stream.err(\"Expected number, got '\" + stream.next + \"'\");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n}\nfunction parseExprRange(stream, expr) {\n    let min = parseNum(stream), max = min;\n    if (stream.eat(\",\")) {\n        if (stream.next != \"}\") max = parseNum(stream);\n        else max = -1;\n    }\n    if (!stream.eat(\"}\")) stream.err(\"Unclosed braced range\");\n    return {\n        type: \"range\",\n        min,\n        max,\n        expr\n    };\n}\nfunction resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type) return [\n        type\n    ];\n    let result = [];\n    for(let typeName in types){\n        let type = types[typeName];\n        if (type.isInGroup(name)) result.push(type);\n    }\n    if (result.length == 0) stream.err(\"No node type or group '\" + name + \"' found\");\n    return result;\n}\nfunction parseExprAtom(stream) {\n    if (stream.eat(\"(\")) {\n        let expr = parseExpr(stream);\n        if (!stream.eat(\")\")) stream.err(\"Missing closing paren\");\n        return expr;\n    } else if (!/\\W/.test(stream.next)) {\n        let exprs = resolveName(stream, stream.next).map((type)=>{\n            if (stream.inline == null) stream.inline = type.isInline;\n            else if (stream.inline != type.isInline) stream.err(\"Mixing inline and block content\");\n            return {\n                type: \"name\",\n                value: type\n            };\n        });\n        stream.pos++;\n        return exprs.length == 1 ? exprs[0] : {\n            type: \"choice\",\n            exprs\n        };\n    } else {\n        stream.err(\"Unexpected token '\" + stream.next + \"'\");\n    }\n}\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n    let nfa = [\n        []\n    ];\n    connect(compile(expr, 0), node());\n    return nfa;\n    function node() {\n        return nfa.push([]) - 1;\n    }\n    function edge(from, to, term) {\n        let edge = {\n            term,\n            to\n        };\n        nfa[from].push(edge);\n        return edge;\n    }\n    function connect(edges, to) {\n        edges.forEach((edge)=>edge.to = to);\n    }\n    function compile(expr, from) {\n        if (expr.type == \"choice\") {\n            return expr.exprs.reduce((out, expr)=>out.concat(compile(expr, from)), []);\n        } else if (expr.type == \"seq\") {\n            for(let i = 0;; i++){\n                let next = compile(expr.exprs[i], from);\n                if (i == expr.exprs.length - 1) return next;\n                connect(next, from = node());\n            }\n        } else if (expr.type == \"star\") {\n            let loop = node();\n            edge(from, loop);\n            connect(compile(expr.expr, loop), loop);\n            return [\n                edge(loop)\n            ];\n        } else if (expr.type == \"plus\") {\n            let loop = node();\n            connect(compile(expr.expr, from), loop);\n            connect(compile(expr.expr, loop), loop);\n            return [\n                edge(loop)\n            ];\n        } else if (expr.type == \"opt\") {\n            return [\n                edge(from)\n            ].concat(compile(expr.expr, from));\n        } else if (expr.type == \"range\") {\n            let cur = from;\n            for(let i = 0; i < expr.min; i++){\n                let next = node();\n                connect(compile(expr.expr, cur), next);\n                cur = next;\n            }\n            if (expr.max == -1) {\n                connect(compile(expr.expr, cur), cur);\n            } else {\n                for(let i = expr.min; i < expr.max; i++){\n                    let next = node();\n                    edge(cur, next);\n                    connect(compile(expr.expr, cur), next);\n                    cur = next;\n                }\n            }\n            return [\n                edge(cur)\n            ];\n        } else if (expr.type == \"name\") {\n            return [\n                edge(from, undefined, expr.value)\n            ];\n        } else {\n            throw new Error(\"Unknown expr type\");\n        }\n    }\n}\nfunction cmp(a, b) {\n    return b - a;\n}\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node) {\n        let edges = nfa[node];\n        if (edges.length == 1 && !edges[0].term) return scan(edges[0].to);\n        result.push(node);\n        for(let i = 0; i < edges.length; i++){\n            let { term, to } = edges[i];\n            if (!term && result.indexOf(to) == -1) scan(to);\n        }\n    }\n}\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n    let labeled = Object.create(null);\n    return explore(nullFrom(nfa, 0));\n    function explore(states) {\n        let out = [];\n        states.forEach((node)=>{\n            nfa[node].forEach(({ term, to })=>{\n                if (!term) return;\n                let set;\n                for(let i = 0; i < out.length; i++)if (out[i][0] == term) set = out[i][1];\n                nullFrom(nfa, to).forEach((node)=>{\n                    if (!set) out.push([\n                        term,\n                        set = []\n                    ]);\n                    if (set.indexOf(node) == -1) set.push(node);\n                });\n            });\n        });\n        let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n        for(let i = 0; i < out.length; i++){\n            let states = out[i][1].sort(cmp);\n            state.next.push({\n                type: out[i][0],\n                next: labeled[states.join(\",\")] || explore(states)\n            });\n        }\n        return state;\n    }\n}\nfunction checkForDeadEnds(match, stream) {\n    for(let i = 0, work = [\n        match\n    ]; i < work.length; i++){\n        let state = work[i], dead = !state.validEnd, nodes = [];\n        for(let j = 0; j < state.next.length; j++){\n            let { type, next } = state.next[j];\n            nodes.push(type.name);\n            if (dead && !(type.isText || type.hasRequiredAttrs())) dead = false;\n            if (work.indexOf(next) == -1) work.push(next);\n        }\n        if (dead) stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n}\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n    let defaults = Object.create(null);\n    for(let attrName in attrs){\n        let attr = attrs[attrName];\n        if (!attr.hasDefault) return null;\n        defaults[attrName] = attr.default;\n    }\n    return defaults;\n}\nfunction computeAttrs(attrs, value) {\n    let built = Object.create(null);\n    for(let name in attrs){\n        let given = value && value[name];\n        if (given === undefined) {\n            let attr = attrs[name];\n            if (attr.hasDefault) given = attr.default;\n            else throw new RangeError(\"No value supplied for attribute \" + name);\n        }\n        built[name] = given;\n    }\n    return built;\n}\nfunction checkAttrs(attrs, values, type, name) {\n    for(let name in values)if (!(name in attrs)) throw new RangeError(`Unsupported attribute ${name} for ${type} of type ${name}`);\n    for(let name in attrs){\n        let attr = attrs[name];\n        if (attr.validate) attr.validate(values[name]);\n    }\n}\nfunction initAttrs(typeName, attrs) {\n    let result = Object.create(null);\n    if (attrs) for(let name in attrs)result[name] = new Attribute(typeName, name, attrs[name]);\n    return result;\n}\n/**\nNode types are objects allocated once per `Schema` and used to\n[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information\nabout the node type, such as its name and what kind of node it\nrepresents.\n*/ class NodeType {\n    /**\n    @internal\n    */ constructor(/**\n    The name the node type has in this schema.\n    */ name, /**\n    A link back to the `Schema` the node type belongs to.\n    */ schema, /**\n    The spec that this type is based on\n    */ spec){\n        this.name = name;\n        this.schema = schema;\n        this.spec = spec;\n        /**\n        The set of marks allowed in this node. `null` means all marks\n        are allowed.\n        */ this.markSet = null;\n        this.groups = spec.group ? spec.group.split(\" \") : [];\n        this.attrs = initAttrs(name, spec.attrs);\n        this.defaultAttrs = defaultAttrs(this.attrs);\n        this.contentMatch = null;\n        this.inlineContent = null;\n        this.isBlock = !(spec.inline || name == \"text\");\n        this.isText = name == \"text\";\n    }\n    /**\n    True if this is an inline type.\n    */ get isInline() {\n        return !this.isBlock;\n    }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */ get isTextblock() {\n        return this.isBlock && this.inlineContent;\n    }\n    /**\n    True for node types that allow no content.\n    */ get isLeaf() {\n        return this.contentMatch == ContentMatch.empty;\n    }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */ get isAtom() {\n        return this.isLeaf || !!this.spec.atom;\n    }\n    /**\n    Return true when this node type is part of the given\n    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).\n    */ isInGroup(group) {\n        return this.groups.indexOf(group) > -1;\n    }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */ get whitespace() {\n        return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */ hasRequiredAttrs() {\n        for(let n in this.attrs)if (this.attrs[n].isRequired) return true;\n        return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */ compatibleContent(other) {\n        return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */ computeAttrs(attrs) {\n        if (!attrs && this.defaultAttrs) return this.defaultAttrs;\n        else return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */ create(attrs = null, content, marks) {\n        if (this.isText) throw new Error(\"NodeType.create can't construct text nodes\");\n        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */ createChecked(attrs = null, content, marks) {\n        content = Fragment.from(content);\n        this.checkContent(content);\n        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */ createAndFill(attrs = null, content, marks) {\n        attrs = this.computeAttrs(attrs);\n        content = Fragment.from(content);\n        if (content.size) {\n            let before = this.contentMatch.fillBefore(content);\n            if (!before) return null;\n            content = before.append(content);\n        }\n        let matched = this.contentMatch.matchFragment(content);\n        let after = matched && matched.fillBefore(Fragment.empty, true);\n        if (!after) return null;\n        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type.\n    */ validContent(content) {\n        let result = this.contentMatch.matchFragment(content);\n        if (!result || !result.validEnd) return false;\n        for(let i = 0; i < content.childCount; i++)if (!this.allowsMarks(content.child(i).marks)) return false;\n        return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */ checkContent(content) {\n        if (!this.validContent(content)) throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    @internal\n    */ checkAttrs(attrs) {\n        checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */ allowsMarkType(markType) {\n        return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */ allowsMarks(marks) {\n        if (this.markSet == null) return true;\n        for(let i = 0; i < marks.length; i++)if (!this.allowsMarkType(marks[i].type)) return false;\n        return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */ allowedMarks(marks) {\n        if (this.markSet == null) return marks;\n        let copy;\n        for(let i = 0; i < marks.length; i++){\n            if (!this.allowsMarkType(marks[i].type)) {\n                if (!copy) copy = marks.slice(0, i);\n            } else if (copy) {\n                copy.push(marks[i]);\n            }\n        }\n        return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n    /**\n    @internal\n    */ static compile(nodes, schema) {\n        let result = Object.create(null);\n        nodes.forEach((name, spec)=>result[name] = new NodeType(name, schema, spec));\n        let topType = schema.spec.topNode || \"doc\";\n        if (!result[topType]) throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n        if (!result.text) throw new RangeError(\"Every schema needs a 'text' type\");\n        for(let _ in result.text.attrs)throw new RangeError(\"The text node type should not have attributes\");\n        return result;\n    }\n}\nfunction validateType(typeName, attrName, type) {\n    let types = type.split(\"|\");\n    return (value)=>{\n        let name = value === null ? \"null\" : typeof value;\n        if (types.indexOf(name) < 0) throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);\n    };\n}\n// Attribute descriptors\nclass Attribute {\n    constructor(typeName, attrName, options){\n        this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n        this.default = options.default;\n        this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n    }\n    get isRequired() {\n        return !this.hasDefault;\n    }\n}\n// Marks\n/**\nLike nodes, marks (which are associated with nodes to signify\nthings like emphasis or being part of a link) are\n[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are\ninstantiated once per `Schema`.\n*/ class MarkType {\n    /**\n    @internal\n    */ constructor(/**\n    The name of the mark type.\n    */ name, /**\n    @internal\n    */ rank, /**\n    The schema that this mark type instance is part of.\n    */ schema, /**\n    The spec on which the type is based.\n    */ spec){\n        this.name = name;\n        this.rank = rank;\n        this.schema = schema;\n        this.spec = spec;\n        this.attrs = initAttrs(name, spec.attrs);\n        this.excluded = null;\n        let defaults = defaultAttrs(this.attrs);\n        this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark's attributes. The others, if\n    they have defaults, will be added.\n    */ create(attrs = null) {\n        if (!attrs && this.instance) return this.instance;\n        return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */ static compile(marks, schema) {\n        let result = Object.create(null), rank = 0;\n        marks.forEach((name, spec)=>result[name] = new MarkType(name, rank++, schema, spec));\n        return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */ removeFromSet(set) {\n        for(var i = 0; i < set.length; i++)if (set[i].type == this) {\n            set = set.slice(0, i).concat(set.slice(i + 1));\n            i--;\n        }\n        return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */ isInSet(set) {\n        for(let i = 0; i < set.length; i++)if (set[i].type == this) return set[i];\n    }\n    /**\n    @internal\n    */ checkAttrs(attrs) {\n        checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */ excludes(other) {\n        return this.excluded.indexOf(other) > -1;\n    }\n}\n/**\nA document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark\ntype](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may\noccur in conforming documents, and provides functionality for\ncreating and deserializing such documents.\n\nWhen given, the type parameters provide the names of the nodes and\nmarks in this schema.\n*/ class Schema {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */ constructor(spec){\n        /**\n        The [linebreak\n        replacement](https://prosemirror.net/docs/ref/#model.NodeSpec.linebreakReplacement) node defined\n        in this schema, if any.\n        */ this.linebreakReplacement = null;\n        /**\n        An object for storing whatever values modules may want to\n        compute and cache per schema. (If you want to store something\n        in it, try to use property names unlikely to clash.)\n        */ this.cached = Object.create(null);\n        let instanceSpec = this.spec = {};\n        for(let prop in spec)instanceSpec[prop] = spec[prop];\n        instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.nodes), instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.marks || {}), this.nodes = NodeType.compile(this.spec.nodes, this);\n        this.marks = MarkType.compile(this.spec.marks, this);\n        let contentExprCache = Object.create(null);\n        for(let prop in this.nodes){\n            if (prop in this.marks) throw new RangeError(prop + \" can not be both a node and a mark\");\n            let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n            type.contentMatch = contentExprCache[contentExpr] || (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n            type.inlineContent = type.contentMatch.inlineContent;\n            if (type.spec.linebreakReplacement) {\n                if (this.linebreakReplacement) throw new RangeError(\"Multiple linebreak nodes defined\");\n                if (!type.isInline || !type.isLeaf) throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n                this.linebreakReplacement = type;\n            }\n            type.markSet = markExpr == \"_\" ? null : markExpr ? gatherMarks(this, markExpr.split(\" \")) : markExpr == \"\" || !type.inlineContent ? [] : null;\n        }\n        for(let prop in this.marks){\n            let type = this.marks[prop], excl = type.spec.excludes;\n            type.excluded = excl == null ? [\n                type\n            ] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n        }\n        this.nodeFromJSON = (json)=>Node.fromJSON(this, json);\n        this.markFromJSON = (json)=>Mark.fromJSON(this, json);\n        this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n        this.cached.wrappings = Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */ node(type, attrs = null, content, marks) {\n        if (typeof type == \"string\") type = this.nodeType(type);\n        else if (!(type instanceof NodeType)) throw new RangeError(\"Invalid node type: \" + type);\n        else if (type.schema != this) throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n        return type.createChecked(attrs, content, marks);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */ text(text, marks) {\n        let type = this.nodes.text;\n        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */ mark(type, attrs) {\n        if (typeof type == \"string\") type = this.marks[type];\n        return type.create(attrs);\n    }\n    /**\n    @internal\n    */ nodeType(name) {\n        let found = this.nodes[name];\n        if (!found) throw new RangeError(\"Unknown node type: \" + name);\n        return found;\n    }\n}\nfunction gatherMarks(schema, marks) {\n    let found = [];\n    for(let i = 0; i < marks.length; i++){\n        let name = marks[i], mark = schema.marks[name], ok = mark;\n        if (mark) {\n            found.push(mark);\n        } else {\n            for(let prop in schema.marks){\n                let mark = schema.marks[prop];\n                if (name == \"_\" || mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1) found.push(ok = mark);\n            }\n        }\n        if (!ok) throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n    }\n    return found;\n}\nfunction isTagRule(rule) {\n    return rule.tag != null;\n}\nfunction isStyleRule(rule) {\n    return rule.style != null;\n}\n/**\nA DOM parser represents a strategy for parsing DOM content into a\nProseMirror document conforming to a given schema. Its behavior is\ndefined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).\n*/ class DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */ constructor(/**\n    The schema into which the parser parses.\n    */ schema, /**\n    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser\n    uses, in order of precedence.\n    */ rules){\n        this.schema = schema;\n        this.rules = rules;\n        /**\n        @internal\n        */ this.tags = [];\n        /**\n        @internal\n        */ this.styles = [];\n        let matchedStyles = this.matchedStyles = [];\n        rules.forEach((rule)=>{\n            if (isTagRule(rule)) {\n                this.tags.push(rule);\n            } else if (isStyleRule(rule)) {\n                let prop = /[^=]*/.exec(rule.style)[0];\n                if (matchedStyles.indexOf(prop) < 0) matchedStyles.push(prop);\n                this.styles.push(rule);\n            }\n        });\n        // Only normalize list elements when lists in the schema can't directly contain themselves\n        this.normalizeLists = !this.tags.some((r)=>{\n            if (!/^(ul|ol)\\b/.test(r.tag) || !r.node) return false;\n            let node = schema.nodes[r.node];\n            return node.contentMatch.matchType(node);\n        });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */ parse(dom, options = {}) {\n        let context = new ParseContext(this, options, false);\n        context.addAll(dom, Mark.none, options.from, options.to);\n        return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */ parseSlice(dom, options = {}) {\n        let context = new ParseContext(this, options, true);\n        context.addAll(dom, Mark.none, options.from, options.to);\n        return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */ matchTag(dom, context, after) {\n        for(let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++){\n            let rule = this.tags[i];\n            if (matches(dom, rule.tag) && (rule.namespace === undefined || dom.namespaceURI == rule.namespace) && (!rule.context || context.matchesContext(rule.context))) {\n                if (rule.getAttrs) {\n                    let result = rule.getAttrs(dom);\n                    if (result === false) continue;\n                    rule.attrs = result || undefined;\n                }\n                return rule;\n            }\n        }\n    }\n    /**\n    @internal\n    */ matchStyle(prop, value, context, after) {\n        for(let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++){\n            let rule = this.styles[i], style = rule.style;\n            if (style.indexOf(prop) != 0 || rule.context && !context.matchesContext(rule.context) || // Test that the style string either precisely matches the prop,\n            // or has an '=' sign after the prop, followed by the given\n            // value.\n            style.length > prop.length && (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value)) continue;\n            if (rule.getAttrs) {\n                let result = rule.getAttrs(value);\n                if (result === false) continue;\n                rule.attrs = result || undefined;\n            }\n            return rule;\n        }\n    }\n    /**\n    @internal\n    */ static schemaRules(schema) {\n        let result = [];\n        function insert(rule) {\n            let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n            for(; i < result.length; i++){\n                let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n                if (nextPriority < priority) break;\n            }\n            result.splice(i, 0, rule);\n        }\n        for(let name in schema.marks){\n            let rules = schema.marks[name].spec.parseDOM;\n            if (rules) rules.forEach((rule)=>{\n                insert(rule = copy(rule));\n                if (!(rule.mark || rule.ignore || rule.clearMark)) rule.mark = name;\n            });\n        }\n        for(let name in schema.nodes){\n            let rules = schema.nodes[name].spec.parseDOM;\n            if (rules) rules.forEach((rule)=>{\n                insert(rule = copy(rule));\n                if (!(rule.node || rule.ignore || rule.mark)) rule.node = name;\n            });\n        }\n        return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).\n    */ static fromSchema(schema) {\n        return schema.cached.domParser || (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n}\nconst blockTags = {\n    address: true,\n    article: true,\n    aside: true,\n    blockquote: true,\n    canvas: true,\n    dd: true,\n    div: true,\n    dl: true,\n    fieldset: true,\n    figcaption: true,\n    figure: true,\n    footer: true,\n    form: true,\n    h1: true,\n    h2: true,\n    h3: true,\n    h4: true,\n    h5: true,\n    h6: true,\n    header: true,\n    hgroup: true,\n    hr: true,\n    li: true,\n    noscript: true,\n    ol: true,\n    output: true,\n    p: true,\n    pre: true,\n    section: true,\n    table: true,\n    tfoot: true,\n    ul: true\n};\nconst ignoreTags = {\n    head: true,\n    noscript: true,\n    object: true,\n    script: true,\n    style: true,\n    title: true\n};\nconst listTags = {\n    ol: true,\n    ul: true\n};\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n    if (preserveWhitespace != null) return (preserveWhitespace ? OPT_PRESERVE_WS : 0) | (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nclass NodeContext {\n    constructor(type, attrs, marks, solid, match, options){\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.solid = solid;\n        this.options = options;\n        this.content = [];\n        // Marks applied to the node's children\n        this.activeMarks = Mark.none;\n        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n        if (!this.match) {\n            if (!this.type) return [];\n            let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n            if (fill) {\n                this.match = this.type.contentMatch.matchFragment(fill);\n            } else {\n                let start = this.type.contentMatch, wrap;\n                if (wrap = start.findWrapping(node.type)) {\n                    this.match = start;\n                    return wrap;\n                } else {\n                    return null;\n                }\n            }\n        }\n        return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n        if (!(this.options & OPT_PRESERVE_WS)) {\n            let last = this.content[this.content.length - 1], m;\n            if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n                let text = last;\n                if (last.text.length == m[0].length) this.content.pop();\n                else this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n            }\n        }\n        let content = Fragment.from(this.content);\n        if (!openEnd && this.match) content = content.append(this.match.fillBefore(Fragment.empty, true));\n        return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    inlineContext(node) {\n        if (this.type) return this.type.inlineContent;\n        if (this.content.length) return this.content[0].isInline;\n        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n}\nclass ParseContext {\n    constructor(// The parser we are using.\n    parser, // The options passed to this parse.\n    options, isOpen){\n        this.parser = parser;\n        this.options = options;\n        this.isOpen = isOpen;\n        this.open = 0;\n        this.localPreserveWS = false;\n        let topNode = options.topNode, topContext;\n        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n        if (topNode) topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n        else if (isOpen) topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);\n        else topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n        this.nodes = [\n            topContext\n        ];\n        this.find = options.findPositions;\n        this.needsBlock = false;\n    }\n    get top() {\n        return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom, marks) {\n        if (dom.nodeType == 3) this.addTextNode(dom, marks);\n        else if (dom.nodeType == 1) this.addElement(dom, marks);\n    }\n    addTextNode(dom, marks) {\n        let value = dom.nodeValue;\n        let top = this.top, preserveWS = top.options & OPT_PRESERVE_WS_FULL ? \"full\" : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n        let { schema } = this.parser;\n        if (preserveWS === \"full\" || top.inlineContext(dom) || /[^ \\t\\r\\n\\u000c]/.test(value)) {\n            if (!preserveWS) {\n                value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n                // If this starts with whitespace, and there is no node before it, or\n                // a hard break, or a text node that ends with whitespace, strip the\n                // leading space.\n                if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n                    let nodeBefore = top.content[top.content.length - 1];\n                    let domNodeBefore = dom.previousSibling;\n                    if (!nodeBefore || domNodeBefore && domNodeBefore.nodeName == \"BR\" || nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)) value = value.slice(1);\n                }\n            } else if (preserveWS === \"full\") {\n                value = value.replace(/\\r\\n?/g, \"\\n\");\n            } else if (schema.linebreakReplacement && /[\\r\\n]/.test(value) && this.top.findWrapping(schema.linebreakReplacement.create())) {\n                let lines = value.split(/\\r?\\n|\\r/);\n                for(let i = 0; i < lines.length; i++){\n                    if (i) this.insertNode(schema.linebreakReplacement.create(), marks, true);\n                    if (lines[i]) this.insertNode(schema.text(lines[i]), marks, !/\\S/.test(lines[i]));\n                }\n                value = \"\";\n            } else {\n                value = value.replace(/\\r?\\n|\\r/g, \" \");\n            }\n            if (value) this.insertNode(schema.text(value), marks, !/\\S/.test(value));\n            this.findInText(dom);\n        } else {\n            this.findInside(dom);\n        }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n    addElement(dom, marks, matchAfter) {\n        let outerWS = this.localPreserveWS, top = this.top;\n        if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace)) this.localPreserveWS = true;\n        let name = dom.nodeName.toLowerCase(), ruleID;\n        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists) normalizeList(dom);\n        let rule = this.options.ruleFromNode && this.options.ruleFromNode(dom) || (ruleID = this.parser.matchTag(dom, this, matchAfter));\n        out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n            this.findInside(dom);\n            this.ignoreFallback(dom, marks);\n        } else if (!rule || rule.skip || rule.closeParent) {\n            if (rule && rule.closeParent) this.open = Math.max(0, this.open - 1);\n            else if (rule && rule.skip.nodeType) dom = rule.skip;\n            let sync, oldNeedsBlock = this.needsBlock;\n            if (blockTags.hasOwnProperty(name)) {\n                if (top.content.length && top.content[0].isInline && this.open) {\n                    this.open--;\n                    top = this.top;\n                }\n                sync = true;\n                if (!top.type) this.needsBlock = true;\n            } else if (!dom.firstChild) {\n                this.leafFallback(dom, marks);\n                break out;\n            }\n            let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);\n            if (innerMarks) this.addAll(dom, innerMarks);\n            if (sync) this.sync(top);\n            this.needsBlock = oldNeedsBlock;\n        } else {\n            let innerMarks = this.readStyles(dom, marks);\n            if (innerMarks) this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : undefined);\n        }\n        this.localPreserveWS = outerWS;\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom, marks) {\n        if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent) this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks);\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom, marks) {\n        // Ignored BR nodes should at least create an inline context\n        if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent)) this.findPlace(this.parser.schema.text(\"-\"), marks, true);\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an updated array of marks, or null to indicate some of the\n    // styles had a rule with `ignore` set.\n    readStyles(dom, marks) {\n        let styles = dom.style;\n        // Because many properties will only show up in 'normalized' form\n        // in `style.item` (i.e. text-decoration becomes\n        // text-decoration-line, text-decoration-color, etc), we directly\n        // query the styles mentioned in our rules instead of iterating\n        // over the items.\n        if (styles && styles.length) for(let i = 0; i < this.parser.matchedStyles.length; i++){\n            let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);\n            if (value) for(let after = undefined;;){\n                let rule = this.parser.matchStyle(name, value, this, after);\n                if (!rule) break;\n                if (rule.ignore) return null;\n                if (rule.clearMark) marks = marks.filter((m)=>!rule.clearMark(m));\n                else marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));\n                if (rule.consuming === false) after = rule;\n                else break;\n            }\n        }\n        return marks;\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n    addElementByRule(dom, rule, marks, continueAfter) {\n        let sync, nodeType;\n        if (rule.node) {\n            nodeType = this.parser.schema.nodes[rule.node];\n            if (!nodeType.isLeaf) {\n                let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);\n                if (inner) {\n                    sync = true;\n                    marks = inner;\n                }\n            } else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == \"BR\")) {\n                this.leafFallback(dom, marks);\n            }\n        } else {\n            let markType = this.parser.schema.marks[rule.mark];\n            marks = marks.concat(markType.create(rule.attrs));\n        }\n        let startIn = this.top;\n        if (nodeType && nodeType.isLeaf) {\n            this.findInside(dom);\n        } else if (continueAfter) {\n            this.addElement(dom, marks, continueAfter);\n        } else if (rule.getContent) {\n            this.findInside(dom);\n            rule.getContent(dom, this.parser.schema).forEach((node)=>this.insertNode(node, marks, false));\n        } else {\n            let contentDOM = dom;\n            if (typeof rule.contentElement == \"string\") contentDOM = dom.querySelector(rule.contentElement);\n            else if (typeof rule.contentElement == \"function\") contentDOM = rule.contentElement(dom);\n            else if (rule.contentElement) contentDOM = rule.contentElement;\n            this.findAround(dom, contentDOM, true);\n            this.addAll(contentDOM, marks);\n            this.findAround(dom, contentDOM, false);\n        }\n        if (sync && this.sync(startIn)) this.open--;\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, marks, startIndex, endIndex) {\n        let index = startIndex || 0;\n        for(let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index){\n            this.findAtPoint(parent, index);\n            this.addDOM(dom, marks);\n        }\n        this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n    findPlace(node, marks, cautious) {\n        let route, sync;\n        for(let depth = this.open, penalty = 0; depth >= 0; depth--){\n            let cx = this.nodes[depth];\n            let found = cx.findWrapping(node);\n            if (found && (!route || route.length > found.length + penalty)) {\n                route = found;\n                sync = cx;\n                if (!found.length) break;\n            }\n            if (cx.solid) {\n                if (cautious) break;\n                penalty += 2;\n            }\n        }\n        if (!route) return null;\n        this.sync(sync);\n        for(let i = 0; i < route.length; i++)marks = this.enterInner(route[i], null, marks, false);\n        return marks;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node, marks, cautious) {\n        if (node.isInline && this.needsBlock && !this.top.type) {\n            let block = this.textblockFromContext();\n            if (block) marks = this.enterInner(block, null, marks);\n        }\n        let innerMarks = this.findPlace(node, marks, cautious);\n        if (innerMarks) {\n            this.closeExtra();\n            let top = this.top;\n            if (top.match) top.match = top.match.matchType(node.type);\n            let nodeMarks = Mark.none;\n            for (let m of innerMarks.concat(node.marks))if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type)) nodeMarks = m.addToSet(nodeMarks);\n            top.content.push(node.mark(nodeMarks));\n            return true;\n        }\n        return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, marks, preserveWS) {\n        let innerMarks = this.findPlace(type.create(attrs), marks, false);\n        if (innerMarks) innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);\n        return innerMarks;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs, marks, solid = false, preserveWS) {\n        this.closeExtra();\n        let top = this.top;\n        top.match = top.match && top.match.matchType(type);\n        let options = wsOptionsFor(type, preserveWS, top.options);\n        if (top.options & OPT_OPEN_LEFT && top.content.length == 0) options |= OPT_OPEN_LEFT;\n        let applyMarks = Mark.none;\n        marks = marks.filter((m)=>{\n            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n                applyMarks = m.addToSet(applyMarks);\n                return false;\n            }\n            return true;\n        });\n        this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n        this.open++;\n        return marks;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n        let i = this.nodes.length - 1;\n        if (i > this.open) {\n            for(; i > this.open; i--)this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n            this.nodes.length = this.open + 1;\n        }\n    }\n    finish() {\n        this.open = 0;\n        this.closeExtra(this.isOpen);\n        return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n    sync(to) {\n        for(let i = this.open; i >= 0; i--){\n            if (this.nodes[i] == to) {\n                this.open = i;\n                return true;\n            } else if (this.localPreserveWS) {\n                this.nodes[i].options |= OPT_PRESERVE_WS;\n            }\n        }\n        return false;\n    }\n    get currentPos() {\n        this.closeExtra();\n        let pos = 0;\n        for(let i = this.open; i >= 0; i--){\n            let content = this.nodes[i].content;\n            for(let j = content.length - 1; j >= 0; j--)pos += content[j].nodeSize;\n            if (i) pos++;\n        }\n        return pos;\n    }\n    findAtPoint(parent, offset) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].node == parent && this.find[i].offset == offset) this.find[i].pos = this.currentPos;\n        }\n    }\n    findInside(parent) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) this.find[i].pos = this.currentPos;\n        }\n    }\n    findAround(parent, content, before) {\n        if (parent != content && this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n                let pos = content.compareDocumentPosition(this.find[i].node);\n                if (pos & (before ? 2 : 4)) this.find[i].pos = this.currentPos;\n            }\n        }\n    }\n    findInText(textNode) {\n        if (this.find) for(let i = 0; i < this.find.length; i++){\n            if (this.find[i].node == textNode) this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n        }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n        if (context.indexOf(\"|\") > -1) return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n        let parts = context.split(\"/\");\n        let option = this.options.context;\n        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n        let match = (i, depth)=>{\n            for(; i >= 0; i--){\n                let part = parts[i];\n                if (part == \"\") {\n                    if (i == parts.length - 1 || i == 0) continue;\n                    for(; depth >= minDepth; depth--)if (match(i - 1, depth)) return true;\n                    return false;\n                } else {\n                    let next = depth > 0 || depth == 0 && useRoot ? this.nodes[depth].type : option && depth >= minDepth ? option.node(depth - minDepth).type : null;\n                    if (!next || next.name != part && !next.isInGroup(part)) return false;\n                    depth--;\n                }\n            }\n            return true;\n        };\n        return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n        let $context = this.options.context;\n        if ($context) for(let d = $context.depth; d >= 0; d--){\n            let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n            if (deflt && deflt.isTextblock && deflt.defaultAttrs) return deflt;\n        }\n        for(let name in this.parser.schema.nodes){\n            let type = this.parser.schema.nodes[name];\n            if (type.isTextblock && type.defaultAttrs) return type;\n        }\n    }\n}\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n    for(let child = dom.firstChild, prevItem = null; child; child = child.nextSibling){\n        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n        if (name && listTags.hasOwnProperty(name) && prevItem) {\n            prevItem.appendChild(child);\n            child = prevItem;\n        } else if (name == \"li\") {\n            prevItem = child;\n        } else if (name) {\n            prevItem = null;\n        }\n    }\n}\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n    let copy = {};\n    for(let prop in obj)copy[prop] = obj[prop];\n    return copy;\n}\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n    let nodes = nodeType.schema.nodes;\n    for(let name in nodes){\n        let parent = nodes[name];\n        if (!parent.allowsMarkType(markType)) continue;\n        let seen = [], scan = (match)=>{\n            seen.push(match);\n            for(let i = 0; i < match.edgeCount; i++){\n                let { type, next } = match.edge(i);\n                if (type == nodeType) return true;\n                if (seen.indexOf(next) < 0 && scan(next)) return true;\n            }\n        };\n        if (scan(parent.contentMatch)) return true;\n    }\n}\n/**\nA DOM serializer knows how to convert ProseMirror nodes and\nmarks of various types to DOM nodes.\n*/ class DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark's content is block or\n    inline content (for typical use, it'll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */ constructor(/**\n    The node serialization functions.\n    */ nodes, /**\n    The mark serialization functions.\n    */ marks){\n        this.nodes = nodes;\n        this.marks = marks;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */ serializeFragment(fragment, options = {}, target) {\n        if (!target) target = doc(options).createDocumentFragment();\n        let top = target, active = [];\n        fragment.forEach((node)=>{\n            if (active.length || node.marks.length) {\n                let keep = 0, rendered = 0;\n                while(keep < active.length && rendered < node.marks.length){\n                    let next = node.marks[rendered];\n                    if (!this.marks[next.type.name]) {\n                        rendered++;\n                        continue;\n                    }\n                    if (!next.eq(active[keep][0]) || next.type.spec.spanning === false) break;\n                    keep++;\n                    rendered++;\n                }\n                while(keep < active.length)top = active.pop()[1];\n                while(rendered < node.marks.length){\n                    let add = node.marks[rendered++];\n                    let markDOM = this.serializeMark(add, node.isInline, options);\n                    if (markDOM) {\n                        active.push([\n                            add,\n                            top\n                        ]);\n                        top.appendChild(markDOM.dom);\n                        top = markDOM.contentDOM || markDOM.dom;\n                    }\n                }\n            }\n            top.appendChild(this.serializeNodeInner(node, options));\n        });\n        return target;\n    }\n    /**\n    @internal\n    */ serializeNodeInner(node, options) {\n        let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);\n        if (contentDOM) {\n            if (node.isLeaf) throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n            this.serializeFragment(node.content, options, contentDOM);\n        }\n        return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */ serializeNode(node, options = {}) {\n        let dom = this.serializeNodeInner(node, options);\n        for(let i = node.marks.length - 1; i >= 0; i--){\n            let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n            if (wrap) {\n                (wrap.contentDOM || wrap.dom).appendChild(dom);\n                dom = wrap.dom;\n            }\n        }\n        return dom;\n    }\n    /**\n    @internal\n    */ serializeMark(mark, inline, options = {}) {\n        let toDOM = this.marks[mark.type.name];\n        return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n    static renderSpec(doc, structure, xmlNS = null, blockArraysIn) {\n        return renderSpec(doc, structure, xmlNS, blockArraysIn);\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */ static fromSchema(schema) {\n        return schema.cached.domSerializer || (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */ static nodesFromSchema(schema) {\n        let result = gatherToDOM(schema.nodes);\n        if (!result.text) result.text = (node)=>node.text;\n        return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */ static marksFromSchema(schema) {\n        return gatherToDOM(schema.marks);\n    }\n}\nfunction gatherToDOM(obj) {\n    let result = {};\n    for(let name in obj){\n        let toDOM = obj[name].spec.toDOM;\n        if (toDOM) result[name] = toDOM;\n    }\n    return result;\n}\nfunction doc(options) {\n    return options.document || window.document;\n}\nconst suspiciousAttributeCache = new WeakMap();\nfunction suspiciousAttributes(attrs) {\n    let value = suspiciousAttributeCache.get(attrs);\n    if (value === undefined) suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n    return value;\n}\nfunction suspiciousAttributesInner(attrs) {\n    let result = null;\n    function scan(value) {\n        if (value && typeof value == \"object\") {\n            if (Array.isArray(value)) {\n                if (typeof value[0] == \"string\") {\n                    if (!result) result = [];\n                    result.push(value);\n                } else {\n                    for(let i = 0; i < value.length; i++)scan(value[i]);\n                }\n            } else {\n                for(let prop in value)scan(value[prop]);\n            }\n        }\n    }\n    scan(attrs);\n    return result;\n}\nfunction renderSpec(doc, structure, xmlNS, blockArraysIn) {\n    if (typeof structure == \"string\") return {\n        dom: doc.createTextNode(structure)\n    };\n    if (structure.nodeType != null) return {\n        dom: structure\n    };\n    if (structure.dom && structure.dom.nodeType != null) return structure;\n    let tagName = structure[0], suspicious;\n    if (typeof tagName != \"string\") throw new RangeError(\"Invalid array passed to renderSpec\");\n    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) && suspicious.indexOf(structure) > -1) throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n    let space = tagName.indexOf(\" \");\n    if (space > 0) {\n        xmlNS = tagName.slice(0, space);\n        tagName = tagName.slice(space + 1);\n    }\n    let contentDOM;\n    let dom = xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName);\n    let attrs = structure[1], start = 1;\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n        start = 2;\n        for(let name in attrs)if (attrs[name] != null) {\n            let space = name.indexOf(\" \");\n            if (space > 0) dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name]);\n            else if (name == \"style\" && dom.style) dom.style.cssText = attrs[name];\n            else dom.setAttribute(name, attrs[name]);\n        }\n    }\n    for(let i = start; i < structure.length; i++){\n        let child = structure[i];\n        if (child === 0) {\n            if (i < structure.length - 1 || i > start) throw new RangeError(\"Content hole must be the only child of its parent node\");\n            return {\n                dom,\n                contentDOM: dom\n            };\n        } else {\n            let { dom: inner, contentDOM: innerContent } = renderSpec(doc, child, xmlNS, blockArraysIn);\n            dom.appendChild(inner);\n            if (innerContent) {\n                if (contentDOM) throw new RangeError(\"Multiple content holes\");\n                contentDOM = innerContent;\n            }\n        }\n    }\n    return {\n        dom,\n        contentDOM\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQztBQUVwQyxTQUFTQyxjQUFjQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsR0FBRztJQUM1QixJQUFLLElBQUlDLElBQUksSUFBSUEsSUFBSztRQUNsQixJQUFJQSxLQUFLSCxFQUFFSSxVQUFVLElBQUlELEtBQUtGLEVBQUVHLFVBQVUsRUFDdEMsT0FBT0osRUFBRUksVUFBVSxJQUFJSCxFQUFFRyxVQUFVLEdBQUcsT0FBT0Y7UUFDakQsSUFBSUcsU0FBU0wsRUFBRU0sS0FBSyxDQUFDSCxJQUFJSSxTQUFTTixFQUFFSyxLQUFLLENBQUNIO1FBQzFDLElBQUlFLFVBQVVFLFFBQVE7WUFDbEJMLE9BQU9HLE9BQU9HLFFBQVE7WUFDdEI7UUFDSjtRQUNBLElBQUksQ0FBQ0gsT0FBT0ksVUFBVSxDQUFDRixTQUNuQixPQUFPTDtRQUNYLElBQUlHLE9BQU9LLE1BQU0sSUFBSUwsT0FBT00sSUFBSSxJQUFJSixPQUFPSSxJQUFJLEVBQUU7WUFDN0MsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLE9BQU9NLElBQUksQ0FBQ0MsRUFBRSxJQUFJTCxPQUFPSSxJQUFJLENBQUNDLEVBQUUsRUFBRUEsSUFDOUNWO1lBQ0osT0FBT0E7UUFDWDtRQUNBLElBQUlHLE9BQU9RLE9BQU8sQ0FBQ0MsSUFBSSxJQUFJUCxPQUFPTSxPQUFPLENBQUNDLElBQUksRUFBRTtZQUM1QyxJQUFJQyxRQUFRaEIsY0FBY00sT0FBT1EsT0FBTyxFQUFFTixPQUFPTSxPQUFPLEVBQUVYLE1BQU07WUFDaEUsSUFBSWEsU0FBUyxNQUNULE9BQU9BO1FBQ2Y7UUFDQWIsT0FBT0csT0FBT0csUUFBUTtJQUMxQjtBQUNKO0FBQ0EsU0FBU1EsWUFBWWhCLENBQUMsRUFBRUMsQ0FBQyxFQUFFZ0IsSUFBSSxFQUFFQyxJQUFJO0lBQ2pDLElBQUssSUFBSUMsS0FB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LENBQUNuYyxLQUFLL0QsS0FBSyxDQUFDLEdBQUcrZixRQUFRaGMsS0FBSy9ELEtBQUssQ0FBQytmLFFBQVEsSUFBSTVjLEtBQUssQ0FBQ1ksS0FBSztpQkFDMUUsSUFBSUEsUUFBUSxXQUFXdVEsSUFBSVYsS0FBSyxFQUNqQ1UsSUFBSVYsS0FBSyxDQUFDdU0sT0FBTyxHQUFHaGQsS0FBSyxDQUFDWSxLQUFLO2lCQUUvQnVRLElBQUk4TCxZQUFZLENBQUNyYyxNQUFNWixLQUFLLENBQUNZLEtBQUs7UUFDMUM7SUFDUjtJQUNBLElBQUssSUFBSXhHLElBQUlnQyxPQUFPaEMsSUFBSTJoQixVQUFVcmdCLE1BQU0sRUFBRXRCLElBQUs7UUFDM0MsSUFBSUcsUUFBUXdoQixTQUFTLENBQUMzaEIsRUFBRTtRQUN4QixJQUFJRyxVQUFVLEdBQUc7WUFDYixJQUFJSCxJQUFJMmhCLFVBQVVyZ0IsTUFBTSxHQUFHLEtBQUt0QixJQUFJZ0MsT0FDaEMsTUFBTSxJQUFJbUMsV0FBVztZQUN6QixPQUFPO2dCQUFFNFM7Z0JBQUsySCxZQUFZM0g7WUFBSTtRQUNsQyxPQUNLO1lBQ0QsSUFBSSxFQUFFQSxLQUFLblcsS0FBSyxFQUFFOGQsWUFBWW9FLFlBQVksRUFBRSxHQUFHdEIsV0FBV2hYLEtBQUtySyxPQUFPeWhCLE9BQU9DO1lBQzdFOUssSUFBSTBKLFdBQVcsQ0FBQzdmO1lBQ2hCLElBQUlraUIsY0FBYztnQkFDZCxJQUFJcEUsWUFDQSxNQUFNLElBQUl2YSxXQUFXO2dCQUN6QnVhLGFBQWFvRTtZQUNqQjtRQUNKO0lBQ0o7SUFDQSxPQUFPO1FBQUUvTDtRQUFLMkg7SUFBVztBQUM3QjtBQUVpSiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLW1vZGVsL2Rpc3QvaW5kZXguanM/NzhlMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgT3JkZXJlZE1hcCBmcm9tICdvcmRlcmVkbWFwJztcblxuZnVuY3Rpb24gZmluZERpZmZTdGFydChhLCBiLCBwb3MpIHtcbiAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICBpZiAoaSA9PSBhLmNoaWxkQ291bnQgfHwgaSA9PSBiLmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gYS5jaGlsZENvdW50ID09IGIuY2hpbGRDb3VudCA/IG51bGwgOiBwb3M7XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKGkpLCBjaGlsZEIgPSBiLmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2hpbGRBLnNhbWVNYXJrdXAoY2hpbGRCKSlcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgY2hpbGRBLnRleHRbal0gPT0gY2hpbGRCLnRleHRbal07IGorKylcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQS5jb250ZW50LnNpemUgfHwgY2hpbGRCLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGlubmVyID0gZmluZERpZmZTdGFydChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvcyArIDEpO1xuICAgICAgICAgICAgaWYgKGlubmVyICE9IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvcyArPSBjaGlsZEEubm9kZVNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZERpZmZFbmQoYSwgYiwgcG9zQSwgcG9zQikge1xuICAgIGZvciAobGV0IGlBID0gYS5jaGlsZENvdW50LCBpQiA9IGIuY2hpbGRDb3VudDs7KSB7XG4gICAgICAgIGlmIChpQSA9PSAwIHx8IGlCID09IDApXG4gICAgICAgICAgICByZXR1cm4gaUEgPT0gaUIgPyBudWxsIDogeyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGxldCBjaGlsZEEgPSBhLmNoaWxkKC0taUEpLCBjaGlsZEIgPSBiLmNoaWxkKC0taUIpLCBzaXplID0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICBpZiAoY2hpbGRBID09IGNoaWxkQikge1xuICAgICAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICBpZiAoY2hpbGRBLmlzVGV4dCAmJiBjaGlsZEEudGV4dCAhPSBjaGlsZEIudGV4dCkge1xuICAgICAgICAgICAgbGV0IHNhbWUgPSAwLCBtaW5TaXplID0gTWF0aC5taW4oY2hpbGRBLnRleHQubGVuZ3RoLCBjaGlsZEIudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgd2hpbGUgKHNhbWUgPCBtaW5TaXplICYmIGNoaWxkQS50ZXh0W2NoaWxkQS50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSA9PSBjaGlsZEIudGV4dFtjaGlsZEIudGV4dC5sZW5ndGggLSBzYW1lIC0gMV0pIHtcbiAgICAgICAgICAgICAgICBzYW1lKys7XG4gICAgICAgICAgICAgICAgcG9zQS0tO1xuICAgICAgICAgICAgICAgIHBvc0ItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZkVuZChjaGlsZEEuY29udGVudCwgY2hpbGRCLmNvbnRlbnQsIHBvc0EgLSAxLCBwb3NCIC0gMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIHBvc0EgLT0gc2l6ZTtcbiAgICAgICAgcG9zQiAtPSBzaXplO1xuICAgIH1cbn1cblxuLyoqXG5BIGZyYWdtZW50IHJlcHJlc2VudHMgYSBub2RlJ3MgY29sbGVjdGlvbiBvZiBjaGlsZCBub2Rlcy5cblxuTGlrZSBub2RlcywgZnJhZ21lbnRzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcywgYW5kIHlvdVxuc2hvdWxkIG5vdCBtdXRhdGUgdGhlbSBvciB0aGVpciBjb250ZW50LiBSYXRoZXIsIHlvdSBjcmVhdGUgbmV3XG5pbnN0YW5jZXMgd2hlbmV2ZXIgbmVlZGVkLiBUaGUgQVBJIHRyaWVzIHRvIG1ha2UgdGhpcyBlYXN5LlxuKi9cbmNsYXNzIEZyYWdtZW50IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBjaGlsZCBub2RlcyBpbiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgY29udGVudCwgc2l6ZSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplIHx8IDA7XG4gICAgICAgIGlmIChzaXplID09IG51bGwpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5zaXplICs9IGNvbnRlbnRbaV0ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyBiZXR3ZWVuIHRoZSBnaXZlbiB0d29cbiAgICBwb3NpdGlvbnMgKHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHRoaXMgZnJhZ21lbnQpLiBEb2Vzbid0IGRlc2NlbmRcbiAgICBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIG5vZGVTdGFydCA9IDAsIHBhcmVudCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgcG9zIDwgdG87IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tICYmIGYoY2hpbGQsIG5vZGVTdGFydCArIHBvcywgcGFyZW50IHx8IG51bGwsIGkpICE9PSBmYWxzZSAmJiBjaGlsZC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBmcm9tIC0gc3RhcnQpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gc3RhcnQpLCBmLCBub2RlU3RhcnQgKyBzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IGRlc2NlbmRhbnQgbm9kZS4gYHBvc2Agd2lsbCBiZVxuICAgIHJlbGF0aXZlIHRvIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuIFRoZSBjYWxsYmFjayBtYXkgcmV0dXJuXG4gICAgYGZhbHNlYCB0byBwcmV2ZW50IHRyYXZlcnNhbCBvZiBhIGdpdmVuIG5vZGUncyBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRXh0cmFjdCB0aGUgdGV4dCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gU2VlIHRoZSBzYW1lIG1ldGhvZCBvblxuICAgIFtgTm9kZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnRleHRCZXR3ZWVuKS5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgbGV0IHRleHQgPSBcIlwiLCBmaXJzdCA9IHRydWU7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBsZXQgbm9kZVRleHQgPSBub2RlLmlzVGV4dCA/IG5vZGUudGV4dC5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcylcbiAgICAgICAgICAgICAgICA6ICFub2RlLmlzTGVhZiA/IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgOiBsZWFmVGV4dCA/ICh0eXBlb2YgbGVhZlRleHQgPT09IFwiZnVuY3Rpb25cIiA/IGxlYWZUZXh0KG5vZGUpIDogbGVhZlRleHQpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG5vZGUudHlwZS5zcGVjLmxlYWZUZXh0ID8gbm9kZS50eXBlLnNwZWMubGVhZlRleHQobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFwiXCI7XG4gICAgICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIChub2RlLmlzTGVhZiAmJiBub2RlVGV4dCB8fCBub2RlLmlzVGV4dGJsb2NrKSAmJiBibG9ja1NlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdClcbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0ICs9IG5vZGVUZXh0O1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBjb250YWluaW5nIHRoZSBjb21iaW5lZCBjb250ZW50IG9mIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIG90aGVyLlxuICAgICovXG4gICAgYXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghb3RoZXIuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBvdGhlcjtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmxhc3RDaGlsZCwgZmlyc3QgPSBvdGhlci5maXJzdENoaWxkLCBjb250ZW50ID0gdGhpcy5jb250ZW50LnNsaWNlKCksIGkgPSAwO1xuICAgICAgICBpZiAobGFzdC5pc1RleHQgJiYgbGFzdC5zYW1lTWFya3VwKGZpcnN0KSkge1xuICAgICAgICAgICAgY29udGVudFtjb250ZW50Lmxlbmd0aCAtIDFdID0gbGFzdC53aXRoVGV4dChsYXN0LnRleHQgKyBmaXJzdC50ZXh0KTtcbiAgICAgICAgICAgIGkgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpIDwgb3RoZXIuY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGNvbnRlbnQucHVzaChvdGhlci5jb250ZW50W2ldKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50LCB0aGlzLnNpemUgKyBvdGhlci5zaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgc3ViLWZyYWdtZW50IGJldHdlZW4gdGhlIHR3byBnaXZlbiBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdLCBzaXplID0gMDtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldLCBlbmQgPSBwb3MgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSB8fCBlbmQgPiB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zKSwgTWF0aC5taW4oY2hpbGQudGV4dC5sZW5ndGgsIHRvIC0gcG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoTWF0aC5tYXgoMCwgZnJvbSAtIHBvcyAtIDEpLCBNYXRoLm1pbihjaGlsZC5jb250ZW50LnNpemUsIHRvIC0gcG9zIC0gMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSArPSBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHJlc3VsdCwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3V0QnlJbmRleChmcm9tLCB0bykge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQodGhpcy5jb250ZW50LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBpbiB3aGljaCB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXggaXNcbiAgICByZXBsYWNlZCBieSB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VDaGlsZChpbmRleCwgbm9kZSkge1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY29udGVudFtpbmRleF07XG4gICAgICAgIGlmIChjdXJyZW50ID09IG5vZGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IGNvcHkgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKTtcbiAgICAgICAgbGV0IHNpemUgPSB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplIC0gY3VycmVudC5ub2RlU2l6ZTtcbiAgICAgICAgY29weVtpbmRleF0gPSBub2RlO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvcHksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgcHJlcGVuZGluZyB0aGUgZ2l2ZW4gbm9kZSB0byB0aGlzXG4gICAgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBhZGRUb1N0YXJ0KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZV0uY29uY2F0KHRoaXMuY29udGVudCksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgZnJhZ21lbnQgYnkgYXBwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvRW5kKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuY29uY2F0KG5vZGUpLCB0aGlzLnNpemUgKyBub2RlLm5vZGVTaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29tcGFyZSB0aGlzIGZyYWdtZW50IHRvIGFub3RoZXIgb25lLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggIT0gb3RoZXIuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnRbaV0uZXEob3RoZXIuY29udGVudFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoID8gdGhpcy5jb250ZW50WzBdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBsYXN0IGNoaWxkIG9mIHRoZSBmcmFnbWVudCwgb3IgYG51bGxgIGlmIGl0IGlzIGVtcHR5LlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdIDogbnVsbDsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGQgbm9kZXMgaW4gdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aDsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXguIFJhaXNlIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggXCIgKyBpbmRleCArIFwiIG91dCBvZiByYW5nZSBmb3IgXCIgKyB0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbaW5kZXhdIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jb250ZW50W2ldO1xuICAgICAgICAgICAgZihjaGlsZCwgcCwgaSk7XG4gICAgICAgICAgICBwICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uIGF0IHdoaWNoIHRoaXMgZnJhZ21lbnQgYW5kIGFub3RoZXJcbiAgICBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZSB0aGUgc2FtZS5cbiAgICAqL1xuICAgIGZpbmREaWZmU3RhcnQob3RoZXIsIHBvcyA9IDApIHtcbiAgICAgICAgcmV0dXJuIGZpbmREaWZmU3RhcnQodGhpcywgb3RoZXIsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGZpcnN0IHBvc2l0aW9uLCBzZWFyY2hpbmcgZnJvbSB0aGUgZW5kLCBhdCB3aGljaCB0aGlzXG4gICAgZnJhZ21lbnQgYW5kIHRoZSBnaXZlbiBmcmFnbWVudCBkaWZmZXIsIG9yIGBudWxsYCBpZiB0aGV5IGFyZVxuICAgIHRoZSBzYW1lLiBTaW5jZSB0aGlzIHBvc2l0aW9uIHdpbGwgbm90IGJlIHRoZSBzYW1lIGluIGJvdGhcbiAgICBub2RlcywgYW4gb2JqZWN0IHdpdGggdHdvIHNlcGFyYXRlIHBvc2l0aW9ucyBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGZpbmREaWZmRW5kKG90aGVyLCBwb3MgPSB0aGlzLnNpemUsIG90aGVyUG9zID0gb3RoZXIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZFbmQodGhpcywgb3RoZXIsIHBvcywgb3RoZXJQb3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBpbmRleCBhbmQgaW5uZXIgb2Zmc2V0IGNvcnJlc3BvbmRpbmcgdG8gYSBnaXZlbiByZWxhdGl2ZVxuICAgIHBvc2l0aW9uIGluIHRoaXMgZnJhZ21lbnQuIFRoZSByZXN1bHQgb2JqZWN0IHdpbGwgYmUgcmV1c2VkXG4gICAgKG92ZXJ3cml0dGVuKSB0aGUgbmV4dCB0aW1lIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZmluZEluZGV4KHBvcykge1xuICAgICAgICBpZiAocG9zID09IDApXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoMCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA9PSB0aGlzLnNpemUpXG4gICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgodGhpcy5jb250ZW50Lmxlbmd0aCwgcG9zKTtcbiAgICAgICAgaWYgKHBvcyA+IHRoaXMuc2l6ZSB8fCBwb3MgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFBvc2l0aW9uICR7cG9zfSBvdXRzaWRlIG9mIGZyYWdtZW50ICgke3RoaXN9KWApO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyUG9zID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuY2hpbGQoaSksIGVuZCA9IGN1clBvcyArIGN1ci5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPj0gcG9zKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA9PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpICsgMSwgZW5kKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0SW5kZXgoaSwgY3VyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBkZWJ1Z2dpbmcgc3RyaW5nIHRoYXQgZGVzY3JpYmVzIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIFwiPFwiICsgdGhpcy50b1N0cmluZ0lubmVyKCkgKyBcIj5cIjsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmdJbm5lcigpIHsgcmV0dXJuIHRoaXMuY29udGVudC5qb2luKFwiLCBcIik7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnQubWFwKG4gPT4gbi50b0pTT04oKSkgOiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIGZyYWdtZW50IGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBGcmFnbWVudC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh2YWx1ZS5tYXAoc2NoZW1hLm5vZGVGcm9tSlNPTikpO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIGZyYWdtZW50IGZyb20gYW4gYXJyYXkgb2Ygbm9kZXMuIEVuc3VyZXMgdGhhdCBhZGphY2VudFxuICAgIHRleHQgbm9kZXMgd2l0aCB0aGUgc2FtZSBtYXJrcyBhcmUgam9pbmVkIHRvZ2V0aGVyLlxuICAgICovXG4gICAgc3RhdGljIGZyb21BcnJheShhcnJheSkge1xuICAgICAgICBpZiAoIWFycmF5Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgbGV0IGpvaW5lZCwgc2l6ZSA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gYXJyYXlbaV07XG4gICAgICAgICAgICBzaXplICs9IG5vZGUubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSAmJiBub2RlLmlzVGV4dCAmJiBhcnJheVtpIC0gMV0uc2FtZU1hcmt1cChub2RlKSkge1xuICAgICAgICAgICAgICAgIGlmICgham9pbmVkKVxuICAgICAgICAgICAgICAgICAgICBqb2luZWQgPSBhcnJheS5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICBqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdID0gbm9kZVxuICAgICAgICAgICAgICAgICAgICAud2l0aFRleHQoam9pbmVkW2pvaW5lZC5sZW5ndGggLSAxXS50ZXh0ICsgbm9kZS50ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGpvaW5lZCkge1xuICAgICAgICAgICAgICAgIGpvaW5lZC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoam9pbmVkIHx8IGFycmF5LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZnJhZ21lbnQgZnJvbSBzb21ldGhpbmcgdGhhdCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgYVxuICAgIHNldCBvZiBub2Rlcy4gRm9yIGBudWxsYCwgaXQgcmV0dXJucyB0aGUgZW1wdHkgZnJhZ21lbnQuIEZvciBhXG4gICAgZnJhZ21lbnQsIHRoZSBmcmFnbWVudCBpdHNlbGYuIEZvciBhIG5vZGUgb3IgYXJyYXkgb2Ygbm9kZXMsIGFcbiAgICBmcmFnbWVudCBjb250YWluaW5nIHRob3NlIG5vZGVzLlxuICAgICovXG4gICAgc3RhdGljIGZyb20obm9kZXMpIHtcbiAgICAgICAgaWYgKCFub2RlcylcbiAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgaWYgKG5vZGVzIGluc3RhbmNlb2YgRnJhZ21lbnQpXG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGVzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyb21BcnJheShub2Rlcyk7XG4gICAgICAgIGlmIChub2Rlcy5hdHRycylcbiAgICAgICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoW25vZGVzXSwgbm9kZXMubm9kZVNpemUpO1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbiBub3QgY29udmVydCBcIiArIG5vZGVzICsgXCIgdG8gYSBGcmFnbWVudFwiICtcbiAgICAgICAgICAgIChub2Rlcy5ub2Rlc0JldHdlZW4gPyBcIiAobG9va3MgbGlrZSBtdWx0aXBsZSB2ZXJzaW9ucyBvZiBwcm9zZW1pcnJvci1tb2RlbCB3ZXJlIGxvYWRlZClcIiA6IFwiXCIpKTtcbiAgICB9XG59XG4vKipcbkFuIGVtcHR5IGZyYWdtZW50LiBJbnRlbmRlZCB0byBiZSByZXVzZWQgd2hlbmV2ZXIgYSBub2RlIGRvZXNuJ3RcbmNvbnRhaW4gYW55dGhpbmcgKHJhdGhlciB0aGFuIGFsbG9jYXRpbmcgYSBuZXcgZW1wdHkgZnJhZ21lbnQgZm9yXG5lYWNoIGxlYWYgbm9kZSkuXG4qL1xuRnJhZ21lbnQuZW1wdHkgPSBuZXcgRnJhZ21lbnQoW10sIDApO1xuY29uc3QgZm91bmQgPSB7IGluZGV4OiAwLCBvZmZzZXQ6IDAgfTtcbmZ1bmN0aW9uIHJldEluZGV4KGluZGV4LCBvZmZzZXQpIHtcbiAgICBmb3VuZC5pbmRleCA9IGluZGV4O1xuICAgIGZvdW5kLm9mZnNldCA9IG9mZnNldDtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEZWVwKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gYilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKCEoYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiKSB8fFxuICAgICAgICAhKGIgJiYgdHlwZW9mIGIgPT0gXCJvYmplY3RcIikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXJyYXkgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGIpICE9IGFycmF5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFjb21wYXJlRGVlcChhW2ldLCBiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgICAgICBpZiAoIShwIGluIGIpIHx8ICFjb21wYXJlRGVlcChhW3BdLCBiW3BdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgICAgIGlmICghKHAgaW4gYSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG5BIG1hcmsgaXMgYSBwaWVjZSBvZiBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byBhIG5vZGUsXG5zdWNoIGFzIGl0IGJlaW5nIGVtcGhhc2l6ZWQsIGluIGNvZGUgZm9udCwgb3IgYSBsaW5rLiBJdCBoYXMgYVxudHlwZSBhbmQgb3B0aW9uYWxseSBhIHNldCBvZiBhdHRyaWJ1dGVzIHRoYXQgcHJvdmlkZSBmdXJ0aGVyXG5pbmZvcm1hdGlvbiAoc3VjaCBhcyB0aGUgdGFyZ2V0IG9mIHRoZSBsaW5rKS4gTWFya3MgYXJlIGNyZWF0ZWRcbnRocm91Z2ggYSBgU2NoZW1hYCwgd2hpY2ggY29udHJvbHMgd2hpY2ggdHlwZXMgZXhpc3QgYW5kIHdoaWNoXG5hdHRyaWJ1dGVzIHRoZXkgaGF2ZS5cbiovXG5jbGFzcyBNYXJrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGVzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG1hcmsuXG4gICAgKi9cbiAgICBhdHRycykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIC8qKlxuICAgIEdpdmVuIGEgc2V0IG9mIG1hcmtzLCBjcmVhdGUgYSBuZXcgc2V0IHdoaWNoIGNvbnRhaW5zIHRoaXMgb25lIGFzXG4gICAgd2VsbCwgaW4gdGhlIHJpZ2h0IHBvc2l0aW9uLiBJZiB0aGlzIG1hcmsgaXMgYWxyZWFkeSBpbiB0aGUgc2V0LFxuICAgIHRoZSBzZXQgaXRzZWxmIGlzIHJldHVybmVkLiBJZiBhbnkgbWFya3MgdGhhdCBhcmUgc2V0IHRvIGJlXG4gICAgW2V4Y2x1c2l2ZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSB3aXRoIHRoaXMgbWFyayBhcmUgcHJlc2VudCxcbiAgICB0aG9zZSBhcmUgcmVwbGFjZWQgYnkgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhZGRUb1NldChzZXQpIHtcbiAgICAgICAgbGV0IGNvcHksIHBsYWNlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG90aGVyID0gc2V0W2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEob3RoZXIpKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXQ7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlLmV4Y2x1ZGVzKG90aGVyLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3RoZXIudHlwZS5leGNsdWRlcyh0aGlzLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghcGxhY2VkICYmIG90aGVyLnR5cGUucmFuayA+IHRoaXMudHlwZS5yYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgcGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkucHVzaChvdGhlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgpO1xuICAgICAgICBpZiAoIXBsYWNlZClcbiAgICAgICAgICAgIGNvcHkucHVzaCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSB0aGlzIG1hcmsgZnJvbSB0aGUgZ2l2ZW4gc2V0LCByZXR1cm5pbmcgYSBuZXcgc2V0LiBJZiB0aGlzXG4gICAgbWFyayBpcyBub3QgaW4gdGhlIHNldCwgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0aGlzLmVxKHNldFtpXSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldC5zbGljZSgwLCBpKS5jb25jYXQoc2V0LnNsaWNlKGkgKyAxKSk7XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaXMgaW4gdGhlIGdpdmVuIHNldCBvZiBtYXJrcy5cbiAgICAqL1xuICAgIGlzSW5TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhpcyBtYXJrIGhhcyB0aGUgc2FtZSB0eXBlIGFuZCBhdHRyaWJ1dGVzIGFzXG4gICAgYW5vdGhlciBtYXJrLlxuICAgICovXG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgICh0aGlzLnR5cGUgPT0gb3RoZXIudHlwZSAmJiBjb21wYXJlRGVlcCh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IHRoaXMgbWFyayB0byBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IG9iaiA9IHsgdHlwZTogdGhpcy50eXBlLm5hbWUgfTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiB0aGlzLmF0dHJzKSB7XG4gICAgICAgICAgICBvYmouYXR0cnMgPSB0aGlzLmF0dHJzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBtYXJrIGZyb20gSlNPTi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBNYXJrLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHNjaGVtYS5tYXJrc1tqc29uLnR5cGVdO1xuICAgICAgICBpZiAoIXR5cGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVGhlcmUgaXMgbm8gbWFyayB0eXBlICR7anNvbi50eXBlfSBpbiB0aGlzIHNjaGVtYWApO1xuICAgICAgICBsZXQgbWFyayA9IHR5cGUuY3JlYXRlKGpzb24uYXR0cnMpO1xuICAgICAgICB0eXBlLmNoZWNrQXR0cnMobWFyay5hdHRycyk7XG4gICAgICAgIHJldHVybiBtYXJrO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIHNldHMgb2YgbWFya3MgYXJlIGlkZW50aWNhbC5cbiAgICAqL1xuICAgIHN0YXRpYyBzYW1lU2V0KGEsIGIpIHtcbiAgICAgICAgaWYgKGEgPT0gYilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoYS5sZW5ndGggIT0gYi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghYVtpXS5lcShiW2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBwcm9wZXJseSBzb3J0ZWQgbWFyayBzZXQgZnJvbSBudWxsLCBhIHNpbmdsZSBtYXJrLCBvciBhblxuICAgIHVuc29ydGVkIGFycmF5IG9mIG1hcmtzLlxuICAgICovXG4gICAgc3RhdGljIHNldEZyb20obWFya3MpIHtcbiAgICAgICAgaWYgKCFtYXJrcyB8fCBBcnJheS5pc0FycmF5KG1hcmtzKSAmJiBtYXJrcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIGlmIChtYXJrcyBpbnN0YW5jZW9mIE1hcmspXG4gICAgICAgICAgICByZXR1cm4gW21hcmtzXTtcbiAgICAgICAgbGV0IGNvcHkgPSBtYXJrcy5zbGljZSgpO1xuICAgICAgICBjb3B5LnNvcnQoKGEsIGIpID0+IGEudHlwZS5yYW5rIC0gYi50eXBlLnJhbmspO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG59XG4vKipcblRoZSBlbXB0eSBzZXQgb2YgbWFya3MuXG4qL1xuTWFyay5ub25lID0gW107XG5cbi8qKlxuRXJyb3IgdHlwZSByYWlzZWQgYnkgW2BOb2RlLnJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5yZXBsYWNlKSB3aGVuXG5naXZlbiBhbiBpbnZhbGlkIHJlcGxhY2VtZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qXG5SZXBsYWNlRXJyb3IgPSBmdW5jdGlvbih0aGlzOiBhbnksIG1lc3NhZ2U6IHN0cmluZykge1xuICBsZXQgZXJyID0gRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKVxuICA7KGVyciBhcyBhbnkpLl9fcHJvdG9fXyA9IFJlcGxhY2VFcnJvci5wcm90b3R5cGVcbiAgcmV0dXJuIGVyclxufSBhcyBhbnlcblxuUmVwbGFjZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKVxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlcGxhY2VFcnJvclxuUmVwbGFjZUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJSZXBsYWNlRXJyb3JcIlxuKi9cbi8qKlxuQSBzbGljZSByZXByZXNlbnRzIGEgcGllY2UgY3V0IG91dCBvZiBhIGxhcmdlciBkb2N1bWVudC4gSXRcbnN0b3JlcyBub3Qgb25seSBhIGZyYWdtZW50LCBidXQgYWxzbyB0aGUgZGVwdGggdXAgdG8gd2hpY2ggbm9kZXMgb25cbmJvdGggc2lkZSBhcmUg4oCYb3BlbuKAmSAoY3V0IHRocm91Z2gpLlxuKi9cbmNsYXNzIFNsaWNlIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZS4gV2hlbiBzcGVjaWZ5aW5nIGEgbm9uLXplcm8gb3BlbiBkZXB0aCwgeW91IG11c3RcbiAgICBtYWtlIHN1cmUgdGhhdCB0aGVyZSBhcmUgbm9kZXMgb2YgYXQgbGVhc3QgdGhhdCBkZXB0aCBhdCB0aGVcbiAgICBhcHByb3ByaWF0ZSBzaWRlIG9mIHRoZSBmcmFnbWVudOKAlGkuZS4gaWYgdGhlIGZyYWdtZW50IGlzIGFuXG4gICAgZW1wdHkgcGFyYWdyYXBoIG5vZGUsIGBvcGVuU3RhcnRgIGFuZCBgb3BlbkVuZGAgY2FuJ3QgYmUgZ3JlYXRlclxuICAgIHRoYW4gMS5cbiAgICBcbiAgICBJdCBpcyBub3QgbmVjZXNzYXJ5IGZvciB0aGUgY29udGVudCBvZiBvcGVuIG5vZGVzIHRvIGNvbmZvcm0gdG9cbiAgICB0aGUgc2NoZW1hJ3MgY29udGVudCBjb25zdHJhaW50cywgdGhvdWdoIGl0IHNob3VsZCBiZSBhIHZhbGlkXG4gICAgc3RhcnQvZW5kL21pZGRsZSBmb3Igc3VjaCBhIG5vZGUsIGRlcGVuZGluZyBvbiB3aGljaCBzaWRlcyBhcmVcbiAgICBvcGVuLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlJ3MgY29udGVudC5cbiAgICAqL1xuICAgIGNvbnRlbnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBvcGVuU3RhcnQsIFxuICAgIC8qKlxuICAgIFRoZSBvcGVuIGRlcHRoIGF0IHRoZSBlbmQuXG4gICAgKi9cbiAgICBvcGVuRW5kKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMub3BlblN0YXJ0ID0gb3BlblN0YXJ0O1xuICAgICAgICB0aGlzLm9wZW5FbmQgPSBvcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSB0aGlzIHNsaWNlIHdvdWxkIGFkZCB3aGVuIGluc2VydGVkIGludG8gYSBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LnNpemUgLSB0aGlzLm9wZW5TdGFydCAtIHRoaXMub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBpbnNlcnRBdChwb3MsIGZyYWdtZW50KSB7XG4gICAgICAgIGxldCBjb250ZW50ID0gaW5zZXJ0SW50byh0aGlzLmNvbnRlbnQsIHBvcyArIHRoaXMub3BlblN0YXJ0LCBmcmFnbWVudCk7XG4gICAgICAgIHJldHVybiBjb250ZW50ICYmIG5ldyBTbGljZShjb250ZW50LCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZW1vdmVCZXR3ZWVuKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UocmVtb3ZlUmFuZ2UodGhpcy5jb250ZW50LCBmcm9tICsgdGhpcy5vcGVuU3RhcnQsIHRvICsgdGhpcy5vcGVuU3RhcnQpLCB0aGlzLm9wZW5TdGFydCwgdGhpcy5vcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGlzIHNsaWNlIGlzIGVxdWFsIHRvIGFub3RoZXIgc2xpY2UuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50LmVxKG90aGVyLmNvbnRlbnQpICYmIHRoaXMub3BlblN0YXJ0ID09IG90aGVyLm9wZW5TdGFydCAmJiB0aGlzLm9wZW5FbmQgPT0gb3RoZXIub3BlbkVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudCArIFwiKFwiICsgdGhpcy5vcGVuU3RhcnQgKyBcIixcIiArIHRoaXMub3BlbkVuZCArIFwiKVwiO1xuICAgIH1cbiAgICAvKipcbiAgICBDb252ZXJ0IGEgc2xpY2UgdG8gYSBKU09OLXNlcmlhbGl6YWJsZSByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQganNvbiA9IHsgY29udGVudDogdGhpcy5jb250ZW50LnRvSlNPTigpIH07XG4gICAgICAgIGlmICh0aGlzLm9wZW5TdGFydCA+IDApXG4gICAgICAgICAgICBqc29uLm9wZW5TdGFydCA9IHRoaXMub3BlblN0YXJ0O1xuICAgICAgICBpZiAodGhpcy5vcGVuRW5kID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlbkVuZCA9IHRoaXMub3BlbkVuZDtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc2xpY2UgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgcmV0dXJuIFNsaWNlLmVtcHR5O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0ganNvbi5vcGVuU3RhcnQgfHwgMCwgb3BlbkVuZCA9IGpzb24ub3BlbkVuZCB8fCAwO1xuICAgICAgICBpZiAodHlwZW9mIG9wZW5TdGFydCAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBvcGVuRW5kICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFNsaWNlLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKEZyYWdtZW50LmZyb21KU09OKHNjaGVtYSwganNvbi5jb250ZW50KSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2xpY2UgZnJvbSBhIGZyYWdtZW50IGJ5IHRha2luZyB0aGUgbWF4aW11bSBwb3NzaWJsZVxuICAgIG9wZW4gdmFsdWUgb24gYm90aCBzaWRlIG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXhPcGVuKGZyYWdtZW50LCBvcGVuSXNvbGF0aW5nID0gdHJ1ZSkge1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gMCwgb3BlbkVuZCA9IDA7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5maXJzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4uZmlyc3RDaGlsZClcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICBmb3IgKGxldCBuID0gZnJhZ21lbnQubGFzdENoaWxkOyBuICYmICFuLmlzTGVhZiAmJiAob3Blbklzb2xhdGluZyB8fCAhbi50eXBlLnNwZWMuaXNvbGF0aW5nKTsgbiA9IG4ubGFzdENoaWxkKVxuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGZyYWdtZW50LCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNsaWNlLlxuKi9cblNsaWNlLmVtcHR5ID0gbmV3IFNsaWNlKEZyYWdtZW50LmVtcHR5LCAwLCAwKTtcbmZ1bmN0aW9uIHJlbW92ZVJhbmdlKGNvbnRlbnQsIGZyb20sIHRvKSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZnJvbSksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBsZXQgeyBpbmRleDogaW5kZXhUbywgb2Zmc2V0OiBvZmZzZXRUbyB9ID0gY29udGVudC5maW5kSW5kZXgodG8pO1xuICAgIGlmIChvZmZzZXQgPT0gZnJvbSB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKG9mZnNldFRvICE9IHRvICYmICFjb250ZW50LmNoaWxkKGluZGV4VG8pLmlzVGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBmcm9tKS5hcHBlbmQoY29udGVudC5jdXQodG8pKTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9IGluZGV4VG8pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUmVtb3Zpbmcgbm9uLWZsYXQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KHJlbW92ZVJhbmdlKGNoaWxkLmNvbnRlbnQsIGZyb20gLSBvZmZzZXQgLSAxLCB0byAtIG9mZnNldCAtIDEpKSk7XG59XG5mdW5jdGlvbiBpbnNlcnRJbnRvKGNvbnRlbnQsIGRpc3QsIGluc2VydCwgcGFyZW50KSB7XG4gICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gY29udGVudC5maW5kSW5kZXgoZGlzdCksIGNoaWxkID0gY29udGVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICBpZiAob2Zmc2V0ID09IGRpc3QgfHwgY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgIXBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCwgaW5zZXJ0KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gY29udGVudC5jdXQoMCwgZGlzdCkuYXBwZW5kKGluc2VydCkuYXBwZW5kKGNvbnRlbnQuY3V0KGRpc3QpKTtcbiAgICB9XG4gICAgbGV0IGlubmVyID0gaW5zZXJ0SW50byhjaGlsZC5jb250ZW50LCBkaXN0IC0gb2Zmc2V0IC0gMSwgaW5zZXJ0LCBjaGlsZCk7XG4gICAgcmV0dXJuIGlubmVyICYmIGNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBjaGlsZC5jb3B5KGlubmVyKSk7XG59XG5mdW5jdGlvbiByZXBsYWNlKCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgaWYgKHNsaWNlLm9wZW5TdGFydCA+ICRmcm9tLmRlcHRoKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiSW5zZXJ0ZWQgY29udGVudCBkZWVwZXIgdGhhbiBpbnNlcnRpb24gcG9zaXRpb25cIik7XG4gICAgaWYgKCRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0ICE9ICR0by5kZXB0aCAtIHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbmNvbnNpc3RlbnQgb3BlbiBkZXB0aHNcIik7XG4gICAgcmV0dXJuIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgMCk7XG59XG5mdW5jdGlvbiByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoKSB7XG4gICAgbGV0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpLCBub2RlID0gJGZyb20ubm9kZShkZXB0aCk7XG4gICAgaWYgKGluZGV4ID09ICR0by5pbmRleChkZXB0aCkgJiYgZGVwdGggPCAkZnJvbS5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICBsZXQgaW5uZXIgPSByZXBsYWNlT3V0ZXIoJGZyb20sICR0bywgc2xpY2UsIGRlcHRoICsgMSk7XG4gICAgICAgIHJldHVybiBub2RlLmNvcHkobm9kZS5jb250ZW50LnJlcGxhY2VDaGlsZChpbmRleCwgaW5uZXIpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIXNsaWNlLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2Uub3BlblN0YXJ0ICYmICFzbGljZS5vcGVuRW5kICYmICRmcm9tLmRlcHRoID09IGRlcHRoICYmICR0by5kZXB0aCA9PSBkZXB0aCkgeyAvLyBTaW1wbGUsIGZsYXQgY2FzZVxuICAgICAgICBsZXQgcGFyZW50ID0gJGZyb20ucGFyZW50LCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQ7XG4gICAgICAgIHJldHVybiBjbG9zZShwYXJlbnQsIGNvbnRlbnQuY3V0KDAsICRmcm9tLnBhcmVudE9mZnNldCkuYXBwZW5kKHNsaWNlLmNvbnRlbnQpLmFwcGVuZChjb250ZW50LmN1dCgkdG8ucGFyZW50T2Zmc2V0KSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGV0IHsgc3RhcnQsIGVuZCB9ID0gcHJlcGFyZVNsaWNlRm9yUmVwbGFjZShzbGljZSwgJGZyb20pO1xuICAgICAgICByZXR1cm4gY2xvc2Uobm9kZSwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCBzdGFydCwgZW5kLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tKb2luKG1haW4sIHN1Yikge1xuICAgIGlmICghc3ViLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQobWFpbi50eXBlKSlcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkNhbm5vdCBqb2luIFwiICsgc3ViLnR5cGUubmFtZSArIFwiIG9udG8gXCIgKyBtYWluLnR5cGUubmFtZSk7XG59XG5mdW5jdGlvbiBqb2luYWJsZSgkYmVmb3JlLCAkYWZ0ZXIsIGRlcHRoKSB7XG4gICAgbGV0IG5vZGUgPSAkYmVmb3JlLm5vZGUoZGVwdGgpO1xuICAgIGNoZWNrSm9pbihub2RlLCAkYWZ0ZXIubm9kZShkZXB0aCkpO1xuICAgIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gYWRkTm9kZShjaGlsZCwgdGFyZ2V0KSB7XG4gICAgbGV0IGxhc3QgPSB0YXJnZXQubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA+PSAwICYmIGNoaWxkLmlzVGV4dCAmJiBjaGlsZC5zYW1lTWFya3VwKHRhcmdldFtsYXN0XSkpXG4gICAgICAgIHRhcmdldFtsYXN0XSA9IGNoaWxkLndpdGhUZXh0KHRhcmdldFtsYXN0XS50ZXh0ICsgY2hpbGQudGV4dCk7XG4gICAgZWxzZVxuICAgICAgICB0YXJnZXQucHVzaChjaGlsZCk7XG59XG5mdW5jdGlvbiBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCB0YXJnZXQpIHtcbiAgICBsZXQgbm9kZSA9ICgkZW5kIHx8ICRzdGFydCkubm9kZShkZXB0aCk7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSAwLCBlbmRJbmRleCA9ICRlbmQgPyAkZW5kLmluZGV4KGRlcHRoKSA6IG5vZGUuY2hpbGRDb3VudDtcbiAgICBpZiAoJHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0SW5kZXggPSAkc3RhcnQuaW5kZXgoZGVwdGgpO1xuICAgICAgICBpZiAoJHN0YXJ0LmRlcHRoID4gZGVwdGgpIHtcbiAgICAgICAgICAgIHN0YXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgkc3RhcnQudGV4dE9mZnNldCkge1xuICAgICAgICAgICAgYWRkTm9kZSgkc3RhcnQubm9kZUFmdGVyLCB0YXJnZXQpO1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgYWRkTm9kZShub2RlLmNoaWxkKGkpLCB0YXJnZXQpO1xuICAgIGlmICgkZW5kICYmICRlbmQuZGVwdGggPT0gZGVwdGggJiYgJGVuZC50ZXh0T2Zmc2V0KVxuICAgICAgICBhZGROb2RlKCRlbmQubm9kZUJlZm9yZSwgdGFyZ2V0KTtcbn1cbmZ1bmN0aW9uIGNsb3NlKG5vZGUsIGNvbnRlbnQpIHtcbiAgICBub2RlLnR5cGUuY2hlY2tDb250ZW50KGNvbnRlbnQpO1xuICAgIHJldHVybiBub2RlLmNvcHkoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSk7XG4gICAgbGV0IG9wZW5FbmQgPSAkdG8uZGVwdGggPiBkZXB0aCAmJiBqb2luYWJsZSgkZW5kLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmIChvcGVuU3RhcnQgJiYgb3BlbkVuZCAmJiAkc3RhcnQuaW5kZXgoZGVwdGgpID09ICRlbmQuaW5kZXgoZGVwdGgpKSB7XG4gICAgICAgIGNoZWNrSm9pbihvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5TdGFydCwgcmVwbGFjZVRocmVlV2F5KCRmcm9tLCAkc3RhcnQsICRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKG9wZW5TdGFydClcbiAgICAgICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkc3RhcnQsIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICAgICAgYWRkUmFuZ2UoJHN0YXJ0LCAkZW5kLCBkZXB0aCwgY29udGVudCk7XG4gICAgICAgIGlmIChvcGVuRW5kKVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuRW5kLCByZXBsYWNlVHdvV2F5KCRlbmQsICR0bywgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgIH1cbiAgICBhZGRSYW5nZSgkdG8sIG51bGwsIGRlcHRoLCBjb250ZW50KTtcbiAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCkge1xuICAgIGxldCBjb250ZW50ID0gW107XG4gICAgYWRkUmFuZ2UobnVsbCwgJGZyb20sIGRlcHRoLCBjb250ZW50KTtcbiAgICBpZiAoJGZyb20uZGVwdGggPiBkZXB0aCkge1xuICAgICAgICBsZXQgdHlwZSA9IGpvaW5hYmxlKCRmcm9tLCAkdG8sIGRlcHRoICsgMSk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2UodHlwZSwgcmVwbGFjZVR3b1dheSgkZnJvbSwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkYWxvbmcpIHtcbiAgICBsZXQgZXh0cmEgPSAkYWxvbmcuZGVwdGggLSBzbGljZS5vcGVuU3RhcnQsIHBhcmVudCA9ICRhbG9uZy5ub2RlKGV4dHJhKTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudC5jb3B5KHNsaWNlLmNvbnRlbnQpO1xuICAgIGZvciAobGV0IGkgPSBleHRyYSAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBub2RlID0gJGFsb25nLm5vZGUoaSkuY29weShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4geyBzdGFydDogbm9kZS5yZXNvbHZlTm9DYWNoZShzbGljZS5vcGVuU3RhcnQgKyBleHRyYSksXG4gICAgICAgIGVuZDogbm9kZS5yZXNvbHZlTm9DYWNoZShub2RlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQgLSBleHRyYSkgfTtcbn1cblxuLyoqXG5Zb3UgY2FuIFtfcmVzb2x2ZV9dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlc29sdmUpIGEgcG9zaXRpb24gdG8gZ2V0IG1vcmVcbmluZm9ybWF0aW9uIGFib3V0IGl0LiBPYmplY3RzIG9mIHRoaXMgY2xhc3MgcmVwcmVzZW50IHN1Y2ggYVxucmVzb2x2ZWQgcG9zaXRpb24sIHByb3ZpZGluZyB2YXJpb3VzIHBpZWNlcyBvZiBjb250ZXh0XG5pbmZvcm1hdGlvbiwgYW5kIHNvbWUgaGVscGVyIG1ldGhvZHMuXG5cblRocm91Z2hvdXQgdGhpcyBpbnRlcmZhY2UsIG1ldGhvZHMgdGhhdCB0YWtlIGFuIG9wdGlvbmFsIGBkZXB0aGBcbnBhcmFtZXRlciB3aWxsIGludGVycHJldCB1bmRlZmluZWQgYXMgYHRoaXMuZGVwdGhgIGFuZCBuZWdhdGl2ZVxubnVtYmVycyBhcyBgdGhpcy5kZXB0aCArIHZhbHVlYC5cbiovXG5jbGFzcyBSZXNvbHZlZFBvcyB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gdGhhdCB3YXMgcmVzb2x2ZWQuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcGF0aCwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCB0aGlzIHBvc2l0aW9uIGhhcyBpbnRvIGl0cyBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHBhcmVudE9mZnNldCkge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5wYXJlbnRPZmZzZXQgPSBwYXJlbnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuZGVwdGggPSBwYXRoLmxlbmd0aCAvIDMgLSAxO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVEZXB0aCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGg7XG4gICAgICAgIGlmICh2YWwgPCAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVwdGggKyB2YWw7XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSBwb3NpdGlvbiBwb2ludHMgaW50by4gTm90ZSB0aGF0IGV2ZW4gaWZcbiAgICBhIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCB0aGF0IG5vZGUgaXMgbm90IGNvbnNpZGVyZWRcbiAgICB0aGUgcGFyZW504oCUdGV4dCBub2RlcyBhcmUg4oCYZmxhdOKAmSBpbiB0aGlzIG1vZGVsLCBhbmQgaGF2ZSBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IHBhcmVudCgpIHsgcmV0dXJuIHRoaXMubm9kZSh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSByb290IG5vZGUgaW4gd2hpY2ggdGhlIHBvc2l0aW9uIHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIGdldCBkb2MoKSB7IHJldHVybiB0aGlzLm5vZGUoMCk7IH1cbiAgICAvKipcbiAgICBUaGUgYW5jZXN0b3Igbm9kZSBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIGBwLm5vZGUocC5kZXB0aClgIGlzIHRoZVxuICAgIHNhbWUgYXMgYHAucGFyZW50YC5cbiAgICAqL1xuICAgIG5vZGUoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzXTsgfVxuICAgIC8qKlxuICAgIFRoZSBpbmRleCBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGUgZ2l2ZW4gbGV2ZWwuIElmIHRoaXMgcG9pbnRzXG4gICAgYXQgdGhlIDNyZCBub2RlIGluIHRoZSAybmQgcGFyYWdyYXBoIG9uIHRoZSB0b3AgbGV2ZWwsIGZvclxuICAgIGV4YW1wbGUsIGBwLmluZGV4KDApYCBpcyAxIGFuZCBgcC5pbmRleCgxKWAgaXMgMi5cbiAgICAqL1xuICAgIGluZGV4KGRlcHRoKSB7IHJldHVybiB0aGlzLnBhdGhbdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpICogMyArIDFdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IHBvaW50aW5nIGFmdGVyIHRoaXMgcG9zaXRpb24gaW50byB0aGUgYW5jZXN0b3IgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwuXG4gICAgKi9cbiAgICBpbmRleEFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleChkZXB0aCkgKyAoZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAhdGhpcy50ZXh0T2Zmc2V0ID8gMCA6IDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIG5vZGUgYXQgdGhlIGdpdmVuXG4gICAgbGV2ZWwuXG4gICAgKi9cbiAgICBzdGFydChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IDAgPyAwIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgMTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIGVuZChkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoZGVwdGgpICsgdGhpcy5ub2RlKGRlcHRoKS5jb250ZW50LnNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGJlZm9yZSB0aGUgd3JhcHBpbmcgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbCwgb3IsIHdoZW4gYGRlcHRoYCBpcyBgdGhpcy5kZXB0aCArIDFgLCB0aGUgb3JpZ2luYWxcbiAgICBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGJlZm9yZShkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYmVmb3JlIHRoZSB0b3AtbGV2ZWwgbm9kZVwiKTtcbiAgICAgICAgcmV0dXJuIGRlcHRoID09IHRoaXMuZGVwdGggKyAxID8gdGhpcy5wb3MgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV07XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGRpcmVjdGx5IGFmdGVyIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAuXG4gICAgKi9cbiAgICBhZnRlcihkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgaWYgKCFkZXB0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlcmUgaXMgbm8gcG9zaXRpb24gYWZ0ZXIgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIHRoaXMucGF0aFtkZXB0aCAqIDNdLm5vZGVTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGVuIHRoaXMgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoaXMgcmV0dXJucyB0aGVcbiAgICBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBwb3NpdGlvbiBhbmQgdGhlIHN0YXJ0IG9mIHRoZSB0ZXh0IG5vZGUuXG4gICAgV2lsbCBiZSB6ZXJvIGZvciBwb3NpdGlvbnMgdGhhdCBwb2ludCBiZXR3ZWVuIG5vZGVzLlxuICAgICovXG4gICAgZ2V0IHRleHRPZmZzZXQoKSB7IHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYWZ0ZXIgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZSBwb3NpdGlvblxuICAgIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZSBhZnRlciB0aGVcbiAgICBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIGdldCBub2RlQWZ0ZXIoKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudCwgaW5kZXggPSB0aGlzLmluZGV4KHRoaXMuZGVwdGgpO1xuICAgICAgICBpZiAoaW5kZXggPT0gcGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV0sIGNoaWxkID0gcGFyZW50LmNoaWxkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIGRPZmYgPyBwYXJlbnQuY2hpbGQoaW5kZXgpLmN1dChkT2ZmKSA6IGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG5vZGUgZGlyZWN0bHkgYmVmb3JlIHRoZSBwb3NpdGlvbiwgaWYgYW55LiBJZiB0aGVcbiAgICBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgb25seSB0aGUgcGFydCBvZiB0aGF0IG5vZGVcbiAgICBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVCZWZvcmUoKSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGxldCBkT2ZmID0gdGhpcy5wb3MgLSB0aGlzLnBhdGhbdGhpcy5wYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoZE9mZilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCkuY3V0KDAsIGRPZmYpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT0gMCA/IG51bGwgOiB0aGlzLnBhcmVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBpbmRleCBpbiB0aGUgcGFyZW50IG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gZGVwdGggKHdoaWNoIGRlZmF1bHRzIHRvIGB0aGlzLmRlcHRoYCkuXG4gICAgKi9cbiAgICBwb3NBdEluZGV4KGluZGV4LCBkZXB0aCkge1xuICAgICAgICBkZXB0aCA9IHRoaXMucmVzb2x2ZURlcHRoKGRlcHRoKTtcbiAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnBhdGhbZGVwdGggKiAzXSwgcG9zID0gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICBwb3MgKz0gbm9kZS5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhdCB0aGlzIHBvc2l0aW9uLCBmYWN0b3JpbmcgaW4gdGhlIHN1cnJvdW5kaW5nXG4gICAgbWFya3MnIFtgaW5jbHVzaXZlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmluY2x1c2l2ZSkgcHJvcGVydHkuIElmIHRoZVxuICAgIHBvc2l0aW9uIGlzIGF0IHRoZSBzdGFydCBvZiBhIG5vbi1lbXB0eSBub2RlLCB0aGUgbWFya3Mgb2YgdGhlXG4gICAgbm9kZSBhZnRlciBpdCAoaWYgYW55KSBhcmUgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBtYXJrcygpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgoKTtcbiAgICAgICAgLy8gSW4gYW4gZW1wdHkgcGFyZW50LCByZXR1cm4gdGhlIGVtcHR5IGFycmF5XG4gICAgICAgIGlmIChwYXJlbnQuY29udGVudC5zaXplID09IDApXG4gICAgICAgICAgICByZXR1cm4gTWFyay5ub25lO1xuICAgICAgICAvLyBXaGVuIGluc2lkZSBhIHRleHQgbm9kZSwganVzdCByZXR1cm4gdGhlIHRleHQgbm9kZSdzIG1hcmtzXG4gICAgICAgIGlmICh0aGlzLnRleHRPZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gcGFyZW50LmNoaWxkKGluZGV4KS5tYXJrcztcbiAgICAgICAgbGV0IG1haW4gPSBwYXJlbnQubWF5YmVDaGlsZChpbmRleCAtIDEpLCBvdGhlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgLy8gSWYgdGhlIGBhZnRlcmAgZmxhZyBpcyB0cnVlIG9mIHRoZXJlIGlzIG5vIG5vZGUgYmVmb3JlLCBtYWtlXG4gICAgICAgIC8vIHRoZSBub2RlIGFmdGVyIHRoaXMgcG9zaXRpb24gdGhlIG1haW4gcmVmZXJlbmNlLlxuICAgICAgICBpZiAoIW1haW4pIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSBtYWluO1xuICAgICAgICAgICAgbWFpbiA9IG90aGVyO1xuICAgICAgICAgICAgb3RoZXIgPSB0bXA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGFsbCBtYXJrcyBpbiB0aGUgbWFpbiBub2RlLCBleGNlcHQgdGhvc2UgdGhhdCBoYXZlXG4gICAgICAgIC8vIGBpbmNsdXNpdmVgIHNldCB0byBmYWxzZSBhbmQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSBvdGhlciBub2RlLlxuICAgICAgICBsZXQgbWFya3MgPSBtYWluLm1hcmtzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghb3RoZXIgfHwgIW1hcmtzW2ldLmlzSW5TZXQob3RoZXIubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBtYXJrcyBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgaWYgYW55LCBleGNlcHQgdGhvc2VcbiAgICB0aGF0IGFyZSBub24taW5jbHVzaXZlIGFuZCBub3QgcHJlc2VudCBhdCBwb3NpdGlvbiBgJGVuZGAuIFRoaXNcbiAgICBpcyBtb3N0bHkgdXNlZnVsIGZvciBnZXR0aW5nIHRoZSBzZXQgb2YgbWFya3MgdG8gcHJlc2VydmUgYWZ0ZXIgYVxuICAgIGRlbGV0aW9uLiBXaWxsIHJldHVybiBgbnVsbGAgaWYgdGhpcyBwb3NpdGlvbiBpcyBhdCB0aGUgZW5kIG9mXG4gICAgaXRzIHBhcmVudCBub2RlIG9yIGl0cyBwYXJlbnQgbm9kZSBpc24ndCBhIHRleHRibG9jayAoaW4gd2hpY2hcbiAgICBjYXNlIG5vIG1hcmtzIHNob3VsZCBiZSBwcmVzZXJ2ZWQpLlxuICAgICovXG4gICAgbWFya3NBY3Jvc3MoJGVuZCkge1xuICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLnBhcmVudC5tYXliZUNoaWxkKHRoaXMuaW5kZXgoKSk7XG4gICAgICAgIGlmICghYWZ0ZXIgfHwgIWFmdGVyLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBtYXJrcyA9IGFmdGVyLm1hcmtzLCBuZXh0ID0gJGVuZC5wYXJlbnQubWF5YmVDaGlsZCgkZW5kLmluZGV4KCkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKG1hcmtzW2ldLnR5cGUuc3BlYy5pbmNsdXNpdmUgPT09IGZhbHNlICYmICghbmV4dCB8fCAhbWFya3NbaV0uaXNJblNldChuZXh0Lm1hcmtzKSkpXG4gICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrc1tpLS1dLnJlbW92ZUZyb21TZXQobWFya3MpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCB1cCB0byB3aGljaCB0aGlzIHBvc2l0aW9uIGFuZCB0aGUgZ2l2ZW4gKG5vbi1yZXNvbHZlZClcbiAgICBwb3NpdGlvbiBzaGFyZSB0aGUgc2FtZSBwYXJlbnQgbm9kZXMuXG4gICAgKi9cbiAgICBzaGFyZWREZXB0aChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgZGVwdGggPSB0aGlzLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFydChkZXB0aCkgPD0gcG9zICYmIHRoaXMuZW5kKGRlcHRoKSA+PSBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlcHRoO1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyBhIHJhbmdlIGJhc2VkIG9uIHRoZSBwbGFjZSB3aGVyZSB0aGlzIHBvc2l0aW9uIGFuZCB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbiBkaXZlcmdlIGFyb3VuZCBibG9jayBjb250ZW50LiBJZiBib3RoIHBvaW50IGludG9cbiAgICB0aGUgc2FtZSB0ZXh0YmxvY2ssIGZvciBleGFtcGxlLCBhIHJhbmdlIGFyb3VuZCB0aGF0IHRleHRibG9ja1xuICAgIHdpbGwgYmUgcmV0dXJuZWQuIElmIHRoZXkgcG9pbnQgaW50byBkaWZmZXJlbnQgYmxvY2tzLCB0aGUgcmFuZ2VcbiAgICBhcm91bmQgdGhvc2UgYmxvY2tzIGluIHRoZWlyIHNoYXJlZCBhbmNlc3RvciBpcyByZXR1cm5lZC4gWW91IGNhblxuICAgIHBhc3MgaW4gYW4gb3B0aW9uYWwgcHJlZGljYXRlIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2l0aCBhIHBhcmVudFxuICAgIG5vZGUgdG8gc2VlIGlmIGEgcmFuZ2UgaW50byB0aGF0IHBhcmVudCBpcyBhY2NlcHRhYmxlLlxuICAgICovXG4gICAgYmxvY2tSYW5nZShvdGhlciA9IHRoaXMsIHByZWQpIHtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA8IHRoaXMucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyLmJsb2NrUmFuZ2UodGhpcyk7XG4gICAgICAgIGZvciAobGV0IGQgPSB0aGlzLmRlcHRoIC0gKHRoaXMucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdGhpcy5wb3MgPT0gb3RoZXIucG9zID8gMSA6IDApOyBkID49IDA7IGQtLSlcbiAgICAgICAgICAgIGlmIChvdGhlci5wb3MgPD0gdGhpcy5lbmQoZCkgJiYgKCFwcmVkIHx8IHByZWQodGhpcy5ub2RlKGQpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2RlUmFuZ2UodGhpcywgb3RoZXIsIGQpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gc2hhcmVzIHRoZSBzYW1lIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgc2FtZVBhcmVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3MgLSB0aGlzLnBhcmVudE9mZnNldCA9PSBvdGhlci5wb3MgLSBvdGhlci5wYXJlbnRPZmZzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgZ3JlYXRlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtYXgob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA+IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gdGhlIHNtYWxsZXIgb2YgdGhpcyBhbmQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgbWluKG90aGVyKSB7XG4gICAgICAgIHJldHVybiBvdGhlci5wb3MgPCB0aGlzLnBvcyA/IG90aGVyIDogdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMuZGVwdGg7IGkrKylcbiAgICAgICAgICAgIHN0ciArPSAoc3RyID8gXCIvXCIgOiBcIlwiKSArIHRoaXMubm9kZShpKS50eXBlLm5hbWUgKyBcIl9cIiArIHRoaXMuaW5kZXgoaSAtIDEpO1xuICAgICAgICByZXR1cm4gc3RyICsgXCI6XCIgKyB0aGlzLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZShkb2MsIHBvcykge1xuICAgICAgICBpZiAoIShwb3MgPj0gMCAmJiBwb3MgPD0gZG9jLmNvbnRlbnQuc2l6ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBvc2l0aW9uIFwiICsgcG9zICsgXCIgb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgICBsZXQgcGF0aCA9IFtdO1xuICAgICAgICBsZXQgc3RhcnQgPSAwLCBwYXJlbnRPZmZzZXQgPSBwb3M7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSBkb2M7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwYXJlbnRPZmZzZXQpO1xuICAgICAgICAgICAgbGV0IHJlbSA9IHBhcmVudE9mZnNldCAtIG9mZnNldDtcbiAgICAgICAgICAgIHBhdGgucHVzaChub2RlLCBpbmRleCwgc3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKCFyZW0pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwYXJlbnRPZmZzZXQgPSByZW0gLSAxO1xuICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlc29sdmVkUG9zKHBvcywgcGF0aCwgcGFyZW50T2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgcmVzb2x2ZUNhY2hlZChkb2MsIHBvcykge1xuICAgICAgICBsZXQgY2FjaGUgPSByZXNvbHZlQ2FjaGUuZ2V0KGRvYyk7XG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWNoZS5lbHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVsdCA9IGNhY2hlLmVsdHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGVsdC5wb3MgPT0gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZUNhY2hlLnNldChkb2MsIGNhY2hlID0gbmV3IFJlc29sdmVDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IGNhY2hlLmVsdHNbY2FjaGUuaV0gPSBSZXNvbHZlZFBvcy5yZXNvbHZlKGRvYywgcG9zKTtcbiAgICAgICAgY2FjaGUuaSA9IChjYWNoZS5pICsgMSkgJSByZXNvbHZlQ2FjaGVTaXplO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmNsYXNzIFJlc29sdmVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZWx0cyA9IFtdO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgIH1cbn1cbmNvbnN0IHJlc29sdmVDYWNoZVNpemUgPSAxMiwgcmVzb2x2ZUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuUmVwcmVzZW50cyBhIGZsYXQgcmFuZ2Ugb2YgY29udGVudCwgaS5lLiBvbmUgdGhhdCBzdGFydHMgYW5kXG5lbmRzIGluIHRoZSBzYW1lIG5vZGUuXG4qL1xuY2xhc3MgTm9kZVJhbmdlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBub2RlIHJhbmdlLiBgJGZyb21gIGFuZCBgJHRvYCBzaG91bGQgcG9pbnQgaW50byB0aGVcbiAgICBzYW1lIG5vZGUgdW50aWwgYXQgbGVhc3QgdGhlIGdpdmVuIGBkZXB0aGAsIHNpbmNlIGEgbm9kZSByYW5nZVxuICAgIGRlbm90ZXMgYW4gYWRqYWNlbnQgc2V0IG9mIG5vZGVzIGluIGEgc2luZ2xlIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQSByZXNvbHZlZCBwb3NpdGlvbiBhbG9uZyB0aGUgc3RhcnQgb2YgdGhlIGNvbnRlbnQuIE1heSBoYXZlIGFcbiAgICBgZGVwdGhgIGdyZWF0ZXIgdGhhbiB0aGlzIG9iamVjdCdzIGBkZXB0aGAgcHJvcGVydHksIHNpbmNlXG4gICAgdGhlc2UgYXJlIHRoZSBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVzZWQgdG8gY29tcHV0ZSB0aGUgcmFuZ2UsXG4gICAgbm90IHJlLXJlc29sdmVkIHBvc2l0aW9ucyBkaXJlY3RseSBhdCBpdHMgYm91bmRhcmllcy5cbiAgICAqL1xuICAgICRmcm9tLCBcbiAgICAvKipcbiAgICBBIHBvc2l0aW9uIGFsb25nIHRoZSBlbmQgb2YgdGhlIGNvbnRlbnQuIFNlZVxuICAgIGNhdmVhdCBmb3IgW2AkZnJvbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UuJGZyb20pLlxuICAgICovXG4gICAgJHRvLCBcbiAgICAvKipcbiAgICBUaGUgZGVwdGggb2YgdGhlIG5vZGUgdGhhdCB0aGlzIHJhbmdlIHBvaW50cyBpbnRvLlxuICAgICovXG4gICAgZGVwdGgpIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gYXQgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuJGZyb20uYmVmb3JlKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAqL1xuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLiR0by5hZnRlcih0aGlzLmRlcHRoICsgMSk7IH1cbiAgICAvKipcbiAgICBUaGUgcGFyZW50IG5vZGUgdGhhdCB0aGUgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgc3RhcnRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJGZyb20uaW5kZXgodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgZW5kIGluZGV4IG9mIHRoZSByYW5nZSBpbiB0aGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgZW5kSW5kZXgoKSB7IHJldHVybiB0aGlzLiR0by5pbmRleEFmdGVyKHRoaXMuZGVwdGgpOyB9XG59XG5cbmNvbnN0IGVtcHR5QXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5UaGlzIGNsYXNzIHJlcHJlc2VudHMgYSBub2RlIGluIHRoZSB0cmVlIHRoYXQgbWFrZXMgdXAgYVxuUHJvc2VNaXJyb3IgZG9jdW1lbnQuIFNvIGEgZG9jdW1lbnQgaXMgYW4gaW5zdGFuY2Ugb2YgYE5vZGVgLCB3aXRoXG5jaGlsZHJlbiB0aGF0IGFyZSBhbHNvIGluc3RhbmNlcyBvZiBgTm9kZWAuXG5cbk5vZGVzIGFyZSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJlcy4gSW5zdGVhZCBvZiBjaGFuZ2luZyB0aGVtLCB5b3VcbmNyZWF0ZSBuZXcgb25lcyB3aXRoIHRoZSBjb250ZW50IHlvdSB3YW50LiBPbGQgb25lcyBrZWVwIHBvaW50aW5nXG5hdCB0aGUgb2xkIGRvY3VtZW50IHNoYXBlLiBUaGlzIGlzIG1hZGUgY2hlYXBlciBieSBzaGFyaW5nXG5zdHJ1Y3R1cmUgYmV0d2VlbiB0aGUgb2xkIGFuZCBuZXcgZGF0YSBhcyBtdWNoIGFzIHBvc3NpYmxlLCB3aGljaCBhXG50cmVlIHNoYXBlIGxpa2UgdGhpcyAod2l0aG91dCBiYWNrIHBvaW50ZXJzKSBtYWtlcyBlYXN5LlxuXG4qKkRvIG5vdCoqIGRpcmVjdGx5IG11dGF0ZSB0aGUgcHJvcGVydGllcyBvZiBhIGBOb2RlYCBvYmplY3QuIFNlZVxuW3RoZSBndWlkZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZG9jKSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiovXG5jbGFzcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIG5vZGUgdGhhdCB0aGlzIGlzLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgQW4gb2JqZWN0IG1hcHBpbmcgYXR0cmlidXRlIG5hbWVzIHRvIHZhbHVlcy4gVGhlIGtpbmQgb2ZcbiAgICBhdHRyaWJ1dGVzIGFsbG93ZWQgYW5kIHJlcXVpcmVkIGFyZVxuICAgIFtkZXRlcm1pbmVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuYXR0cnMpIGJ5IHRoZSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBhdHRycywgXG4gICAgLy8gQSBmcmFnbWVudCBob2xkaW5nIHRoZSBub2RlJ3MgY2hpbGRyZW4uXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG1hcmtzICh0aGluZ3MgbGlrZSB3aGV0aGVyIGl0IGlzIGVtcGhhc2l6ZWQgb3IgcGFydCBvZiBhXG4gICAgbGluaykgYXBwbGllZCB0byB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBtYXJrcyA9IE1hcmsubm9uZSkge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmF0dHJzID0gYXR0cnM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudCB8fCBGcmFnbWVudC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGFycmF5IG9mIHRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgZ2V0IGNoaWxkcmVuKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUaGUgc2l6ZSBvZiB0aGlzIG5vZGUsIGFzIGRlZmluZWQgYnkgdGhlIGludGVnZXItYmFzZWQgW2luZGV4aW5nXG4gICAgc2NoZW1lXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNkb2MuaW5kZXhpbmcpLiBGb3IgdGV4dCBub2RlcywgdGhpcyBpcyB0aGVcbiAgICBhbW91bnQgb2YgY2hhcmFjdGVycy4gRm9yIG90aGVyIGxlYWYgbm9kZXMsIGl0IGlzIG9uZS4gRm9yXG4gICAgbm9uLWxlYWYgbm9kZXMsIGl0IGlzIHRoZSBzaXplIG9mIHRoZSBjb250ZW50IHBsdXMgdHdvICh0aGVcbiAgICBzdGFydCBhbmQgZW5kIHRva2VuKS5cbiAgICAqL1xuICAgIGdldCBub2RlU2l6ZSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmID8gMSA6IDIgKyB0aGlzLmNvbnRlbnQuc2l6ZTsgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCB0aGUgbm9kZSBoYXMuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRDb3VudCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZENvdW50OyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2VzIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgaW5kZXggaXMgb3V0IG9mIHJhbmdlLlxuICAgICovXG4gICAgY2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5jaGlsZChpbmRleCk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LCBpZiBpdCBleGlzdHMuXG4gICAgKi9cbiAgICBtYXliZUNoaWxkKGluZGV4KSB7IHJldHVybiB0aGlzLmNvbnRlbnQubWF5YmVDaGlsZChpbmRleCk7IH1cbiAgICAvKipcbiAgICBDYWxsIGBmYCBmb3IgZXZlcnkgY2hpbGQgbm9kZSwgcGFzc2luZyB0aGUgbm9kZSwgaXRzIG9mZnNldFxuICAgIGludG8gdGhpcyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBpbmRleC5cbiAgICAqL1xuICAgIGZvckVhY2goZikgeyB0aGlzLmNvbnRlbnQuZm9yRWFjaChmKTsgfVxuICAgIC8qKlxuICAgIEludm9rZSBhIGNhbGxiYWNrIGZvciBhbGwgZGVzY2VuZGFudCBub2RlcyByZWN1cnNpdmVseSBiZXR3ZWVuXG4gICAgdGhlIGdpdmVuIHR3byBwb3NpdGlvbnMgdGhhdCBhcmUgcmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpc1xuICAgIG5vZGUncyBjb250ZW50LiBUaGUgY2FsbGJhY2sgaXMgaW52b2tlZCB3aXRoIHRoZSBub2RlLCBpdHNcbiAgICBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgb3JpZ2luYWwgbm9kZSAobWV0aG9kIHJlY2VpdmVyKSxcbiAgICBpdHMgcGFyZW50IG5vZGUsIGFuZCBpdHMgY2hpbGQgaW5kZXguIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgICBmYWxzZSBmb3IgYSBnaXZlbiBub2RlLCB0aGF0IG5vZGUncyBjaGlsZHJlbiB3aWxsIG5vdCBiZVxuICAgIHJlY3Vyc2VkIG92ZXIuIFRoZSBsYXN0IHBhcmFtZXRlciBjYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGFcbiAgICBzdGFydGluZyBwb3NpdGlvbiB0byBjb3VudCBmcm9tLlxuICAgICovXG4gICAgbm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcyA9IDApIHtcbiAgICAgICAgdGhpcy5jb250ZW50Lm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgc3RhcnRQb3MsIHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBEb2Vzbid0XG4gICAgZGVzY2VuZCBpbnRvIGEgbm9kZSB3aGVuIHRoZSBjYWxsYmFjayByZXR1cm5zIGBmYWxzZWAuXG4gICAgKi9cbiAgICBkZXNjZW5kYW50cyhmKSB7XG4gICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBmKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uY2F0ZW5hdGVzIGFsbCB0aGUgdGV4dCBub2RlcyBmb3VuZCBpbiB0aGlzIGZyYWdtZW50IGFuZCBpdHNcbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzTGVhZiAmJiB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dClcbiAgICAgICAgICAgID8gdGhpcy50eXBlLnNwZWMubGVhZlRleHQodGhpcylcbiAgICAgICAgICAgIDogdGhpcy50ZXh0QmV0d2VlbigwLCB0aGlzLmNvbnRlbnQuc2l6ZSwgXCJcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhbGwgdGV4dCBiZXR3ZWVuIHBvc2l0aW9ucyBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgYmxvY2tTZXBhcmF0b3JgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIGluc2VydGVkIHRvIHNlcGFyYXRlIHRleHRcbiAgICBmcm9tIGRpZmZlcmVudCBibG9jayBub2Rlcy4gSWYgYGxlYWZUZXh0YCBpcyBnaXZlbiwgaXQnbGwgYmVcbiAgICBpbnNlcnRlZCBmb3IgZXZlcnkgbm9uLXRleHQgbGVhZiBub2RlIGVuY291bnRlcmVkLCBvdGhlcndpc2VcbiAgICBbYGxlYWZUZXh0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmxlYWZUZXh0KSB3aWxsIGJlIHVzZWQuXG4gICAgKi9cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQudGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQsIG9yIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQsIG9yIGBudWxsYCBpZiB0aGVyZSBhcmUgbm9cbiAgICBjaGlsZHJlbi5cbiAgICAqL1xuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGFzdENoaWxkOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHR3byBub2RlcyByZXByZXNlbnQgdGhlIHNhbWUgcGllY2Ugb2YgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCAodGhpcy5zYW1lTWFya3VwKG90aGVyKSAmJiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoZSBtYXJrdXAgKHR5cGUsIGF0dHJpYnV0ZXMsIGFuZCBtYXJrcykgb2YgdGhpcyBub2RlIHRvXG4gICAgdGhvc2Ugb2YgYW5vdGhlci4gUmV0dXJucyBgdHJ1ZWAgaWYgYm90aCBoYXZlIHRoZSBzYW1lIG1hcmt1cC5cbiAgICAqL1xuICAgIHNhbWVNYXJrdXAob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzTWFya3VwKG90aGVyLnR5cGUsIG90aGVyLmF0dHJzLCBvdGhlci5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBub2RlJ3MgbWFya3VwIGNvcnJlc3BvbmQgdG8gdGhlIGdpdmVuIHR5cGUsXG4gICAgYXR0cmlidXRlcywgYW5kIG1hcmtzLlxuICAgICovXG4gICAgaGFzTWFya3VwKHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09IHR5cGUgJiZcbiAgICAgICAgICAgIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIGF0dHJzIHx8IHR5cGUuZGVmYXVsdEF0dHJzIHx8IGVtcHR5QXR0cnMpICYmXG4gICAgICAgICAgICBNYXJrLnNhbWVTZXQodGhpcy5tYXJrcywgbWFya3MgfHwgTWFyay5ub25lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgd2l0aCB0aGUgc2FtZSBtYXJrdXAgYXMgdGhpcyBub2RlLCBjb250YWluaW5nXG4gICAgdGhlIGdpdmVuIGNvbnRlbnQgKG9yIGVtcHR5LCBpZiBubyBjb250ZW50IGlzIGdpdmVuKS5cbiAgICAqL1xuICAgIGNvcHkoY29udGVudCA9IG51bGwpIHtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gdGhpcy5jb250ZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSwgd2l0aCB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGluc3RlYWRcbiAgICBvZiB0aGUgbm9kZSdzIG93biBtYXJrcy5cbiAgICAqL1xuICAgIG1hcmsobWFya3MpIHtcbiAgICAgICAgcmV0dXJuIG1hcmtzID09IHRoaXMubWFya3MgPyB0aGlzIDogbmV3IE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLmNvbnRlbnQsIG1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgY29weSBvZiB0aGlzIG5vZGUgd2l0aCBvbmx5IHRoZSBjb250ZW50IGJldHdlZW4gdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb25zLiBJZiBgdG9gIGlzIG5vdCBnaXZlbiwgaXQgZGVmYXVsdHMgdG8gdGhlIGVuZCBvZlxuICAgIHRoZSBub2RlLlxuICAgICovXG4gICAgY3V0KGZyb20sIHRvID0gdGhpcy5jb250ZW50LnNpemUpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gMCAmJiB0byA9PSB0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5jb3B5KHRoaXMuY29udGVudC5jdXQoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3V0IG91dCB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLCBhbmRcbiAgICByZXR1cm4gaXQgYXMgYSBgU2xpY2VgIG9iamVjdC5cbiAgICAqL1xuICAgIHNsaWNlKGZyb20sIHRvID0gdGhpcy5jb250ZW50LnNpemUsIGluY2x1ZGVQYXJlbnRzID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGZyb20gPT0gdG8pXG4gICAgICAgICAgICByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCAkZnJvbSA9IHRoaXMucmVzb2x2ZShmcm9tKSwgJHRvID0gdGhpcy5yZXNvbHZlKHRvKTtcbiAgICAgICAgbGV0IGRlcHRoID0gaW5jbHVkZVBhcmVudHMgPyAwIDogJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgICAgICBsZXQgc3RhcnQgPSAkZnJvbS5zdGFydChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBub2RlLmNvbnRlbnQuY3V0KCRmcm9tLnBvcyAtIHN0YXJ0LCAkdG8ucG9zIC0gc3RhcnQpO1xuICAgICAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsICRmcm9tLmRlcHRoIC0gZGVwdGgsICR0by5kZXB0aCAtIGRlcHRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgcGFydCBvZiB0aGUgZG9jdW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zIHdpdGhcbiAgICB0aGUgZ2l2ZW4gc2xpY2UuIFRoZSBzbGljZSBtdXN0ICdmaXQnLCBtZWFuaW5nIGl0cyBvcGVuIHNpZGVzXG4gICAgbXVzdCBiZSBhYmxlIHRvIGNvbm5lY3QgdG8gdGhlIHN1cnJvdW5kaW5nIGNvbnRlbnQsIGFuZCBpdHNcbiAgICBjb250ZW50IG5vZGVzIG11c3QgYmUgdmFsaWQgY2hpbGRyZW4gZm9yIHRoZSBub2RlIHRoZXkgYXJlIHBsYWNlZFxuICAgIGludG8uIElmIGFueSBvZiB0aGlzIGlzIHZpb2xhdGVkLCBhbiBlcnJvciBvZiB0eXBlXG4gICAgW2BSZXBsYWNlRXJyb3JgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUmVwbGFjZUVycm9yKSBpcyB0aHJvd24uXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZSh0aGlzLnJlc29sdmUoZnJvbSksIHRoaXMucmVzb2x2ZSh0byksIHNsaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBub2RlQXQocG9zKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0aGlzOzspIHtcbiAgICAgICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKG9mZnNldCA9PSBwb3MgfHwgbm9kZS5pc1RleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICBwb3MgLT0gb2Zmc2V0ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSAoZGlyZWN0KSBjaGlsZCBub2RlIGFmdGVyIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEFmdGVyKHBvcykge1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KSwgaW5kZXgsIG9mZnNldCB9O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSAoZGlyZWN0KSBjaGlsZCBub2RlIGJlZm9yZSB0aGUgZ2l2ZW4gb2Zmc2V0LCBpZiBhbnksXG4gICAgYW5kIHJldHVybiBpdCBhbG9uZyB3aXRoIGl0cyBpbmRleCBhbmQgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoaXNcbiAgICBub2RlLlxuICAgICovXG4gICAgY2hpbGRCZWZvcmUocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG51bGwsIGluZGV4OiAwLCBvZmZzZXQ6IDAgfTtcbiAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gdGhpcy5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICBpZiAob2Zmc2V0IDwgcG9zKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KSwgaW5kZXgsIG9mZnNldCB9O1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuY29udGVudC5jaGlsZChpbmRleCAtIDEpO1xuICAgICAgICByZXR1cm4geyBub2RlLCBpbmRleDogaW5kZXggLSAxLCBvZmZzZXQ6IG9mZnNldCAtIG5vZGUubm9kZVNpemUgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVzb2x2ZSB0aGUgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCByZXR1cm5pbmcgYW5cbiAgICBbb2JqZWN0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUmVzb2x2ZWRQb3MpIHdpdGggaW5mb3JtYXRpb24gYWJvdXQgaXRzIGNvbnRleHQuXG4gICAgKi9cbiAgICByZXNvbHZlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZUNhY2hlZCh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNvbHZlTm9DYWNoZShwb3MpIHsgcmV0dXJuIFJlc29sdmVkUG9zLnJlc29sdmUodGhpcywgcG9zKTsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIG1hcmsgb3IgbWFyayB0eXBlIG9jY3VycyBpbiB0aGlzIGRvY3VtZW50XG4gICAgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIHJhbmdlSGFzTWFyayhmcm9tLCB0bywgdHlwZSkge1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRvID4gZnJvbSlcbiAgICAgICAgICAgIHRoaXMubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZS5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgYmxvY2sgKG5vbi1pbmxpbmUgbm9kZSlcbiAgICAqL1xuICAgIGdldCBpc0Jsb2NrKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIHRleHRibG9jayBub2RlLCBhIGJsb2NrIG5vZGUgd2l0aCBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dGJsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBhbGxvd3MgaW5saW5lIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHsgcmV0dXJuIHRoaXMudHlwZS5pbmxpbmVDb250ZW50OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gaW5saW5lIG5vZGUgKGEgdGV4dCBub2RlIG9yIGEgbm9kZSB0aGF0IGNhblxuICAgIGFwcGVhciBhbW9uZyB0ZXh0KS5cbiAgICAqL1xuICAgIGdldCBpc0lubGluZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0lubGluZTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dCBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzVGV4dCgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc1RleHQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhIGxlYWYgbm9kZS5cbiAgICAqL1xuICAgIGdldCBpc0xlYWYoKSB7IHJldHVybiB0aGlzLnR5cGUuaXNMZWFmOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmUgZGlyZWN0bHlcbiAgICBlZGl0YWJsZSBjb250ZW50LiBUaGlzIGlzIHVzdWFsbHkgdGhlIHNhbWUgYXMgYGlzTGVhZmAsIGJ1dCBjYW5cbiAgICBiZSBjb25maWd1cmVkIHdpdGggdGhlIFtgYXRvbWAgcHJvcGVydHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdG9tKVxuICAgIG9uIGEgbm9kZSdzIHNwZWMgKHR5cGljYWxseSB1c2VkIHdoZW4gdGhlIG5vZGUgaXMgZGlzcGxheWVkIGFzXG4gICAgYW4gdW5lZGl0YWJsZSBbbm9kZSB2aWV3XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5Ob2RlVmlldykpLlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0F0b207IH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlIGZvciBkZWJ1Z2dpbmdcbiAgICBwdXJwb3Nlcy5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgICBsZXQgbmFtZSA9IHRoaXMudHlwZS5uYW1lO1xuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBuYW1lICs9IFwiKFwiICsgdGhpcy5jb250ZW50LnRvU3RyaW5nSW5uZXIoKSArIFwiKVwiO1xuICAgICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIG5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRlbnQgbWF0Y2ggaW4gdGhpcyBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC5cbiAgICAqL1xuICAgIGNvbnRlbnRNYXRjaEF0KGluZGV4KSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIDAsIGluZGV4KTtcbiAgICAgICAgaWYgKCFtYXRjaClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxlZCBjb250ZW50TWF0Y2hBdCBvbiBhIG5vZGUgd2l0aCBpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AgKGJ5XG4gICAgY2hpbGQgaW5kZXgpIHdpdGggdGhlIGdpdmVuIHJlcGxhY2VtZW50IGZyYWdtZW50ICh3aGljaCBkZWZhdWx0c1xuICAgIHRvIHRoZSBlbXB0eSBmcmFnbWVudCkgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLiBZb3VcbiAgICBjYW4gb3B0aW9uYWxseSBwYXNzIGBzdGFydGAgYW5kIGBlbmRgIGluZGljZXMgaW50byB0aGVcbiAgICByZXBsYWNlbWVudCBmcmFnbWVudC5cbiAgICAqL1xuICAgIGNhblJlcGxhY2UoZnJvbSwgdG8sIHJlcGxhY2VtZW50ID0gRnJhZ21lbnQuZW1wdHksIHN0YXJ0ID0gMCwgZW5kID0gcmVwbGFjZW1lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICBsZXQgb25lID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaEZyYWdtZW50KHJlcGxhY2VtZW50LCBzdGFydCwgZW5kKTtcbiAgICAgICAgbGV0IHR3byA9IG9uZSAmJiBvbmUubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgICAgaWYgKCF0d28gfHwgIXR3by52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhyZXBsYWNlbWVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHJlcGxhY2luZyB0aGUgcmFuZ2UgYGZyb21gIHRvIGB0b2AgKGJ5IGluZGV4KSB3aXRoXG4gICAgYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdvdWxkIGxlYXZlIHRoZSBub2RlJ3MgY29udGVudCB2YWxpZC5cbiAgICAqL1xuICAgIGNhblJlcGxhY2VXaXRoKGZyb20sIHRvLCB0eXBlLCBtYXJrcykge1xuICAgICAgICBpZiAobWFya3MgJiYgIXRoaXMudHlwZS5hbGxvd3NNYXJrcyhtYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMuY29udGVudE1hdGNoQXQoZnJvbSkubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBsZXQgZW5kID0gc3RhcnQgJiYgc3RhcnQubWF0Y2hGcmFnbWVudCh0aGlzLmNvbnRlbnQsIHRvKTtcbiAgICAgICAgcmV0dXJuIGVuZCA/IGVuZC52YWxpZEVuZCA6IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUncyBjb250ZW50IGNvdWxkIGJlIGFwcGVuZGVkIHRvIHRoaXNcbiAgICBub2RlLiBJZiB0aGF0IG5vZGUgaXMgZW1wdHksIHRoaXMgd2lsbCBvbmx5IHJldHVybiB0cnVlIGlmIHRoZXJlXG4gICAgaXMgYXQgbGVhc3Qgb25lIG5vZGUgdHlwZSB0aGF0IGNhbiBhcHBlYXIgaW4gYm90aCBub2RlcyAodG8gYXZvaWRcbiAgICBtZXJnaW5nIGNvbXBsZXRlbHkgaW5jb21wYXRpYmxlIG5vZGVzKS5cbiAgICAqL1xuICAgIGNhbkFwcGVuZChvdGhlcikge1xuICAgICAgICBpZiAob3RoZXIuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FuUmVwbGFjZSh0aGlzLmNoaWxkQ291bnQsIHRoaXMuY2hpbGRDb3VudCwgb3RoZXIuY29udGVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuY29tcGF0aWJsZUNvbnRlbnQob3RoZXIudHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIHdoZXRoZXIgdGhpcyBub2RlIGFuZCBpdHMgZGVzY2VuZGFudHMgY29uZm9ybSB0byB0aGVcbiAgICBzY2hlbWEsIGFuZCByYWlzZSBhbiBleGNlcHRpb24gd2hlbiB0aGV5IGRvIG5vdC5cbiAgICAqL1xuICAgIGNoZWNrKCkge1xuICAgICAgICB0aGlzLnR5cGUuY2hlY2tDb250ZW50KHRoaXMuY29udGVudCk7XG4gICAgICAgIHRoaXMudHlwZS5jaGVja0F0dHJzKHRoaXMuYXR0cnMpO1xuICAgICAgICBsZXQgY29weSA9IE1hcmsubm9uZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFyayA9IHRoaXMubWFya3NbaV07XG4gICAgICAgICAgICBtYXJrLnR5cGUuY2hlY2tBdHRycyhtYXJrLmF0dHJzKTtcbiAgICAgICAgICAgIGNvcHkgPSBtYXJrLmFkZFRvU2V0KGNvcHkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghTWFyay5zYW1lU2V0KGNvcHksIHRoaXMubWFya3MpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29sbGVjdGlvbiBvZiBtYXJrcyBmb3Igbm9kZSAke3RoaXMudHlwZS5uYW1lfTogJHt0aGlzLm1hcmtzLm1hcChtID0+IG0udHlwZS5uYW1lKX1gKTtcbiAgICAgICAgdGhpcy5jb250ZW50LmZvckVhY2gobm9kZSA9PiBub2RlLmNoZWNrKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6ZWFibGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBub2RlLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUpXG4gICAgICAgICAgICBvYmouY29udGVudCA9IHRoaXMuY29udGVudC50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMubWFya3MubGVuZ3RoKVxuICAgICAgICAgICAgb2JqLm1hcmtzID0gdGhpcy5tYXJrcy5tYXAobiA9PiBuLnRvSlNPTigpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBub2RlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IG1hcmtzID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoanNvbi5tYXJrcykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBtYXJrIGRhdGEgZm9yIE5vZGUuZnJvbUpTT05cIik7XG4gICAgICAgICAgICBtYXJrcyA9IGpzb24ubWFya3MubWFwKHNjaGVtYS5tYXJrRnJvbUpTT04pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqc29uLnR5cGUgPT0gXCJ0ZXh0XCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YganNvbi50ZXh0ICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHRleHQgbm9kZSBpbiBKU09OXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS50ZXh0KGpzb24udGV4dCwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpO1xuICAgICAgICBsZXQgbm9kZSA9IHNjaGVtYS5ub2RlVHlwZShqc29uLnR5cGUpLmNyZWF0ZShqc29uLmF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgICAgIG5vZGUudHlwZS5jaGVja0F0dHJzKG5vZGUuYXR0cnMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG59XG5Ob2RlLnByb3RvdHlwZS50ZXh0ID0gdW5kZWZpbmVkO1xuY2xhc3MgVGV4dE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBzdXBlcih0eXBlLCBhdHRycywgbnVsbCwgbWFya3MpO1xuICAgICAgICBpZiAoIWNvbnRlbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVtcHR5IHRleHQgbm9kZXMgYXJlIG5vdCBhbGxvd2VkXCIpO1xuICAgICAgICB0aGlzLnRleHQgPSBjb250ZW50O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHdyYXBNYXJrcyh0aGlzLm1hcmtzLCBKU09OLnN0cmluZ2lmeSh0aGlzLnRleHQpKTtcbiAgICB9XG4gICAgZ2V0IHRleHRDb250ZW50KCkgeyByZXR1cm4gdGhpcy50ZXh0OyB9XG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8pIHsgcmV0dXJuIHRoaXMudGV4dC5zbGljZShmcm9tLCB0byk7IH1cbiAgICBnZXQgbm9kZVNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgVGV4dE5vZGUodGhpcy50eXBlLCB0aGlzLmF0dHJzLCB0aGlzLnRleHQsIG1hcmtzKTtcbiAgICB9XG4gICAgd2l0aFRleHQodGV4dCkge1xuICAgICAgICBpZiAodGV4dCA9PSB0aGlzLnRleHQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRleHQsIHRoaXMubWFya3MpO1xuICAgIH1cbiAgICBjdXQoZnJvbSA9IDAsIHRvID0gdGhpcy50ZXh0Lmxlbmd0aCkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMudGV4dC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRleHQodGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKSk7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMudGV4dCA9PSBvdGhlci50ZXh0O1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBiYXNlID0gc3VwZXIudG9KU09OKCk7XG4gICAgICAgIGJhc2UudGV4dCA9IHRoaXMudGV4dDtcbiAgICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gd3JhcE1hcmtzKG1hcmtzLCBzdHIpIHtcbiAgICBmb3IgKGxldCBpID0gbWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHN0ciA9IG1hcmtzW2ldLnR5cGUubmFtZSArIFwiKFwiICsgc3RyICsgXCIpXCI7XG4gICAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG5JbnN0YW5jZXMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgYSBtYXRjaCBzdGF0ZSBvZiBhIG5vZGUgdHlwZSdzXG5bY29udGVudCBleHByZXNzaW9uXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29udGVudCksIGFuZCBjYW4gYmUgdXNlZCB0b1xuZmluZCBvdXQgd2hldGhlciBmdXJ0aGVyIGNvbnRlbnQgbWF0Y2hlcyBoZXJlLCBhbmQgd2hldGhlciBhIGdpdmVuXG5wb3NpdGlvbiBpcyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiovXG5jbGFzcyBDb250ZW50TWF0Y2gge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbWF0Y2ggc3RhdGUgcmVwcmVzZW50cyBhIHZhbGlkIGVuZCBvZiB0aGUgbm9kZS5cbiAgICAqL1xuICAgIHZhbGlkRW5kKSB7XG4gICAgICAgIHRoaXMudmFsaWRFbmQgPSB2YWxpZEVuZDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm5leHQgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLndyYXBDYWNoZSA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBwYXJzZShzdHJpbmcsIG5vZGVUeXBlcykge1xuICAgICAgICBsZXQgc3RyZWFtID0gbmV3IFRva2VuU3RyZWFtKHN0cmluZywgbm9kZVR5cGVzKTtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gQ29udGVudE1hdGNoLmVtcHR5O1xuICAgICAgICBsZXQgZXhwciA9IHBhcnNlRXhwcihzdHJlYW0pO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0cmFpbGluZyB0ZXh0XCIpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBkZmEobmZhKGV4cHIpKTtcbiAgICAgICAgY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCBhIG5vZGUgdHlwZSwgcmV0dXJuaW5nIGEgbWF0Y2ggYWZ0ZXIgdGhhdCBub2RlIGlmXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoVHlwZSh0eXBlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IHR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV4dFtpXS5uZXh0O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIGEgZnJhZ21lbnQuIFJldHVybnMgdGhlIHJlc3VsdGluZyBtYXRjaCB3aGVuXG4gICAgc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIG1hdGNoRnJhZ21lbnQoZnJhZywgc3RhcnQgPSAwLCBlbmQgPSBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgbGV0IGN1ciA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydDsgY3VyICYmIGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGN1ciA9IGN1ci5tYXRjaFR5cGUoZnJhZy5jaGlsZChpKS50eXBlKTtcbiAgICAgICAgcmV0dXJuIGN1cjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgaW5saW5lQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGggIT0gMCAmJiB0aGlzLm5leHRbMF0udHlwZS5pc0lubGluZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBmaXJzdCBtYXRjaGluZyBub2RlIHR5cGUgYXQgdGhpcyBtYXRjaCBwb3NpdGlvbiB0aGF0IGNhblxuICAgIGJlIGdlbmVyYXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWZhdWx0VHlwZSgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUgfSA9IHRoaXMubmV4dFtpXTtcbiAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wYXRpYmxlKG90aGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlci5uZXh0Lmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHRbaV0udHlwZSA9PSBvdGhlci5uZXh0W2pdLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtYXRjaCB0aGUgZ2l2ZW4gZnJhZ21lbnQsIGFuZCBpZiB0aGF0IGZhaWxzLCBzZWUgaWYgaXQgY2FuXG4gICAgYmUgbWFkZSB0byBtYXRjaCBieSBpbnNlcnRpbmcgbm9kZXMgaW4gZnJvbnQgb2YgaXQuIFdoZW5cbiAgICBzdWNjZXNzZnVsLCByZXR1cm4gYSBmcmFnbWVudCBvZiBpbnNlcnRlZCBub2RlcyAod2hpY2ggbWF5IGJlXG4gICAgZW1wdHkgaWYgbm90aGluZyBoYWQgdG8gYmUgaW5zZXJ0ZWQpLiBXaGVuIGB0b0VuZGAgaXMgdHJ1ZSwgb25seVxuICAgIHJldHVybiBhIGZyYWdtZW50IGlmIHRoZSByZXN1bHRpbmcgbWF0Y2ggZ29lcyB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGZpbGxCZWZvcmUoYWZ0ZXIsIHRvRW5kID0gZmFsc2UsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGxldCBzZWVuID0gW3RoaXNdO1xuICAgICAgICBmdW5jdGlvbiBzZWFyY2gobWF0Y2gsIHR5cGVzKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSBtYXRjaC5tYXRjaEZyYWdtZW50KGFmdGVyLCBzdGFydEluZGV4KTtcbiAgICAgICAgICAgIGlmIChmaW5pc2hlZCAmJiAoIXRvRW5kIHx8IGZpbmlzaGVkLnZhbGlkRW5kKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbSh0eXBlcy5tYXAodHAgPT4gdHAuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSAmJiBzZWVuLmluZGV4T2YobmV4dCkgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2Vlbi5wdXNoKG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBzZWFyY2gobmV4dCwgdHlwZXMuY29uY2F0KHR5cGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWFyY2godGhpcywgW10pO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGUgdHlwZXMgdGhhdCB3b3VsZCBhbGxvdyBhIG5vZGUgb2YgdGhlXG4gICAgZ2l2ZW4gdHlwZSB0byBhcHBlYXIgYXQgdGhpcyBwb3NpdGlvbi4gVGhlIHJlc3VsdCBtYXkgYmUgZW1wdHlcbiAgICAod2hlbiBpdCBmaXRzIGRpcmVjdGx5KSBhbmQgd2lsbCBiZSBudWxsIHdoZW4gbm8gc3VjaCB3cmFwcGluZ1xuICAgIGV4aXN0cy5cbiAgICAqL1xuICAgIGZpbmRXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLndyYXBDYWNoZS5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgICAgIGlmICh0aGlzLndyYXBDYWNoZVtpXSA9PSB0YXJnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud3JhcENhY2hlW2kgKyAxXTtcbiAgICAgICAgbGV0IGNvbXB1dGVkID0gdGhpcy5jb21wdXRlV3JhcHBpbmcodGFyZ2V0KTtcbiAgICAgICAgdGhpcy53cmFwQ2FjaGUucHVzaCh0YXJnZXQsIGNvbXB1dGVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXB1dGVXcmFwcGluZyh0YXJnZXQpIHtcbiAgICAgICAgbGV0IHNlZW4gPSBPYmplY3QuY3JlYXRlKG51bGwpLCBhY3RpdmUgPSBbeyBtYXRjaDogdGhpcywgdHlwZTogbnVsbCwgdmlhOiBudWxsIH1dO1xuICAgICAgICB3aGlsZSAoYWN0aXZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSBhY3RpdmUuc2hpZnQoKSwgbWF0Y2ggPSBjdXJyZW50Lm1hdGNoO1xuICAgICAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IG9iaiA9IGN1cnJlbnQ7IG9iai50eXBlOyBvYmogPSBvYmoudmlhKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChvYmoudHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLm5leHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBuZXh0IH0gPSBtYXRjaC5uZXh0W2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pc0xlYWYgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpICYmICEodHlwZS5uYW1lIGluIHNlZW4pICYmICghY3VycmVudC50eXBlIHx8IG5leHQudmFsaWRFbmQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKHsgbWF0Y2g6IHR5cGUuY29udGVudE1hdGNoLCB0eXBlLCB2aWE6IGN1cnJlbnQgfSk7XG4gICAgICAgICAgICAgICAgICAgIHNlZW5bdHlwZS5uYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIHRoaXMgbm9kZSBoYXMgaW4gdGhlIGZpbml0ZVxuICAgIGF1dG9tYXRvbiB0aGF0IGRlc2NyaWJlcyB0aGUgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZ2V0IGVkZ2VDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dC5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgX25f4oCLdGggb3V0Z29pbmcgZWRnZSBmcm9tIHRoaXMgbm9kZSBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBlZGdlKG4pIHtcbiAgICAgICAgaWYgKG4gPj0gdGhpcy5uZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSdzIG5vICR7bn10aCBlZGdlIGluIHRoaXMgY29udGVudCBtYXRjaGApO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0W25dO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc2VlbiA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBzY2FuKG0pIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbS5uZXh0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBzY2FuKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBzY2FuKHRoaXMpO1xuICAgICAgICByZXR1cm4gc2Vlbi5tYXAoKG0sIGkpID0+IHtcbiAgICAgICAgICAgIGxldCBvdXQgPSBpICsgKG0udmFsaWRFbmQgPyBcIipcIiA6IFwiIFwiKSArIFwiIFwiO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgb3V0ICs9IChpID8gXCIsIFwiIDogXCJcIikgKyBtLm5leHRbaV0udHlwZS5uYW1lICsgXCItPlwiICsgc2Vlbi5pbmRleE9mKG0ubmV4dFtpXS5uZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5Db250ZW50TWF0Y2guZW1wdHkgPSBuZXcgQ29udGVudE1hdGNoKHRydWUpO1xuY2xhc3MgVG9rZW5TdHJlYW0ge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgICAgICB0aGlzLm5vZGVUeXBlcyA9IG5vZGVUeXBlcztcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBudWxsO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMudG9rZW5zID0gc3RyaW5nLnNwbGl0KC9cXHMqKD89XFxifFxcV3wkKS8pO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbdGhpcy50b2tlbnMubGVuZ3RoIC0gMV0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnBvcCgpO1xuICAgICAgICBpZiAodGhpcy50b2tlbnNbMF0gPT0gXCJcIilcbiAgICAgICAgICAgIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICAgfVxuICAgIGdldCBuZXh0KCkgeyByZXR1cm4gdGhpcy50b2tlbnNbdGhpcy5wb3NdOyB9XG4gICAgZWF0KHRvaykgeyByZXR1cm4gdGhpcy5uZXh0ID09IHRvayAmJiAodGhpcy5wb3MrKyB8fCB0cnVlKTsgfVxuICAgIGVycihzdHIpIHsgdGhyb3cgbmV3IFN5bnRheEVycm9yKHN0ciArIFwiIChpbiBjb250ZW50IGV4cHJlc3Npb24gJ1wiICsgdGhpcy5zdHJpbmcgKyBcIicpXCIpOyB9XG59XG5mdW5jdGlvbiBwYXJzZUV4cHIoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclNlcShzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0uZWF0KFwifFwiKSk7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTZXEoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHJzID0gW107XG4gICAgZG8ge1xuICAgICAgICBleHBycy5wdXNoKHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pKTtcbiAgICB9IHdoaWxlIChzdHJlYW0ubmV4dCAmJiBzdHJlYW0ubmV4dCAhPSBcIilcIiAmJiBzdHJlYW0ubmV4dCAhPSBcInxcIik7XG4gICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwic2VxXCIsIGV4cHJzIH07XG59XG5mdW5jdGlvbiBwYXJzZUV4cHJTdWJzY3JpcHQoc3RyZWFtKSB7XG4gICAgbGV0IGV4cHIgPSBwYXJzZUV4cHJBdG9tKHN0cmVhbSk7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoc3RyZWFtLmVhdChcIitcIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcInBsdXNcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwiKlwiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwic3RhclwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCI/XCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJvcHRcIiwgZXhwciB9O1xuICAgICAgICBlbHNlIGlmIChzdHJlYW0uZWF0KFwie1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSBwYXJzZUV4cHJSYW5nZShzdHJlYW0sIGV4cHIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGV4cHI7XG59XG5mdW5jdGlvbiBwYXJzZU51bShzdHJlYW0pIHtcbiAgICBpZiAoL1xcRC8udGVzdChzdHJlYW0ubmV4dCkpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJFeHBlY3RlZCBudW1iZXIsIGdvdCAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICBsZXQgcmVzdWx0ID0gTnVtYmVyKHN0cmVhbS5uZXh0KTtcbiAgICBzdHJlYW0ucG9zKys7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcikge1xuICAgIGxldCBtaW4gPSBwYXJzZU51bShzdHJlYW0pLCBtYXggPSBtaW47XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIsXCIpKSB7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dCAhPSBcIn1cIilcbiAgICAgICAgICAgIG1heCA9IHBhcnNlTnVtKHN0cmVhbSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1heCA9IC0xO1xuICAgIH1cbiAgICBpZiAoIXN0cmVhbS5lYXQoXCJ9XCIpKVxuICAgICAgICBzdHJlYW0uZXJyKFwiVW5jbG9zZWQgYnJhY2VkIHJhbmdlXCIpO1xuICAgIHJldHVybiB7IHR5cGU6IFwicmFuZ2VcIiwgbWluLCBtYXgsIGV4cHIgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHN0cmVhbSwgbmFtZSkge1xuICAgIGxldCB0eXBlcyA9IHN0cmVhbS5ub2RlVHlwZXMsIHR5cGUgPSB0eXBlc1tuYW1lXTtcbiAgICBpZiAodHlwZSlcbiAgICAgICAgcmV0dXJuIFt0eXBlXTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgdHlwZU5hbWUgaW4gdHlwZXMpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1t0eXBlTmFtZV07XG4gICAgICAgIGlmICh0eXBlLmlzSW5Hcm91cChuYW1lKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHR5cGUpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PSAwKVxuICAgICAgICBzdHJlYW0uZXJyKFwiTm8gbm9kZSB0eXBlIG9yIGdyb3VwICdcIiArIG5hbWUgKyBcIicgZm91bmRcIik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwckF0b20oc3RyZWFtKSB7XG4gICAgaWYgKHN0cmVhbS5lYXQoXCIoXCIpKSB7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICAgIGlmICghc3RyZWFtLmVhdChcIilcIikpXG4gICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWlzc2luZyBjbG9zaW5nIHBhcmVuXCIpO1xuICAgICAgICByZXR1cm4gZXhwcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIS9cXFcvLnRlc3Qoc3RyZWFtLm5leHQpKSB7XG4gICAgICAgIGxldCBleHBycyA9IHJlc29sdmVOYW1lKHN0cmVhbSwgc3RyZWFtLm5leHQpLm1hcCh0eXBlID0+IHtcbiAgICAgICAgICAgIGlmIChzdHJlYW0uaW5saW5lID09IG51bGwpXG4gICAgICAgICAgICAgICAgc3RyZWFtLmlubGluZSA9IHR5cGUuaXNJbmxpbmU7XG4gICAgICAgICAgICBlbHNlIGlmIChzdHJlYW0uaW5saW5lICE9IHR5cGUuaXNJbmxpbmUpXG4gICAgICAgICAgICAgICAgc3RyZWFtLmVycihcIk1peGluZyBpbmxpbmUgYW5kIGJsb2NrIGNvbnRlbnRcIik7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIm5hbWVcIiwgdmFsdWU6IHR5cGUgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbS5wb3MrKztcbiAgICAgICAgcmV0dXJuIGV4cHJzLmxlbmd0aCA9PSAxID8gZXhwcnNbMF0gOiB7IHR5cGU6IFwiY2hvaWNlXCIsIGV4cHJzIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdHJlYW0uZXJyKFwiVW5leHBlY3RlZCB0b2tlbiAnXCIgKyBzdHJlYW0ubmV4dCArIFwiJ1wiKTtcbiAgICB9XG59XG4vLyBDb25zdHJ1Y3QgYW4gTkZBIGZyb20gYW4gZXhwcmVzc2lvbiBhcyByZXR1cm5lZCBieSB0aGUgcGFyc2VyLiBUaGVcbi8vIE5GQSBpcyByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBzdGF0ZXMsIHdoaWNoIGFyZSB0aGVtc2VsdmVzXG4vLyBhcnJheXMgb2YgZWRnZXMsIHdoaWNoIGFyZSBge3Rlcm0sIHRvfWAgb2JqZWN0cy4gVGhlIGZpcnN0IHN0YXRlIGlzXG4vLyB0aGUgZW50cnkgc3RhdGUgYW5kIHRoZSBsYXN0IG5vZGUgaXMgdGhlIHN1Y2Nlc3Mgc3RhdGUuXG4vL1xuLy8gTm90ZSB0aGF0IHVubGlrZSB0eXBpY2FsIE5GQXMsIHRoZSBlZGdlIG9yZGVyaW5nIGluIHRoaXMgb25lIGlzXG4vLyBzaWduaWZpY2FudCwgaW4gdGhhdCBpdCBpcyB1c2VkIHRvIGNvbnRydWN0IGZpbGxlciBjb250ZW50IHdoZW5cbi8vIG5lY2Vzc2FyeS5cbmZ1bmN0aW9uIG5mYShleHByKSB7XG4gICAgbGV0IG5mYSA9IFtbXV07XG4gICAgY29ubmVjdChjb21waWxlKGV4cHIsIDApLCBub2RlKCkpO1xuICAgIHJldHVybiBuZmE7XG4gICAgZnVuY3Rpb24gbm9kZSgpIHsgcmV0dXJuIG5mYS5wdXNoKFtdKSAtIDE7IH1cbiAgICBmdW5jdGlvbiBlZGdlKGZyb20sIHRvLCB0ZXJtKSB7XG4gICAgICAgIGxldCBlZGdlID0geyB0ZXJtLCB0byB9O1xuICAgICAgICBuZmFbZnJvbV0ucHVzaChlZGdlKTtcbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbm5lY3QoZWRnZXMsIHRvKSB7XG4gICAgICAgIGVkZ2VzLmZvckVhY2goZWRnZSA9PiBlZGdlLnRvID0gdG8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21waWxlKGV4cHIsIGZyb20pIHtcbiAgICAgICAgaWYgKGV4cHIudHlwZSA9PSBcImNob2ljZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhwci5leHBycy5yZWR1Y2UoKG91dCwgZXhwcikgPT4gb3V0LmNvbmNhdChjb21waWxlKGV4cHIsIGZyb20pKSwgW10pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInNlcVwiKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY29tcGlsZShleHByLmV4cHJzW2ldLCBmcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBleHByLmV4cHJzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgIGNvbm5lY3QobmV4dCwgZnJvbSA9IG5vZGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic3RhclwiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGVkZ2UoZnJvbSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInBsdXNcIikge1xuICAgICAgICAgICAgbGV0IGxvb3AgPSBub2RlKCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSwgbG9vcCk7XG4gICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBsb29wKSwgbG9vcCk7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UobG9vcCldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm9wdFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW2VkZ2UoZnJvbSldLmNvbmNhdChjb21waWxlKGV4cHIuZXhwciwgZnJvbSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcInJhbmdlXCIpIHtcbiAgICAgICAgICAgIGxldCBjdXIgPSBmcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleHByLm1pbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgY3VyID0gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChleHByLm1heCA9PSAtMSkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIGN1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gZXhwci5taW47IGkgPCBleHByLm1heDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZSgpO1xuICAgICAgICAgICAgICAgICAgICBlZGdlKGN1ciwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGN1ciksIG5leHQpO1xuICAgICAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbZWRnZShjdXIpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tLCB1bmRlZmluZWQsIGV4cHIudmFsdWUpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZXhwciB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY21wKGEsIGIpIHsgcmV0dXJuIGIgLSBhOyB9XG4vLyBHZXQgdGhlIHNldCBvZiBub2RlcyByZWFjaGFibGUgYnkgbnVsbCBlZGdlcyBmcm9tIGBub2RlYC4gT21pdFxuLy8gbm9kZXMgd2l0aCBvbmx5IGEgc2luZ2xlIG51bGwtb3V0LWVkZ2UsIHNpbmNlIHRoZXkgbWF5IGxlYWQgdG9cbi8vIG5lZWRsZXNzIGR1cGxpY2F0ZWQgbm9kZXMuXG5mdW5jdGlvbiBudWxsRnJvbShuZmEsIG5vZGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgc2Nhbihub2RlKTtcbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKTtcbiAgICBmdW5jdGlvbiBzY2FuKG5vZGUpIHtcbiAgICAgICAgbGV0IGVkZ2VzID0gbmZhW25vZGVdO1xuICAgICAgICBpZiAoZWRnZXMubGVuZ3RoID09IDEgJiYgIWVkZ2VzWzBdLnRlcm0pXG4gICAgICAgICAgICByZXR1cm4gc2NhbihlZGdlc1swXS50byk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVkZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyB0ZXJtLCB0byB9ID0gZWRnZXNbaV07XG4gICAgICAgICAgICBpZiAoIXRlcm0gJiYgcmVzdWx0LmluZGV4T2YodG8pID09IC0xKVxuICAgICAgICAgICAgICAgIHNjYW4odG8pO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gQ29tcGlsZXMgYW4gTkZBIGFzIHByb2R1Y2VkIGJ5IGBuZmFgIGludG8gYSBERkEsIG1vZGVsZWQgYXMgYSBzZXRcbi8vIG9mIHN0YXRlIG9iamVjdHMgKGBDb250ZW50TWF0Y2hgIGluc3RhbmNlcykgd2l0aCB0cmFuc2l0aW9uc1xuLy8gYmV0d2VlbiB0aGVtLlxuZnVuY3Rpb24gZGZhKG5mYSkge1xuICAgIGxldCBsYWJlbGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICByZXR1cm4gZXhwbG9yZShudWxsRnJvbShuZmEsIDApKTtcbiAgICBmdW5jdGlvbiBleHBsb3JlKHN0YXRlcykge1xuICAgICAgICBsZXQgb3V0ID0gW107XG4gICAgICAgIHN0YXRlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgbmZhW25vZGVdLmZvckVhY2goKHsgdGVybSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGVybSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGxldCBzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRbaV1bMF0gPT0gdGVybSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldCA9IG91dFtpXVsxXTtcbiAgICAgICAgICAgICAgICBudWxsRnJvbShuZmEsIHRvKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldClcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKFt0ZXJtLCBzZXQgPSBbXV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0LmluZGV4T2Yobm9kZSkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHN0YXRlID0gbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildID0gbmV3IENvbnRlbnRNYXRjaChzdGF0ZXMuaW5kZXhPZihuZmEubGVuZ3RoIC0gMSkgPiAtMSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgc3RhdGVzID0gb3V0W2ldWzFdLnNvcnQoY21wKTtcbiAgICAgICAgICAgIHN0YXRlLm5leHQucHVzaCh7IHR5cGU6IG91dFtpXVswXSwgbmV4dDogbGFiZWxlZFtzdGF0ZXMuam9pbihcIixcIildIHx8IGV4cGxvcmUoc3RhdGVzKSB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tGb3JEZWFkRW5kcyhtYXRjaCwgc3RyZWFtKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHdvcmsgPSBbbWF0Y2hdOyBpIDwgd29yay5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc3RhdGUgPSB3b3JrW2ldLCBkZWFkID0gIXN0YXRlLnZhbGlkRW5kLCBub2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlLm5leHQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IHN0YXRlLm5leHRbal07XG4gICAgICAgICAgICBub2Rlcy5wdXNoKHR5cGUubmFtZSk7XG4gICAgICAgICAgICBpZiAoZGVhZCAmJiAhKHR5cGUuaXNUZXh0IHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSlcbiAgICAgICAgICAgICAgICBkZWFkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAod29yay5pbmRleE9mKG5leHQpID09IC0xKVxuICAgICAgICAgICAgICAgIHdvcmsucHVzaChuZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVhZClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJPbmx5IG5vbi1nZW5lcmF0YWJsZSBub2RlcyAoXCIgKyBub2Rlcy5qb2luKFwiLCBcIikgKyBcIikgaW4gYSByZXF1aXJlZCBwb3NpdGlvbiAoc2VlIGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2dlbmVyYXRhYmxlKVwiKTtcbiAgICB9XG59XG5cbi8vIEZvciBub2RlIHR5cGVzIHdoZXJlIGFsbCBhdHRycyBoYXZlIGEgZGVmYXVsdCB2YWx1ZSAob3Igd2hpY2ggZG9uJ3Rcbi8vIGhhdmUgYW55IGF0dHJpYnV0ZXMpLCBidWlsZCB1cCBhIHNpbmdsZSByZXVzYWJsZSBkZWZhdWx0IGF0dHJpYnV0ZVxuLy8gb2JqZWN0LCBhbmQgdXNlIGl0IGZvciBhbGwgbm9kZXMgdGhhdCBkb24ndCBzcGVjaWZ5IHNwZWNpZmljXG4vLyBhdHRyaWJ1dGVzLlxuZnVuY3Rpb24gZGVmYXVsdEF0dHJzKGF0dHJzKSB7XG4gICAgbGV0IGRlZmF1bHRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBhdHRyTmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW2F0dHJOYW1lXTtcbiAgICAgICAgaWYgKCFhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZGVmYXVsdHNbYXR0ck5hbWVdID0gYXR0ci5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdHM7XG59XG5mdW5jdGlvbiBjb21wdXRlQXR0cnMoYXR0cnMsIHZhbHVlKSB7XG4gICAgbGV0IGJ1aWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBnaXZlbiA9IHZhbHVlICYmIHZhbHVlW25hbWVdO1xuICAgICAgICBpZiAoZ2l2ZW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChhdHRyLmhhc0RlZmF1bHQpXG4gICAgICAgICAgICAgICAgZ2l2ZW4gPSBhdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyB2YWx1ZSBzdXBwbGllZCBmb3IgYXR0cmlidXRlIFwiICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbHRbbmFtZV0gPSBnaXZlbjtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWx0O1xufVxuZnVuY3Rpb24gY2hlY2tBdHRycyhhdHRycywgdmFsdWVzLCB0eXBlLCBuYW1lKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiB2YWx1ZXMpXG4gICAgICAgIGlmICghKG5hbWUgaW4gYXR0cnMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFVuc3VwcG9ydGVkIGF0dHJpYnV0ZSAke25hbWV9IGZvciAke3R5cGV9IG9mIHR5cGUgJHtuYW1lfWApO1xuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGF0dHIgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgaWYgKGF0dHIudmFsaWRhdGUpXG4gICAgICAgICAgICBhdHRyLnZhbGlkYXRlKHZhbHVlc1tuYW1lXSk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5pdEF0dHJzKHR5cGVOYW1lLCBhdHRycykge1xuICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChhdHRycylcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IG5ldyBBdHRyaWJ1dGUodHlwZU5hbWUsIG5hbWUsIGF0dHJzW25hbWVdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5Ob2RlIHR5cGVzIGFyZSBvYmplY3RzIGFsbG9jYXRlZCBvbmNlIHBlciBgU2NoZW1hYCBhbmQgdXNlZCB0b1xuW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudHlwZSkgYE5vZGVgIGluc3RhbmNlcy4gVGhleSBjb250YWluIGluZm9ybWF0aW9uXG5hYm91dCB0aGUgbm9kZSB0eXBlLCBzdWNoIGFzIGl0cyBuYW1lIGFuZCB3aGF0IGtpbmQgb2Ygbm9kZSBpdFxucmVwcmVzZW50cy5cbiovXG5jbGFzcyBOb2RlVHlwZSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSB0aGUgbm9kZSB0eXBlIGhhcyBpbiB0aGlzIHNjaGVtYS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEEgbGluayBiYWNrIHRvIHRoZSBgU2NoZW1hYCB0aGUgbm9kZSB0eXBlIGJlbG9uZ3MgdG8uXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHRoYXQgdGhpcyB0eXBlIGlzIGJhc2VkIG9uXG4gICAgKi9cbiAgICBzcGVjKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHNldCBvZiBtYXJrcyBhbGxvd2VkIGluIHRoaXMgbm9kZS4gYG51bGxgIG1lYW5zIGFsbCBtYXJrc1xuICAgICAgICBhcmUgYWxsb3dlZC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrU2V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5ncm91cHMgPSBzcGVjLmdyb3VwID8gc3BlYy5ncm91cC5zcGxpdChcIiBcIikgOiBbXTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhuYW1lLCBzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0QXR0cnMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuY29udGVudE1hdGNoID0gbnVsbDtcbiAgICAgICAgdGhpcy5pbmxpbmVDb250ZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0Jsb2NrID0gIShzcGVjLmlubGluZSB8fCBuYW1lID09IFwidGV4dFwiKTtcbiAgICAgICAgdGhpcy5pc1RleHQgPSBuYW1lID09IFwidGV4dFwiO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYW4gaW5saW5lIHR5cGUuXG4gICAgKi9cbiAgICBnZXQgaXNJbmxpbmUoKSB7IHJldHVybiAhdGhpcy5pc0Jsb2NrOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBpZiB0aGlzIGlzIGEgdGV4dGJsb2NrIHR5cGUsIGEgYmxvY2sgdGhhdCBjb250YWlucyBpbmxpbmVcbiAgICBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzVGV4dGJsb2NrKCkgeyByZXR1cm4gdGhpcy5pc0Jsb2NrICYmIHRoaXMuaW5saW5lQ29udGVudDsgfVxuICAgIC8qKlxuICAgIFRydWUgZm9yIG5vZGUgdHlwZXMgdGhhdCBhbGxvdyBubyBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMuY29udGVudE1hdGNoID09IENvbnRlbnRNYXRjaC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIG5vZGUgaXMgYW4gYXRvbSwgaS5lLiB3aGVuIGl0IGRvZXMgbm90IGhhdmVcbiAgICBkaXJlY3RseSBlZGl0YWJsZSBjb250ZW50LlxuICAgICovXG4gICAgZ2V0IGlzQXRvbSgpIHsgcmV0dXJuIHRoaXMuaXNMZWFmIHx8ICEhdGhpcy5zcGVjLmF0b207IH1cbiAgICAvKipcbiAgICBSZXR1cm4gdHJ1ZSB3aGVuIHRoaXMgbm9kZSB0eXBlIGlzIHBhcnQgb2YgdGhlIGdpdmVuXG4gICAgW2dyb3VwXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZ3JvdXApLlxuICAgICovXG4gICAgaXNJbkdyb3VwKGdyb3VwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyb3Vwcy5pbmRleE9mKGdyb3VwKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgbm9kZSB0eXBlJ3MgW3doaXRlc3BhY2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy53aGl0ZXNwYWNlKSBvcHRpb24uXG4gICAgKi9cbiAgICBnZXQgd2hpdGVzcGFjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy53aGl0ZXNwYWNlIHx8ICh0aGlzLnNwZWMuY29kZSA/IFwicHJlXCIgOiBcIm5vcm1hbFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBub2RlIHR5cGUgaGFzIGFueSByZXF1aXJlZCBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgaGFzUmVxdWlyZWRBdHRycygpIHtcbiAgICAgICAgZm9yIChsZXQgbiBpbiB0aGlzLmF0dHJzKVxuICAgICAgICAgICAgaWYgKHRoaXMuYXR0cnNbbl0uaXNSZXF1aXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIG5vZGUgYWxsb3dzIHNvbWUgb2YgdGhlIHNhbWUgY29udGVudCBhc1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBjb21wYXRpYmxlQ29udGVudChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fCB0aGlzLmNvbnRlbnRNYXRjaC5jb21wYXRpYmxlKG90aGVyLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZUF0dHJzKGF0dHJzKSB7XG4gICAgICAgIGlmICghYXR0cnMgJiYgdGhpcy5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0QXR0cnM7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBgTm9kZWAgb2YgdGhpcyB0eXBlLiBUaGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmVcbiAgICBjaGVja2VkIGFuZCBkZWZhdWx0ZWQgKHlvdSBjYW4gcGFzcyBgbnVsbGAgdG8gdXNlIHRoZSB0eXBlJ3NcbiAgICBkZWZhdWx0cyBlbnRpcmVseSwgaWYgbm8gcmVxdWlyZWQgYXR0cmlidXRlcyBleGlzdCkuIGBjb250ZW50YFxuICAgIG1heSBiZSBhIGBGcmFnbWVudGAsIGEgbm9kZSwgYW4gYXJyYXkgb2Ygbm9kZXMsIG9yXG4gICAgYG51bGxgLiBTaW1pbGFybHkgYG1hcmtzYCBtYXkgYmUgYG51bGxgIHRvIGRlZmF1bHQgdG8gdGhlIGVtcHR5XG4gICAgc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZVR5cGUuY3JlYXRlIGNhbid0IGNvbnN0cnVjdCB0ZXh0IG5vZGVzXCIpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpLCBGcmFnbWVudC5mcm9tKGNvbnRlbnQpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgTGlrZSBbYGNyZWF0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZS5jcmVhdGUpLCBidXQgY2hlY2sgdGhlIGdpdmVuIGNvbnRlbnRcbiAgICBhZ2FpbnN0IHRoZSBub2RlIHR5cGUncyBjb250ZW50IHJlc3RyaWN0aW9ucywgYW5kIHRocm93IGFuIGVycm9yXG4gICAgaWYgaXQgZG9lc24ndCBtYXRjaC5cbiAgICAqL1xuICAgIGNyZWF0ZUNoZWNrZWQoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgdGhpcy5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIGNvbnRlbnQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBzZWUgaWYgaXQgaXNcbiAgICBuZWNlc3NhcnkgdG8gYWRkIG5vZGVzIHRvIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIGdpdmVuIGZyYWdtZW50XG4gICAgdG8gbWFrZSBpdCBmaXQgdGhlIG5vZGUuIElmIG5vIGZpdHRpbmcgd3JhcHBpbmcgY2FuIGJlIGZvdW5kLFxuICAgIHJldHVybiBudWxsLiBOb3RlIHRoYXQsIGR1ZSB0byB0aGUgZmFjdCB0aGF0IHJlcXVpcmVkIG5vZGVzIGNhblxuICAgIGFsd2F5cyBiZSBjcmVhdGVkLCB0aGlzIHdpbGwgYWx3YXlzIHN1Y2NlZWQgaWYgeW91IHBhc3MgbnVsbCBvclxuICAgIGBGcmFnbWVudC5lbXB0eWAgYXMgY29udGVudC5cbiAgICAqL1xuICAgIGNyZWF0ZUFuZEZpbGwoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBhdHRycyA9IHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKTtcbiAgICAgICAgY29udGVudCA9IEZyYWdtZW50LmZyb20oY29udGVudCk7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSB0aGlzLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjb250ZW50ID0gYmVmb3JlLmFwcGVuZChjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbWF0Y2hlZCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGxldCBhZnRlciA9IG1hdGNoZWQgJiYgbWF0Y2hlZC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKTtcbiAgICAgICAgaWYgKCFhZnRlcilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUodGhpcywgYXR0cnMsIGNvbnRlbnQuYXBwZW5kKGFmdGVyKSwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgdmFsaWQgY29udGVudCBmb3IgdGhpcyBub2RlXG4gICAgdHlwZS5cbiAgICAqL1xuICAgIHZhbGlkQ29udGVudChjb250ZW50KSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRlbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtzKGNvbnRlbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFRocm93cyBhIFJhbmdlRXJyb3IgaWYgdGhlIGdpdmVuIGZyYWdtZW50IGlzIG5vdCB2YWxpZCBjb250ZW50IGZvciB0aGlzXG4gICAgbm9kZSB0eXBlLlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkQ29udGVudChjb250ZW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgJHt0aGlzLm5hbWV9OiAke2NvbnRlbnQudG9TdHJpbmcoKS5zbGljZSgwLCA1MCl9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tBdHRycyhhdHRycykge1xuICAgICAgICBjaGVja0F0dHJzKHRoaXMuYXR0cnMsIGF0dHJzLCBcIm5vZGVcIiwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gbWFyayB0eXBlIGlzIGFsbG93ZWQgaW4gdGhpcyBub2RlLlxuICAgICovXG4gICAgYWxsb3dzTWFya1R5cGUobWFya1R5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFya1NldCA9PSBudWxsIHx8IHRoaXMubWFya1NldC5pbmRleE9mKG1hcmtUeXBlKSA+IC0xO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdGhlIGdpdmVuIHNldCBvZiBtYXJrcyBhcmUgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5tYXJrU2V0ID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmVzIHRoZSBtYXJrcyB0aGF0IGFyZSBub3QgYWxsb3dlZCBpbiB0aGlzIG5vZGUgZnJvbSB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgYWxsb3dlZE1hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBtYXJrcztcbiAgICAgICAgbGV0IGNvcHk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hbGxvd3NNYXJrVHlwZShtYXJrc1tpXS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGlmICghY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weSA9IG1hcmtzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29weSkge1xuICAgICAgICAgICAgICAgIGNvcHkucHVzaChtYXJrc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFjb3B5ID8gbWFya3MgOiBjb3B5Lmxlbmd0aCA/IGNvcHkgOiBNYXJrLm5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGNvbXBpbGUobm9kZXMsIHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE5vZGVUeXBlKG5hbWUsIHNjaGVtYSwgc3BlYykpO1xuICAgICAgICBsZXQgdG9wVHlwZSA9IHNjaGVtYS5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIjtcbiAgICAgICAgaWYgKCFyZXN1bHRbdG9wVHlwZV0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGl0cyB0b3Agbm9kZSB0eXBlICgnXCIgKyB0b3BUeXBlICsgXCInKVwiKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRXZlcnkgc2NoZW1hIG5lZWRzIGEgJ3RleHQnIHR5cGVcIik7XG4gICAgICAgIGZvciAobGV0IF8gaW4gcmVzdWx0LnRleHQuYXR0cnMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB0ZXh0IG5vZGUgdHlwZSBzaG91bGQgbm90IGhhdmUgYXR0cmlidXRlc1wiKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUodHlwZU5hbWUsIGF0dHJOYW1lLCB0eXBlKSB7XG4gICAgbGV0IHR5cGVzID0gdHlwZS5zcGxpdChcInxcIik7XG4gICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICBsZXQgbmFtZSA9IHZhbHVlID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgdmFsdWU7XG4gICAgICAgIGlmICh0eXBlcy5pbmRleE9mKG5hbWUpIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBFeHBlY3RlZCB2YWx1ZSBvZiB0eXBlICR7dHlwZXN9IGZvciBhdHRyaWJ1dGUgJHthdHRyTmFtZX0gb24gdHlwZSAke3R5cGVOYW1lfSwgZ290ICR7bmFtZX1gKTtcbiAgICB9O1xufVxuLy8gQXR0cmlidXRlIGRlc2NyaXB0b3JzXG5jbGFzcyBBdHRyaWJ1dGUge1xuICAgIGNvbnN0cnVjdG9yKHR5cGVOYW1lLCBhdHRyTmFtZSwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmhhc0RlZmF1bHQgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgXCJkZWZhdWx0XCIpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSBvcHRpb25zLmRlZmF1bHQ7XG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB0eXBlb2Ygb3B0aW9ucy52YWxpZGF0ZSA9PSBcInN0cmluZ1wiID8gdmFsaWRhdGVUeXBlKHR5cGVOYW1lLCBhdHRyTmFtZSwgb3B0aW9ucy52YWxpZGF0ZSkgOiBvcHRpb25zLnZhbGlkYXRlO1xuICAgIH1cbiAgICBnZXQgaXNSZXF1aXJlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmhhc0RlZmF1bHQ7XG4gICAgfVxufVxuLy8gTWFya3Ncbi8qKlxuTGlrZSBub2RlcywgbWFya3MgKHdoaWNoIGFyZSBhc3NvY2lhdGVkIHdpdGggbm9kZXMgdG8gc2lnbmlmeVxudGhpbmdzIGxpa2UgZW1waGFzaXMgb3IgYmVpbmcgcGFydCBvZiBhIGxpbmspIGFyZVxuW3RhZ2dlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmsudHlwZSkgd2l0aCB0eXBlIG9iamVjdHMsIHdoaWNoIGFyZVxuaW5zdGFudGlhdGVkIG9uY2UgcGVyIGBTY2hlbWFgLlxuKi9cbmNsYXNzIE1hcmtUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBtYXJrIHR5cGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmssIFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgdGhhdCB0aGlzIG1hcmsgdHlwZSBpbnN0YW5jZSBpcyBwYXJ0IG9mLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc3BlYyBvbiB3aGljaCB0aGUgdHlwZSBpcyBiYXNlZC5cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBpbml0QXR0cnMobmFtZSwgc3BlYy5hdHRycyk7XG4gICAgICAgIHRoaXMuZXhjbHVkZWQgPSBudWxsO1xuICAgICAgICBsZXQgZGVmYXVsdHMgPSBkZWZhdWx0QXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBkZWZhdWx0cyA/IG5ldyBNYXJrKHRoaXMsIGRlZmF1bHRzKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgb2YgdGhpcyB0eXBlLiBgYXR0cnNgIG1heSBiZSBgbnVsbGAgb3IgYW4gb2JqZWN0XG4gICAgY29udGFpbmluZyBvbmx5IHNvbWUgb2YgdGhlIG1hcmsncyBhdHRyaWJ1dGVzLiBUaGUgb3RoZXJzLCBpZlxuICAgIHRoZXkgaGF2ZSBkZWZhdWx0cywgd2lsbCBiZSBhZGRlZC5cbiAgICAqL1xuICAgIGNyZWF0ZShhdHRycyA9IG51bGwpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2U7XG4gICAgICAgIHJldHVybiBuZXcgTWFyayh0aGlzLCBjb21wdXRlQXR0cnModGhpcy5hdHRycywgYXR0cnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShtYXJrcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpLCByYW5rID0gMDtcbiAgICAgICAgbWFya3MuZm9yRWFjaCgobmFtZSwgc3BlYykgPT4gcmVzdWx0W25hbWVdID0gbmV3IE1hcmtUeXBlKG5hbWUsIHJhbmsrKywgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LCBhIG5ldyBzZXRcbiAgICB3aXRob3V0IGl0IGlzIHJldHVybmVkLiBPdGhlcndpc2UsIHRoZSBpbnB1dCBzZXQgaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICByZW1vdmVGcm9tU2V0KHNldCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKSB7XG4gICAgICAgICAgICAgICAgc2V0ID0gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3RzIHdoZXRoZXIgdGhlcmUgaXMgYSBtYXJrIG9mIHRoaXMgdHlwZSBpbiB0aGUgZ2l2ZW4gc2V0LlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoc2V0W2ldLnR5cGUgPT0gdGhpcylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0W2ldO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNoZWNrQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgY2hlY2tBdHRycyh0aGlzLmF0dHJzLCBhdHRycywgXCJtYXJrXCIsIHRoaXMubmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJpZXMgd2hldGhlciBhIGdpdmVuIG1hcmsgdHlwZSBpc1xuICAgIFtleGNsdWRlZF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk1hcmtTcGVjLmV4Y2x1ZGVzKSBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGV4Y2x1ZGVzKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4Y2x1ZGVkLmluZGV4T2Yob3RoZXIpID4gLTE7XG4gICAgfVxufVxuLyoqXG5BIGRvY3VtZW50IHNjaGVtYS4gSG9sZHMgW25vZGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlVHlwZSkgYW5kIFttYXJrXG50eXBlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1R5cGUpIG9iamVjdHMgZm9yIHRoZSBub2RlcyBhbmQgbWFya3MgdGhhdCBtYXlcbm9jY3VyIGluIGNvbmZvcm1pbmcgZG9jdW1lbnRzLCBhbmQgcHJvdmlkZXMgZnVuY3Rpb25hbGl0eSBmb3JcbmNyZWF0aW5nIGFuZCBkZXNlcmlhbGl6aW5nIHN1Y2ggZG9jdW1lbnRzLlxuXG5XaGVuIGdpdmVuLCB0aGUgdHlwZSBwYXJhbWV0ZXJzIHByb3ZpZGUgdGhlIG5hbWVzIG9mIHRoZSBub2RlcyBhbmRcbm1hcmtzIGluIHRoaXMgc2NoZW1hLlxuKi9cbmNsYXNzIFNjaGVtYSB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgc2NoZW1hIGZyb20gYSBzY2hlbWEgW3NwZWNpZmljYXRpb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TY2hlbWFTcGVjKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNwZWMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBbbGluZWJyZWFrXG4gICAgICAgIHJlcGxhY2VtZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMubGluZWJyZWFrUmVwbGFjZW1lbnQpIG5vZGUgZGVmaW5lZFxuICAgICAgICBpbiB0aGlzIHNjaGVtYSwgaWYgYW55LlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmxpbmVicmVha1JlcGxhY2VtZW50ID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEFuIG9iamVjdCBmb3Igc3RvcmluZyB3aGF0ZXZlciB2YWx1ZXMgbW9kdWxlcyBtYXkgd2FudCB0b1xuICAgICAgICBjb21wdXRlIGFuZCBjYWNoZSBwZXIgc2NoZW1hLiAoSWYgeW91IHdhbnQgdG8gc3RvcmUgc29tZXRoaW5nXG4gICAgICAgIGluIGl0LCB0cnkgdG8gdXNlIHByb3BlcnR5IG5hbWVzIHVubGlrZWx5IHRvIGNsYXNoLilcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYWNoZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgaW5zdGFuY2VTcGVjID0gdGhpcy5zcGVjID0ge307XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gc3BlYylcbiAgICAgICAgICAgIGluc3RhbmNlU3BlY1twcm9wXSA9IHNwZWNbcHJvcF07XG4gICAgICAgIGluc3RhbmNlU3BlYy5ub2RlcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm5vZGVzKSxcbiAgICAgICAgICAgIGluc3RhbmNlU3BlYy5tYXJrcyA9IE9yZGVyZWRNYXAuZnJvbShzcGVjLm1hcmtzIHx8IHt9KSxcbiAgICAgICAgICAgIHRoaXMubm9kZXMgPSBOb2RlVHlwZS5jb21waWxlKHRoaXMuc3BlYy5ub2RlcywgdGhpcyk7XG4gICAgICAgIHRoaXMubWFya3MgPSBNYXJrVHlwZS5jb21waWxlKHRoaXMuc3BlYy5tYXJrcywgdGhpcyk7XG4gICAgICAgIGxldCBjb250ZW50RXhwckNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0aGlzLm5vZGVzKSB7XG4gICAgICAgICAgICBpZiAocHJvcCBpbiB0aGlzLm1hcmtzKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHByb3AgKyBcIiBjYW4gbm90IGJlIGJvdGggYSBub2RlIGFuZCBhIG1hcmtcIik7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHRoaXMubm9kZXNbcHJvcF0sIGNvbnRlbnRFeHByID0gdHlwZS5zcGVjLmNvbnRlbnQgfHwgXCJcIiwgbWFya0V4cHIgPSB0eXBlLnNwZWMubWFya3M7XG4gICAgICAgICAgICB0eXBlLmNvbnRlbnRNYXRjaCA9IGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdIHx8XG4gICAgICAgICAgICAgICAgKGNvbnRlbnRFeHByQ2FjaGVbY29udGVudEV4cHJdID0gQ29udGVudE1hdGNoLnBhcnNlKGNvbnRlbnRFeHByLCB0aGlzLm5vZGVzKSk7XG4gICAgICAgICAgICB0eXBlLmlubGluZUNvbnRlbnQgPSB0eXBlLmNvbnRlbnRNYXRjaC5pbmxpbmVDb250ZW50O1xuICAgICAgICAgICAgaWYgKHR5cGUuc3BlYy5saW5lYnJlYWtSZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmxpbmVicmVha1JlcGxhY2VtZW50KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGxpbmVicmVhayBub2RlcyBkZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIGlmICghdHlwZS5pc0lubGluZSB8fCAhdHlwZS5pc0xlYWYpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTGluZWJyZWFrIHJlcGxhY2VtZW50IG5vZGVzIG11c3QgYmUgaW5saW5lIGxlYWYgbm9kZXNcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5saW5lYnJlYWtSZXBsYWNlbWVudCA9IHR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eXBlLm1hcmtTZXQgPSBtYXJrRXhwciA9PSBcIl9cIiA/IG51bGwgOlxuICAgICAgICAgICAgICAgIG1hcmtFeHByID8gZ2F0aGVyTWFya3ModGhpcywgbWFya0V4cHIuc3BsaXQoXCIgXCIpKSA6XG4gICAgICAgICAgICAgICAgICAgIG1hcmtFeHByID09IFwiXCIgfHwgIXR5cGUuaW5saW5lQ29udGVudCA/IFtdIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubWFya3MpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5tYXJrc1twcm9wXSwgZXhjbCA9IHR5cGUuc3BlYy5leGNsdWRlcztcbiAgICAgICAgICAgIHR5cGUuZXhjbHVkZWQgPSBleGNsID09IG51bGwgPyBbdHlwZV0gOiBleGNsID09IFwiXCIgPyBbXSA6IGdhdGhlck1hcmtzKHRoaXMsIGV4Y2wuc3BsaXQoXCIgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVGcm9tSlNPTiA9IGpzb24gPT4gTm9kZS5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICAgICAgdGhpcy5tYXJrRnJvbUpTT04gPSBqc29uID0+IE1hcmsuZnJvbUpTT04odGhpcywganNvbik7XG4gICAgICAgIHRoaXMudG9wTm9kZVR5cGUgPSB0aGlzLm5vZGVzW3RoaXMuc3BlYy50b3BOb2RlIHx8IFwiZG9jXCJdO1xuICAgICAgICB0aGlzLmNhY2hlZC53cmFwcGluZ3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIGluIHRoaXMgc2NoZW1hLiBUaGUgYHR5cGVgIG1heSBiZSBhIHN0cmluZyBvciBhXG4gICAgYE5vZGVUeXBlYCBpbnN0YW5jZS4gQXR0cmlidXRlcyB3aWxsIGJlIGV4dGVuZGVkIHdpdGggZGVmYXVsdHMsXG4gICAgYGNvbnRlbnRgIG1heSBiZSBhIGBGcmFnbWVudGAsIGBudWxsYCwgYSBgTm9kZWAsIG9yIGFuIGFycmF5IG9mXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBub2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCwgbWFya3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5ub2RlVHlwZSh0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAoISh0eXBlIGluc3RhbmNlb2YgTm9kZVR5cGUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG5vZGUgdHlwZTogXCIgKyB0eXBlKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZS5zY2hlbWEgIT0gdGhpcylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGZyb20gZGlmZmVyZW50IHNjaGVtYSB1c2VkIChcIiArIHR5cGUubmFtZSArIFwiKVwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlQ2hlY2tlZChhdHRycywgY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IG5vZGUgaW4gdGhlIHNjaGVtYS4gRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90XG4gICAgYWxsb3dlZC5cbiAgICAqL1xuICAgIHRleHQodGV4dCwgbWFya3MpIHtcbiAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm5vZGVzLnRleHQ7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dE5vZGUodHlwZSwgdHlwZS5kZWZhdWx0QXR0cnMsIHRleHQsIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHdpdGggdGhlIGdpdmVuIHR5cGUgYW5kIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBtYXJrKHR5cGUsIGF0dHJzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdHlwZSA9IHRoaXMubWFya3NbdHlwZV07XG4gICAgICAgIHJldHVybiB0eXBlLmNyZWF0ZShhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbm9kZVR5cGUobmFtZSkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLm5vZGVzW25hbWVdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVbmtub3duIG5vZGUgdHlwZTogXCIgKyBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdhdGhlck1hcmtzKHNjaGVtYSwgbWFya3MpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBuYW1lID0gbWFya3NbaV0sIG1hcmsgPSBzY2hlbWEubWFya3NbbmFtZV0sIG9rID0gbWFyaztcbiAgICAgICAgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGZvdW5kLnB1c2gobWFyayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgICAgIGxldCBtYXJrID0gc2NoZW1hLm1hcmtzW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lID09IFwiX1wiIHx8IChtYXJrLnNwZWMuZ3JvdXAgJiYgbWFyay5zcGVjLmdyb3VwLnNwbGl0KFwiIFwiKS5pbmRleE9mKG5hbWUpID4gLTEpKVxuICAgICAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKG9rID0gbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvaylcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlVua25vd24gbWFyayB0eXBlOiAnXCIgKyBtYXJrc1tpXSArIFwiJ1wiKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuXG5mdW5jdGlvbiBpc1RhZ1J1bGUocnVsZSkgeyByZXR1cm4gcnVsZS50YWcgIT0gbnVsbDsgfVxuZnVuY3Rpb24gaXNTdHlsZVJ1bGUocnVsZSkgeyByZXR1cm4gcnVsZS5zdHlsZSAhPSBudWxsOyB9XG4vKipcbkEgRE9NIHBhcnNlciByZXByZXNlbnRzIGEgc3RyYXRlZ3kgZm9yIHBhcnNpbmcgRE9NIGNvbnRlbnQgaW50byBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudCBjb25mb3JtaW5nIHRvIGEgZ2l2ZW4gc2NoZW1hLiBJdHMgYmVoYXZpb3IgaXNcbmRlZmluZWQgYnkgYW4gYXJyYXkgb2YgW3J1bGVzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuUGFyc2VSdWxlKS5cbiovXG5jbGFzcyBET01QYXJzZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBhcnNlciB0aGF0IHRhcmdldHMgdGhlIGdpdmVuIHNjaGVtYSwgdXNpbmcgdGhlIGdpdmVuXG4gICAgcGFyc2luZyBydWxlcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgaW50byB3aGljaCB0aGUgcGFyc2VyIHBhcnNlcy5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiBbcGFyc2UgcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpIHRoYXQgdGhlIHBhcnNlclxuICAgIHVzZXMsIGluIG9yZGVyIG9mIHByZWNlZGVuY2UuXG4gICAgKi9cbiAgICBydWxlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMudGFncyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3R5bGVzID0gW107XG4gICAgICAgIGxldCBtYXRjaGVkU3R5bGVzID0gdGhpcy5tYXRjaGVkU3R5bGVzID0gW107XG4gICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNUYWdSdWxlKHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzLnB1c2gocnVsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0eWxlUnVsZShydWxlKSkge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gL1tePV0qLy5leGVjKHJ1bGUuc3R5bGUpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaGVkU3R5bGVzLmluZGV4T2YocHJvcCkgPCAwKVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkU3R5bGVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHlsZXMucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE9ubHkgbm9ybWFsaXplIGxpc3QgZWxlbWVudHMgd2hlbiBsaXN0cyBpbiB0aGUgc2NoZW1hIGNhbid0IGRpcmVjdGx5IGNvbnRhaW4gdGhlbXNlbHZlc1xuICAgICAgICB0aGlzLm5vcm1hbGl6ZUxpc3RzID0gIXRoaXMudGFncy5zb21lKHIgPT4ge1xuICAgICAgICAgICAgaWYgKCEvXih1bHxvbClcXGIvLnRlc3Qoci50YWcpIHx8ICFyLm5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBzY2hlbWEubm9kZXNbci5ub2RlXTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZSBhIGRvY3VtZW50IGZyb20gdGhlIGNvbnRlbnQgb2YgYSBET00gbm9kZS5cbiAgICAqL1xuICAgIHBhcnNlKGRvbSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gbmV3IFBhcnNlQ29udGV4dCh0aGlzLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgTWFyay5ub25lLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gY29udGV4dC5maW5pc2goKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUGFyc2VzIHRoZSBjb250ZW50IG9mIHRoZSBnaXZlbiBET00gbm9kZSwgbGlrZVxuICAgIFtgcGFyc2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NUGFyc2VyLnBhcnNlKSwgYW5kIHRha2VzIHRoZSBzYW1lIHNldCBvZlxuICAgIG9wdGlvbnMuIEJ1dCB1bmxpa2UgdGhhdCBtZXRob2QsIHdoaWNoIHByb2R1Y2VzIGEgd2hvbGUgbm9kZSxcbiAgICB0aGlzIG9uZSByZXR1cm5zIGEgc2xpY2UgdGhhdCBpcyBvcGVuIGF0IHRoZSBzaWRlcywgbWVhbmluZyB0aGF0XG4gICAgdGhlIHNjaGVtYSBjb25zdHJhaW50cyBhcmVuJ3QgYXBwbGllZCB0byB0aGUgc3RhcnQgb2Ygbm9kZXMgdG9cbiAgICB0aGUgbGVmdCBvZiB0aGUgaW5wdXQgYW5kIHRoZSBlbmQgb2Ygbm9kZXMgYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIHBhcnNlU2xpY2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICBjb250ZXh0LmFkZEFsbChkb20sIE1hcmsubm9uZSwgb3B0aW9ucy5mcm9tLCBvcHRpb25zLnRvKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlLm1heE9wZW4oY29udGV4dC5maW5pc2goKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hUYWcoZG9tLCBjb250ZXh0LCBhZnRlcikge1xuICAgICAgICBmb3IgKGxldCBpID0gYWZ0ZXIgPyB0aGlzLnRhZ3MuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMudGFncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnRhZ3NbaV07XG4gICAgICAgICAgICBpZiAobWF0Y2hlcyhkb20sIHJ1bGUudGFnKSAmJlxuICAgICAgICAgICAgICAgIChydWxlLm5hbWVzcGFjZSA9PT0gdW5kZWZpbmVkIHx8IGRvbS5uYW1lc3BhY2VVUkkgPT0gcnVsZS5uYW1lc3BhY2UpICYmXG4gICAgICAgICAgICAgICAgKCFydWxlLmNvbnRleHQgfHwgY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGlmIChydWxlLmdldEF0dHJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKGRvbSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hdGNoU3R5bGUocHJvcCwgdmFsdWUsIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMuc3R5bGVzLmluZGV4T2YoYWZ0ZXIpICsgMSA6IDA7IGkgPCB0aGlzLnN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnN0eWxlc1tpXSwgc3R5bGUgPSBydWxlLnN0eWxlO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmluZGV4T2YocHJvcCkgIT0gMCB8fFxuICAgICAgICAgICAgICAgIHJ1bGUuY29udGV4dCAmJiAhY29udGV4dC5tYXRjaGVzQ29udGV4dChydWxlLmNvbnRleHQpIHx8XG4gICAgICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBzdHlsZSBzdHJpbmcgZWl0aGVyIHByZWNpc2VseSBtYXRjaGVzIHRoZSBwcm9wLFxuICAgICAgICAgICAgICAgIC8vIG9yIGhhcyBhbiAnPScgc2lnbiBhZnRlciB0aGUgcHJvcCwgZm9sbG93ZWQgYnkgdGhlIGdpdmVuXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUuXG4gICAgICAgICAgICAgICAgc3R5bGUubGVuZ3RoID4gcHJvcC5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAgICAgKHN0eWxlLmNoYXJDb2RlQXQocHJvcC5sZW5ndGgpICE9IDYxIHx8IHN0eWxlLnNsaWNlKHByb3AubGVuZ3RoICsgMSkgIT0gdmFsdWUpKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcnVsZS5nZXRBdHRycyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHJ1bGUuYXR0cnMgPSByZXN1bHQgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgc2NoZW1hUnVsZXMoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIGxldCBwcmlvcml0eSA9IHJ1bGUucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogcnVsZS5wcmlvcml0eSwgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gcmVzdWx0W2ldLCBuZXh0UHJpb3JpdHkgPSBuZXh0LnByaW9yaXR5ID09IG51bGwgPyA1MCA6IG5leHQucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRQcmlvcml0eSA8IHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5zcGxpY2UoaSwgMCwgcnVsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubWFya3MpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5tYXJrc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubWFyayB8fCBydWxlLmlnbm9yZSB8fCBydWxlLmNsZWFyTWFyaykpXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLm1hcmsgPSBuYW1lO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gc2NoZW1hLm5vZGVzKSB7XG4gICAgICAgICAgICBsZXQgcnVsZXMgPSBzY2hlbWEubm9kZXNbbmFtZV0uc3BlYy5wYXJzZURPTTtcbiAgICAgICAgICAgIGlmIChydWxlcylcbiAgICAgICAgICAgICAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQocnVsZSA9IGNvcHkocnVsZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShydWxlLm5vZGUgfHwgcnVsZS5pZ25vcmUgfHwgcnVsZS5tYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubm9kZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgRE9NIHBhcnNlciB1c2luZyB0aGUgcGFyc2luZyBydWxlcyBsaXN0ZWQgaW4gYVxuICAgIHNjaGVtYSdzIFtub2RlIHNwZWNzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMucGFyc2VET00pLCByZW9yZGVyZWQgYnlcbiAgICBbcHJpb3JpdHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5HZW5lcmljUGFyc2VSdWxlLnByaW9yaXR5KS5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21QYXJzZXIgfHxcbiAgICAgICAgICAgIChzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciA9IG5ldyBET01QYXJzZXIoc2NoZW1hLCBET01QYXJzZXIuc2NoZW1hUnVsZXMoc2NoZW1hKSkpO1xuICAgIH1cbn1cbmNvbnN0IGJsb2NrVGFncyA9IHtcbiAgICBhZGRyZXNzOiB0cnVlLCBhcnRpY2xlOiB0cnVlLCBhc2lkZTogdHJ1ZSwgYmxvY2txdW90ZTogdHJ1ZSwgY2FudmFzOiB0cnVlLFxuICAgIGRkOiB0cnVlLCBkaXY6IHRydWUsIGRsOiB0cnVlLCBmaWVsZHNldDogdHJ1ZSwgZmlnY2FwdGlvbjogdHJ1ZSwgZmlndXJlOiB0cnVlLFxuICAgIGZvb3RlcjogdHJ1ZSwgZm9ybTogdHJ1ZSwgaDE6IHRydWUsIGgyOiB0cnVlLCBoMzogdHJ1ZSwgaDQ6IHRydWUsIGg1OiB0cnVlLFxuICAgIGg2OiB0cnVlLCBoZWFkZXI6IHRydWUsIGhncm91cDogdHJ1ZSwgaHI6IHRydWUsIGxpOiB0cnVlLCBub3NjcmlwdDogdHJ1ZSwgb2w6IHRydWUsXG4gICAgb3V0cHV0OiB0cnVlLCBwOiB0cnVlLCBwcmU6IHRydWUsIHNlY3Rpb246IHRydWUsIHRhYmxlOiB0cnVlLCB0Zm9vdDogdHJ1ZSwgdWw6IHRydWVcbn07XG5jb25zdCBpZ25vcmVUYWdzID0ge1xuICAgIGhlYWQ6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvYmplY3Q6IHRydWUsIHNjcmlwdDogdHJ1ZSwgc3R5bGU6IHRydWUsIHRpdGxlOiB0cnVlXG59O1xuY29uc3QgbGlzdFRhZ3MgPSB7IG9sOiB0cnVlLCB1bDogdHJ1ZSB9O1xuLy8gVXNpbmcgYSBiaXRmaWVsZCBmb3Igbm9kZSBjb250ZXh0IG9wdGlvbnNcbmNvbnN0IE9QVF9QUkVTRVJWRV9XUyA9IDEsIE9QVF9QUkVTRVJWRV9XU19GVUxMID0gMiwgT1BUX09QRU5fTEVGVCA9IDQ7XG5mdW5jdGlvbiB3c09wdGlvbnNGb3IodHlwZSwgcHJlc2VydmVXaGl0ZXNwYWNlLCBiYXNlKSB7XG4gICAgaWYgKHByZXNlcnZlV2hpdGVzcGFjZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gKHByZXNlcnZlV2hpdGVzcGFjZSA/IE9QVF9QUkVTRVJWRV9XUyA6IDApIHxcbiAgICAgICAgICAgIChwcmVzZXJ2ZVdoaXRlc3BhY2UgPT09IFwiZnVsbFwiID8gT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiAwKTtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIiA/IE9QVF9QUkVTRVJWRV9XUyB8IE9QVF9QUkVTRVJWRV9XU19GVUxMIDogYmFzZSAmIH5PUFRfT1BFTl9MRUZUO1xufVxuY2xhc3MgTm9kZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGF0dHJzLCBtYXJrcywgc29saWQsIG1hdGNoLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLnNvbGlkID0gc29saWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICAvLyBNYXJrcyBhcHBsaWVkIHRvIHRoZSBub2RlJ3MgY2hpbGRyZW5cbiAgICAgICAgdGhpcy5hY3RpdmVNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IG1hdGNoIHx8IChvcHRpb25zICYgT1BUX09QRU5fTEVGVCA/IG51bGwgOiB0eXBlLmNvbnRlbnRNYXRjaCk7XG4gICAgfVxuICAgIGZpbmRXcmFwcGluZyhub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXRjaCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnR5cGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgbGV0IGZpbGwgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZnJvbShub2RlKSk7XG4gICAgICAgICAgICBpZiAoZmlsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF0Y2ggPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZmlsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnR5cGUuY29udGVudE1hdGNoLCB3cmFwO1xuICAgICAgICAgICAgICAgIGlmICh3cmFwID0gc3RhcnQuZmluZFdyYXBwaW5nKG5vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5tYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKTtcbiAgICB9XG4gICAgZmluaXNoKG9wZW5FbmQpIHtcbiAgICAgICAgaWYgKCEodGhpcy5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSkgeyAvLyBTdHJpcCB0cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0sIG07XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsYXN0LmlzVGV4dCAmJiAobSA9IC9bIFxcdFxcclxcblxcdTAwMGNdKyQvLmV4ZWMobGFzdC50ZXh0KSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgdGV4dCA9IGxhc3Q7XG4gICAgICAgICAgICAgICAgaWYgKGxhc3QudGV4dC5sZW5ndGggPT0gbVswXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudC5wb3AoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gPSB0ZXh0LndpdGhUZXh0KHRleHQudGV4dC5zbGljZSgwLCB0ZXh0LnRleHQubGVuZ3RoIC0gbVswXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmZyb20odGhpcy5jb250ZW50KTtcbiAgICAgICAgaWYgKCFvcGVuRW5kICYmIHRoaXMubWF0Y2gpXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5hcHBlbmQodGhpcy5tYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPyB0aGlzLnR5cGUuY3JlYXRlKHRoaXMuYXR0cnMsIGNvbnRlbnQsIHRoaXMubWFya3MpIDogY29udGVudDtcbiAgICB9XG4gICAgaW5saW5lQ29udGV4dChub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXS5pc0lubGluZTtcbiAgICAgICAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZSAmJiAhYmxvY2tUYWdzLmhhc093blByb3BlcnR5KG5vZGUucGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG59XG5jbGFzcyBQYXJzZUNvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSBwYXJzZXIgd2UgYXJlIHVzaW5nLlxuICAgIHBhcnNlciwgXG4gICAgLy8gVGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoaXMgcGFyc2UuXG4gICAgb3B0aW9ucywgaXNPcGVuKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IGlzT3BlbjtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSBmYWxzZTtcbiAgICAgICAgbGV0IHRvcE5vZGUgPSBvcHRpb25zLnRvcE5vZGUsIHRvcENvbnRleHQ7XG4gICAgICAgIGxldCB0b3BPcHRpb25zID0gd3NPcHRpb25zRm9yKG51bGwsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAwKSB8IChpc09wZW4gPyBPUFRfT1BFTl9MRUZUIDogMCk7XG4gICAgICAgIGlmICh0b3BOb2RlKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dCh0b3BOb2RlLnR5cGUsIHRvcE5vZGUuYXR0cnMsIE1hcmsubm9uZSwgdHJ1ZSwgb3B0aW9ucy50b3BNYXRjaCB8fCB0b3BOb2RlLnR5cGUuY29udGVudE1hdGNoLCB0b3BPcHRpb25zKTtcbiAgICAgICAgZWxzZSBpZiAoaXNPcGVuKVxuICAgICAgICAgICAgdG9wQ29udGV4dCA9IG5ldyBOb2RlQ29udGV4dChudWxsLCBudWxsLCBNYXJrLm5vbmUsIHRydWUsIG51bGwsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHBhcnNlci5zY2hlbWEudG9wTm9kZVR5cGUsIG51bGwsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIHRoaXMubm9kZXMgPSBbdG9wQ29udGV4dF07XG4gICAgICAgIHRoaXMuZmluZCA9IG9wdGlvbnMuZmluZFBvc2l0aW9ucztcbiAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCB0b3AoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzW3RoaXMub3Blbl07XG4gICAgfVxuICAgIC8vIEFkZCBhIERPTSBub2RlIHRvIHRoZSBjb250ZW50LiBUZXh0IGlzIGluc2VydGVkIGFzIHRleHQgbm9kZSxcbiAgICAvLyBvdGhlcndpc2UsIHRoZSBub2RlIGlzIHBhc3NlZCB0byBgYWRkRWxlbWVudGAgb3IsIGlmIGl0IGhhcyBhXG4gICAgLy8gYHN0eWxlYCBhdHRyaWJ1dGUsIGBhZGRFbGVtZW50V2l0aFN0eWxlc2AuXG4gICAgYWRkRE9NKGRvbSwgbWFya3MpIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgdGhpcy5hZGRUZXh0Tm9kZShkb20sIG1hcmtzKTtcbiAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlID09IDEpXG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBtYXJrcyk7XG4gICAgfVxuICAgIGFkZFRleHROb2RlKGRvbSwgbWFya3MpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gZG9tLm5vZGVWYWx1ZTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wLCBwcmVzZXJ2ZVdTID0gKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTX0ZVTEwpID8gXCJmdWxsXCJcbiAgICAgICAgICAgIDogdGhpcy5sb2NhbFByZXNlcnZlV1MgfHwgKHRvcC5vcHRpb25zICYgT1BUX1BSRVNFUlZFX1dTKSA+IDA7XG4gICAgICAgIGxldCB7IHNjaGVtYSB9ID0gdGhpcy5wYXJzZXI7XG4gICAgICAgIGlmIChwcmVzZXJ2ZVdTID09PSBcImZ1bGxcIiB8fFxuICAgICAgICAgICAgdG9wLmlubGluZUNvbnRleHQoZG9tKSB8fFxuICAgICAgICAgICAgL1teIFxcdFxcclxcblxcdTAwMGNdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZVdTKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9bIFxcdFxcclxcblxcdTAwMGNdKy9nLCBcIiBcIik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBzdGFydHMgd2l0aCB3aGl0ZXNwYWNlLCBhbmQgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUgaXQsIG9yXG4gICAgICAgICAgICAgICAgLy8gYSBoYXJkIGJyZWFrLCBvciBhIHRleHQgbm9kZSB0aGF0IGVuZHMgd2l0aCB3aGl0ZXNwYWNlLCBzdHJpcCB0aGVcbiAgICAgICAgICAgICAgICAvLyBsZWFkaW5nIHNwYWNlLlxuICAgICAgICAgICAgICAgIGlmICgvXlsgXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpICYmIHRoaXMub3BlbiA9PSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVCZWZvcmUgPSB0b3AuY29udGVudFt0b3AuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRvbU5vZGVCZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVCZWZvcmUgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChkb21Ob2RlQmVmb3JlICYmIGRvbU5vZGVCZWZvcmUubm9kZU5hbWUgPT0gJ0JSJykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChub2RlQmVmb3JlLmlzVGV4dCAmJiAvWyBcXHRcXHJcXG5cXHUwMDBjXSQvLnRlc3Qobm9kZUJlZm9yZS50ZXh0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByZXNlcnZlV1MgPT09IFwiZnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHJcXG4/L2csIFwiXFxuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50ICYmIC9bXFxyXFxuXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy50b3AuZmluZFdyYXBwaW5nKHNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudC5jcmVhdGUoKSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgbGluZXMgPSB2YWx1ZS5zcGxpdCgvXFxyP1xcbnxcXHIvKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudC5jcmVhdGUoKSwgbWFya3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobGluZXNbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vZGUoc2NoZW1hLnRleHQobGluZXNbaV0pLCBtYXJrcywgIS9cXFMvLnRlc3QobGluZXNbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXHI/XFxufFxcci9nLCBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnROb2RlKHNjaGVtYS50ZXh0KHZhbHVlKSwgbWFya3MsICEvXFxTLy50ZXN0KHZhbHVlKSk7XG4gICAgICAgICAgICB0aGlzLmZpbmRJblRleHQoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFRyeSB0byBmaW5kIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIHRhZyBhbmQgdXNlIHRoYXQgdG8gcGFyc2UuIElmXG4gICAgLy8gbm9uZSBpcyBmb3VuZCwgdGhlIGVsZW1lbnQncyBjb250ZW50IG5vZGVzIGFyZSBhZGRlZCBkaXJlY3RseS5cbiAgICBhZGRFbGVtZW50KGRvbSwgbWFya3MsIG1hdGNoQWZ0ZXIpIHtcbiAgICAgICAgbGV0IG91dGVyV1MgPSB0aGlzLmxvY2FsUHJlc2VydmVXUywgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIGlmIChkb20udGFnTmFtZSA9PSBcIlBSRVwiIHx8IC9wcmUvLnRlc3QoZG9tLnN0eWxlICYmIGRvbS5zdHlsZS53aGl0ZVNwYWNlKSlcbiAgICAgICAgICAgIHRoaXMubG9jYWxQcmVzZXJ2ZVdTID0gdHJ1ZTtcbiAgICAgICAgbGV0IG5hbWUgPSBkb20ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcnVsZUlEO1xuICAgICAgICBpZiAobGlzdFRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgdGhpcy5wYXJzZXIubm9ybWFsaXplTGlzdHMpXG4gICAgICAgICAgICBub3JtYWxpemVMaXN0KGRvbSk7XG4gICAgICAgIGxldCBydWxlID0gKHRoaXMub3B0aW9ucy5ydWxlRnJvbU5vZGUgJiYgdGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZShkb20pKSB8fFxuICAgICAgICAgICAgKHJ1bGVJRCA9IHRoaXMucGFyc2VyLm1hdGNoVGFnKGRvbSwgdGhpcywgbWF0Y2hBZnRlcikpO1xuICAgICAgICBvdXQ6IGlmIChydWxlID8gcnVsZS5pZ25vcmUgOiBpZ25vcmVUYWdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHRoaXMuaWdub3JlRmFsbGJhY2soZG9tLCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXJ1bGUgfHwgcnVsZS5za2lwIHx8IHJ1bGUuY2xvc2VQYXJlbnQpIHtcbiAgICAgICAgICAgIGlmIChydWxlICYmIHJ1bGUuY2xvc2VQYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gTWF0aC5tYXgoMCwgdGhpcy5vcGVuIC0gMSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlICYmIHJ1bGUuc2tpcC5ub2RlVHlwZSlcbiAgICAgICAgICAgICAgICBkb20gPSBydWxlLnNraXA7XG4gICAgICAgICAgICBsZXQgc3luYywgb2xkTmVlZHNCbG9jayA9IHRoaXMubmVlZHNCbG9jaztcbiAgICAgICAgICAgIGlmIChibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9wLmNvbnRlbnQubGVuZ3RoICYmIHRvcC5jb250ZW50WzBdLmlzSW5saW5lICYmIHRoaXMub3Blbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wZW4tLTtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghdG9wLnR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20sIG1hcmtzKTtcbiAgICAgICAgICAgICAgICBicmVhayBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaW5uZXJNYXJrcyA9IHJ1bGUgJiYgcnVsZS5za2lwID8gbWFya3MgOiB0aGlzLnJlYWRTdHlsZXMoZG9tLCBtYXJrcyk7XG4gICAgICAgICAgICBpZiAoaW5uZXJNYXJrcylcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEFsbChkb20sIGlubmVyTWFya3MpO1xuICAgICAgICAgICAgaWYgKHN5bmMpXG4gICAgICAgICAgICAgICAgdGhpcy5zeW5jKHRvcCk7XG4gICAgICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBvbGROZWVkc0Jsb2NrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGlubmVyTWFya3MgPSB0aGlzLnJlYWRTdHlsZXMoZG9tLCBtYXJrcyk7XG4gICAgICAgICAgICBpZiAoaW5uZXJNYXJrcylcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnRCeVJ1bGUoZG9tLCBydWxlLCBpbm5lck1hcmtzLCBydWxlLmNvbnN1bWluZyA9PT0gZmFsc2UgPyBydWxlSUQgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9jYWxQcmVzZXJ2ZVdTID0gb3V0ZXJXUztcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBsZWFmIERPTSBub2RlcyB0aGF0IHdvdWxkIG90aGVyd2lzZSBiZSBpZ25vcmVkXG4gICAgbGVhZkZhbGxiYWNrKGRvbSwgbWFya3MpIHtcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgdGhpcy50b3AudHlwZSAmJiB0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbS5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXFxuXCIpLCBtYXJrcyk7XG4gICAgfVxuICAgIC8vIENhbGxlZCBmb3IgaWdub3JlZCBub2Rlc1xuICAgIGlnbm9yZUZhbGxiYWNrKGRvbSwgbWFya3MpIHtcbiAgICAgICAgLy8gSWdub3JlZCBCUiBub2RlcyBzaG91bGQgYXQgbGVhc3QgY3JlYXRlIGFuIGlubGluZSBjb250ZXh0XG4gICAgICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJCUlwiICYmICghdGhpcy50b3AudHlwZSB8fCAhdGhpcy50b3AudHlwZS5pbmxpbmVDb250ZW50KSlcbiAgICAgICAgICAgIHRoaXMuZmluZFBsYWNlKHRoaXMucGFyc2VyLnNjaGVtYS50ZXh0KFwiLVwiKSwgbWFya3MsIHRydWUpO1xuICAgIH1cbiAgICAvLyBSdW4gYW55IHN0eWxlIHBhcnNlciBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUncyBzdHlsZXMuIEVpdGhlclxuICAgIC8vIHJldHVybiBhbiB1cGRhdGVkIGFycmF5IG9mIG1hcmtzLCBvciBudWxsIHRvIGluZGljYXRlIHNvbWUgb2YgdGhlXG4gICAgLy8gc3R5bGVzIGhhZCBhIHJ1bGUgd2l0aCBgaWdub3JlYCBzZXQuXG4gICAgcmVhZFN0eWxlcyhkb20sIG1hcmtzKSB7XG4gICAgICAgIGxldCBzdHlsZXMgPSBkb20uc3R5bGU7XG4gICAgICAgIC8vIEJlY2F1c2UgbWFueSBwcm9wZXJ0aWVzIHdpbGwgb25seSBzaG93IHVwIGluICdub3JtYWxpemVkJyBmb3JtXG4gICAgICAgIC8vIGluIGBzdHlsZS5pdGVtYCAoaS5lLiB0ZXh0LWRlY29yYXRpb24gYmVjb21lc1xuICAgICAgICAvLyB0ZXh0LWRlY29yYXRpb24tbGluZSwgdGV4dC1kZWNvcmF0aW9uLWNvbG9yLCBldGMpLCB3ZSBkaXJlY3RseVxuICAgICAgICAvLyBxdWVyeSB0aGUgc3R5bGVzIG1lbnRpb25lZCBpbiBvdXIgcnVsZXMgaW5zdGVhZCBvZiBpdGVyYXRpbmdcbiAgICAgICAgLy8gb3ZlciB0aGUgaXRlbXMuXG4gICAgICAgIGlmIChzdHlsZXMgJiYgc3R5bGVzLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXJzZXIubWF0Y2hlZFN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuYW1lID0gdGhpcy5wYXJzZXIubWF0Y2hlZFN0eWxlc1tpXSwgdmFsdWUgPSBzdHlsZXMuZ2V0UHJvcGVydHlWYWx1ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGFmdGVyID0gdW5kZWZpbmVkOzspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBydWxlID0gdGhpcy5wYXJzZXIubWF0Y2hTdHlsZShuYW1lLCB2YWx1ZSwgdGhpcywgYWZ0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFydWxlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuaWdub3JlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuY2xlYXJNYXJrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuZmlsdGVyKG0gPT4gIXJ1bGUuY2xlYXJNYXJrKG0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXS5jcmVhdGUocnVsZS5hdHRycykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZnRlciA9IHJ1bGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvLyBMb29rIHVwIGEgaGFuZGxlciBmb3IgdGhlIGdpdmVuIG5vZGUuIElmIG5vbmUgYXJlIGZvdW5kLCByZXR1cm5cbiAgICAvLyBmYWxzZS4gT3RoZXJ3aXNlLCBhcHBseSBpdCwgdXNlIGl0cyByZXR1cm4gdmFsdWUgdG8gZHJpdmUgdGhlIHdheVxuICAgIC8vIHRoZSBub2RlJ3MgY29udGVudCBpcyB3cmFwcGVkLCBhbmQgcmV0dXJuIHRydWUuXG4gICAgYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIG1hcmtzLCBjb250aW51ZUFmdGVyKSB7XG4gICAgICAgIGxldCBzeW5jLCBub2RlVHlwZTtcbiAgICAgICAgaWYgKHJ1bGUubm9kZSkge1xuICAgICAgICAgICAgbm9kZVR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbcnVsZS5ub2RlXTtcbiAgICAgICAgICAgIGlmICghbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlubmVyID0gdGhpcy5lbnRlcihub2RlVHlwZSwgcnVsZS5hdHRycyB8fCBudWxsLCBtYXJrcywgcnVsZS5wcmVzZXJ2ZVdoaXRlc3BhY2UpO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lcikge1xuICAgICAgICAgICAgICAgICAgICBzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBpbm5lcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5pbnNlcnROb2RlKG5vZGVUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSwgbWFya3MsIGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWFmRmFsbGJhY2soZG9tLCBtYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya1R5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubWFya3NbcnVsZS5tYXJrXTtcbiAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KG1hcmtUeXBlLmNyZWF0ZShydWxlLmF0dHJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0SW4gPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlLmlzTGVhZikge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGludWVBZnRlcikge1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGRvbSwgbWFya3MsIGNvbnRpbnVlQWZ0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJ1bGUuZ2V0Q29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgICAgICBydWxlLmdldENvbnRlbnQoZG9tLCB0aGlzLnBhcnNlci5zY2hlbWEpLmZvckVhY2gobm9kZSA9PiB0aGlzLmluc2VydE5vZGUobm9kZSwgbWFya3MsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgY29udGVudERPTSA9IGRvbTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcnVsZS5jb250ZW50RWxlbWVudCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBkb20ucXVlcnlTZWxlY3RvcihydWxlLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudChkb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gcnVsZS5jb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHRoaXMuZmluZEFyb3VuZChkb20sIGNvbnRlbnRET00sIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5hZGRBbGwoY29udGVudERPTSwgbWFya3MpO1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzeW5jICYmIHRoaXMuc3luYyhzdGFydEluKSlcbiAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgIH1cbiAgICAvLyBBZGQgYWxsIGNoaWxkIG5vZGVzIGJldHdlZW4gYHN0YXJ0SW5kZXhgIGFuZCBgZW5kSW5kZXhgIChvciB0aGVcbiAgICAvLyB3aG9sZSBub2RlLCBpZiBub3QgZ2l2ZW4pLiBJZiBgc3luY2AgaXMgcGFzc2VkLCB1c2UgaXQgdG9cbiAgICAvLyBzeW5jaHJvbml6ZSBhZnRlciBldmVyeSBibG9jayBlbGVtZW50LlxuICAgIGFkZEFsbChwYXJlbnQsIG1hcmtzLCBzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICAgICAgICBsZXQgaW5kZXggPSBzdGFydEluZGV4IHx8IDA7XG4gICAgICAgIGZvciAobGV0IGRvbSA9IHN0YXJ0SW5kZXggPyBwYXJlbnQuY2hpbGROb2Rlc1tzdGFydEluZGV4XSA6IHBhcmVudC5maXJzdENoaWxkLCBlbmQgPSBlbmRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudC5jaGlsZE5vZGVzW2VuZEluZGV4XTsgZG9tICE9IGVuZDsgZG9tID0gZG9tLm5leHRTaWJsaW5nLCArK2luZGV4KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5hZGRET00oZG9tLCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5maW5kQXRQb2ludChwYXJlbnQsIGluZGV4KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSB3YXkgdG8gZml0IHRoZSBnaXZlbiBub2RlIHR5cGUgaW50byB0aGUgY3VycmVudFxuICAgIC8vIGNvbnRleHQuIE1heSBhZGQgaW50ZXJtZWRpYXRlIHdyYXBwZXJzIGFuZC9vciBsZWF2ZSBub24tc29saWRcbiAgICAvLyBub2RlcyB0aGF0IHdlJ3JlIGluLlxuICAgIGZpbmRQbGFjZShub2RlLCBtYXJrcywgY2F1dGlvdXMpIHtcbiAgICAgICAgbGV0IHJvdXRlLCBzeW5jO1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMub3BlbiwgcGVuYWx0eSA9IDA7IGRlcHRoID49IDA7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBjeCA9IHRoaXMubm9kZXNbZGVwdGhdO1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gY3guZmluZFdyYXBwaW5nKG5vZGUpO1xuICAgICAgICAgICAgaWYgKGZvdW5kICYmICghcm91dGUgfHwgcm91dGUubGVuZ3RoID4gZm91bmQubGVuZ3RoICsgcGVuYWx0eSkpIHtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IGZvdW5kO1xuICAgICAgICAgICAgICAgIHN5bmMgPSBjeDtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3guc29saWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2F1dGlvdXMpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBlbmFsdHkgKz0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXMuc3luYyhzeW5jKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3V0ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG1hcmtzID0gdGhpcy5lbnRlcklubmVyKHJvdXRlW2ldLCBudWxsLCBtYXJrcywgZmFsc2UpO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8vIFRyeSB0byBpbnNlcnQgdGhlIGdpdmVuIG5vZGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuIG5lZWRlZC5cbiAgICBpbnNlcnROb2RlKG5vZGUsIG1hcmtzLCBjYXV0aW91cykge1xuICAgICAgICBpZiAobm9kZS5pc0lubGluZSAmJiB0aGlzLm5lZWRzQmxvY2sgJiYgIXRoaXMudG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGxldCBibG9jayA9IHRoaXMudGV4dGJsb2NrRnJvbUNvbnRleHQoKTtcbiAgICAgICAgICAgIGlmIChibG9jaylcbiAgICAgICAgICAgICAgICBtYXJrcyA9IHRoaXMuZW50ZXJJbm5lcihibG9jaywgbnVsbCwgbWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbm5lck1hcmtzID0gdGhpcy5maW5kUGxhY2Uobm9kZSwgbWFya3MsIGNhdXRpb3VzKTtcbiAgICAgICAgaWYgKGlubmVyTWFya3MpIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICAgICAgbGV0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgICAgICAgaWYgKHRvcC5tYXRjaClcbiAgICAgICAgICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICBsZXQgbm9kZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICAgICAgZm9yIChsZXQgbSBvZiBpbm5lck1hcmtzLmNvbmNhdChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICBpZiAodG9wLnR5cGUgPyB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShtLnR5cGUpIDogbWFya01heUFwcGx5KG0udHlwZSwgbm9kZS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgbm9kZU1hcmtzID0gbS5hZGRUb1NldChub2RlTWFya3MpO1xuICAgICAgICAgICAgdG9wLmNvbnRlbnQucHVzaChub2RlLm1hcmsobm9kZU1hcmtzKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFRyeSB0byBzdGFydCBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUsIGFkanVzdGluZyB0aGUgY29udGV4dCB3aGVuXG4gICAgLy8gbmVjZXNzYXJ5LlxuICAgIGVudGVyKHR5cGUsIGF0dHJzLCBtYXJrcywgcHJlc2VydmVXUykge1xuICAgICAgICBsZXQgaW5uZXJNYXJrcyA9IHRoaXMuZmluZFBsYWNlKHR5cGUuY3JlYXRlKGF0dHJzKSwgbWFya3MsIGZhbHNlKTtcbiAgICAgICAgaWYgKGlubmVyTWFya3MpXG4gICAgICAgICAgICBpbm5lck1hcmtzID0gdGhpcy5lbnRlcklubmVyKHR5cGUsIGF0dHJzLCBtYXJrcywgdHJ1ZSwgcHJlc2VydmVXUyk7XG4gICAgICAgIHJldHVybiBpbm5lck1hcmtzO1xuICAgIH1cbiAgICAvLyBPcGVuIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZVxuICAgIGVudGVySW5uZXIodHlwZSwgYXR0cnMsIG1hcmtzLCBzb2xpZCA9IGZhbHNlLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaCAmJiB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBsZXQgb3B0aW9ucyA9IHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdTLCB0b3Aub3B0aW9ucyk7XG4gICAgICAgIGlmICgodG9wLm9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUKSAmJiB0b3AuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIG9wdGlvbnMgfD0gT1BUX09QRU5fTEVGVDtcbiAgICAgICAgbGV0IGFwcGx5TWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgIG1hcmtzID0gbWFya3MuZmlsdGVyKG0gPT4ge1xuICAgICAgICAgICAgaWYgKHRvcC50eXBlID8gdG9wLnR5cGUuYWxsb3dzTWFya1R5cGUobS50eXBlKSA6IG1hcmtNYXlBcHBseShtLnR5cGUsIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlNYXJrcyA9IG0uYWRkVG9TZXQoYXBwbHlNYXJrcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5vZGVzLnB1c2gobmV3IE5vZGVDb250ZXh0KHR5cGUsIGF0dHJzLCBhcHBseU1hcmtzLCBzb2xpZCwgbnVsbCwgb3B0aW9ucykpO1xuICAgICAgICB0aGlzLm9wZW4rKztcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYWxsIG5vZGVzIGFib3ZlIHRoaXMub3BlbiBhcmUgZmluaXNoZWQgYW5kIGFkZGVkIHRvXG4gICAgLy8gdGhlaXIgcGFyZW50c1xuICAgIGNsb3NlRXh0cmEob3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5ub2Rlcy5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoaSA+IHRoaXMub3Blbikge1xuICAgICAgICAgICAgZm9yICg7IGkgPiB0aGlzLm9wZW47IGktLSlcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2kgLSAxXS5jb250ZW50LnB1c2godGhpcy5ub2Rlc1tpXS5maW5pc2gob3BlbkVuZCkpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5sZW5ndGggPSB0aGlzLm9wZW4gKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgdGhpcy5vcGVuID0gMDtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKHRoaXMuaXNPcGVuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbMF0uZmluaXNoKCEhKHRoaXMuaXNPcGVuIHx8IHRoaXMub3B0aW9ucy50b3BPcGVuKSk7XG4gICAgfVxuICAgIHN5bmModG8pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vZGVzW2ldID09IHRvKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuID0gaTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubG9jYWxQcmVzZXJ2ZVdTKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlc1tpXS5vcHRpb25zIHw9IE9QVF9QUkVTRVJWRV9XUztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGdldCBjdXJyZW50UG9zKCkge1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEoKTtcbiAgICAgICAgbGV0IHBvcyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLm9wZW47IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgY29udGVudCA9IHRoaXMubm9kZXNbaV0uY29udGVudDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBjb250ZW50Lmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuICAgICAgICAgICAgICAgIHBvcyArPSBjb250ZW50W2pdLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGkpXG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgZmluZEF0UG9pbnQocGFyZW50LCBvZmZzZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHBhcmVudCAmJiB0aGlzLmZpbmRbaV0ub2Zmc2V0ID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluc2lkZShwYXJlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kQXJvdW5kKHBhcmVudCwgY29udGVudCwgYmVmb3JlKSB7XG4gICAgICAgIGlmIChwYXJlbnQgIT0gY29udGVudCAmJiB0aGlzLmZpbmQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmluZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbmRbaV0ucG9zID09IG51bGwgJiYgcGFyZW50Lm5vZGVUeXBlID09IDEgJiYgcGFyZW50LmNvbnRhaW5zKHRoaXMuZmluZFtpXS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gY29udGVudC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbih0aGlzLmZpbmRbaV0ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgJiAoYmVmb3JlID8gMiA6IDQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5kW2ldLnBvcyA9IHRoaXMuY3VycmVudFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRJblRleHQodGV4dE5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5ub2RlID09IHRleHROb2RlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zIC0gKHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGggLSB0aGlzLmZpbmRbaV0ub2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBnaXZlbiBjb250ZXh0IHN0cmluZyBtYXRjaGVzIHRoaXMgY29udGV4dC5cbiAgICBtYXRjaGVzQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIGlmIChjb250ZXh0LmluZGV4T2YoXCJ8XCIpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gY29udGV4dC5zcGxpdCgvXFxzKlxcfFxccyovKS5zb21lKHRoaXMubWF0Y2hlc0NvbnRleHQsIHRoaXMpO1xuICAgICAgICBsZXQgcGFydHMgPSBjb250ZXh0LnNwbGl0KFwiL1wiKTtcbiAgICAgICAgbGV0IG9wdGlvbiA9IHRoaXMub3B0aW9ucy5jb250ZXh0O1xuICAgICAgICBsZXQgdXNlUm9vdCA9ICF0aGlzLmlzT3BlbiAmJiAoIW9wdGlvbiB8fCBvcHRpb24ucGFyZW50LnR5cGUgPT0gdGhpcy5ub2Rlc1swXS50eXBlKTtcbiAgICAgICAgbGV0IG1pbkRlcHRoID0gLShvcHRpb24gPyBvcHRpb24uZGVwdGggKyAxIDogMCkgKyAodXNlUm9vdCA/IDAgOiAxKTtcbiAgICAgICAgbGV0IG1hdGNoID0gKGksIGRlcHRoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0ID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT0gcGFydHMubGVuZ3RoIC0gMSB8fCBpID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGRlcHRoID49IG1pbkRlcHRoOyBkZXB0aC0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKGkgLSAxLCBkZXB0aCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gZGVwdGggPiAwIHx8IChkZXB0aCA9PSAwICYmIHVzZVJvb3QpID8gdGhpcy5ub2Rlc1tkZXB0aF0udHlwZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvcHRpb24gJiYgZGVwdGggPj0gbWluRGVwdGggPyBvcHRpb24ubm9kZShkZXB0aCAtIG1pbkRlcHRoKS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQgfHwgKG5leHQubmFtZSAhPSBwYXJ0ICYmICFuZXh0LmlzSW5Hcm91cChwYXJ0KSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBtYXRjaChwYXJ0cy5sZW5ndGggLSAxLCB0aGlzLm9wZW4pO1xuICAgIH1cbiAgICB0ZXh0YmxvY2tGcm9tQ29udGV4dCgpIHtcbiAgICAgICAgbGV0ICRjb250ZXh0ID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGlmICgkY29udGV4dClcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkY29udGV4dC5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGVmbHQgPSAkY29udGV4dC5ub2RlKGQpLmNvbnRlbnRNYXRjaEF0KCRjb250ZXh0LmluZGV4QWZ0ZXIoZCkpLmRlZmF1bHRUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jayAmJiBkZWZsdC5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5wYXJzZXIuc2NoZW1hLm5vZGVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgdHlwZS5kZWZhdWx0QXR0cnMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgZGlyZWN0bHkgbmVzdGVkIGxpc3Qgbm9kZXMgcHJvZHVjZWQgYnkgc29tZVxuLy8gdG9vbHMgYW5kIGFsbG93ZWQgYnkgYnJvd3NlcnMgdG8gbWVhbiB0aGF0IHRoZSBuZXN0ZWQgbGlzdCBpc1xuLy8gYWN0dWFsbHkgcGFydCBvZiB0aGUgbGlzdCBpdGVtIGFib3ZlIGl0LlxuZnVuY3Rpb24gbm9ybWFsaXplTGlzdChkb20pIHtcbiAgICBmb3IgKGxldCBjaGlsZCA9IGRvbS5maXJzdENoaWxkLCBwcmV2SXRlbSA9IG51bGw7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIGxldCBuYW1lID0gY2hpbGQubm9kZVR5cGUgPT0gMSA/IGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuICAgICAgICBpZiAobmFtZSAmJiBsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiBwcmV2SXRlbSkge1xuICAgICAgICAgICAgcHJldkl0ZW0uYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgY2hpbGQgPSBwcmV2SXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lID09IFwibGlcIikge1xuICAgICAgICAgICAgcHJldkl0ZW0gPSBjaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBBcHBseSBhIENTUyBzZWxlY3Rvci5cbmZ1bmN0aW9uIG1hdGNoZXMoZG9tLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiAoZG9tLm1hdGNoZXMgfHwgZG9tLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IGRvbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLm1vek1hdGNoZXNTZWxlY3RvcikuY2FsbChkb20sIHNlbGVjdG9yKTtcbn1cbmZ1bmN0aW9uIGNvcHkob2JqKSB7XG4gICAgbGV0IGNvcHkgPSB7fTtcbiAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgY29weVtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8vIFVzZWQgd2hlbiBmaW5kaW5nIGEgbWFyayBhdCB0aGUgdG9wIGxldmVsIG9mIGEgZnJhZ21lbnQgcGFyc2UuXG4vLyBDaGVja3Mgd2hldGhlciBpdCB3b3VsZCBiZSByZWFzb25hYmxlIHRvIGFwcGx5IGEgZ2l2ZW4gbWFyayB0eXBlIHRvXG4vLyBhIGdpdmVuIG5vZGUsIGJ5IGxvb2tpbmcgYXQgdGhlIHdheSB0aGUgbWFyayBvY2N1cnMgaW4gdGhlIHNjaGVtYS5cbmZ1bmN0aW9uIG1hcmtNYXlBcHBseShtYXJrVHlwZSwgbm9kZVR5cGUpIHtcbiAgICBsZXQgbm9kZXMgPSBub2RlVHlwZS5zY2hlbWEubm9kZXM7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBub2Rlcykge1xuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZXNbbmFtZV07XG4gICAgICAgIGlmICghcGFyZW50LmFsbG93c01hcmtUeXBlKG1hcmtUeXBlKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc2VlbiA9IFtdLCBzY2FuID0gKG1hdGNoKSA9PiB7XG4gICAgICAgICAgICBzZWVuLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT0gbm9kZVR5cGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChzZWVuLmluZGV4T2YobmV4dCkgPCAwICYmIHNjYW4obmV4dCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NhbihwYXJlbnQuY29udGVudE1hdGNoKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG5BIERPTSBzZXJpYWxpemVyIGtub3dzIGhvdyB0byBjb252ZXJ0IFByb3NlTWlycm9yIG5vZGVzIGFuZFxubWFya3Mgb2YgdmFyaW91cyB0eXBlcyB0byBET00gbm9kZXMuXG4qL1xuY2xhc3MgRE9NU2VyaWFsaXplciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2VyaWFsaXplci4gYG5vZGVzYCBzaG91bGQgbWFwIG5vZGUgbmFtZXMgdG8gZnVuY3Rpb25zXG4gICAgdGhhdCB0YWtlIGEgbm9kZSBhbmQgcmV0dXJuIGEgZGVzY3JpcHRpb24gb2YgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICBET00uIGBtYXJrc2AgZG9lcyB0aGUgc2FtZSBmb3IgbWFyayBuYW1lcywgYnV0IGFsc28gZ2V0cyBhblxuICAgIGFyZ3VtZW50IHRoYXQgdGVsbHMgaXQgd2hldGhlciB0aGUgbWFyaydzIGNvbnRlbnQgaXMgYmxvY2sgb3JcbiAgICBpbmxpbmUgY29udGVudCAoZm9yIHR5cGljYWwgdXNlLCBpdCdsbCBhbHdheXMgYmUgaW5saW5lKS4gQSBtYXJrXG4gICAgc2VyaWFsaXplciBtYXkgYmUgYG51bGxgIHRvIGluZGljYXRlIHRoYXQgbWFya3Mgb2YgdGhhdCB0eXBlXG4gICAgc2hvdWxkIG5vdCBiZSBzZXJpYWxpemVkLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5vZGUgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBub2RlcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgc2VyaWFsaXphdGlvbiBmdW5jdGlvbnMuXG4gICAgKi9cbiAgICBtYXJrcykge1xuICAgICAgICB0aGlzLm5vZGVzID0gbm9kZXM7XG4gICAgICAgIHRoaXMubWFya3MgPSBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoZSBjb250ZW50IG9mIHRoaXMgZnJhZ21lbnQgdG8gYSBET00gZnJhZ21lbnQuIFdoZW5cbiAgICBub3QgaW4gdGhlIGJyb3dzZXIsIHRoZSBgZG9jdW1lbnRgIG9wdGlvbiwgY29udGFpbmluZyBhIERPTVxuICAgIGRvY3VtZW50LCBzaG91bGQgYmUgcGFzc2VkIHNvIHRoYXQgdGhlIHNlcmlhbGl6ZXIgY2FuIGNyZWF0ZVxuICAgIG5vZGVzLlxuICAgICovXG4gICAgc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQsIG9wdGlvbnMgPSB7fSwgdGFyZ2V0KSB7XG4gICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgdGFyZ2V0ID0gZG9jKG9wdGlvbnMpLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgbGV0IHRvcCA9IHRhcmdldCwgYWN0aXZlID0gW107XG4gICAgICAgIGZyYWdtZW50LmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlLmxlbmd0aCB8fCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxldCBrZWVwID0gMCwgcmVuZGVyZWQgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aCAmJiByZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gbm9kZS5tYXJrc1tyZW5kZXJlZF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5tYXJrc1tuZXh0LnR5cGUubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5leHQuZXEoYWN0aXZlW2tlZXBdWzBdKSB8fCBuZXh0LnR5cGUuc3BlYy5zcGFubmluZyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAga2VlcCsrO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoa2VlcCA8IGFjdGl2ZS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IGFjdGl2ZS5wb3AoKVsxXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmVuZGVyZWQgPCBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWRkID0gbm9kZS5tYXJrc1tyZW5kZXJlZCsrXTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hcmtET00gPSB0aGlzLnNlcmlhbGl6ZU1hcmsoYWRkLCBub2RlLmlzSW5saW5lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtET00pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGl2ZS5wdXNoKFthZGQsIHRvcF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKG1hcmtET00uZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9IG1hcmtET00uY29udGVudERPTSB8fCBtYXJrRE9NLmRvbTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcC5hcHBlbmRDaGlsZCh0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCB7IGRvbSwgY29udGVudERPTSB9ID0gcmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRoaXMubm9kZXNbbm9kZS50eXBlLm5hbWVdKG5vZGUpLCBudWxsLCBub2RlLmF0dHJzKTtcbiAgICAgICAgaWYgKGNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGlmIChub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNvbnRlbnQgaG9sZSBub3QgYWxsb3dlZCBpbiBhIGxlYWYgbm9kZSBzcGVjXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJpYWxpemVGcmFnbWVudChub2RlLmNvbnRlbnQsIG9wdGlvbnMsIGNvbnRlbnRET00pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIG5vZGUgdG8gYSBET00gbm9kZS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4geW91XG4gICAgbmVlZCB0byBzZXJpYWxpemUgYSBwYXJ0IG9mIGEgZG9jdW1lbnQsIGFzIG9wcG9zZWQgdG8gdGhlIHdob2xlXG4gICAgZG9jdW1lbnQuIFRvIHNlcmlhbGl6ZSBhIHdob2xlIGRvY3VtZW50LCB1c2VcbiAgICBbYHNlcmlhbGl6ZUZyYWdtZW50YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkRPTVNlcmlhbGl6ZXIuc2VyaWFsaXplRnJhZ21lbnQpIG9uXG4gICAgaXRzIFtjb250ZW50XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS5jb250ZW50KS5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZU5vZGUobm9kZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBkb20gPSB0aGlzLnNlcmlhbGl6ZU5vZGVJbm5lcihub2RlLCBvcHRpb25zKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IG5vZGUubWFya3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB3cmFwID0gdGhpcy5zZXJpYWxpemVNYXJrKG5vZGUubWFya3NbaV0sIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHdyYXApIHtcbiAgICAgICAgICAgICAgICAod3JhcC5jb250ZW50RE9NIHx8IHdyYXAuZG9tKS5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgICAgICAgIGRvbSA9IHdyYXAuZG9tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb207XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTWFyayhtYXJrLCBpbmxpbmUsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgdG9ET00gPSB0aGlzLm1hcmtzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgcmV0dXJuIHRvRE9NICYmIHJlbmRlclNwZWMoZG9jKG9wdGlvbnMpLCB0b0RPTShtYXJrLCBpbmxpbmUpLCBudWxsLCBtYXJrLmF0dHJzKTtcbiAgICB9XG4gICAgc3RhdGljIHJlbmRlclNwZWMoZG9jLCBzdHJ1Y3R1cmUsIHhtbE5TID0gbnVsbCwgYmxvY2tBcnJheXNJbikge1xuICAgICAgICByZXR1cm4gcmVuZGVyU3BlYyhkb2MsIHN0cnVjdHVyZSwgeG1sTlMsIGJsb2NrQXJyYXlzSW4pO1xuICAgIH1cbiAgICAvKipcbiAgICBCdWlsZCBhIHNlcmlhbGl6ZXIgdXNpbmcgdGhlIFtgdG9ET01gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMudG9ET00pXG4gICAgcHJvcGVydGllcyBpbiBhIHNjaGVtYSdzIG5vZGUgYW5kIG1hcmsgc3BlY3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tU2VyaWFsaXplciA9IG5ldyBET01TZXJpYWxpemVyKHRoaXMubm9kZXNGcm9tU2NoZW1hKHNjaGVtYSksIHRoaXMubWFya3NGcm9tU2NoZW1hKHNjaGVtYSkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG5vZGUgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgVGhpcyBjYW4gYmUgdXNlZnVsIGFzIGEgYmFzZSB0byBidWlsZCBhIGN1c3RvbSBzZXJpYWxpemVyIGZyb20uXG4gICAgKi9cbiAgICBzdGF0aWMgbm9kZXNGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gZ2F0aGVyVG9ET00oc2NoZW1hLm5vZGVzKTtcbiAgICAgICAgaWYgKCFyZXN1bHQudGV4dClcbiAgICAgICAgICAgIHJlc3VsdC50ZXh0ID0gbm9kZSA9PiBub2RlLnRleHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdhdGhlciB0aGUgc2VyaWFsaXplcnMgaW4gYSBzY2hlbWEncyBtYXJrIHNwZWNzIGludG8gYW4gb2JqZWN0LlxuICAgICovXG4gICAgc3RhdGljIG1hcmtzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIGdhdGhlclRvRE9NKHNjaGVtYS5tYXJrcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyVG9ET00ob2JqKSB7XG4gICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgIGZvciAobGV0IG5hbWUgaW4gb2JqKSB7XG4gICAgICAgIGxldCB0b0RPTSA9IG9ialtuYW1lXS5zcGVjLnRvRE9NO1xuICAgICAgICBpZiAodG9ET00pXG4gICAgICAgICAgICByZXN1bHRbbmFtZV0gPSB0b0RPTTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGRvYyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMuZG9jdW1lbnQgfHwgd2luZG93LmRvY3VtZW50O1xufVxuY29uc3Qgc3VzcGljaW91c0F0dHJpYnV0ZUNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHN1c3BpY2lvdXNBdHRyaWJ1dGVzKGF0dHJzKSB7XG4gICAgbGV0IHZhbHVlID0gc3VzcGljaW91c0F0dHJpYnV0ZUNhY2hlLmdldChhdHRycyk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHN1c3BpY2lvdXNBdHRyaWJ1dGVDYWNoZS5zZXQoYXR0cnMsIHZhbHVlID0gc3VzcGljaW91c0F0dHJpYnV0ZXNJbm5lcihhdHRycykpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHN1c3BpY2lvdXNBdHRyaWJ1dGVzSW5uZXIoYXR0cnMpIHtcbiAgICBsZXQgcmVzdWx0ID0gbnVsbDtcbiAgICBmdW5jdGlvbiBzY2FuKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVswXSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBzY2FuKHZhbHVlW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwcm9wIGluIHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICBzY2FuKHZhbHVlW3Byb3BdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzY2FuKGF0dHJzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVuZGVyU3BlYyhkb2MsIHN0cnVjdHVyZSwgeG1sTlMsIGJsb2NrQXJyYXlzSW4pIHtcbiAgICBpZiAodHlwZW9mIHN0cnVjdHVyZSA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4geyBkb206IGRvYy5jcmVhdGVUZXh0Tm9kZShzdHJ1Y3R1cmUpIH07XG4gICAgaWYgKHN0cnVjdHVyZS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4geyBkb206IHN0cnVjdHVyZSB9O1xuICAgIGlmIChzdHJ1Y3R1cmUuZG9tICYmIHN0cnVjdHVyZS5kb20ubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHN0cnVjdHVyZTtcbiAgICBsZXQgdGFnTmFtZSA9IHN0cnVjdHVyZVswXSwgc3VzcGljaW91cztcbiAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGFycmF5IHBhc3NlZCB0byByZW5kZXJTcGVjXCIpO1xuICAgIGlmIChibG9ja0FycmF5c0luICYmIChzdXNwaWNpb3VzID0gc3VzcGljaW91c0F0dHJpYnV0ZXMoYmxvY2tBcnJheXNJbikpICYmXG4gICAgICAgIHN1c3BpY2lvdXMuaW5kZXhPZihzdHJ1Y3R1cmUpID4gLTEpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVXNpbmcgYW4gYXJyYXkgZnJvbSBhbiBhdHRyaWJ1dGUgb2JqZWN0IGFzIGEgRE9NIHNwZWMuIFRoaXMgbWF5IGJlIGFuIGF0dGVtcHRlZCBjcm9zcyBzaXRlIHNjcmlwdGluZyBhdHRhY2suXCIpO1xuICAgIGxldCBzcGFjZSA9IHRhZ05hbWUuaW5kZXhPZihcIiBcIik7XG4gICAgaWYgKHNwYWNlID4gMCkge1xuICAgICAgICB4bWxOUyA9IHRhZ05hbWUuc2xpY2UoMCwgc3BhY2UpO1xuICAgICAgICB0YWdOYW1lID0gdGFnTmFtZS5zbGljZShzcGFjZSArIDEpO1xuICAgIH1cbiAgICBsZXQgY29udGVudERPTTtcbiAgICBsZXQgZG9tID0gKHhtbE5TID8gZG9jLmNyZWF0ZUVsZW1lbnROUyh4bWxOUywgdGFnTmFtZSkgOiBkb2MuY3JlYXRlRWxlbWVudCh0YWdOYW1lKSk7XG4gICAgbGV0IGF0dHJzID0gc3RydWN0dXJlWzFdLCBzdGFydCA9IDE7XG4gICAgaWYgKGF0dHJzICYmIHR5cGVvZiBhdHRycyA9PSBcIm9iamVjdFwiICYmIGF0dHJzLm5vZGVUeXBlID09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICAgIHN0YXJ0ID0gMjtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycylcbiAgICAgICAgICAgIGlmIChhdHRyc1tuYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNwYWNlID0gbmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3BhY2UgPiAwKVxuICAgICAgICAgICAgICAgICAgICBkb20uc2V0QXR0cmlidXRlTlMobmFtZS5zbGljZSgwLCBzcGFjZSksIG5hbWUuc2xpY2Uoc3BhY2UgKyAxKSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJzdHlsZVwiICYmIGRvbS5zdHlsZSlcbiAgICAgICAgICAgICAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBzdHJ1Y3R1cmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gc3RydWN0dXJlW2ldO1xuICAgICAgICBpZiAoY2hpbGQgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChpIDwgc3RydWN0dXJlLmxlbmd0aCAtIDEgfHwgaSA+IHN0YXJ0KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG11c3QgYmUgdGhlIG9ubHkgY2hpbGQgb2YgaXRzIHBhcmVudCBub2RlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tLCBjb250ZW50RE9NOiBkb20gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCB7IGRvbTogaW5uZXIsIGNvbnRlbnRET006IGlubmVyQ29udGVudCB9ID0gcmVuZGVyU3BlYyhkb2MsIGNoaWxkLCB4bWxOUywgYmxvY2tBcnJheXNJbik7XG4gICAgICAgICAgICBkb20uYXBwZW5kQ2hpbGQoaW5uZXIpO1xuICAgICAgICAgICAgaWYgKGlubmVyQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk11bHRpcGxlIGNvbnRlbnQgaG9sZXNcIik7XG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGlubmVyQ29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET00gfTtcbn1cblxuZXhwb3J0IHsgQ29udGVudE1hdGNoLCBET01QYXJzZXIsIERPTVNlcmlhbGl6ZXIsIEZyYWdtZW50LCBNYXJrLCBNYXJrVHlwZSwgTm9kZSwgTm9kZVJhbmdlLCBOb2RlVHlwZSwgUmVwbGFjZUVycm9yLCBSZXNvbHZlZFBvcywgU2NoZW1hLCBTbGljZSB9O1xuIl0sIm5hbWVzIjpbIk9yZGVyZWRNYXAiLCJmaW5kRGlmZlN0YXJ0IiwiYSIsImIiLCJwb3MiLCJpIiwiY2hpbGRDb3VudCIsImNoaWxkQSIsImNoaWxkIiwiY2hpbGRCIiwibm9kZVNpemUiLCJzYW1lTWFya3VwIiwiaXNUZXh0IiwidGV4dCIsImoiLCJjb250ZW50Iiwic2l6ZSIsImlubmVyIiwiZmluZERpZmZFbmQiLCJwb3NBIiwicG9zQiIsImlBIiwiaUIiLCJzYW1lIiwibWluU2l6ZSIsIk1hdGgiLCJtaW4iLCJsZW5ndGgiLCJGcmFnbWVudCIsImNvbnN0cnVjdG9yIiwibm9kZXNCZXR3ZWVuIiwiZnJvbSIsInRvIiwiZiIsIm5vZGVTdGFydCIsInBhcmVudCIsImVuZCIsInN0YXJ0IiwibWF4IiwiZGVzY2VuZGFudHMiLCJ0ZXh0QmV0d2VlbiIsImJsb2NrU2VwYXJhdG9yIiwibGVhZlRleHQiLCJmaXJzdCIsIm5vZGUiLCJub2RlVGV4dCIsInNsaWNlIiwiaXNMZWFmIiwidHlwZSIsInNwZWMiLCJpc0Jsb2NrIiwiaXNUZXh0YmxvY2siLCJhcHBlbmQiLCJvdGhlciIsImxhc3QiLCJsYXN0Q2hpbGQiLCJmaXJzdENoaWxkIiwid2l0aFRleHQiLCJwdXNoIiwiY3V0IiwicmVzdWx0IiwiY3V0QnlJbmRleCIsImVtcHR5IiwicmVwbGFjZUNoaWxkIiwiaW5kZXgiLCJjdXJyZW50IiwiY29weSIsImFkZFRvU3RhcnQiLCJjb25jYXQiLCJhZGRUb0VuZCIsImVxIiwiZm91bmQiLCJSYW5nZUVycm9yIiwibWF5YmVDaGlsZCIsImZvckVhY2giLCJwIiwib3RoZXJQb3MiLCJmaW5kSW5kZXgiLCJyZXRJbmRleCIsImN1clBvcyIsImN1ciIsInRvU3RyaW5nIiwidG9TdHJpbmdJbm5lciIsImpvaW4iLCJ0b0pTT04iLCJtYXAiLCJuIiwiZnJvbUpTT04iLCJzY2hlbWEiLCJ2YWx1ZSIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVGcm9tSlNPTiIsImZyb21BcnJheSIsImFycmF5Iiwiam9pbmVkIiwibm9kZXMiLCJhdHRycyIsIm9mZnNldCIsImNvbXBhcmVEZWVwIiwiTWFyayIsImFkZFRvU2V0Iiwic2V0IiwicGxhY2VkIiwiZXhjbHVkZXMiLCJyYW5rIiwicmVtb3ZlRnJvbVNldCIsImlzSW5TZXQiLCJvYmoiLCJuYW1lIiwiXyIsImpzb24iLCJtYXJrcyIsIm1hcmsiLCJjcmVhdGUiLCJjaGVja0F0dHJzIiwic2FtZVNldCIsInNldEZyb20iLCJub25lIiwic29ydCIsIlJlcGxhY2VFcnJvciIsIkVycm9yIiwiU2xpY2UiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwiaW5zZXJ0QXQiLCJmcmFnbWVudCIsImluc2VydEludG8iLCJyZW1vdmVCZXR3ZWVuIiwicmVtb3ZlUmFuZ2UiLCJtYXhPcGVuIiwib3Blbklzb2xhdGluZyIsImlzb2xhdGluZyIsImluZGV4VG8iLCJvZmZzZXRUbyIsImRpc3QiLCJpbnNlcnQiLCJjYW5SZXBsYWNlIiwicmVwbGFjZSIsIiRmcm9tIiwiJHRvIiwiZGVwdGgiLCJyZXBsYWNlT3V0ZXIiLCJjbG9zZSIsInJlcGxhY2VUd29XYXkiLCJwYXJlbnRPZmZzZXQiLCJwcmVwYXJlU2xpY2VGb3JSZXBsYWNlIiwicmVwbGFjZVRocmVlV2F5IiwiY2hlY2tKb2luIiwibWFpbiIsInN1YiIsImNvbXBhdGlibGVDb250ZW50Iiwiam9pbmFibGUiLCIkYmVmb3JlIiwiJGFmdGVyIiwiYWRkTm9kZSIsInRhcmdldCIsImFkZFJhbmdlIiwiJHN0YXJ0IiwiJGVuZCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInRleHRPZmZzZXQiLCJub2RlQWZ0ZXIiLCJub2RlQmVmb3JlIiwiY2hlY2tDb250ZW50IiwiJGFsb25nIiwiZXh0cmEiLCJyZXNvbHZlTm9DYWNoZSIsIlJlc29sdmVkUG9zIiwicGF0aCIsInJlc29sdmVEZXB0aCIsInZhbCIsImRvYyIsImluZGV4QWZ0ZXIiLCJiZWZvcmUiLCJhZnRlciIsImRPZmYiLCJwb3NBdEluZGV4IiwidG1wIiwiaW5jbHVzaXZlIiwibWFya3NBY3Jvc3MiLCJpc0lubGluZSIsIm5leHQiLCJzaGFyZWREZXB0aCIsImJsb2NrUmFuZ2UiLCJwcmVkIiwiZCIsImlubGluZUNvbnRlbnQiLCJOb2RlUmFuZ2UiLCJzYW1lUGFyZW50Iiwic3RyIiwicmVzb2x2ZSIsInJlbSIsInJlc29sdmVDYWNoZWQiLCJjYWNoZSIsInJlc29sdmVDYWNoZSIsImdldCIsImVsdHMiLCJlbHQiLCJSZXNvbHZlQ2FjaGUiLCJyZXNvbHZlQ2FjaGVTaXplIiwiV2Vha01hcCIsImVtcHR5QXR0cnMiLCJPYmplY3QiLCJOb2RlIiwiY2hpbGRyZW4iLCJzdGFydFBvcyIsInRleHRDb250ZW50IiwiaGFzTWFya3VwIiwiZGVmYXVsdEF0dHJzIiwiaW5jbHVkZVBhcmVudHMiLCJub2RlQXQiLCJjaGlsZEFmdGVyIiwiY2hpbGRCZWZvcmUiLCJyYW5nZUhhc01hcmsiLCJpc0F0b20iLCJ0b0RlYnVnU3RyaW5nIiwid3JhcE1hcmtzIiwiY29udGVudE1hdGNoQXQiLCJtYXRjaCIsImNvbnRlbnRNYXRjaCIsIm1hdGNoRnJhZ21lbnQiLCJyZXBsYWNlbWVudCIsIm9uZSIsInR3byIsInZhbGlkRW5kIiwiYWxsb3dzTWFya3MiLCJjYW5SZXBsYWNlV2l0aCIsIm1hdGNoVHlwZSIsImNhbkFwcGVuZCIsImNoZWNrIiwibSIsInVuZGVmaW5lZCIsIm1hcmtGcm9tSlNPTiIsIm5vZGVUeXBlIiwicHJvdG90eXBlIiwiVGV4dE5vZGUiLCJKU09OIiwic3RyaW5naWZ5IiwiYmFzZSIsIkNvbnRlbnRNYXRjaCIsIndyYXBDYWNoZSIsInBhcnNlIiwic3RyaW5nIiwibm9kZVR5cGVzIiwic3RyZWFtIiwiVG9rZW5TdHJlYW0iLCJleHByIiwicGFyc2VFeHByIiwiZXJyIiwiZGZhIiwibmZhIiwiY2hlY2tGb3JEZWFkRW5kcyIsImZyYWciLCJkZWZhdWx0VHlwZSIsImhhc1JlcXVpcmVkQXR0cnMiLCJjb21wYXRpYmxlIiwiZmlsbEJlZm9yZSIsInRvRW5kIiwic2VlbiIsInNlYXJjaCIsInR5cGVzIiwiZmluaXNoZWQiLCJ0cCIsImNyZWF0ZUFuZEZpbGwiLCJpbmRleE9mIiwiZmluZFdyYXBwaW5nIiwiY29tcHV0ZWQiLCJjb21wdXRlV3JhcHBpbmciLCJhY3RpdmUiLCJ2aWEiLCJzaGlmdCIsInJldmVyc2UiLCJlZGdlQ291bnQiLCJlZGdlIiwic2NhbiIsIm91dCIsImlubGluZSIsInRva2VucyIsInNwbGl0IiwicG9wIiwiZWF0IiwidG9rIiwiU3ludGF4RXJyb3IiLCJleHBycyIsInBhcnNlRXhwclNlcSIsInBhcnNlRXhwclN1YnNjcmlwdCIsInBhcnNlRXhwckF0b20iLCJwYXJzZUV4cHJSYW5nZSIsInBhcnNlTnVtIiwidGVzdCIsIk51bWJlciIsInJlc29sdmVOYW1lIiwidHlwZU5hbWUiLCJpc0luR3JvdXAiLCJjb25uZWN0IiwiY29tcGlsZSIsInRlcm0iLCJlZGdlcyIsInJlZHVjZSIsImxvb3AiLCJjbXAiLCJudWxsRnJvbSIsImxhYmVsZWQiLCJleHBsb3JlIiwic3RhdGVzIiwic3RhdGUiLCJ3b3JrIiwiZGVhZCIsImRlZmF1bHRzIiwiYXR0ck5hbWUiLCJhdHRyIiwiaGFzRGVmYXVsdCIsImRlZmF1bHQiLCJjb21wdXRlQXR0cnMiLCJidWlsdCIsImdpdmVuIiwidmFsdWVzIiwidmFsaWRhdGUiLCJpbml0QXR0cnMiLCJBdHRyaWJ1dGUiLCJOb2RlVHlwZSIsIm1hcmtTZXQiLCJncm91cHMiLCJncm91cCIsImF0b20iLCJ3aGl0ZXNwYWNlIiwiY29kZSIsImlzUmVxdWlyZWQiLCJjcmVhdGVDaGVja2VkIiwibWF0Y2hlZCIsInZhbGlkQ29udGVudCIsImFsbG93c01hcmtUeXBlIiwibWFya1R5cGUiLCJhbGxvd2VkTWFya3MiLCJ0b3BUeXBlIiwidG9wTm9kZSIsInZhbGlkYXRlVHlwZSIsIm9wdGlvbnMiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJNYXJrVHlwZSIsImV4Y2x1ZGVkIiwiaW5zdGFuY2UiLCJTY2hlbWEiLCJsaW5lYnJlYWtSZXBsYWNlbWVudCIsImNhY2hlZCIsImluc3RhbmNlU3BlYyIsInByb3AiLCJjb250ZW50RXhwckNhY2hlIiwiY29udGVudEV4cHIiLCJtYXJrRXhwciIsImdhdGhlck1hcmtzIiwiZXhjbCIsInRvcE5vZGVUeXBlIiwid3JhcHBpbmdzIiwib2siLCJpc1RhZ1J1bGUiLCJydWxlIiwidGFnIiwiaXNTdHlsZVJ1bGUiLCJzdHlsZSIsIkRPTVBhcnNlciIsInJ1bGVzIiwidGFncyIsInN0eWxlcyIsIm1hdGNoZWRTdHlsZXMiLCJleGVjIiwibm9ybWFsaXplTGlzdHMiLCJzb21lIiwiciIsImRvbSIsImNvbnRleHQiLCJQYXJzZUNvbnRleHQiLCJhZGRBbGwiLCJmaW5pc2giLCJwYXJzZVNsaWNlIiwibWF0Y2hUYWciLCJtYXRjaGVzIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlVVJJIiwibWF0Y2hlc0NvbnRleHQiLCJnZXRBdHRycyIsIm1hdGNoU3R5bGUiLCJjaGFyQ29kZUF0Iiwic2NoZW1hUnVsZXMiLCJwcmlvcml0eSIsIm5leHRQcmlvcml0eSIsInNwbGljZSIsInBhcnNlRE9NIiwiaWdub3JlIiwiY2xlYXJNYXJrIiwiZnJvbVNjaGVtYSIsImRvbVBhcnNlciIsImJsb2NrVGFncyIsImFkZHJlc3MiLCJhcnRpY2xlIiwiYXNpZGUiLCJibG9ja3F1b3RlIiwiY2FudmFzIiwiZGQiLCJkaXYiLCJkbCIsImZpZWxkc2V0IiwiZmlnY2FwdGlvbiIsImZpZ3VyZSIsImZvb3RlciIsImZvcm0iLCJoMSIsImgyIiwiaDMiLCJoNCIsImg1IiwiaDYiLCJoZWFkZXIiLCJoZ3JvdXAiLCJociIsImxpIiwibm9zY3JpcHQiLCJvbCIsIm91dHB1dCIsInByZSIsInNlY3Rpb24iLCJ0YWJsZSIsInRmb290IiwidWwiLCJpZ25vcmVUYWdzIiwiaGVhZCIsIm9iamVjdCIsInNjcmlwdCIsInRpdGxlIiwibGlzdFRhZ3MiLCJPUFRfUFJFU0VSVkVfV1MiLCJPUFRfUFJFU0VSVkVfV1NfRlVMTCIsIk9QVF9PUEVOX0xFRlQiLCJ3c09wdGlvbnNGb3IiLCJwcmVzZXJ2ZVdoaXRlc3BhY2UiLCJOb2RlQ29udGV4dCIsInNvbGlkIiwiYWN0aXZlTWFya3MiLCJmaWxsIiwid3JhcCIsImlubGluZUNvbnRleHQiLCJwYXJlbnROb2RlIiwibm9kZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlciIsImlzT3BlbiIsIm9wZW4iLCJsb2NhbFByZXNlcnZlV1MiLCJ0b3BDb250ZXh0IiwidG9wT3B0aW9ucyIsInRvcE1hdGNoIiwiZmluZCIsImZpbmRQb3NpdGlvbnMiLCJuZWVkc0Jsb2NrIiwidG9wIiwiYWRkRE9NIiwiYWRkVGV4dE5vZGUiLCJhZGRFbGVtZW50Iiwibm9kZVZhbHVlIiwicHJlc2VydmVXUyIsImRvbU5vZGVCZWZvcmUiLCJwcmV2aW91c1NpYmxpbmciLCJsaW5lcyIsImluc2VydE5vZGUiLCJmaW5kSW5UZXh0IiwiZmluZEluc2lkZSIsIm1hdGNoQWZ0ZXIiLCJvdXRlcldTIiwidGFnTmFtZSIsIndoaXRlU3BhY2UiLCJydWxlSUQiLCJub3JtYWxpemVMaXN0IiwicnVsZUZyb21Ob2RlIiwiaWdub3JlRmFsbGJhY2siLCJza2lwIiwiY2xvc2VQYXJlbnQiLCJzeW5jIiwib2xkTmVlZHNCbG9jayIsImxlYWZGYWxsYmFjayIsImlubmVyTWFya3MiLCJyZWFkU3R5bGVzIiwiYWRkRWxlbWVudEJ5UnVsZSIsImNvbnN1bWluZyIsIm93bmVyRG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImZpbmRQbGFjZSIsImdldFByb3BlcnR5VmFsdWUiLCJmaWx0ZXIiLCJjb250aW51ZUFmdGVyIiwiZW50ZXIiLCJzdGFydEluIiwiZ2V0Q29udGVudCIsImNvbnRlbnRET00iLCJjb250ZW50RWxlbWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJmaW5kQXJvdW5kIiwiY2hpbGROb2RlcyIsIm5leHRTaWJsaW5nIiwiZmluZEF0UG9pbnQiLCJjYXV0aW91cyIsInJvdXRlIiwicGVuYWx0eSIsImN4IiwiZW50ZXJJbm5lciIsImJsb2NrIiwidGV4dGJsb2NrRnJvbUNvbnRleHQiLCJjbG9zZUV4dHJhIiwibm9kZU1hcmtzIiwibWFya01heUFwcGx5IiwiYXBwbHlNYXJrcyIsInRvcE9wZW4iLCJjdXJyZW50UG9zIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsInRleHROb2RlIiwicGFydHMiLCJvcHRpb24iLCJ1c2VSb290IiwibWluRGVwdGgiLCJwYXJ0IiwiJGNvbnRleHQiLCJkZWZsdCIsInByZXZJdGVtIiwiYXBwZW5kQ2hpbGQiLCJzZWxlY3RvciIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwiRE9NU2VyaWFsaXplciIsInNlcmlhbGl6ZUZyYWdtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImtlZXAiLCJyZW5kZXJlZCIsInNwYW5uaW5nIiwiYWRkIiwibWFya0RPTSIsInNlcmlhbGl6ZU1hcmsiLCJzZXJpYWxpemVOb2RlSW5uZXIiLCJyZW5kZXJTcGVjIiwic2VyaWFsaXplTm9kZSIsInRvRE9NIiwic3RydWN0dXJlIiwieG1sTlMiLCJibG9ja0FycmF5c0luIiwiZG9tU2VyaWFsaXplciIsIm5vZGVzRnJvbVNjaGVtYSIsIm1hcmtzRnJvbVNjaGVtYSIsImdhdGhlclRvRE9NIiwiZG9jdW1lbnQiLCJ3aW5kb3ciLCJzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUiLCJzdXNwaWNpb3VzQXR0cmlidXRlcyIsInN1c3BpY2lvdXNBdHRyaWJ1dGVzSW5uZXIiLCJzdXNwaWNpb3VzIiwic3BhY2UiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlTlMiLCJjc3NUZXh0Iiwic2V0QXR0cmlidXRlIiwiaW5uZXJDb250ZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-model/dist/index.js\n");

/***/ })

};
;
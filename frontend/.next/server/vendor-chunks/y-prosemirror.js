"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/y-prosemirror";
exports.ids = ["vendor-chunks/y-prosemirror"];
exports.modules = {

/***/ "(ssr)/./node_modules/y-prosemirror/src/lib.js":
/*!***********************************************!*\
  !*** ./node_modules/y-prosemirror/src/lib.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   absolutePositionToRelativePosition: () => (/* binding */ absolutePositionToRelativePosition),\n/* harmony export */   initProseMirrorDoc: () => (/* binding */ initProseMirrorDoc),\n/* harmony export */   prosemirrorJSONToYDoc: () => (/* binding */ prosemirrorJSONToYDoc),\n/* harmony export */   prosemirrorJSONToYXmlFragment: () => (/* binding */ prosemirrorJSONToYXmlFragment),\n/* harmony export */   prosemirrorToYDoc: () => (/* binding */ prosemirrorToYDoc),\n/* harmony export */   prosemirrorToYXmlFragment: () => (/* binding */ prosemirrorToYXmlFragment),\n/* harmony export */   relativePositionToAbsolutePosition: () => (/* binding */ relativePositionToAbsolutePosition),\n/* harmony export */   setMeta: () => (/* binding */ setMeta),\n/* harmony export */   yDocToProsemirror: () => (/* binding */ yDocToProsemirror),\n/* harmony export */   yDocToProsemirrorJSON: () => (/* binding */ yDocToProsemirrorJSON),\n/* harmony export */   yXmlFragmentToProseMirrorFragment: () => (/* binding */ yXmlFragmentToProseMirrorFragment),\n/* harmony export */   yXmlFragmentToProseMirrorRootNode: () => (/* binding */ yXmlFragmentToProseMirrorRootNode),\n/* harmony export */   yXmlFragmentToProsemirror: () => (/* binding */ yXmlFragmentToProsemirror),\n/* harmony export */   yXmlFragmentToProsemirrorJSON: () => (/* binding */ yXmlFragmentToProsemirrorJSON)\n/* harmony export */ });\n/* harmony import */ var _plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./plugins/sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./plugins/keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n // eslint-disable-line\n\n\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType, Node | Array<Node>>} ProsemirrorMapping\n */ /**\n * Is null if no timeout is in progress.\n * Is defined if a timeout is in progress.\n * Maps from view\n * @type {Map<EditorView, Map<any, any>>|null}\n */ let viewsToUpdate = null;\nconst updateMetas = ()=>{\n    const ups = /** @type {Map<EditorView, Map<any, any>>} */ viewsToUpdate;\n    viewsToUpdate = null;\n    ups.forEach((metas, view)=>{\n        const tr = view.state.tr;\n        const syncState = _plugins_keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state);\n        if (syncState && syncState.binding && !syncState.binding.isDestroyed) {\n            metas.forEach((val, key)=>{\n                tr.setMeta(key, val);\n            });\n            view.dispatch(tr);\n        }\n    });\n};\nconst setMeta = (view, key, value)=>{\n    if (!viewsToUpdate) {\n        viewsToUpdate = new Map();\n        lib0_eventloop__WEBPACK_IMPORTED_MODULE_1__.timeout(0, updateMetas);\n    }\n    lib0_map__WEBPACK_IMPORTED_MODULE_2__.setIfUndefined(viewsToUpdate, view, lib0_map__WEBPACK_IMPORTED_MODULE_2__.create).set(key, value);\n};\n/**\n * Transforms a Prosemirror based absolute position to a Yjs Cursor (relative position in the Yjs model).\n *\n * @param {number} pos\n * @param {Y.XmlFragment} type\n * @param {ProsemirrorMapping} mapping\n * @return {any} relative position\n */ const absolutePositionToRelativePosition = (pos, type, mapping)=>{\n    if (pos === 0) {\n        // if the type is later populated, we want to retain the 0 position (hence assoc=-1)\n        return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, 0, type.length === 0 ? -1 : 0);\n    }\n    /**\n   * @type {any}\n   */ let n = type._first === null ? null : /** @type {Y.ContentType} */ type._first.content.type;\n    while(n !== null && type !== n){\n        if (n instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n            if (n._length >= pos) {\n                return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(n, pos, type.length === 0 ? -1 : 0);\n            } else {\n                pos -= n._length;\n            }\n            if (n._item !== null && n._item.next !== null) {\n                n = /** @type {Y.ContentType} */ n._item.next.content.type;\n            } else {\n                do {\n                    n = n._item === null ? null : n._item.parent;\n                    pos--;\n                }while (n !== type && n !== null && n._item !== null && n._item.next === null);\n                if (n !== null && n !== type) {\n                    // @ts-gnore we know that n.next !== null because of above loop conditition\n                    n = n._item === null ? null : /** @type {Y.ContentType} */ /** @type Y.Item */ n._item.next.content.type;\n                }\n            }\n        } else {\n            const pNodeSize = /** @type {any} */ (mapping.get(n) || {\n                nodeSize: 0\n            }).nodeSize;\n            if (n._first !== null && pos < pNodeSize) {\n                n = /** @type {Y.ContentType} */ n._first.content.type;\n                pos--;\n            } else {\n                if (pos === 1 && n._length === 0 && pNodeSize > 1) {\n                    // edge case, should end in this paragraph\n                    return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null);\n                }\n                pos -= pNodeSize;\n                if (n._item !== null && n._item.next !== null) {\n                    n = /** @type {Y.ContentType} */ n._item.next.content.type;\n                } else {\n                    if (pos === 0) {\n                        // set to end of n.parent\n                        n = n._item === null ? n : n._item.parent;\n                        return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(n._item === null ? null : n._item.id, n._item === null ? yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(n) : null, null);\n                    }\n                    do {\n                        n = /** @type {Y.Item} */ n._item.parent;\n                        pos--;\n                    }while (n !== type && /** @type {Y.Item} */ n._item.next === null);\n                    // if n is null at this point, we have an unexpected case\n                    if (n !== type) {\n                        // We know that n._item.next is defined because of above loop condition\n                        n = /** @type {Y.ContentType} */ /** @type {Y.Item} */ /** @type {Y.Item} */ n._item.next.content.type;\n                    }\n                }\n            }\n        }\n        if (n === null) {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase();\n        }\n        if (pos === 0 && n.constructor !== yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText && n !== type) {\n            return createRelativePosition(n._item.parent, n._item);\n        }\n    }\n    return yjs__WEBPACK_IMPORTED_MODULE_3__.createRelativePositionFromTypeIndex(type, type._length, type.length === 0 ? -1 : 0);\n};\nconst createRelativePosition = (type, item)=>{\n    let typeid = null;\n    let tname = null;\n    if (type._item === null) {\n        tname = yjs__WEBPACK_IMPORTED_MODULE_3__.findRootTypeKey(type);\n    } else {\n        typeid = yjs__WEBPACK_IMPORTED_MODULE_3__.createID(type._item.id.client, type._item.id.clock);\n    }\n    return new yjs__WEBPACK_IMPORTED_MODULE_3__.RelativePosition(typeid, tname, item.id);\n};\n/**\n * @param {Y.Doc} y\n * @param {Y.XmlFragment} documentType Top level type that is bound to pView\n * @param {any} relPos Encoded Yjs based relative position\n * @param {ProsemirrorMapping} mapping\n * @return {null|number}\n */ const relativePositionToAbsolutePosition = (y, documentType, relPos, mapping)=>{\n    const decodedPos = yjs__WEBPACK_IMPORTED_MODULE_3__.createAbsolutePositionFromRelativePosition(relPos, y);\n    if (decodedPos === null || decodedPos.type !== documentType && !yjs__WEBPACK_IMPORTED_MODULE_3__.isParentOf(documentType, decodedPos.type._item)) {\n        return null;\n    }\n    let type = decodedPos.type;\n    let pos = 0;\n    if (type.constructor === yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n        pos = decodedPos.index;\n    } else if (type._item === null || !type._item.deleted) {\n        let n = type._first;\n        let i = 0;\n        while(i < type._length && i < decodedPos.index && n !== null){\n            if (!n.deleted) {\n                const t = /** @type {Y.ContentType} */ n.content.type;\n                i++;\n                if (t instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n                    pos += t._length;\n                } else {\n                    pos += /** @type {any} */ mapping.get(t).nodeSize;\n                }\n            }\n            n = /** @type {Y.Item} */ n.right;\n        }\n        pos += 1 // increase because we go out of n\n        ;\n    }\n    while(type !== documentType && type._item !== null){\n        // @ts-ignore\n        const parent = type._item.parent;\n        // @ts-ignore\n        if (parent._item === null || !parent._item.deleted) {\n            pos += 1 // the start tag\n            ;\n            let n = /** @type {Y.AbstractType} */ parent._first;\n            // now iterate until we found type\n            while(n !== null){\n                const contentType = /** @type {Y.ContentType} */ n.content.type;\n                if (contentType === type) {\n                    break;\n                }\n                if (!n.deleted) {\n                    if (contentType instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n                        pos += contentType._length;\n                    } else {\n                        pos += /** @type {any} */ mapping.get(contentType).nodeSize;\n                    }\n                }\n                n = n.right;\n            }\n        }\n        type = /** @type {Y.AbstractType} */ parent;\n    }\n    return pos - 1 // we don't count the most outer tag, because it is a fragment\n    ;\n};\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror fragment.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */ const yXmlFragmentToProseMirrorFragment = (yXmlFragment, schema)=>{\n    const fragmentContent = yXmlFragment.toArray().map((t)=>(0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(/** @type {Y.XmlElement} */ t, schema, (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createEmptyMeta)())).filter((n)=>n !== null);\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent);\n};\n/**\n * Utility function for converting an Y.Fragment to a ProseMirror node.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n */ const yXmlFragmentToProseMirrorRootNode = (yXmlFragment, schema)=>schema.topNodeType.create(null, yXmlFragmentToProseMirrorFragment(yXmlFragment, schema));\n/**\n * The initial ProseMirror content should be supplied by Yjs. This function transforms a Y.Fragment\n * to a ProseMirror Doc node and creates a mapping that is used by the sync plugin.\n *\n * @param {Y.XmlFragment} yXmlFragment\n * @param {Schema} schema\n *\n * @todo deprecate mapping property\n */ const initProseMirrorDoc = (yXmlFragment, schema)=>{\n    const meta = (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createEmptyMeta)();\n    const fragmentContent = yXmlFragment.toArray().map((t)=>(0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.createNodeFromYElement)(/** @type {Y.XmlElement} */ t, schema, meta)).filter((n)=>n !== null);\n    const doc = schema.topNodeType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Fragment.fromArray(fragmentContent));\n    return {\n        doc,\n        meta,\n        mapping: meta.mapping\n    };\n};\n/**\n * Utility method to convert a Prosemirror Doc Node into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Node} doc\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */ function prosemirrorToYDoc(doc, xmlFragment = \"prosemirror\") {\n    const ydoc = new yjs__WEBPACK_IMPORTED_MODULE_3__.Doc();\n    const type = /** @type {Y.XmlFragment} */ ydoc.get(xmlFragment, yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment);\n    if (!type.doc) {\n        return ydoc;\n    }\n    prosemirrorToYXmlFragment(doc, type);\n    return type.doc;\n}\n/**\n * Utility method to update an empty Y.XmlFragment with content from a Prosemirror Doc Node.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * Note: The Y.XmlFragment does not need to be part of a Y.Doc document at the time that this\n * method is called, but it must be added before any other operations are performed on it.\n *\n * @param {Node} doc prosemirror document.\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */ function prosemirrorToYXmlFragment(doc, xmlFragment) {\n    const type = xmlFragment || new yjs__WEBPACK_IMPORTED_MODULE_3__.XmlFragment();\n    const ydoc = type.doc ? type.doc : {\n        transact: (transaction)=>transaction(undefined)\n    };\n    (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.updateYFragment)(ydoc, type, doc, {\n        mapping: new Map(),\n        isOMark: new Map()\n    });\n    return type;\n}\n/**\n * Utility method to convert Prosemirror compatible JSON into a Y.Doc.\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {string} xmlFragment\n * @return {Y.Doc}\n */ function prosemirrorJSONToYDoc(schema, state, xmlFragment = \"prosemirror\") {\n    const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n    return prosemirrorToYDoc(doc, xmlFragment);\n}\n/**\n * Utility method to convert Prosemirror compatible JSON to a Y.XmlFragment\n *\n * This can be used when importing existing content to Y.Doc for the first time,\n * note that this should not be used to rehydrate a Y.Doc from a database once\n * collaboration has begun as all history will be lost\n *\n * @param {Schema} schema\n * @param {any} state\n * @param {Y.XmlFragment} [xmlFragment] If supplied, an xml fragment to be\n *   populated from the prosemirror state; otherwise a new XmlFragment will be created.\n * @return {Y.XmlFragment}\n */ function prosemirrorJSONToYXmlFragment(schema, state, xmlFragment) {\n    const doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n    return prosemirrorToYXmlFragment(doc, xmlFragment);\n}\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.Doc} ydoc\n * @return {Node}\n */ function yDocToProsemirror(schema, ydoc) {\n    const state = yDocToProsemirrorJSON(ydoc);\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n}\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.XmlFragment to a Prosemirror Doc node.\n *\n * @param {Schema} schema\n * @param {Y.XmlFragment} xmlFragment\n * @return {Node}\n */ function yXmlFragmentToProsemirror(schema, xmlFragment) {\n    const state = yXmlFragmentToProsemirrorJSON(xmlFragment);\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_6__.Node.fromJSON(schema, state);\n}\n/**\n *\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.Doc} ydoc\n * @param {string} xmlFragment\n * @return {Record<string, any>}\n */ function yDocToProsemirrorJSON(ydoc, xmlFragment = \"prosemirror\") {\n    return yXmlFragmentToProsemirrorJSON(ydoc.getXmlFragment(xmlFragment));\n}\n/**\n * @deprecated Use `yXmlFragmentToProseMirrorRootNode` instead\n *\n * Utility method to convert a Y.Doc to Prosemirror compatible JSON.\n *\n * @param {Y.XmlFragment} xmlFragment The fragment, which must be part of a Y.Doc.\n * @return {Record<string, any>}\n */ function yXmlFragmentToProsemirrorJSON(xmlFragment) {\n    const items = xmlFragment.toArray();\n    /**\n   * @param {Y.AbstractType} item\n   */ const serialize = (item)=>{\n        /**\n     * @type {Object} NodeObject\n     * @property {string} NodeObject.type\n     * @property {Record<string, string>=} NodeObject.attrs\n     * @property {Array<NodeObject>=} NodeObject.content\n     */ let response;\n        // TODO: Must be a better way to detect text nodes than this\n        if (item instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlText) {\n            const delta = item.toDelta();\n            response = delta.map(/** @param {any} d */ (d)=>{\n                const text = {\n                    type: \"text\",\n                    text: d.insert\n                };\n                if (d.attributes) {\n                    text.marks = Object.keys(d.attributes).map((type_)=>{\n                        const attrs = d.attributes[type_];\n                        const type = (0,_plugins_sync_plugin_js__WEBPACK_IMPORTED_MODULE_5__.yattr2markname)(type_);\n                        const mark = {\n                            type\n                        };\n                        if (Object.keys(attrs)) {\n                            mark.attrs = attrs;\n                        }\n                        return mark;\n                    });\n                }\n                return text;\n            });\n        } else if (item instanceof yjs__WEBPACK_IMPORTED_MODULE_3__.XmlElement) {\n            response = {\n                type: item.nodeName\n            };\n            const attrs = item.getAttributes();\n            if (Object.keys(attrs).length) {\n                response.attrs = attrs;\n            }\n            const children = item.toArray();\n            if (children.length) {\n                response.content = children.map(serialize).flat();\n            }\n        } else {\n            // expected either Y.XmlElement or Y.XmlText\n            lib0_error__WEBPACK_IMPORTED_MODULE_4__.unexpectedCase();\n        }\n        return response;\n    };\n    return {\n        type: \"doc\",\n        content: items.map(serialize)\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvbGliLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSCxDQUFDLHNCQUFzQjtBQUN4RjtBQUMxQjtBQUNxQixDQUFDLHNCQUFzQjtBQUNWLENBQUMsc0JBQXNCO0FBQzlDO0FBQ0o7QUFDWTtBQUUzQzs7O0NBR0MsR0FFRDs7Ozs7Q0FLQyxHQUNELElBQUlhLGdCQUFnQjtBQUVwQixNQUFNQyxjQUFjO0lBQ2xCLE1BQU1DLE1BQU0sMkNBQTJDLEdBQUlGO0lBQzNEQSxnQkFBZ0I7SUFDaEJFLElBQUlDLE9BQU8sQ0FBQyxDQUFDQyxPQUFPQztRQUNsQixNQUFNQyxLQUFLRCxLQUFLRSxLQUFLLENBQUNELEVBQUU7UUFDeEIsTUFBTUUsWUFBWWpCLDREQUFjQSxDQUFDa0IsUUFBUSxDQUFDSixLQUFLRSxLQUFLO1FBQ3BELElBQUlDLGFBQWFBLFVBQVVFLE9BQU8sSUFBSSxDQUFDRixVQUFVRSxPQUFPLENBQUNDLFdBQVcsRUFBRTtZQUNwRVAsTUFBTUQsT0FBTyxDQUFDLENBQUNTLEtBQUtDO2dCQUNsQlAsR0FBR1EsT0FBTyxDQUFDRCxLQUFLRDtZQUNsQjtZQUNBUCxLQUFLVSxRQUFRLENBQUNUO1FBQ2hCO0lBQ0Y7QUFDRjtBQUVPLE1BQU1RLFVBQVUsQ0FBQ1QsTUFBTVEsS0FBS0c7SUFDakMsSUFBSSxDQUFDaEIsZUFBZTtRQUNsQkEsZ0JBQWdCLElBQUlpQjtRQUNwQmxCLG1EQUFpQixDQUFDLEdBQUdFO0lBQ3ZCO0lBQ0FILG9EQUFrQixDQUFDRSxlQUFlSyxNQUFNUCw0Q0FBVSxFQUFFdUIsR0FBRyxDQUFDUixLQUFLRztBQUMvRCxFQUFDO0FBRUQ7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1NLHFDQUFxQyxDQUFDQyxLQUFLQyxNQUFNQztJQUM1RCxJQUFJRixRQUFRLEdBQUc7UUFDYixvRkFBb0Y7UUFDcEYsT0FBTy9CLG9FQUFxQyxDQUFDZ0MsTUFBTSxHQUFHQSxLQUFLRyxNQUFNLEtBQUssSUFBSSxDQUFDLElBQUk7SUFDakY7SUFDQTs7R0FFQyxHQUNELElBQUlDLElBQUlKLEtBQUtLLE1BQU0sS0FBSyxPQUFPLE9BQW9DLDBCQUFILEdBQUlMLEtBQUtLLE1BQU0sQ0FBQ0MsT0FBTyxDQUFFTixJQUFJO0lBQzdGLE1BQU9JLE1BQU0sUUFBUUosU0FBU0ksRUFBRztRQUMvQixJQUFJQSxhQUFhcEMsd0NBQVMsRUFBRTtZQUMxQixJQUFJb0MsRUFBRUksT0FBTyxJQUFJVCxLQUFLO2dCQUNwQixPQUFPL0Isb0VBQXFDLENBQUNvQyxHQUFHTCxLQUFLQyxLQUFLRyxNQUFNLEtBQUssSUFBSSxDQUFDLElBQUk7WUFDaEYsT0FBTztnQkFDTEosT0FBT0ssRUFBRUksT0FBTztZQUNsQjtZQUNBLElBQUlKLEVBQUVLLEtBQUssS0FBSyxRQUFRTCxFQUFFSyxLQUFLLENBQUNDLElBQUksS0FBSyxNQUFNO2dCQUM3Q04sSUFBaUMsMEJBQUgsR0FBSUEsRUFBRUssS0FBSyxDQUFDQyxJQUFJLENBQUNKLE9BQU8sQ0FBRU4sSUFBSTtZQUM5RCxPQUFPO2dCQUNMLEdBQUc7b0JBQ0RJLElBQUlBLEVBQUVLLEtBQUssS0FBSyxPQUFPLE9BQU9MLEVBQUVLLEtBQUssQ0FBQ0UsTUFBTTtvQkFDNUNaO2dCQUNGLFFBQVNLLE1BQU1KLFFBQVFJLE1BQU0sUUFBUUEsRUFBRUssS0FBSyxLQUFLLFFBQVFMLEVBQUVLLEtBQUssQ0FBQ0MsSUFBSSxLQUFLLE1BQUs7Z0JBQy9FLElBQUlOLE1BQU0sUUFBUUEsTUFBTUosTUFBTTtvQkFDNUIsMkVBQTJFO29CQUMzRUksSUFBSUEsRUFBRUssS0FBSyxLQUFLLE9BQU8sT0FBb0MsMEJBQUgsR0FBd0IsaUJBQUgsR0FBSUwsRUFBRUssS0FBSyxDQUFDQyxJQUFJLENBQUVKLE9BQU8sQ0FBRU4sSUFBSTtnQkFDOUc7WUFDRjtRQUNGLE9BQU87WUFDTCxNQUFNWSxZQUErQixnQkFBSCxHQUFJWCxDQUFBQSxRQUFRWSxHQUFHLENBQUNULE1BQU07Z0JBQUVVLFVBQVU7WUFBRSxHQUFHQSxRQUFRO1lBQ2pGLElBQUlWLEVBQUVDLE1BQU0sS0FBSyxRQUFRTixNQUFNYSxXQUFXO2dCQUN4Q1IsSUFBaUMsMEJBQUgsR0FBSUEsRUFBRUMsTUFBTSxDQUFDQyxPQUFPLENBQUVOLElBQUk7Z0JBQ3hERDtZQUNGLE9BQU87Z0JBQ0wsSUFBSUEsUUFBUSxLQUFLSyxFQUFFSSxPQUFPLEtBQUssS0FBS0ksWUFBWSxHQUFHO29CQUNqRCwwQ0FBMEM7b0JBQzFDLE9BQU8sSUFBSTVDLGlEQUFrQixDQUFDb0MsRUFBRUssS0FBSyxLQUFLLE9BQU8sT0FBT0wsRUFBRUssS0FBSyxDQUFDTyxFQUFFLEVBQUVaLEVBQUVLLEtBQUssS0FBSyxPQUFPekMsZ0RBQWlCLENBQUNvQyxLQUFLLE1BQU07Z0JBQ3RIO2dCQUNBTCxPQUFPYTtnQkFDUCxJQUFJUixFQUFFSyxLQUFLLEtBQUssUUFBUUwsRUFBRUssS0FBSyxDQUFDQyxJQUFJLEtBQUssTUFBTTtvQkFDN0NOLElBQWlDLDBCQUFILEdBQUlBLEVBQUVLLEtBQUssQ0FBQ0MsSUFBSSxDQUFDSixPQUFPLENBQUVOLElBQUk7Z0JBQzlELE9BQU87b0JBQ0wsSUFBSUQsUUFBUSxHQUFHO3dCQUNiLHlCQUF5Qjt3QkFDekJLLElBQUlBLEVBQUVLLEtBQUssS0FBSyxPQUFPTCxJQUFJQSxFQUFFSyxLQUFLLENBQUNFLE1BQU07d0JBQ3pDLE9BQU8sSUFBSTNDLGlEQUFrQixDQUFDb0MsRUFBRUssS0FBSyxLQUFLLE9BQU8sT0FBT0wsRUFBRUssS0FBSyxDQUFDTyxFQUFFLEVBQUVaLEVBQUVLLEtBQUssS0FBSyxPQUFPekMsZ0RBQWlCLENBQUNvQyxLQUFLLE1BQU07b0JBQ3RIO29CQUNBLEdBQUc7d0JBQ0RBLElBQTBCLG1CQUFILEdBQUlBLEVBQUVLLEtBQUssQ0FBRUUsTUFBTTt3QkFDMUNaO29CQUNGLFFBQVNLLE1BQU1KLFFBQThCLG1CQUFILEdBQUlJLEVBQUVLLEtBQUssQ0FBRUMsSUFBSSxLQUFLLE1BQUs7b0JBQ3JFLHlEQUF5RDtvQkFDekQsSUFBSU4sTUFBTUosTUFBTTt3QkFDZCx1RUFBdUU7d0JBQ3ZFSSxJQUFpQywwQkFBSCxHQUEwQixtQkFBSCxHQUEwQixtQkFBSCxHQUFJQSxFQUFFSyxLQUFLLENBQUVDLElBQUksQ0FBRUosT0FBTyxDQUFFTixJQUFJO29CQUM5RztnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxJQUFJSSxNQUFNLE1BQU07WUFDZCxNQUFNL0Isc0RBQW9CO1FBQzVCO1FBQ0EsSUFBSTBCLFFBQVEsS0FBS0ssRUFBRWUsV0FBVyxLQUFLbkQsd0NBQVMsSUFBSW9DLE1BQU1KLE1BQU07WUFDMUQsT0FBT29CLHVCQUF1QmhCLEVBQUVLLEtBQUssQ0FBQ0UsTUFBTSxFQUFFUCxFQUFFSyxLQUFLO1FBQ3ZEO0lBQ0Y7SUFDQSxPQUFPekMsb0VBQXFDLENBQUNnQyxNQUFNQSxLQUFLUSxPQUFPLEVBQUVSLEtBQUtHLE1BQU0sS0FBSyxJQUFJLENBQUMsSUFBSTtBQUM1RixFQUFDO0FBRUQsTUFBTWlCLHlCQUF5QixDQUFDcEIsTUFBTXFCO0lBQ3BDLElBQUlDLFNBQVM7SUFDYixJQUFJQyxRQUFRO0lBQ1osSUFBSXZCLEtBQUtTLEtBQUssS0FBSyxNQUFNO1FBQ3ZCYyxRQUFRdkQsZ0RBQWlCLENBQUNnQztJQUM1QixPQUFPO1FBQ0xzQixTQUFTdEQseUNBQVUsQ0FBQ2dDLEtBQUtTLEtBQUssQ0FBQ08sRUFBRSxDQUFDUyxNQUFNLEVBQUV6QixLQUFLUyxLQUFLLENBQUNPLEVBQUUsQ0FBQ1UsS0FBSztJQUMvRDtJQUNBLE9BQU8sSUFBSTFELGlEQUFrQixDQUFDc0QsUUFBUUMsT0FBT0YsS0FBS0wsRUFBRTtBQUN0RDtBQUVBOzs7Ozs7Q0FNQyxHQUNNLE1BQU1XLHFDQUFxQyxDQUFDQyxHQUFHQyxjQUFjQyxRQUFRN0I7SUFDMUUsTUFBTThCLGFBQWEvRCwyRUFBNEMsQ0FBQzhELFFBQVFGO0lBQ3hFLElBQUlHLGVBQWUsUUFBU0EsV0FBVy9CLElBQUksS0FBSzZCLGdCQUFnQixDQUFDN0QsMkNBQVksQ0FBQzZELGNBQWNFLFdBQVcvQixJQUFJLENBQUNTLEtBQUssR0FBSTtRQUNuSCxPQUFPO0lBQ1Q7SUFDQSxJQUFJVCxPQUFPK0IsV0FBVy9CLElBQUk7SUFDMUIsSUFBSUQsTUFBTTtJQUNWLElBQUlDLEtBQUttQixXQUFXLEtBQUtuRCx3Q0FBUyxFQUFFO1FBQ2xDK0IsTUFBTWdDLFdBQVdHLEtBQUs7SUFDeEIsT0FBTyxJQUFJbEMsS0FBS1MsS0FBSyxLQUFLLFFBQVEsQ0FBQ1QsS0FBS1MsS0FBSyxDQUFDMEIsT0FBTyxFQUFFO1FBQ3JELElBQUkvQixJQUFJSixLQUFLSyxNQUFNO1FBQ25CLElBQUkrQixJQUFJO1FBQ1IsTUFBT0EsSUFBSXBDLEtBQUtRLE9BQU8sSUFBSTRCLElBQUlMLFdBQVdHLEtBQUssSUFBSTlCLE1BQU0sS0FBTTtZQUM3RCxJQUFJLENBQUNBLEVBQUUrQixPQUFPLEVBQUU7Z0JBQ2QsTUFBTUUsSUFBaUMsMEJBQUgsR0FBSWpDLEVBQUVFLE9BQU8sQ0FBRU4sSUFBSTtnQkFDdkRvQztnQkFDQSxJQUFJQyxhQUFhckUsd0NBQVMsRUFBRTtvQkFDMUIrQixPQUFPc0MsRUFBRTdCLE9BQU87Z0JBQ2xCLE9BQU87b0JBQ0xULE9BQTBCLGdCQUFILEdBQUlFLFFBQVFZLEdBQUcsQ0FBQ3dCLEdBQUl2QixRQUFRO2dCQUNyRDtZQUNGO1lBQ0FWLElBQUksbUJBQW1CLEdBQUlBLEVBQUVrQyxLQUFLO1FBQ3BDO1FBQ0F2QyxPQUFPLEVBQUUsa0NBQWtDOztJQUM3QztJQUNBLE1BQU9DLFNBQVM2QixnQkFBZ0I3QixLQUFLUyxLQUFLLEtBQUssS0FBTTtRQUNuRCxhQUFhO1FBQ2IsTUFBTUUsU0FBU1gsS0FBS1MsS0FBSyxDQUFDRSxNQUFNO1FBQ2hDLGFBQWE7UUFDYixJQUFJQSxPQUFPRixLQUFLLEtBQUssUUFBUSxDQUFDRSxPQUFPRixLQUFLLENBQUMwQixPQUFPLEVBQUU7WUFDbERwQyxPQUFPLEVBQUUsZ0JBQWdCOztZQUN6QixJQUFJSyxJQUFrQywyQkFBSCxHQUFJTyxPQUFRTixNQUFNO1lBQ3JELGtDQUFrQztZQUNsQyxNQUFPRCxNQUFNLEtBQU07Z0JBQ2pCLE1BQU1tQyxjQUEyQywwQkFBSCxHQUFJbkMsRUFBRUUsT0FBTyxDQUFFTixJQUFJO2dCQUNqRSxJQUFJdUMsZ0JBQWdCdkMsTUFBTTtvQkFDeEI7Z0JBQ0Y7Z0JBQ0EsSUFBSSxDQUFDSSxFQUFFK0IsT0FBTyxFQUFFO29CQUNkLElBQUlJLHVCQUF1QnZFLHdDQUFTLEVBQUU7d0JBQ3BDK0IsT0FBT3dDLFlBQVkvQixPQUFPO29CQUM1QixPQUFPO3dCQUNMVCxPQUEwQixnQkFBSCxHQUFJRSxRQUFRWSxHQUFHLENBQUMwQixhQUFjekIsUUFBUTtvQkFDL0Q7Z0JBQ0Y7Z0JBQ0FWLElBQUlBLEVBQUVrQyxLQUFLO1lBQ2I7UUFDRjtRQUNBdEMsT0FBTywyQkFBMkIsR0FBSVc7SUFDeEM7SUFDQSxPQUFPWixNQUFNLEVBQUUsOERBQThEOztBQUMvRSxFQUFDO0FBRUQ7Ozs7O0NBS0MsR0FDTSxNQUFNeUMsb0NBQW9DLENBQUNDLGNBQWNDO0lBQzlELE1BQU1DLGtCQUFrQkYsYUFBYUcsT0FBTyxHQUFHdEUsR0FBRyxDQUFDLENBQUMrRCxJQUNsRHpFLCtFQUFzQkEsQ0FDcEIseUJBQXlCLEdBQUl5RSxHQUM3QkssUUFDQTVFLHdFQUFlQSxLQUVqQitFLE1BQU0sQ0FBQyxDQUFDekMsSUFBTUEsTUFBTTtJQUN0QixPQUFPaEMsdURBQVFBLENBQUMwRSxTQUFTLENBQUNIO0FBQzVCLEVBQUM7QUFFRDs7Ozs7Q0FLQyxHQUNNLE1BQU1JLG9DQUFvQyxDQUFDTixjQUFjQyxTQUM5REEsT0FBT00sV0FBVyxDQUFDcEQsTUFBTSxDQUFDLE1BQU00QyxrQ0FBa0NDLGNBQWNDLFNBQVE7QUFFMUY7Ozs7Ozs7O0NBUUMsR0FDTSxNQUFNTyxxQkFBcUIsQ0FBQ1IsY0FBY0M7SUFDL0MsTUFBTVEsT0FBT3BGLHdFQUFlQTtJQUM1QixNQUFNNkUsa0JBQWtCRixhQUFhRyxPQUFPLEdBQUd0RSxHQUFHLENBQUMsQ0FBQytELElBQ2xEekUsK0VBQXNCQSxDQUNwQix5QkFBeUIsR0FBSXlFLEdBQzdCSyxRQUNBUSxPQUVGTCxNQUFNLENBQUMsQ0FBQ3pDLElBQU1BLE1BQU07SUFDdEIsTUFBTStDLE1BQU1ULE9BQU9NLFdBQVcsQ0FBQ3BELE1BQU0sQ0FBQyxNQUFNeEIsdURBQVFBLENBQUMwRSxTQUFTLENBQUNIO0lBQy9ELE9BQU87UUFBRVE7UUFBS0Q7UUFBTWpELFNBQVNpRCxLQUFLakQsT0FBTztJQUFDO0FBQzVDLEVBQUM7QUFFRDs7Ozs7Ozs7OztDQVVDLEdBQ00sU0FBU21ELGtCQUFtQkQsR0FBRyxFQUFFRSxjQUFjLGFBQWE7SUFDakUsTUFBTUMsT0FBTyxJQUFJdEYsb0NBQUs7SUFDdEIsTUFBTWdDLE9BQU8sMEJBQTBCLEdBQUlzRCxLQUFLekMsR0FBRyxDQUFDd0MsYUFBYXJGLDRDQUFhO0lBQzlFLElBQUksQ0FBQ2dDLEtBQUttRCxHQUFHLEVBQUU7UUFDYixPQUFPRztJQUNUO0lBRUFHLDBCQUEwQk4sS0FBS25EO0lBQy9CLE9BQU9BLEtBQUttRCxHQUFHO0FBQ2pCO0FBRUE7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FDTSxTQUFTTSwwQkFBMkJOLEdBQUcsRUFBRUUsV0FBVztJQUN6RCxNQUFNckQsT0FBT3FELGVBQWUsSUFBSXJGLDRDQUFhO0lBQzdDLE1BQU1zRixPQUFPdEQsS0FBS21ELEdBQUcsR0FBR25ELEtBQUttRCxHQUFHLEdBQUc7UUFBRU8sVUFBVSxDQUFDQyxjQUFnQkEsWUFBWUM7SUFBVztJQUN2RmpHLHdFQUFlQSxDQUFDMkYsTUFBTXRELE1BQU1tRCxLQUFLO1FBQUVsRCxTQUFTLElBQUlSO1FBQU9vRSxTQUFTLElBQUlwRTtJQUFNO0lBQzFFLE9BQU9PO0FBQ1Q7QUFFQTs7Ozs7Ozs7Ozs7Q0FXQyxHQUNNLFNBQVM4RCxzQkFBdUJwQixNQUFNLEVBQUUzRCxLQUFLLEVBQUVzRSxjQUFjLGFBQWE7SUFDL0UsTUFBTUYsTUFBTWpGLG1EQUFJQSxDQUFDNkYsUUFBUSxDQUFDckIsUUFBUTNEO0lBQ2xDLE9BQU9xRSxrQkFBa0JELEtBQUtFO0FBQ2hDO0FBRUE7Ozs7Ozs7Ozs7OztDQVlDLEdBQ00sU0FBU1csOEJBQStCdEIsTUFBTSxFQUFFM0QsS0FBSyxFQUFFc0UsV0FBVztJQUN2RSxNQUFNRixNQUFNakYsbURBQUlBLENBQUM2RixRQUFRLENBQUNyQixRQUFRM0Q7SUFDbEMsT0FBTzBFLDBCQUEwQk4sS0FBS0U7QUFDeEM7QUFFQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVNZLGtCQUFtQnZCLE1BQU0sRUFBRVksSUFBSTtJQUM3QyxNQUFNdkUsUUFBUW1GLHNCQUFzQlo7SUFDcEMsT0FBT3BGLG1EQUFJQSxDQUFDNkYsUUFBUSxDQUFDckIsUUFBUTNEO0FBQy9CO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU29GLDBCQUEyQnpCLE1BQU0sRUFBRVcsV0FBVztJQUM1RCxNQUFNdEUsUUFBUXFGLDhCQUE4QmY7SUFDNUMsT0FBT25GLG1EQUFJQSxDQUFDNkYsUUFBUSxDQUFDckIsUUFBUTNEO0FBQy9CO0FBRUE7Ozs7Ozs7OztDQVNDLEdBQ00sU0FBU21GLHNCQUNkWixJQUFJLEVBQ0pELGNBQWMsYUFBYTtJQUUzQixPQUFPZSw4QkFBOEJkLEtBQUtlLGNBQWMsQ0FBQ2hCO0FBQzNEO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNNLFNBQVNlLDhCQUErQmYsV0FBVztJQUN4RCxNQUFNaUIsUUFBUWpCLFlBQVlULE9BQU87SUFFakM7O0dBRUMsR0FDRCxNQUFNMkIsWUFBWWxELENBQUFBO1FBQ2hCOzs7OztLQUtDLEdBQ0QsSUFBSW1EO1FBRUosNERBQTREO1FBQzVELElBQUluRCxnQkFBZ0JyRCx3Q0FBUyxFQUFFO1lBQzdCLE1BQU15RyxRQUFRcEQsS0FBS3FELE9BQU87WUFDMUJGLFdBQVdDLE1BQU1uRyxHQUFHLENBQUMsbUJBQW1CLEdBQUcsQ0FBQ3FHO2dCQUMxQyxNQUFNQyxPQUFPO29CQUNYNUUsTUFBTTtvQkFDTjRFLE1BQU1ELEVBQUVFLE1BQU07Z0JBQ2hCO2dCQUNBLElBQUlGLEVBQUVHLFVBQVUsRUFBRTtvQkFDaEJGLEtBQUtHLEtBQUssR0FBR0MsT0FBT0MsSUFBSSxDQUFDTixFQUFFRyxVQUFVLEVBQUV4RyxHQUFHLENBQUMsQ0FBQzRHO3dCQUMxQyxNQUFNQyxRQUFRUixFQUFFRyxVQUFVLENBQUNJLE1BQU07d0JBQ2pDLE1BQU1sRixPQUFPbkMsdUVBQWNBLENBQUNxSDt3QkFDNUIsTUFBTUUsT0FBTzs0QkFDWHBGO3dCQUNGO3dCQUNBLElBQUlnRixPQUFPQyxJQUFJLENBQUNFLFFBQVE7NEJBQ3RCQyxLQUFLRCxLQUFLLEdBQUdBO3dCQUNmO3dCQUNBLE9BQU9DO29CQUNUO2dCQUNGO2dCQUNBLE9BQU9SO1lBQ1Q7UUFDRixPQUFPLElBQUl2RCxnQkFBZ0JyRCwyQ0FBWSxFQUFFO1lBQ3ZDd0csV0FBVztnQkFDVHhFLE1BQU1xQixLQUFLaUUsUUFBUTtZQUNyQjtZQUVBLE1BQU1ILFFBQVE5RCxLQUFLa0UsYUFBYTtZQUNoQyxJQUFJUCxPQUFPQyxJQUFJLENBQUNFLE9BQU9oRixNQUFNLEVBQUU7Z0JBQzdCcUUsU0FBU1csS0FBSyxHQUFHQTtZQUNuQjtZQUVBLE1BQU1LLFdBQVduRSxLQUFLdUIsT0FBTztZQUM3QixJQUFJNEMsU0FBU3JGLE1BQU0sRUFBRTtnQkFDbkJxRSxTQUFTbEUsT0FBTyxHQUFHa0YsU0FBU2xILEdBQUcsQ0FBQ2lHLFdBQVdrQixJQUFJO1lBQ2pEO1FBQ0YsT0FBTztZQUNMLDRDQUE0QztZQUM1Q3BILHNEQUFvQjtRQUN0QjtRQUVBLE9BQU9tRztJQUNUO0lBRUEsT0FBTztRQUNMeEUsTUFBTTtRQUNOTSxTQUFTZ0UsTUFBTWhHLEdBQUcsQ0FBQ2lHO0lBQ3JCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9saWIuanM/MzRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1cGRhdGVZRnJhZ21lbnQsIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQsIHlhdHRyMm1hcmtuYW1lLCBjcmVhdGVFbXB0eU1ldGEgfSBmcm9tICcuL3BsdWdpbnMvc3luYy1wbHVnaW4uanMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9wbHVnaW5zL2tleXMuanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdwcm9zZW1pcnJvci12aWV3JyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyBOb2RlLCBTY2hlbWEsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBldmVudGxvb3AgZnJvbSAnbGliMC9ldmVudGxvb3AnXG5cbi8qKlxuICogRWl0aGVyIGEgbm9kZSBpZiB0eXBlIGlzIFlYbWxFbGVtZW50IG9yIGFuIEFycmF5IG9mIHRleHQgbm9kZXMgaWYgWVhtbFRleHRcbiAqIEB0eXBlZGVmIHtNYXA8WS5BYnN0cmFjdFR5cGUsIE5vZGUgfCBBcnJheTxOb2RlPj59IFByb3NlbWlycm9yTWFwcGluZ1xuICovXG5cbi8qKlxuICogSXMgbnVsbCBpZiBubyB0aW1lb3V0IGlzIGluIHByb2dyZXNzLlxuICogSXMgZGVmaW5lZCBpZiBhIHRpbWVvdXQgaXMgaW4gcHJvZ3Jlc3MuXG4gKiBNYXBzIGZyb20gdmlld1xuICogQHR5cGUge01hcDxFZGl0b3JWaWV3LCBNYXA8YW55LCBhbnk+PnxudWxsfVxuICovXG5sZXQgdmlld3NUb1VwZGF0ZSA9IG51bGxcblxuY29uc3QgdXBkYXRlTWV0YXMgPSAoKSA9PiB7XG4gIGNvbnN0IHVwcyA9IC8qKiBAdHlwZSB7TWFwPEVkaXRvclZpZXcsIE1hcDxhbnksIGFueT4+fSAqLyAodmlld3NUb1VwZGF0ZSlcbiAgdmlld3NUb1VwZGF0ZSA9IG51bGxcbiAgdXBzLmZvckVhY2goKG1ldGFzLCB2aWV3KSA9PiB7XG4gICAgY29uc3QgdHIgPSB2aWV3LnN0YXRlLnRyXG4gICAgY29uc3Qgc3luY1N0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICBpZiAoc3luY1N0YXRlICYmIHN5bmNTdGF0ZS5iaW5kaW5nICYmICFzeW5jU3RhdGUuYmluZGluZy5pc0Rlc3Ryb3llZCkge1xuICAgICAgbWV0YXMuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgICAgdHIuc2V0TWV0YShrZXksIHZhbClcbiAgICAgIH0pXG4gICAgICB2aWV3LmRpc3BhdGNoKHRyKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHNldE1ldGEgPSAodmlldywga2V5LCB2YWx1ZSkgPT4ge1xuICBpZiAoIXZpZXdzVG9VcGRhdGUpIHtcbiAgICB2aWV3c1RvVXBkYXRlID0gbmV3IE1hcCgpXG4gICAgZXZlbnRsb29wLnRpbWVvdXQoMCwgdXBkYXRlTWV0YXMpXG4gIH1cbiAgbWFwLnNldElmVW5kZWZpbmVkKHZpZXdzVG9VcGRhdGUsIHZpZXcsIG1hcC5jcmVhdGUpLnNldChrZXksIHZhbHVlKVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYSBQcm9zZW1pcnJvciBiYXNlZCBhYnNvbHV0ZSBwb3NpdGlvbiB0byBhIFlqcyBDdXJzb3IgKHJlbGF0aXZlIHBvc2l0aW9uIGluIHRoZSBZanMgbW9kZWwpLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gdHlwZVxuICogQHBhcmFtIHtQcm9zZW1pcnJvck1hcHBpbmd9IG1hcHBpbmdcbiAqIEByZXR1cm4ge2FueX0gcmVsYXRpdmUgcG9zaXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24gPSAocG9zLCB0eXBlLCBtYXBwaW5nKSA9PiB7XG4gIGlmIChwb3MgPT09IDApIHtcbiAgICAvLyBpZiB0aGUgdHlwZSBpcyBsYXRlciBwb3B1bGF0ZWQsIHdlIHdhbnQgdG8gcmV0YWluIHRoZSAwIHBvc2l0aW9uIChoZW5jZSBhc3NvYz0tMSlcbiAgICByZXR1cm4gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0eXBlLCAwLCB0eXBlLmxlbmd0aCA9PT0gMCA/IC0xIDogMClcbiAgfVxuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCBuID0gdHlwZS5fZmlyc3QgPT09IG51bGwgPyBudWxsIDogLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAodHlwZS5fZmlyc3QuY29udGVudCkudHlwZVxuICB3aGlsZSAobiAhPT0gbnVsbCAmJiB0eXBlICE9PSBuKSB7XG4gICAgaWYgKG4gaW5zdGFuY2VvZiBZLlhtbFRleHQpIHtcbiAgICAgIGlmIChuLl9sZW5ndGggPj0gcG9zKSB7XG4gICAgICAgIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KG4sIHBvcywgdHlwZS5sZW5ndGggPT09IDAgPyAtMSA6IDApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwb3MgLT0gbi5fbGVuZ3RoXG4gICAgICB9XG4gICAgICBpZiAobi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uX2l0ZW0ubmV4dC5jb250ZW50KS50eXBlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkbyB7XG4gICAgICAgICAgbiA9IG4uX2l0ZW0gPT09IG51bGwgPyBudWxsIDogbi5faXRlbS5wYXJlbnRcbiAgICAgICAgICBwb3MtLVxuICAgICAgICB9IHdoaWxlIChuICE9PSB0eXBlICYmIG4gIT09IG51bGwgJiYgbi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgPT09IG51bGwpXG4gICAgICAgIGlmIChuICE9PSBudWxsICYmIG4gIT09IHR5cGUpIHtcbiAgICAgICAgICAvLyBAdHMtZ25vcmUgd2Uga25vdyB0aGF0IG4ubmV4dCAhPT0gbnVsbCBiZWNhdXNlIG9mIGFib3ZlIGxvb3AgY29uZGl0aXRpb25cbiAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovICgvKiogQHR5cGUgWS5JdGVtICovIChuLl9pdGVtLm5leHQpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwTm9kZVNpemUgPSAvKiogQHR5cGUge2FueX0gKi8gKG1hcHBpbmcuZ2V0KG4pIHx8IHsgbm9kZVNpemU6IDAgfSkubm9kZVNpemVcbiAgICAgIGlmIChuLl9maXJzdCAhPT0gbnVsbCAmJiBwb3MgPCBwTm9kZVNpemUpIHtcbiAgICAgICAgbiA9IC8qKiBAdHlwZSB7WS5Db250ZW50VHlwZX0gKi8gKG4uX2ZpcnN0LmNvbnRlbnQpLnR5cGVcbiAgICAgICAgcG9zLS1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwb3MgPT09IDEgJiYgbi5fbGVuZ3RoID09PSAwICYmIHBOb2RlU2l6ZSA+IDEpIHtcbiAgICAgICAgICAvLyBlZGdlIGNhc2UsIHNob3VsZCBlbmQgaW4gdGhpcyBwYXJhZ3JhcGhcbiAgICAgICAgICByZXR1cm4gbmV3IFkuUmVsYXRpdmVQb3NpdGlvbihuLl9pdGVtID09PSBudWxsID8gbnVsbCA6IG4uX2l0ZW0uaWQsIG4uX2l0ZW0gPT09IG51bGwgPyBZLmZpbmRSb290VHlwZUtleShuKSA6IG51bGwsIG51bGwpXG4gICAgICAgIH1cbiAgICAgICAgcG9zIC09IHBOb2RlU2l6ZVxuICAgICAgICBpZiAobi5faXRlbSAhPT0gbnVsbCAmJiBuLl9pdGVtLm5leHQgIT09IG51bGwpIHtcbiAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAobi5faXRlbS5uZXh0LmNvbnRlbnQpLnR5cGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocG9zID09PSAwKSB7XG4gICAgICAgICAgICAvLyBzZXQgdG8gZW5kIG9mIG4ucGFyZW50XG4gICAgICAgICAgICBuID0gbi5faXRlbSA9PT0gbnVsbCA/IG4gOiBuLl9pdGVtLnBhcmVudFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBZLlJlbGF0aXZlUG9zaXRpb24obi5faXRlbSA9PT0gbnVsbCA/IG51bGwgOiBuLl9pdGVtLmlkLCBuLl9pdGVtID09PSBudWxsID8gWS5maW5kUm9vdFR5cGVLZXkobikgOiBudWxsLCBudWxsKVxuICAgICAgICAgIH1cbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLl9pdGVtKS5wYXJlbnRcbiAgICAgICAgICAgIHBvcy0tXG4gICAgICAgICAgfSB3aGlsZSAobiAhPT0gdHlwZSAmJiAvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLm5leHQgPT09IG51bGwpXG4gICAgICAgICAgLy8gaWYgbiBpcyBudWxsIGF0IHRoaXMgcG9pbnQsIHdlIGhhdmUgYW4gdW5leHBlY3RlZCBjYXNlXG4gICAgICAgICAgaWYgKG4gIT09IHR5cGUpIHtcbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhhdCBuLl9pdGVtLm5leHQgaXMgZGVmaW5lZCBiZWNhdXNlIG9mIGFib3ZlIGxvb3AgY29uZGl0aW9uXG4gICAgICAgICAgICBuID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoLyoqIEB0eXBlIHtZLkl0ZW19ICovICgvKiogQHR5cGUge1kuSXRlbX0gKi8gKG4uX2l0ZW0pLm5leHQpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKHBvcyA9PT0gMCAmJiBuLmNvbnN0cnVjdG9yICE9PSBZLlhtbFRleHQgJiYgbiAhPT0gdHlwZSkgeyAvLyBUT0RPOiBzZXQgdG8gPD0gMFxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24obi5faXRlbS5wYXJlbnQsIG4uX2l0ZW0pXG4gICAgfVxuICB9XG4gIHJldHVybiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHR5cGUsIHR5cGUuX2xlbmd0aCwgdHlwZS5sZW5ndGggPT09IDAgPyAtMSA6IDApXG59XG5cbmNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24gPSAodHlwZSwgaXRlbSkgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbFxuICBsZXQgdG5hbWUgPSBudWxsXG4gIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgdG5hbWUgPSBZLmZpbmRSb290VHlwZUtleSh0eXBlKVxuICB9IGVsc2Uge1xuICAgIHR5cGVpZCA9IFkuY3JlYXRlSUQodHlwZS5faXRlbS5pZC5jbGllbnQsIHR5cGUuX2l0ZW0uaWQuY2xvY2spXG4gIH1cbiAgcmV0dXJuIG5ldyBZLlJlbGF0aXZlUG9zaXRpb24odHlwZWlkLCB0bmFtZSwgaXRlbS5pZClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuRG9jfSB5XG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IGRvY3VtZW50VHlwZSBUb3AgbGV2ZWwgdHlwZSB0aGF0IGlzIGJvdW5kIHRvIHBWaWV3XG4gKiBAcGFyYW0ge2FueX0gcmVsUG9zIEVuY29kZWQgWWpzIGJhc2VkIHJlbGF0aXZlIHBvc2l0aW9uXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yTWFwcGluZ30gbWFwcGluZ1xuICogQHJldHVybiB7bnVsbHxudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uID0gKHksIGRvY3VtZW50VHlwZSwgcmVsUG9zLCBtYXBwaW5nKSA9PiB7XG4gIGNvbnN0IGRlY29kZWRQb3MgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihyZWxQb3MsIHkpXG4gIGlmIChkZWNvZGVkUG9zID09PSBudWxsIHx8IChkZWNvZGVkUG9zLnR5cGUgIT09IGRvY3VtZW50VHlwZSAmJiAhWS5pc1BhcmVudE9mKGRvY3VtZW50VHlwZSwgZGVjb2RlZFBvcy50eXBlLl9pdGVtKSkpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGxldCB0eXBlID0gZGVjb2RlZFBvcy50eXBlXG4gIGxldCBwb3MgPSAwXG4gIGlmICh0eXBlLmNvbnN0cnVjdG9yID09PSBZLlhtbFRleHQpIHtcbiAgICBwb3MgPSBkZWNvZGVkUG9zLmluZGV4XG4gIH0gZWxzZSBpZiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSB7XG4gICAgbGV0IG4gPSB0eXBlLl9maXJzdFxuICAgIGxldCBpID0gMFxuICAgIHdoaWxlIChpIDwgdHlwZS5fbGVuZ3RoICYmIGkgPCBkZWNvZGVkUG9zLmluZGV4ICYmIG4gIT09IG51bGwpIHtcbiAgICAgIGlmICghbi5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IHQgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgaSsrXG4gICAgICAgIGlmICh0IGluc3RhbmNlb2YgWS5YbWxUZXh0KSB7XG4gICAgICAgICAgcG9zICs9IHQuX2xlbmd0aFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvcyArPSAvKiogQHR5cGUge2FueX0gKi8gKG1hcHBpbmcuZ2V0KHQpKS5ub2RlU2l6ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBuID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChuLnJpZ2h0KVxuICAgIH1cbiAgICBwb3MgKz0gMSAvLyBpbmNyZWFzZSBiZWNhdXNlIHdlIGdvIG91dCBvZiBuXG4gIH1cbiAgd2hpbGUgKHR5cGUgIT09IGRvY3VtZW50VHlwZSAmJiB0eXBlLl9pdGVtICE9PSBudWxsKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHBhcmVudCA9IHR5cGUuX2l0ZW0ucGFyZW50XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChwYXJlbnQuX2l0ZW0gPT09IG51bGwgfHwgIXBhcmVudC5faXRlbS5kZWxldGVkKSB7XG4gICAgICBwb3MgKz0gMSAvLyB0aGUgc3RhcnQgdGFnXG4gICAgICBsZXQgbiA9IC8qKiBAdHlwZSB7WS5BYnN0cmFjdFR5cGV9ICovIChwYXJlbnQpLl9maXJzdFxuICAgICAgLy8gbm93IGl0ZXJhdGUgdW50aWwgd2UgZm91bmQgdHlwZVxuICAgICAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSAvKiogQHR5cGUge1kuQ29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW4uZGVsZXRlZCkge1xuICAgICAgICAgIGlmIChjb250ZW50VHlwZSBpbnN0YW5jZW9mIFkuWG1sVGV4dCkge1xuICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRUeXBlLl9sZW5ndGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IC8qKiBAdHlwZSB7YW55fSAqLyAobWFwcGluZy5nZXQoY29udGVudFR5cGUpKS5ub2RlU2l6ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuID0gbi5yaWdodFxuICAgICAgfVxuICAgIH1cbiAgICB0eXBlID0gLyoqIEB0eXBlIHtZLkFic3RyYWN0VHlwZX0gKi8gKHBhcmVudClcbiAgfVxuICByZXR1cm4gcG9zIC0gMSAvLyB3ZSBkb24ndCBjb3VudCB0aGUgbW9zdCBvdXRlciB0YWcsIGJlY2F1c2UgaXQgaXMgYSBmcmFnbWVudFxufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgYW4gWS5GcmFnbWVudCB0byBhIFByb3NlTWlycm9yIGZyYWdtZW50LlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKi9cbmV4cG9ydCBjb25zdCB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yRnJhZ21lbnQgPSAoeVhtbEZyYWdtZW50LCBzY2hlbWEpID0+IHtcbiAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0geVhtbEZyYWdtZW50LnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICBzY2hlbWEsXG4gICAgICBjcmVhdGVFbXB0eU1ldGEoKVxuICAgIClcbiAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoZnJhZ21lbnRDb250ZW50KVxufVxuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgYW4gWS5GcmFnbWVudCB0byBhIFByb3NlTWlycm9yIG5vZGUuXG4gKlxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnRcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IHlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JSb290Tm9kZSA9ICh5WG1sRnJhZ21lbnQsIHNjaGVtYSkgPT5cbiAgc2NoZW1hLnRvcE5vZGVUeXBlLmNyZWF0ZShudWxsLCB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yRnJhZ21lbnQoeVhtbEZyYWdtZW50LCBzY2hlbWEpKVxuXG4vKipcbiAqIFRoZSBpbml0aWFsIFByb3NlTWlycm9yIGNvbnRlbnQgc2hvdWxkIGJlIHN1cHBsaWVkIGJ5IFlqcy4gVGhpcyBmdW5jdGlvbiB0cmFuc2Zvcm1zIGEgWS5GcmFnbWVudFxuICogdG8gYSBQcm9zZU1pcnJvciBEb2Mgbm9kZSBhbmQgY3JlYXRlcyBhIG1hcHBpbmcgdGhhdCBpcyB1c2VkIGJ5IHRoZSBzeW5jIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IHlYbWxGcmFnbWVudFxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICpcbiAqIEB0b2RvIGRlcHJlY2F0ZSBtYXBwaW5nIHByb3BlcnR5XG4gKi9cbmV4cG9ydCBjb25zdCBpbml0UHJvc2VNaXJyb3JEb2MgPSAoeVhtbEZyYWdtZW50LCBzY2hlbWEpID0+IHtcbiAgY29uc3QgbWV0YSA9IGNyZWF0ZUVtcHR5TWV0YSgpXG4gIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHlYbWxGcmFnbWVudC50b0FycmF5KCkubWFwKCh0KSA9PlxuICAgIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudH0gKi8gKHQpLFxuICAgICAgc2NoZW1hLFxuICAgICAgbWV0YVxuICAgIClcbiAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gIGNvbnN0IGRvYyA9IHNjaGVtYS50b3BOb2RlVHlwZS5jcmVhdGUobnVsbCwgRnJhZ21lbnQuZnJvbUFycmF5KGZyYWdtZW50Q29udGVudCkpXG4gIHJldHVybiB7IGRvYywgbWV0YSwgbWFwcGluZzogbWV0YS5tYXBwaW5nIH1cbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgUHJvc2VtaXJyb3IgRG9jIE5vZGUgaW50byBhIFkuRG9jLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gZG9jXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1kuRG9jfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JUb1lEb2MgKGRvYywgeG1sRnJhZ21lbnQgPSAncHJvc2VtaXJyb3InKSB7XG4gIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoKVxuICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtZLlhtbEZyYWdtZW50fSAqLyAoeWRvYy5nZXQoeG1sRnJhZ21lbnQsIFkuWG1sRnJhZ21lbnQpKVxuICBpZiAoIXR5cGUuZG9jKSB7XG4gICAgcmV0dXJuIHlkb2NcbiAgfVxuXG4gIHByb3NlbWlycm9yVG9ZWG1sRnJhZ21lbnQoZG9jLCB0eXBlKVxuICByZXR1cm4gdHlwZS5kb2Ncbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byB1cGRhdGUgYW4gZW1wdHkgWS5YbWxGcmFnbWVudCB3aXRoIGNvbnRlbnQgZnJvbSBhIFByb3NlbWlycm9yIERvYyBOb2RlLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgd2hlbiBpbXBvcnRpbmcgZXhpc3RpbmcgY29udGVudCB0byBZLkRvYyBmb3IgdGhlIGZpcnN0IHRpbWUsXG4gKiBub3RlIHRoYXQgdGhpcyBzaG91bGQgbm90IGJlIHVzZWQgdG8gcmVoeWRyYXRlIGEgWS5Eb2MgZnJvbSBhIGRhdGFiYXNlIG9uY2VcbiAqIGNvbGxhYm9yYXRpb24gaGFzIGJlZ3VuIGFzIGFsbCBoaXN0b3J5IHdpbGwgYmUgbG9zdFxuICpcbiAqIE5vdGU6IFRoZSBZLlhtbEZyYWdtZW50IGRvZXMgbm90IG5lZWQgdG8gYmUgcGFydCBvZiBhIFkuRG9jIGRvY3VtZW50IGF0IHRoZSB0aW1lIHRoYXQgdGhpc1xuICogbWV0aG9kIGlzIGNhbGxlZCwgYnV0IGl0IG11c3QgYmUgYWRkZWQgYmVmb3JlIGFueSBvdGhlciBvcGVyYXRpb25zIGFyZSBwZXJmb3JtZWQgb24gaXQuXG4gKlxuICogQHBhcmFtIHtOb2RlfSBkb2MgcHJvc2VtaXJyb3IgZG9jdW1lbnQuXG4gKiBAcGFyYW0ge1kuWG1sRnJhZ21lbnR9IFt4bWxGcmFnbWVudF0gSWYgc3VwcGxpZWQsIGFuIHhtbCBmcmFnbWVudCB0byBiZVxuICogICBwb3B1bGF0ZWQgZnJvbSB0aGUgcHJvc2VtaXJyb3Igc3RhdGU7IG90aGVyd2lzZSBhIG5ldyBYbWxGcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQuXG4gKiBAcmV0dXJuIHtZLlhtbEZyYWdtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudCAoZG9jLCB4bWxGcmFnbWVudCkge1xuICBjb25zdCB0eXBlID0geG1sRnJhZ21lbnQgfHwgbmV3IFkuWG1sRnJhZ21lbnQoKVxuICBjb25zdCB5ZG9jID0gdHlwZS5kb2MgPyB0eXBlLmRvYyA6IHsgdHJhbnNhY3Q6ICh0cmFuc2FjdGlvbikgPT4gdHJhbnNhY3Rpb24odW5kZWZpbmVkKSB9XG4gIHVwZGF0ZVlGcmFnbWVudCh5ZG9jLCB0eXBlLCBkb2MsIHsgbWFwcGluZzogbmV3IE1hcCgpLCBpc09NYXJrOiBuZXcgTWFwKCkgfSlcbiAgcmV0dXJuIHR5cGVcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTiBpbnRvIGEgWS5Eb2MuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB3aGVuIGltcG9ydGluZyBleGlzdGluZyBjb250ZW50IHRvIFkuRG9jIGZvciB0aGUgZmlyc3QgdGltZSxcbiAqIG5vdGUgdGhhdCB0aGlzIHNob3VsZCBub3QgYmUgdXNlZCB0byByZWh5ZHJhdGUgYSBZLkRvYyBmcm9tIGEgZGF0YWJhc2Ugb25jZVxuICogY29sbGFib3JhdGlvbiBoYXMgYmVndW4gYXMgYWxsIGhpc3Rvcnkgd2lsbCBiZSBsb3N0XG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHthbnl9IHN0YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1kuRG9jfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvc2VtaXJyb3JKU09OVG9ZRG9jIChzY2hlbWEsIHN0YXRlLCB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcicpIHtcbiAgY29uc3QgZG9jID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxuICByZXR1cm4gcHJvc2VtaXJyb3JUb1lEb2MoZG9jLCB4bWxGcmFnbWVudClcbn1cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTiB0byBhIFkuWG1sRnJhZ21lbnRcbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHdoZW4gaW1wb3J0aW5nIGV4aXN0aW5nIGNvbnRlbnQgdG8gWS5Eb2MgZm9yIHRoZSBmaXJzdCB0aW1lLFxuICogbm90ZSB0aGF0IHRoaXMgc2hvdWxkIG5vdCBiZSB1c2VkIHRvIHJlaHlkcmF0ZSBhIFkuRG9jIGZyb20gYSBkYXRhYmFzZSBvbmNlXG4gKiBjb2xsYWJvcmF0aW9uIGhhcyBiZWd1biBhcyBhbGwgaGlzdG9yeSB3aWxsIGJlIGxvc3RcbiAqXG4gKiBAcGFyYW0ge1NjaGVtYX0gc2NoZW1hXG4gKiBAcGFyYW0ge2FueX0gc3RhdGVcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0gW3htbEZyYWdtZW50XSBJZiBzdXBwbGllZCwgYW4geG1sIGZyYWdtZW50IHRvIGJlXG4gKiAgIHBvcHVsYXRlZCBmcm9tIHRoZSBwcm9zZW1pcnJvciBzdGF0ZTsgb3RoZXJ3aXNlIGEgbmV3IFhtbEZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm4ge1kuWG1sRnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9zZW1pcnJvckpTT05Ub1lYbWxGcmFnbWVudCAoc2NoZW1hLCBzdGF0ZSwgeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgZG9jID0gTm9kZS5mcm9tSlNPTihzY2hlbWEsIHN0YXRlKVxuICByZXR1cm4gcHJvc2VtaXJyb3JUb1lYbWxGcmFnbWVudChkb2MsIHhtbEZyYWdtZW50KVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSBgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlYCBpbnN0ZWFkXG4gKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIGEgUHJvc2VtaXJyb3IgRG9jIG5vZGUuXG4gKlxuICogQHBhcmFtIHtTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtZLkRvY30geWRvY1xuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHlEb2NUb1Byb3NlbWlycm9yIChzY2hlbWEsIHlkb2MpIHtcbiAgY29uc3Qgc3RhdGUgPSB5RG9jVG9Qcm9zZW1pcnJvckpTT04oeWRvYylcbiAgcmV0dXJuIE5vZGUuZnJvbUpTT04oc2NoZW1hLCBzdGF0ZSlcbn1cblxuLyoqXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5YbWxGcmFnbWVudCB0byBhIFByb3NlbWlycm9yIERvYyBub2RlLlxuICpcbiAqIEBwYXJhbSB7U2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge05vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9yIChzY2hlbWEsIHhtbEZyYWdtZW50KSB7XG4gIGNvbnN0IHN0YXRlID0geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeG1sRnJhZ21lbnQpXG4gIHJldHVybiBOb2RlLmZyb21KU09OKHNjaGVtYSwgc3RhdGUpXG59XG5cbi8qKlxuICpcbiAqIEBkZXByZWNhdGVkIFVzZSBgeVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvclJvb3ROb2RlYCBpbnN0ZWFkXG4gKlxuICogVXRpbGl0eSBtZXRob2QgdG8gY29udmVydCBhIFkuRG9jIHRvIFByb3NlbWlycm9yIGNvbXBhdGlibGUgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1kuRG9jfSB5ZG9jXG4gKiBAcGFyYW0ge3N0cmluZ30geG1sRnJhZ21lbnRcbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5RG9jVG9Qcm9zZW1pcnJvckpTT04gKFxuICB5ZG9jLFxuICB4bWxGcmFnbWVudCA9ICdwcm9zZW1pcnJvcidcbikge1xuICByZXR1cm4geVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oeWRvYy5nZXRYbWxGcmFnbWVudCh4bWxGcmFnbWVudCkpXG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIGB5WG1sRnJhZ21lbnRUb1Byb3NlTWlycm9yUm9vdE5vZGVgIGluc3RlYWRcbiAqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgWS5Eb2MgdG8gUHJvc2VtaXJyb3IgY29tcGF0aWJsZSBKU09OLlxuICpcbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geG1sRnJhZ21lbnQgVGhlIGZyYWdtZW50LCB3aGljaCBtdXN0IGJlIHBhcnQgb2YgYSBZLkRvYy5cbiAqIEByZXR1cm4ge1JlY29yZDxzdHJpbmcsIGFueT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTiAoeG1sRnJhZ21lbnQpIHtcbiAgY29uc3QgaXRlbXMgPSB4bWxGcmFnbWVudC50b0FycmF5KClcblxuICAvKipcbiAgICogQHBhcmFtIHtZLkFic3RyYWN0VHlwZX0gaXRlbVxuICAgKi9cbiAgY29uc3Qgc2VyaWFsaXplID0gaXRlbSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH0gTm9kZU9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBOb2RlT2JqZWN0LnR5cGVcbiAgICAgKiBAcHJvcGVydHkge1JlY29yZDxzdHJpbmcsIHN0cmluZz49fSBOb2RlT2JqZWN0LmF0dHJzXG4gICAgICogQHByb3BlcnR5IHtBcnJheTxOb2RlT2JqZWN0Pj19IE5vZGVPYmplY3QuY29udGVudFxuICAgICAqL1xuICAgIGxldCByZXNwb25zZVxuXG4gICAgLy8gVE9ETzogTXVzdCBiZSBhIGJldHRlciB3YXkgdG8gZGV0ZWN0IHRleHQgbm9kZXMgdGhhbiB0aGlzXG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBZLlhtbFRleHQpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gaXRlbS50b0RlbHRhKClcbiAgICAgIHJlc3BvbnNlID0gZGVsdGEubWFwKC8qKiBAcGFyYW0ge2FueX0gZCAqLyAoZCkgPT4ge1xuICAgICAgICBjb25zdCB0ZXh0ID0ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiBkLmluc2VydFxuICAgICAgICB9XG4gICAgICAgIGlmIChkLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB0ZXh0Lm1hcmtzID0gT2JqZWN0LmtleXMoZC5hdHRyaWJ1dGVzKS5tYXAoKHR5cGVfKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRycyA9IGQuYXR0cmlidXRlc1t0eXBlX11cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB5YXR0cjJtYXJrbmFtZSh0eXBlXylcbiAgICAgICAgICAgIGNvbnN0IG1hcmsgPSB7XG4gICAgICAgICAgICAgIHR5cGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRycykpIHtcbiAgICAgICAgICAgICAgbWFyay5hdHRycyA9IGF0dHJzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFya1xuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHRcbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50KSB7XG4gICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogaXRlbS5ub2RlTmFtZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhdHRycyA9IGl0ZW0uZ2V0QXR0cmlidXRlcygpXG4gICAgICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgICAgICByZXNwb25zZS5hdHRycyA9IGF0dHJzXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoaWxkcmVuID0gaXRlbS50b0FycmF5KClcbiAgICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgcmVzcG9uc2UuY29udGVudCA9IGNoaWxkcmVuLm1hcChzZXJpYWxpemUpLmZsYXQoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleHBlY3RlZCBlaXRoZXIgWS5YbWxFbGVtZW50IG9yIFkuWG1sVGV4dFxuICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnZG9jJyxcbiAgICBjb250ZW50OiBpdGVtcy5tYXAoc2VyaWFsaXplKVxuICB9XG59XG4iXSwibmFtZXMiOlsidXBkYXRlWUZyYWdtZW50IiwiY3JlYXRlTm9kZUZyb21ZRWxlbWVudCIsInlhdHRyMm1hcmtuYW1lIiwiY3JlYXRlRW1wdHlNZXRhIiwieVN5bmNQbHVnaW5LZXkiLCJZIiwiRWRpdG9yVmlldyIsIk5vZGUiLCJTY2hlbWEiLCJGcmFnbWVudCIsImVycm9yIiwibWFwIiwiZXZlbnRsb29wIiwidmlld3NUb1VwZGF0ZSIsInVwZGF0ZU1ldGFzIiwidXBzIiwiZm9yRWFjaCIsIm1ldGFzIiwidmlldyIsInRyIiwic3RhdGUiLCJzeW5jU3RhdGUiLCJnZXRTdGF0ZSIsImJpbmRpbmciLCJpc0Rlc3Ryb3llZCIsInZhbCIsImtleSIsInNldE1ldGEiLCJkaXNwYXRjaCIsInZhbHVlIiwiTWFwIiwidGltZW91dCIsInNldElmVW5kZWZpbmVkIiwiY3JlYXRlIiwic2V0IiwiYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiIsInBvcyIsInR5cGUiLCJtYXBwaW5nIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgiLCJsZW5ndGgiLCJuIiwiX2ZpcnN0IiwiY29udGVudCIsIlhtbFRleHQiLCJfbGVuZ3RoIiwiX2l0ZW0iLCJuZXh0IiwicGFyZW50IiwicE5vZGVTaXplIiwiZ2V0Iiwibm9kZVNpemUiLCJSZWxhdGl2ZVBvc2l0aW9uIiwiaWQiLCJmaW5kUm9vdFR5cGVLZXkiLCJ1bmV4cGVjdGVkQ2FzZSIsImNvbnN0cnVjdG9yIiwiY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiIsIml0ZW0iLCJ0eXBlaWQiLCJ0bmFtZSIsImNyZWF0ZUlEIiwiY2xpZW50IiwiY2xvY2siLCJyZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uIiwieSIsImRvY3VtZW50VHlwZSIsInJlbFBvcyIsImRlY29kZWRQb3MiLCJjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24iLCJpc1BhcmVudE9mIiwiaW5kZXgiLCJkZWxldGVkIiwiaSIsInQiLCJyaWdodCIsImNvbnRlbnRUeXBlIiwieVhtbEZyYWdtZW50VG9Qcm9zZU1pcnJvckZyYWdtZW50IiwieVhtbEZyYWdtZW50Iiwic2NoZW1hIiwiZnJhZ21lbnRDb250ZW50IiwidG9BcnJheSIsImZpbHRlciIsImZyb21BcnJheSIsInlYbWxGcmFnbWVudFRvUHJvc2VNaXJyb3JSb290Tm9kZSIsInRvcE5vZGVUeXBlIiwiaW5pdFByb3NlTWlycm9yRG9jIiwibWV0YSIsImRvYyIsInByb3NlbWlycm9yVG9ZRG9jIiwieG1sRnJhZ21lbnQiLCJ5ZG9jIiwiRG9jIiwiWG1sRnJhZ21lbnQiLCJwcm9zZW1pcnJvclRvWVhtbEZyYWdtZW50IiwidHJhbnNhY3QiLCJ0cmFuc2FjdGlvbiIsInVuZGVmaW5lZCIsImlzT01hcmsiLCJwcm9zZW1pcnJvckpTT05Ub1lEb2MiLCJmcm9tSlNPTiIsInByb3NlbWlycm9ySlNPTlRvWVhtbEZyYWdtZW50IiwieURvY1RvUHJvc2VtaXJyb3IiLCJ5RG9jVG9Qcm9zZW1pcnJvckpTT04iLCJ5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9yIiwieVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04iLCJnZXRYbWxGcmFnbWVudCIsIml0ZW1zIiwic2VyaWFsaXplIiwicmVzcG9uc2UiLCJkZWx0YSIsInRvRGVsdGEiLCJkIiwidGV4dCIsImluc2VydCIsImF0dHJpYnV0ZXMiLCJtYXJrcyIsIk9iamVjdCIsImtleXMiLCJ0eXBlXyIsImF0dHJzIiwibWFyayIsIlhtbEVsZW1lbnQiLCJub2RlTmFtZSIsImdldEF0dHJpYnV0ZXMiLCJjaGlsZHJlbiIsImZsYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/lib.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/cursor-plugin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createDecorations: () => (/* binding */ createDecorations),\n/* harmony export */   defaultAwarenessStateFilter: () => (/* binding */ defaultAwarenessStateFilter),\n/* harmony export */   defaultCursorBuilder: () => (/* binding */ defaultCursorBuilder),\n/* harmony export */   defaultSelectionBuilder: () => (/* binding */ defaultSelectionBuilder),\n/* harmony export */   yCursorPlugin: () => (/* binding */ yCursorPlugin)\n/* harmony export */ });\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var y_protocols_awareness__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! y-protocols/awareness */ \"(ssr)/./node_modules/y-protocols/awareness.js\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n\n // eslint-disable-line\n // eslint-disable-line\n // eslint-disable-line\n\n\n\n/**\n * Default awareness state filter\n *\n * @param {number} currentClientId current client id\n * @param {number} userClientId user client id\n * @param {any} _user user data\n * @return {boolean}\n */ const defaultAwarenessStateFilter = (currentClientId, userClientId, _user)=>currentClientId !== userClientId;\n/**\n * Default generator for a cursor element\n *\n * @param {any} user user data\n * @return {HTMLElement}\n */ const defaultCursorBuilder = (user)=>{\n    const cursor = document.createElement(\"span\");\n    cursor.classList.add(\"ProseMirror-yjs-cursor\");\n    cursor.setAttribute(\"style\", `border-color: ${user.color}`);\n    const userDiv = document.createElement(\"div\");\n    userDiv.setAttribute(\"style\", `background-color: ${user.color}`);\n    userDiv.insertBefore(document.createTextNode(user.name), null);\n    const nonbreakingSpace1 = document.createTextNode(\"\");\n    const nonbreakingSpace2 = document.createTextNode(\"\");\n    cursor.insertBefore(nonbreakingSpace1, null);\n    cursor.insertBefore(userDiv, null);\n    cursor.insertBefore(nonbreakingSpace2, null);\n    return cursor;\n};\n/**\n * Default generator for the selection attributes\n *\n * @param {any} user user data\n * @return {import('prosemirror-view').DecorationAttrs}\n */ const defaultSelectionBuilder = (user)=>{\n    return {\n        style: `background-color: ${user.color}70`,\n        class: \"ProseMirror-yjs-selection\"\n    };\n};\nconst rxValidColor = /^#[0-9a-fA-F]{6}$/;\n/**\n * @param {any} state\n * @param {Awareness} awareness\n * @param {function(number, number, any):boolean} awarenessFilter\n * @param {(user: { name: string, color: string }, clientId: number) => Element} createCursor\n * @param {(user: { name: string, color: string }, clientId: number) => import('prosemirror-view').DecorationAttrs} createSelection\n * @return {any} DecorationSet\n */ const createDecorations = (state, awareness, awarenessFilter, createCursor, createSelection)=>{\n    const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(state);\n    const y = ystate.doc;\n    const decorations = [];\n    if (ystate.snapshot != null || ystate.prevSnapshot != null || ystate.binding.mapping.size === 0) {\n        // do not render cursors while snapshot is active\n        return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, []);\n    }\n    awareness.getStates().forEach((aw, clientId)=>{\n        if (!awarenessFilter(y.clientID, clientId, aw)) {\n            return;\n        }\n        if (aw.cursor != null) {\n            const user = aw.user || {};\n            if (user.color == null) {\n                user.color = \"#ffa500\";\n            } else if (!rxValidColor.test(user.color)) {\n                // We only support 6-digit RGB colors in y-prosemirror\n                console.warn(\"A user uses an unsupported color format\", user);\n            }\n            if (user.name == null) {\n                user.name = `User: ${clientId}`;\n            }\n            let anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(y, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.anchor), ystate.binding.mapping);\n            let head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(y, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(aw.cursor.head), ystate.binding.mapping);\n            if (anchor !== null && head !== null) {\n                const maxsize = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(state.doc.content.size - 1, 0);\n                anchor = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, maxsize);\n                head = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(head, maxsize);\n                decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.widget(head, ()=>createCursor(user, clientId), {\n                    key: clientId + \"\",\n                    side: 10\n                }));\n                const from = lib0_math__WEBPACK_IMPORTED_MODULE_5__.min(anchor, head);\n                const to = lib0_math__WEBPACK_IMPORTED_MODULE_5__.max(anchor, head);\n                decorations.push(prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.Decoration.inline(from, to, createSelection(user, clientId), {\n                    inclusiveEnd: true,\n                    inclusiveStart: false\n                }));\n            }\n        }\n    });\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_2__.DecorationSet.create(state.doc, decorations);\n};\n/**\n * A prosemirror plugin that listens to awareness information on Yjs.\n * This requires that a `prosemirrorPlugin` is also bound to the prosemirror.\n *\n * @public\n * @param {Awareness} awareness\n * @param {object} opts\n * @param {function(any, any, any):boolean} [opts.awarenessStateFilter]\n * @param {(user: any, clientId: number) => HTMLElement} [opts.cursorBuilder]\n * @param {(user: any, clientId: number) => import('prosemirror-view').DecorationAttrs} [opts.selectionBuilder]\n * @param {function(any):any} [opts.getSelection]\n * @param {string} [cursorStateField] By default all editor bindings use the awareness 'cursor' field to propagate cursor information.\n * @return {any}\n */ const yCursorPlugin = (awareness, { awarenessStateFilter = defaultAwarenessStateFilter, cursorBuilder = defaultCursorBuilder, selectionBuilder = defaultSelectionBuilder, getSelection = (state)=>state.selection } = {}, cursorStateField = \"cursor\")=>new prosemirror_state__WEBPACK_IMPORTED_MODULE_6__.Plugin({\n        key: _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey,\n        state: {\n            init (_, state) {\n                return createDecorations(state, awareness, awarenessStateFilter, cursorBuilder, selectionBuilder);\n            },\n            apply (tr, prevState, _oldState, newState) {\n                const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(newState);\n                const yCursorState = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey);\n                if (ystate && ystate.isChangeOrigin || yCursorState && yCursorState.awarenessUpdated) {\n                    return createDecorations(newState, awareness, awarenessStateFilter, cursorBuilder, selectionBuilder);\n                }\n                return prevState.map(tr.mapping, tr.doc);\n            }\n        },\n        props: {\n            decorations: (state)=>{\n                return _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey.getState(state);\n            }\n        },\n        view: (view)=>{\n            const awarenessListener = ()=>{\n                // @ts-ignore\n                if (view.docView) {\n                    (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.setMeta)(view, _keys_js__WEBPACK_IMPORTED_MODULE_1__.yCursorPluginKey, {\n                        awarenessUpdated: true\n                    });\n                }\n            };\n            const updateCursorInfo = ()=>{\n                const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_1__.ySyncPluginKey.getState(view.state);\n                // @note We make implicit checks when checking for the cursor property\n                const current = awareness.getLocalState() || {};\n                if (view.hasFocus()) {\n                    const selection = getSelection(view.state);\n                    /**\n           * @type {Y.RelativePosition}\n           */ const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(selection.anchor, ystate.type, ystate.binding.mapping);\n                    /**\n           * @type {Y.RelativePosition}\n           */ const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.absolutePositionToRelativePosition)(selection.head, ystate.type, ystate.binding.mapping);\n                    if (current.cursor == null || !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor), anchor) || !yjs__WEBPACK_IMPORTED_MODULE_4__.compareRelativePositions(yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.head), head)) {\n                        awareness.setLocalStateField(cursorStateField, {\n                            anchor,\n                            head\n                        });\n                    }\n                } else if (current.cursor != null && (0,_lib_js__WEBPACK_IMPORTED_MODULE_3__.relativePositionToAbsolutePosition)(ystate.doc, ystate.type, yjs__WEBPACK_IMPORTED_MODULE_4__.createRelativePositionFromJSON(current.cursor.anchor), ystate.binding.mapping) !== null) {\n                    // delete cursor information if current cursor information is owned by this editor binding\n                    awareness.setLocalStateField(cursorStateField, null);\n                }\n            };\n            awareness.on(\"change\", awarenessListener);\n            view.dom.addEventListener(\"focusin\", updateCursorInfo);\n            view.dom.addEventListener(\"focusout\", updateCursorInfo);\n            return {\n                update: updateCursorInfo,\n                destroy: ()=>{\n                    view.dom.removeEventListener(\"focusin\", updateCursorInfo);\n                    view.dom.removeEventListener(\"focusout\", updateCursorInfo);\n                    awareness.off(\"change\", awarenessListener);\n                    awareness.setLocalStateField(cursorStateField, null);\n                }\n            };\n        }\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9jdXJzb3ItcGx1Z2luLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUF3QjtBQUNxQyxDQUFDLHNCQUFzQjtBQUN6QyxDQUFDLHNCQUFzQjtBQUNoQixDQUFDLHNCQUFzQjtBQUt2RDtBQUMwQztBQUUzQjtBQUVqQzs7Ozs7OztDQU9DLEdBQ00sTUFBTVcsOEJBQThCLENBQUNDLGlCQUFpQkMsY0FBY0MsUUFBVUYsb0JBQW9CQyxhQUFZO0FBRXJIOzs7OztDQUtDLEdBQ00sTUFBTUUsdUJBQXVCLENBQUNDO0lBQ25DLE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztJQUN0Q0YsT0FBT0csU0FBUyxDQUFDQyxHQUFHLENBQUM7SUFDckJKLE9BQU9LLFlBQVksQ0FBQyxTQUFTLENBQUMsY0FBYyxFQUFFTixLQUFLTyxLQUFLLENBQUMsQ0FBQztJQUMxRCxNQUFNQyxVQUFVTixTQUFTQyxhQUFhLENBQUM7SUFDdkNLLFFBQVFGLFlBQVksQ0FBQyxTQUFTLENBQUMsa0JBQWtCLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxDQUFDO0lBQy9EQyxRQUFRQyxZQUFZLENBQUNQLFNBQVNRLGNBQWMsQ0FBQ1YsS0FBS1csSUFBSSxHQUFHO0lBQ3pELE1BQU1DLG9CQUFvQlYsU0FBU1EsY0FBYyxDQUFDO0lBQ2xELE1BQU1HLG9CQUFvQlgsU0FBU1EsY0FBYyxDQUFDO0lBQ2xEVCxPQUFPUSxZQUFZLENBQUNHLG1CQUFtQjtJQUN2Q1gsT0FBT1EsWUFBWSxDQUFDRCxTQUFTO0lBQzdCUCxPQUFPUSxZQUFZLENBQUNJLG1CQUFtQjtJQUN2QyxPQUFPWjtBQUNULEVBQUM7QUFFRDs7Ozs7Q0FLQyxHQUNNLE1BQU1hLDBCQUEwQixDQUFDZDtJQUN0QyxPQUFPO1FBQ0xlLE9BQU8sQ0FBQyxrQkFBa0IsRUFBRWYsS0FBS08sS0FBSyxDQUFDLEVBQUUsQ0FBQztRQUMxQ1MsT0FBTztJQUNU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S0FBS1UsR0FBRyxDQUFDSSxtQkFBbUIsQ0FBQyxXQUFXWDtvQkFDeENILEtBQUtVLEdBQUcsQ0FBQ0ksbUJBQW1CLENBQUMsWUFBWVg7b0JBQ3pDL0QsVUFBVTJFLEdBQUcsQ0FBQyxVQUFVZDtvQkFDeEI3RCxVQUFVb0Usa0JBQWtCLENBQUN0QixrQkFBa0I7Z0JBQ2pEO1lBQ0Y7UUFDRjtJQUNGLEdBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy95LXByb3NlbWlycm9yL3NyYy9wbHVnaW5zL2N1cnNvci1wbHVnaW4uanM/OGVmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tIFwicHJvc2VtaXJyb3Itc3RhdGVcIjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0IHsgQXdhcmVuZXNzIH0gZnJvbSBcInktcHJvdG9jb2xzL2F3YXJlbmVzc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQge1xuICBhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uLFxuICByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uLFxuICBzZXRNZXRhXG59IGZyb20gJy4uL2xpYi5qcydcbmltcG9ydCB7IHlDdXJzb3JQbHVnaW5LZXksIHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9rZXlzLmpzJ1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcblxuLyoqXG4gKiBEZWZhdWx0IGF3YXJlbmVzcyBzdGF0ZSBmaWx0ZXJcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudENsaWVudElkIGN1cnJlbnQgY2xpZW50IGlkXG4gKiBAcGFyYW0ge251bWJlcn0gdXNlckNsaWVudElkIHVzZXIgY2xpZW50IGlkXG4gKiBAcGFyYW0ge2FueX0gX3VzZXIgdXNlciBkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdEF3YXJlbmVzc1N0YXRlRmlsdGVyID0gKGN1cnJlbnRDbGllbnRJZCwgdXNlckNsaWVudElkLCBfdXNlcikgPT4gY3VycmVudENsaWVudElkICE9PSB1c2VyQ2xpZW50SWRcblxuLyoqXG4gKiBEZWZhdWx0IGdlbmVyYXRvciBmb3IgYSBjdXJzb3IgZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7YW55fSB1c2VyIHVzZXIgZGF0YVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0Q3Vyc29yQnVpbGRlciA9ICh1c2VyKSA9PiB7XG4gIGNvbnN0IGN1cnNvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICBjdXJzb3IuY2xhc3NMaXN0LmFkZCgnUHJvc2VNaXJyb3IteWpzLWN1cnNvcicpXG4gIGN1cnNvci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJvcmRlci1jb2xvcjogJHt1c2VyLmNvbG9yfWApXG4gIGNvbnN0IHVzZXJEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICB1c2VyRGl2LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCBgYmFja2dyb3VuZC1jb2xvcjogJHt1c2VyLmNvbG9yfWApXG4gIHVzZXJEaXYuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHVzZXIubmFtZSksIG51bGwpXG4gIGNvbnN0IG5vbmJyZWFraW5nU3BhY2UxID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ1xcdTIwNjAnKVxuICBjb25zdCBub25icmVha2luZ1NwYWNlMiA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCdcXHUyMDYwJylcbiAgY3Vyc29yLmluc2VydEJlZm9yZShub25icmVha2luZ1NwYWNlMSwgbnVsbClcbiAgY3Vyc29yLmluc2VydEJlZm9yZSh1c2VyRGl2LCBudWxsKVxuICBjdXJzb3IuaW5zZXJ0QmVmb3JlKG5vbmJyZWFraW5nU3BhY2UyLCBudWxsKVxuICByZXR1cm4gY3Vyc29yXG59XG5cbi8qKlxuICogRGVmYXVsdCBnZW5lcmF0b3IgZm9yIHRoZSBzZWxlY3Rpb24gYXR0cmlidXRlc1xuICpcbiAqIEBwYXJhbSB7YW55fSB1c2VyIHVzZXIgZGF0YVxuICogQHJldHVybiB7aW1wb3J0KCdwcm9zZW1pcnJvci12aWV3JykuRGVjb3JhdGlvbkF0dHJzfVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdFNlbGVjdGlvbkJ1aWxkZXIgPSAodXNlcikgPT4ge1xuICByZXR1cm4ge1xuICAgIHN0eWxlOiBgYmFja2dyb3VuZC1jb2xvcjogJHt1c2VyLmNvbG9yfTcwYCxcbiAgICBjbGFzczogJ1Byb3NlTWlycm9yLXlqcy1zZWxlY3Rpb24nXG4gIH1cbn1cblxuY29uc3QgcnhWYWxpZENvbG9yID0gL14jWzAtOWEtZkEtRl17Nn0kL1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzdGF0ZVxuICogQHBhcmFtIHtBd2FyZW5lc3N9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsIG51bWJlciwgYW55KTpib29sZWFufSBhd2FyZW5lc3NGaWx0ZXJcbiAqIEBwYXJhbSB7KHVzZXI6IHsgbmFtZTogc3RyaW5nLCBjb2xvcjogc3RyaW5nIH0sIGNsaWVudElkOiBudW1iZXIpID0+IEVsZW1lbnR9IGNyZWF0ZUN1cnNvclxuICogQHBhcmFtIHsodXNlcjogeyBuYW1lOiBzdHJpbmcsIGNvbG9yOiBzdHJpbmcgfSwgY2xpZW50SWQ6IG51bWJlcikgPT4gaW1wb3J0KCdwcm9zZW1pcnJvci12aWV3JykuRGVjb3JhdGlvbkF0dHJzfSBjcmVhdGVTZWxlY3Rpb25cbiAqIEByZXR1cm4ge2FueX0gRGVjb3JhdGlvblNldFxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGVjb3JhdGlvbnMgPSAoXG4gIHN0YXRlLFxuICBhd2FyZW5lc3MsXG4gIGF3YXJlbmVzc0ZpbHRlcixcbiAgY3JlYXRlQ3Vyc29yLFxuICBjcmVhdGVTZWxlY3Rpb25cbikgPT4ge1xuICBjb25zdCB5c3RhdGUgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSlcbiAgY29uc3QgeSA9IHlzdGF0ZS5kb2NcbiAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXVxuICBpZiAoXG4gICAgeXN0YXRlLnNuYXBzaG90ICE9IG51bGwgfHwgeXN0YXRlLnByZXZTbmFwc2hvdCAhPSBudWxsIHx8XG4gICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZy5zaXplID09PSAwXG4gICkge1xuICAgIC8vIGRvIG5vdCByZW5kZXIgY3Vyc29ycyB3aGlsZSBzbmFwc2hvdCBpcyBhY3RpdmVcbiAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbXSlcbiAgfVxuICBhd2FyZW5lc3MuZ2V0U3RhdGVzKCkuZm9yRWFjaCgoYXcsIGNsaWVudElkKSA9PiB7XG4gICAgaWYgKCFhd2FyZW5lc3NGaWx0ZXIoeS5jbGllbnRJRCwgY2xpZW50SWQsIGF3KSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGF3LmN1cnNvciAhPSBudWxsKSB7XG4gICAgICBjb25zdCB1c2VyID0gYXcudXNlciB8fCB7fVxuICAgICAgaWYgKHVzZXIuY29sb3IgPT0gbnVsbCkge1xuICAgICAgICB1c2VyLmNvbG9yID0gJyNmZmE1MDAnXG4gICAgICB9IGVsc2UgaWYgKCFyeFZhbGlkQ29sb3IudGVzdCh1c2VyLmNvbG9yKSkge1xuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgNi1kaWdpdCBSR0IgY29sb3JzIGluIHktcHJvc2VtaXJyb3JcbiAgICAgICAgY29uc29sZS53YXJuKCdBIHVzZXIgdXNlcyBhbiB1bnN1cHBvcnRlZCBjb2xvciBmb3JtYXQnLCB1c2VyKVxuICAgICAgfVxuICAgICAgaWYgKHVzZXIubmFtZSA9PSBudWxsKSB7XG4gICAgICAgIHVzZXIubmFtZSA9IGBVc2VyOiAke2NsaWVudElkfWBcbiAgICAgIH1cbiAgICAgIGxldCBhbmNob3IgPSByZWxhdGl2ZVBvc2l0aW9uVG9BYnNvbHV0ZVBvc2l0aW9uKFxuICAgICAgICB5LFxuICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oYXcuY3Vyc29yLmFuY2hvciksXG4gICAgICAgIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmdcbiAgICAgIClcbiAgICAgIGxldCBoZWFkID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgeSxcbiAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGF3LmN1cnNvci5oZWFkKSxcbiAgICAgICAgeXN0YXRlLmJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IG1heHNpemUgPSBtYXRoLm1heChzdGF0ZS5kb2MuY29udGVudC5zaXplIC0gMSwgMClcbiAgICAgICAgYW5jaG9yID0gbWF0aC5taW4oYW5jaG9yLCBtYXhzaXplKVxuICAgICAgICBoZWFkID0gbWF0aC5taW4oaGVhZCwgbWF4c2l6ZSlcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaChcbiAgICAgICAgICBEZWNvcmF0aW9uLndpZGdldChoZWFkLCAoKSA9PiBjcmVhdGVDdXJzb3IodXNlciwgY2xpZW50SWQpLCB7XG4gICAgICAgICAgICBrZXk6IGNsaWVudElkICsgJycsXG4gICAgICAgICAgICBzaWRlOiAxMFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICAgY29uc3QgZnJvbSA9IG1hdGgubWluKGFuY2hvciwgaGVhZClcbiAgICAgICAgY29uc3QgdG8gPSBtYXRoLm1heChhbmNob3IsIGhlYWQpXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goXG4gICAgICAgICAgRGVjb3JhdGlvbi5pbmxpbmUoZnJvbSwgdG8sIGNyZWF0ZVNlbGVjdGlvbih1c2VyLCBjbGllbnRJZCksIHtcbiAgICAgICAgICAgIGluY2x1c2l2ZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZVN0YXJ0OiBmYWxzZVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG4gIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShzdGF0ZS5kb2MsIGRlY29yYXRpb25zKVxufVxuXG4vKipcbiAqIEEgcHJvc2VtaXJyb3IgcGx1Z2luIHRoYXQgbGlzdGVucyB0byBhd2FyZW5lc3MgaW5mb3JtYXRpb24gb24gWWpzLlxuICogVGhpcyByZXF1aXJlcyB0aGF0IGEgYHByb3NlbWlycm9yUGx1Z2luYCBpcyBhbHNvIGJvdW5kIHRvIHRoZSBwcm9zZW1pcnJvci5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICogQHBhcmFtIHtmdW5jdGlvbihhbnksIGFueSwgYW55KTpib29sZWFufSBbb3B0cy5hd2FyZW5lc3NTdGF0ZUZpbHRlcl1cbiAqIEBwYXJhbSB7KHVzZXI6IGFueSwgY2xpZW50SWQ6IG51bWJlcikgPT4gSFRNTEVsZW1lbnR9IFtvcHRzLmN1cnNvckJ1aWxkZXJdXG4gKiBAcGFyYW0geyh1c2VyOiBhbnksIGNsaWVudElkOiBudW1iZXIpID0+IGltcG9ydCgncHJvc2VtaXJyb3ItdmlldycpLkRlY29yYXRpb25BdHRyc30gW29wdHMuc2VsZWN0aW9uQnVpbGRlcl1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55KTphbnl9IFtvcHRzLmdldFNlbGVjdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY3Vyc29yU3RhdGVGaWVsZF0gQnkgZGVmYXVsdCBhbGwgZWRpdG9yIGJpbmRpbmdzIHVzZSB0aGUgYXdhcmVuZXNzICdjdXJzb3InIGZpZWxkIHRvIHByb3BhZ2F0ZSBjdXJzb3IgaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBjb25zdCB5Q3Vyc29yUGx1Z2luID0gKFxuICBhd2FyZW5lc3MsXG4gIHtcbiAgICBhd2FyZW5lc3NTdGF0ZUZpbHRlciA9IGRlZmF1bHRBd2FyZW5lc3NTdGF0ZUZpbHRlcixcbiAgICBjdXJzb3JCdWlsZGVyID0gZGVmYXVsdEN1cnNvckJ1aWxkZXIsXG4gICAgc2VsZWN0aW9uQnVpbGRlciA9IGRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyLFxuICAgIGdldFNlbGVjdGlvbiA9IChzdGF0ZSkgPT4gc3RhdGUuc2VsZWN0aW9uXG4gIH0gPSB7fSxcbiAgY3Vyc29yU3RhdGVGaWVsZCA9ICdjdXJzb3InXG4pID0+XG4gIG5ldyBQbHVnaW4oe1xuICAgIGtleTogeUN1cnNvclBsdWdpbktleSxcbiAgICBzdGF0ZToge1xuICAgICAgaW5pdCAoXywgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlY29yYXRpb25zKFxuICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgIGF3YXJlbmVzcyxcbiAgICAgICAgICBhd2FyZW5lc3NTdGF0ZUZpbHRlcixcbiAgICAgICAgICBjdXJzb3JCdWlsZGVyLFxuICAgICAgICAgIHNlbGVjdGlvbkJ1aWxkZXJcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIGFwcGx5ICh0ciwgcHJldlN0YXRlLCBfb2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gICAgICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKG5ld1N0YXRlKVxuICAgICAgICBjb25zdCB5Q3Vyc29yU3RhdGUgPSB0ci5nZXRNZXRhKHlDdXJzb3JQbHVnaW5LZXkpXG4gICAgICAgIGlmIChcbiAgICAgICAgICAoeXN0YXRlICYmIHlzdGF0ZS5pc0NoYW5nZU9yaWdpbikgfHxcbiAgICAgICAgICAoeUN1cnNvclN0YXRlICYmIHlDdXJzb3JTdGF0ZS5hd2FyZW5lc3NVcGRhdGVkKVxuICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlRGVjb3JhdGlvbnMoXG4gICAgICAgICAgICBuZXdTdGF0ZSxcbiAgICAgICAgICAgIGF3YXJlbmVzcyxcbiAgICAgICAgICAgIGF3YXJlbmVzc1N0YXRlRmlsdGVyLFxuICAgICAgICAgICAgY3Vyc29yQnVpbGRlcixcbiAgICAgICAgICAgIHNlbGVjdGlvbkJ1aWxkZXJcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXZTdGF0ZS5tYXAodHIubWFwcGluZywgdHIuZG9jKVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvcHM6IHtcbiAgICAgIGRlY29yYXRpb25zOiAoc3RhdGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHlDdXJzb3JQbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpXG4gICAgICB9XG4gICAgfSxcbiAgICB2aWV3OiAodmlldykgPT4ge1xuICAgICAgY29uc3QgYXdhcmVuZXNzTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKHZpZXcuZG9jVmlldykge1xuICAgICAgICAgIHNldE1ldGEodmlldywgeUN1cnNvclBsdWdpbktleSwgeyBhd2FyZW5lc3NVcGRhdGVkOiB0cnVlIH0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHVwZGF0ZUN1cnNvckluZm8gPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgICAgIC8vIEBub3RlIFdlIG1ha2UgaW1wbGljaXQgY2hlY2tzIHdoZW4gY2hlY2tpbmcgZm9yIHRoZSBjdXJzb3IgcHJvcGVydHlcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgfHwge31cbiAgICAgICAgaWYgKHZpZXcuaGFzRm9jdXMoKSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbih2aWV3LnN0YXRlKVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHtZLlJlbGF0aXZlUG9zaXRpb259XG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgYW5jaG9yID0gYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICAgICAgICAgIHNlbGVjdGlvbi5hbmNob3IsXG4gICAgICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgICAgIHlzdGF0ZS5iaW5kaW5nLm1hcHBpbmdcbiAgICAgICAgICApXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUge1kuUmVsYXRpdmVQb3NpdGlvbn1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBoZWFkID0gYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICAgICAgICAgIHNlbGVjdGlvbi5oZWFkLFxuICAgICAgICAgICAgeXN0YXRlLnR5cGUsXG4gICAgICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGN1cnJlbnQuY3Vyc29yID09IG51bGwgfHxcbiAgICAgICAgICAgICFZLmNvbXBhcmVSZWxhdGl2ZVBvc2l0aW9ucyhcbiAgICAgICAgICAgICAgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oY3VycmVudC5jdXJzb3IuYW5jaG9yKSxcbiAgICAgICAgICAgICAgYW5jaG9yXG4gICAgICAgICAgICApIHx8XG4gICAgICAgICAgICAhWS5jb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMoXG4gICAgICAgICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmhlYWQpLFxuICAgICAgICAgICAgICBoZWFkXG4gICAgICAgICAgICApXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIHtcbiAgICAgICAgICAgICAgYW5jaG9yLFxuICAgICAgICAgICAgICBoZWFkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjdXJyZW50LmN1cnNvciAhPSBudWxsICYmXG4gICAgICAgICAgcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgICAgIHlzdGF0ZS5kb2MsXG4gICAgICAgICAgICB5c3RhdGUudHlwZSxcbiAgICAgICAgICAgIFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKGN1cnJlbnQuY3Vyc29yLmFuY2hvciksXG4gICAgICAgICAgICB5c3RhdGUuYmluZGluZy5tYXBwaW5nXG4gICAgICAgICAgKSAhPT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBkZWxldGUgY3Vyc29yIGluZm9ybWF0aW9uIGlmIGN1cnJlbnQgY3Vyc29yIGluZm9ybWF0aW9uIGlzIG93bmVkIGJ5IHRoaXMgZWRpdG9yIGJpbmRpbmdcbiAgICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YXJlbmVzcy5vbignY2hhbmdlJywgYXdhcmVuZXNzTGlzdGVuZXIpXG4gICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogdXBkYXRlQ3Vyc29ySW5mbyxcbiAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB1cGRhdGVDdXJzb3JJbmZvKVxuICAgICAgICAgIHZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdXBkYXRlQ3Vyc29ySW5mbylcbiAgICAgICAgICBhd2FyZW5lc3Mub2ZmKCdjaGFuZ2UnLCBhd2FyZW5lc3NMaXN0ZW5lcilcbiAgICAgICAgICBhd2FyZW5lc3Muc2V0TG9jYWxTdGF0ZUZpZWxkKGN1cnNvclN0YXRlRmllbGQsIG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pXG4iXSwibmFtZXMiOlsiWSIsIkRlY29yYXRpb24iLCJEZWNvcmF0aW9uU2V0IiwiUGx1Z2luIiwiQXdhcmVuZXNzIiwiYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbiIsInJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24iLCJzZXRNZXRhIiwieUN1cnNvclBsdWdpbktleSIsInlTeW5jUGx1Z2luS2V5IiwibWF0aCIsImRlZmF1bHRBd2FyZW5lc3NTdGF0ZUZpbHRlciIsImN1cnJlbnRDbGllbnRJZCIsInVzZXJDbGllbnRJZCIsIl91c2VyIiwiZGVmYXVsdEN1cnNvckJ1aWxkZXIiLCJ1c2VyIiwiY3Vyc29yIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwic2V0QXR0cmlidXRlIiwiY29sb3IiLCJ1c2VyRGl2IiwiaW5zZXJ0QmVmb3JlIiwiY3JlYXRlVGV4dE5vZGUiLCJuYW1lIiwibm9uYnJlYWtpbmdTcGFjZTEiLCJub25icmVha2luZ1NwYWNlMiIsImRlZmF1bHRTZWxlY3Rpb25CdWlsZGVyIiwic3R5bGUiLCJjbGFzcyIsInJ4VmFsaWRDb2xvciIsImNyZWF0ZURlY29yYXRpb25zIiwic3RhdGUiLCJhd2FyZW5lc3MiLCJhd2FyZW5lc3NGaWx0ZXIiLCJjcmVhdGVDdXJzb3IiLCJjcmVhdGVTZWxlY3Rpb24iLCJ5c3RhdGUiLCJnZXRTdGF0ZSIsInkiLCJkb2MiLCJkZWNvcmF0aW9ucyIsInNuYXBzaG90IiwicHJldlNuYXBzaG90IiwiYmluZGluZyIsIm1hcHBpbmciLCJzaXplIiwiY3JlYXRlIiwiZ2V0U3RhdGVzIiwiZm9yRWFjaCIsImF3IiwiY2xpZW50SWQiLCJjbGllbnRJRCIsInRlc3QiLCJjb25zb2xlIiwid2FybiIsImFuY2hvciIsInR5cGUiLCJjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04iLCJoZWFkIiwibWF4c2l6ZSIsIm1heCIsImNvbnRlbnQiLCJtaW4iLCJwdXNoIiwid2lkZ2V0Iiwia2V5Iiwic2lkZSIsImZyb20iLCJ0byIsImlubGluZSIsImluY2x1c2l2ZUVuZCIsImluY2x1c2l2ZVN0YXJ0IiwieUN1cnNvclBsdWdpbiIsImF3YXJlbmVzc1N0YXRlRmlsdGVyIiwiY3Vyc29yQnVpbGRlciIsInNlbGVjdGlvbkJ1aWxkZXIiLCJnZXRTZWxlY3Rpb24iLCJzZWxlY3Rpb24iLCJjdXJzb3JTdGF0ZUZpZWxkIiwiaW5pdCIsIl8iLCJhcHBseSIsInRyIiwicHJldlN0YXRlIiwiX29sZFN0YXRlIiwibmV3U3RhdGUiLCJ5Q3Vyc29yU3RhdGUiLCJnZXRNZXRhIiwiaXNDaGFuZ2VPcmlnaW4iLCJhd2FyZW5lc3NVcGRhdGVkIiwibWFwIiwicHJvcHMiLCJ2aWV3IiwiYXdhcmVuZXNzTGlzdGVuZXIiLCJkb2NWaWV3IiwidXBkYXRlQ3Vyc29ySW5mbyIsImN1cnJlbnQiLCJnZXRMb2NhbFN0YXRlIiwiaGFzRm9jdXMiLCJjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMiLCJzZXRMb2NhbFN0YXRlRmllbGQiLCJvbiIsImRvbSIsImFkZEV2ZW50TGlzdGVuZXIiLCJ1cGRhdGUiLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9mZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js":
/*!********************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/keys.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yCursorPluginKey: () => (/* binding */ yCursorPluginKey),\n/* harmony export */   ySyncPluginKey: () => (/* binding */ ySyncPluginKey),\n/* harmony export */   yUndoPluginKey: () => (/* binding */ yUndoPluginKey)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n // eslint-disable-line\n/**\n * The unique prosemirror plugin key for syncPlugin\n *\n * @public\n */ const ySyncPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"y-sync\");\n/**\n * The unique prosemirror plugin key for undoPlugin\n *\n * @public\n * @type {PluginKey<import('./undo-plugin').UndoPluginState>}\n */ const yUndoPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"y-undo\");\n/**\n * The unique prosemirror plugin key for cursorPlugin\n *\n * @public\n */ const yCursorPluginKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"yjs-cursor\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkMsQ0FBQyxzQkFBc0I7QUFFcEU7Ozs7Q0FJQyxHQUNNLE1BQU1DLGlCQUFpQixJQUFJRCx3REFBU0EsQ0FBQyxVQUFTO0FBRXJEOzs7OztDQUtDLEdBQ00sTUFBTUUsaUJBQWlCLElBQUlGLHdEQUFTQSxDQUFDLFVBQVM7QUFFckQ7Ozs7Q0FJQyxHQUNNLE1BQU1HLG1CQUFtQixJQUFJSCx3REFBU0EsQ0FBQyxjQUFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9rZXlzLmpzPzBlMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGx1Z2luS2V5IH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBUaGUgdW5pcXVlIHByb3NlbWlycm9yIHBsdWdpbiBrZXkgZm9yIHN5bmNQbHVnaW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3ktc3luYycpXG5cbi8qKlxuICogVGhlIHVuaXF1ZSBwcm9zZW1pcnJvciBwbHVnaW4ga2V5IGZvciB1bmRvUGx1Z2luXG4gKlxuICogQHB1YmxpY1xuICogQHR5cGUge1BsdWdpbktleTxpbXBvcnQoJy4vdW5kby1wbHVnaW4nKS5VbmRvUGx1Z2luU3RhdGU+fVxuICovXG5leHBvcnQgY29uc3QgeVVuZG9QbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCd5LXVuZG8nKVxuXG4vKipcbiAqIFRoZSB1bmlxdWUgcHJvc2VtaXJyb3IgcGx1Z2luIGtleSBmb3IgY3Vyc29yUGx1Z2luXG4gKlxuICogQHB1YmxpY1xuICovXG5leHBvcnQgY29uc3QgeUN1cnNvclBsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ3lqcy1jdXJzb3InKVxuIl0sIm5hbWVzIjpbIlBsdWdpbktleSIsInlTeW5jUGx1Z2luS2V5IiwieVVuZG9QbHVnaW5LZXkiLCJ5Q3Vyc29yUGx1Z2luS2V5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/sync-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProsemirrorBinding: () => (/* binding */ ProsemirrorBinding),\n/* harmony export */   attributesToMarks: () => (/* binding */ attributesToMarks),\n/* harmony export */   createEmptyMeta: () => (/* binding */ createEmptyMeta),\n/* harmony export */   createNodeFromYElement: () => (/* binding */ createNodeFromYElement),\n/* harmony export */   getRelativeSelection: () => (/* binding */ getRelativeSelection),\n/* harmony export */   isVisible: () => (/* binding */ isVisible),\n/* harmony export */   updateYFragment: () => (/* binding */ updateYFragment),\n/* harmony export */   ySyncPlugin: () => (/* binding */ ySyncPlugin),\n/* harmony export */   yattr2markname: () => (/* binding */ yattr2markname)\n/* harmony export */ });\n/* harmony import */ var lib0_mutex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lib0/mutex */ \"(ssr)/./node_modules/lib0/mutex.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var lib0_math__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lib0/math */ \"(ssr)/./node_modules/lib0/math.js\");\n/* harmony import */ var lib0_object__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lib0/object */ \"(ssr)/./node_modules/lib0/object.js\");\n/* harmony import */ var lib0_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/set */ \"(ssr)/./node_modules/lib0/set.js\");\n/* harmony import */ var lib0_diff__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lib0/diff */ \"(ssr)/./node_modules/lib0/diff.js\");\n/* harmony import */ var lib0_error__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lib0/error */ \"(ssr)/./node_modules/lib0/error.js\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _lib_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib.js */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n/* harmony import */ var lib0_random__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lib0/random */ \"(ssr)/./node_modules/lib0/random.js\");\n/* harmony import */ var lib0_environment__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lib0/environment */ \"(ssr)/./node_modules/lib0/environment.js\");\n/* harmony import */ var lib0_dom__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lib0/dom */ \"(ssr)/./node_modules/lib0/dom.js\");\n/* harmony import */ var lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lib0/eventloop */ \"(ssr)/./node_modules/lib0/eventloop.js\");\n/* harmony import */ var lib0_map__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lib0/map */ \"(ssr)/./node_modules/lib0/map.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/y-prosemirror/src/utils.js\");\n/**\n * @module bindings/prosemirror\n */ \n\n // eslint-disable-line\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @typedef {Object} BindingMetadata\n * @property {ProsemirrorMapping} BindingMetadata.mapping\n * @property {Map<import('prosemirror-model').MarkType, boolean>} BindingMetadata.isOMark - is overlapping mark\n */ /**\n * @return {BindingMetadata}\n */ const createEmptyMeta = ()=>({\n        mapping: new Map(),\n        isOMark: new Map()\n    });\n/**\n * @param {Y.Item} item\n * @param {Y.Snapshot} [snapshot]\n */ const isVisible = (item, snapshot)=>snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && /** @type {number} */ snapshot.sv.get(item.id.client) > item.id.clock && !yjs__WEBPACK_IMPORTED_MODULE_0__.isDeleted(snapshot.ds, item.id);\n/**\n * Either a node if type is YXmlElement or an Array of text nodes if YXmlText\n * @typedef {Map<Y.AbstractType<any>, PModel.Node | Array<PModel.Node>>} ProsemirrorMapping\n */ /**\n * @typedef {Object} ColorDef\n * @property {string} ColorDef.light\n * @property {string} ColorDef.dark\n */ /**\n * @typedef {Object} YSyncOpts\n * @property {Array<ColorDef>} [YSyncOpts.colors]\n * @property {Map<string,ColorDef>} [YSyncOpts.colorMapping]\n * @property {Y.PermanentUserData|null} [YSyncOpts.permanentUserData]\n * @property {ProsemirrorMapping} [YSyncOpts.mapping]\n * @property {function} [YSyncOpts.onFirstRender] Fired when the content from Yjs is initially rendered to ProseMirror\n */ /**\n * @type {Array<ColorDef>}\n */ const defaultColors = [\n    {\n        light: \"#ecd44433\",\n        dark: \"#ecd444\"\n    }\n];\n/**\n * @param {Map<string,ColorDef>} colorMapping\n * @param {Array<ColorDef>} colors\n * @param {string} user\n * @return {ColorDef}\n */ const getUserColor = (colorMapping, colors, user)=>{\n    // @todo do not hit the same color twice if possible\n    if (!colorMapping.has(user)) {\n        if (colorMapping.size < colors.length) {\n            const usedColors = lib0_set__WEBPACK_IMPORTED_MODULE_1__.create();\n            colorMapping.forEach((color)=>usedColors.add(color));\n            colors = colors.filter((color)=>!usedColors.has(color));\n        }\n        colorMapping.set(user, lib0_random__WEBPACK_IMPORTED_MODULE_2__.oneOf(colors));\n    }\n    return /** @type {ColorDef} */ colorMapping.get(user);\n};\n/**\n * This plugin listens to changes in prosemirror view and keeps yXmlState and view in sync.\n *\n * This plugin also keeps references to the type and the shared document so other plugins can access it.\n * @param {Y.XmlFragment} yXmlFragment\n * @param {YSyncOpts} opts\n * @return {any} Returns a prosemirror plugin that binds to this type\n */ const ySyncPlugin = (yXmlFragment, { colors = defaultColors, colorMapping = new Map(), permanentUserData = null, onFirstRender = ()=>{}, mapping } = {})=>{\n    let initialContentChanged = false;\n    const binding = new ProsemirrorBinding(yXmlFragment, mapping);\n    const plugin = new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.Plugin({\n        props: {\n            editable: (state)=>{\n                const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(state);\n                return syncState.snapshot == null && syncState.prevSnapshot == null;\n            }\n        },\n        key: _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey,\n        state: {\n            /**\n       * @returns {any}\n       */ init: (_initargs, _state)=>{\n                return {\n                    type: yXmlFragment,\n                    doc: yXmlFragment.doc,\n                    binding,\n                    snapshot: null,\n                    prevSnapshot: null,\n                    isChangeOrigin: false,\n                    isUndoRedoOperation: false,\n                    addToHistory: true,\n                    colors,\n                    colorMapping,\n                    permanentUserData\n                };\n            },\n            apply: (tr, pluginState)=>{\n                const change = tr.getMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n                if (change !== undefined) {\n                    pluginState = Object.assign({}, pluginState);\n                    for(const key in change){\n                        pluginState[key] = change[key];\n                    }\n                }\n                pluginState.addToHistory = tr.getMeta(\"addToHistory\") !== false;\n                // always set isChangeOrigin. If undefined, this is not change origin.\n                pluginState.isChangeOrigin = change !== undefined && !!change.isChangeOrigin;\n                pluginState.isUndoRedoOperation = change !== undefined && !!change.isChangeOrigin && !!change.isUndoRedoOperation;\n                if (binding.prosemirrorView !== null) {\n                    if (change !== undefined && (change.snapshot != null || change.prevSnapshot != null)) {\n                        // snapshot changed, rerender next\n                        lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, ()=>{\n                            if (binding.prosemirrorView == null) {\n                                return;\n                            }\n                            if (change.restore == null) {\n                                binding._renderSnapshot(change.snapshot, change.prevSnapshot, pluginState);\n                            } else {\n                                binding._renderSnapshot(change.snapshot, change.snapshot, pluginState);\n                                // reset to current prosemirror state\n                                delete pluginState.restore;\n                                delete pluginState.snapshot;\n                                delete pluginState.prevSnapshot;\n                                binding.mux(()=>{\n                                    binding._prosemirrorChanged(binding.prosemirrorView.state.doc);\n                                });\n                            }\n                        });\n                    }\n                }\n                return pluginState;\n            }\n        },\n        view: (view)=>{\n            binding.initView(view);\n            if (mapping == null) {\n                // force rerender to update the bindings mapping\n                binding._forceRerender();\n            }\n            onFirstRender();\n            return {\n                update: ()=>{\n                    const pluginState = plugin.getState(view.state);\n                    if (pluginState.snapshot == null && pluginState.prevSnapshot == null) {\n                        if (// If the content doesn't change initially, we don't render anything to Yjs\n                        // If the content was cleared by a user action, we want to catch the change and\n                        // represent it in Yjs\n                        initialContentChanged || view.state.doc.content.findDiffStart(view.state.doc.type.createAndFill().content) !== null) {\n                            initialContentChanged = true;\n                            if (pluginState.addToHistory === false && !pluginState.isChangeOrigin) {\n                                const yUndoPluginState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.yUndoPluginKey.getState(view.state);\n                                /**\n                 * @type {Y.UndoManager}\n                 */ const um = yUndoPluginState && yUndoPluginState.undoManager;\n                                if (um) {\n                                    um.stopCapturing();\n                                }\n                            }\n                            binding.mux(()=>{\n                                /** @type {Y.Doc} */ pluginState.doc.transact((tr)=>{\n                                    tr.meta.set(\"addToHistory\", pluginState.addToHistory);\n                                    binding._prosemirrorChanged(view.state.doc);\n                                }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n                            });\n                        }\n                    }\n                },\n                destroy: ()=>{\n                    binding.destroy();\n                }\n            };\n        }\n    });\n    return plugin;\n};\n/**\n * @param {import('prosemirror-state').Transaction} tr\n * @param {ReturnType<typeof getRelativeSelection>} relSel\n * @param {ProsemirrorBinding} binding\n */ const restoreRelativeSelection = (tr, relSel, binding)=>{\n    if (relSel !== null && relSel.anchor !== null && relSel.head !== null) {\n        if (relSel.type === \"all\") {\n            tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.AllSelection(tr.doc));\n        } else if (relSel.type === \"node\") {\n            const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(binding.doc, binding.type, relSel.anchor, binding.mapping);\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.NodeSelection.create(tr.doc, anchor));\n        } else {\n            const anchor = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(binding.doc, binding.type, relSel.anchor, binding.mapping);\n            const head = (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.relativePositionToAbsolutePosition)(binding.doc, binding.type, relSel.head, binding.mapping);\n            if (anchor !== null && head !== null) {\n                const sel = prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.between(tr.doc.resolve(anchor), tr.doc.resolve(head));\n                tr.setSelection(sel);\n            }\n        }\n    }\n};\n/**\n * @param {ProsemirrorBinding} pmbinding\n * @param {import('prosemirror-state').EditorState} state\n */ const getRelativeSelection = (pmbinding, state)=>({\n        type: /** @type {any} */ state.selection.jsonID,\n        anchor: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(state.selection.anchor, pmbinding.type, pmbinding.mapping),\n        head: (0,_lib_js__WEBPACK_IMPORTED_MODULE_6__.absolutePositionToRelativePosition)(state.selection.head, pmbinding.type, pmbinding.mapping)\n    });\n/**\n * Binding for prosemirror.\n *\n * @protected\n */ class ProsemirrorBinding {\n    /**\n   * @param {Y.XmlFragment} yXmlFragment The bind source\n   * @param {ProsemirrorMapping} mapping\n   */ constructor(yXmlFragment, mapping = new Map()){\n        this.type = yXmlFragment;\n        /**\n     * this will be set once the view is created\n     * @type {any}\n     */ this.prosemirrorView = null;\n        this.mux = (0,lib0_mutex__WEBPACK_IMPORTED_MODULE_7__.createMutex)();\n        this.mapping = mapping;\n        /**\n     * Is overlapping mark - i.e. mark does not exclude itself.\n     *\n     * @type {Map<import('prosemirror-model').MarkType, boolean>}\n     */ this.isOMark = new Map();\n        this._observeFunction = this._typeChanged.bind(this);\n        /**\n     * @type {Y.Doc}\n     */ // @ts-ignore\n        this.doc = yXmlFragment.doc;\n        /**\n     * current selection as relative positions in the Yjs model\n     */ this.beforeTransactionSelection = null;\n        this.beforeAllTransactions = ()=>{\n            if (this.beforeTransactionSelection === null && this.prosemirrorView != null) {\n                this.beforeTransactionSelection = getRelativeSelection(this, this.prosemirrorView.state);\n            }\n        };\n        this.afterAllTransactions = ()=>{\n            this.beforeTransactionSelection = null;\n        };\n        this._domSelectionInView = null;\n    }\n    /**\n   * Create a transaction for changing the prosemirror state.\n   *\n   * @returns\n   */ get _tr() {\n        return this.prosemirrorView.state.tr.setMeta(\"addToHistory\", false);\n    }\n    _isLocalCursorInView() {\n        if (!this.prosemirrorView.hasFocus()) return false;\n        if (lib0_environment__WEBPACK_IMPORTED_MODULE_8__.isBrowser && this._domSelectionInView === null) {\n            // Calculate the domSelectionInView and clear by next tick after all events are finished\n            lib0_eventloop__WEBPACK_IMPORTED_MODULE_5__.timeout(0, ()=>{\n                this._domSelectionInView = null;\n            });\n            this._domSelectionInView = this._isDomSelectionInView();\n        }\n        return this._domSelectionInView;\n    }\n    _isDomSelectionInView() {\n        const selection = this.prosemirrorView._root.getSelection();\n        if (selection == null || selection.anchorNode == null) return false;\n        const range = this.prosemirrorView._root.createRange();\n        range.setStart(selection.anchorNode, selection.anchorOffset);\n        range.setEnd(selection.focusNode, selection.focusOffset);\n        // This is a workaround for an edgecase where getBoundingClientRect will\n        // return zero values if the selection is collapsed at the start of a newline\n        // see reference here: https://stackoverflow.com/a/59780954\n        const rects = range.getClientRects();\n        if (rects.length === 0) {\n            // probably buggy newline behavior, explicitly select the node contents\n            if (range.startContainer && range.collapsed) {\n                range.selectNodeContents(range.startContainer);\n            }\n        }\n        const bounding = range.getBoundingClientRect();\n        const documentElement = lib0_dom__WEBPACK_IMPORTED_MODULE_9__.doc.documentElement;\n        return bounding.bottom >= 0 && bounding.right >= 0 && bounding.left <= (window.innerWidth || documentElement.clientWidth || 0) && bounding.top <= (window.innerHeight || documentElement.clientHeight || 0);\n    }\n    /**\n   * @param {Y.Snapshot} snapshot\n   * @param {Y.Snapshot} prevSnapshot\n   */ renderSnapshot(snapshot, prevSnapshot) {\n        if (!prevSnapshot) {\n            prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.createSnapshot(yjs__WEBPACK_IMPORTED_MODULE_0__.createDeleteSet(), new Map());\n        }\n        this.prosemirrorView.dispatch(this._tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n            snapshot,\n            prevSnapshot\n        }));\n    }\n    unrenderSnapshot() {\n        this.mapping.clear();\n        this.mux(()=>{\n            const fragmentContent = this.type.toArray().map((t)=>createNodeFromYElement(/** @type {Y.XmlElement} */ t, this.prosemirrorView.state.schema, this)).filter((n)=>n !== null);\n            // @ts-ignore\n            const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n            tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                snapshot: null,\n                prevSnapshot: null\n            });\n            this.prosemirrorView.dispatch(tr);\n        });\n    }\n    _forceRerender() {\n        this.mapping.clear();\n        this.mux(()=>{\n            // If this is a forced rerender, this might neither happen as a pm change nor within a Yjs\n            // transaction. Then the \"before selection\" doesn't exist. In this case, we need to create a\n            // relative position before replacing content. Fixes #126\n            const sel = this.beforeTransactionSelection !== null ? null : this.prosemirrorView.state.selection;\n            const fragmentContent = this.type.toArray().map((t)=>createNodeFromYElement(/** @type {Y.XmlElement} */ t, this.prosemirrorView.state.schema, this)).filter((n)=>n !== null);\n            // @ts-ignore\n            const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n            if (sel) {\n                /**\n         * If the Prosemirror document we just created from this.type is\n         * smaller than the previous document, the selection might be\n         * out of bound, which would make Prosemirror throw an error.\n         */ const clampedAnchor = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(lib0_math__WEBPACK_IMPORTED_MODULE_11__.max(sel.anchor, 0), tr.doc.content.size);\n                const clampedHead = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(lib0_math__WEBPACK_IMPORTED_MODULE_11__.max(sel.head, 0), tr.doc.content.size);\n                tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_3__.TextSelection.create(tr.doc, clampedAnchor, clampedHead));\n            }\n            this.prosemirrorView.dispatch(tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                isChangeOrigin: true,\n                binding: this\n            }));\n        });\n    }\n    /**\n   * @param {Y.Snapshot|Uint8Array} snapshot\n   * @param {Y.Snapshot|Uint8Array} prevSnapshot\n   * @param {Object} pluginState\n   */ _renderSnapshot(snapshot, prevSnapshot, pluginState) {\n        /**\n     * The document that contains the full history of this document.\n     * @type {Y.Doc}\n     */ let historyDoc = this.doc;\n        let historyType = this.type;\n        if (!snapshot) {\n            snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(this.doc);\n        }\n        if (snapshot instanceof Uint8Array || prevSnapshot instanceof Uint8Array) {\n            if (!(snapshot instanceof Uint8Array) || !(prevSnapshot instanceof Uint8Array)) {\n                // expected both snapshots to be v2 updates\n                lib0_error__WEBPACK_IMPORTED_MODULE_12__.unexpectedCase();\n            }\n            historyDoc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc({\n                gc: false\n            });\n            yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, prevSnapshot);\n            prevSnapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc);\n            yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdateV2(historyDoc, snapshot);\n            snapshot = yjs__WEBPACK_IMPORTED_MODULE_0__.snapshot(historyDoc);\n            if (historyType._item === null) {\n                /**\n         * If is a root type, we need to find the root key in the initial document\n         * and use it to get the history type.\n         */ const rootKey = Array.from(this.doc.share.keys()).find((key)=>this.doc.share.get(key) === this.type);\n                historyType = historyDoc.getXmlFragment(rootKey);\n            } else {\n                /**\n         * If it is a sub type, we use the item id to find the history type.\n         */ const historyStructs = historyDoc.store.clients.get(historyType._item.id.client) ?? [];\n                const itemIndex = yjs__WEBPACK_IMPORTED_MODULE_0__.findIndexSS(historyStructs, historyType._item.id.clock);\n                const item = /** @type {Y.Item} */ historyStructs[itemIndex];\n                const content = /** @type {Y.ContentType} */ item.content;\n                historyType = /** @type {Y.XmlFragment} */ content.type;\n            }\n        }\n        // clear mapping because we are going to rerender\n        this.mapping.clear();\n        this.mux(()=>{\n            historyDoc.transact((transaction)=>{\n                // before rendering, we are going to sanitize ops and split deleted ops\n                // if they were deleted by seperate users.\n                /**\n         * @type {Y.PermanentUserData}\n         */ const pud = pluginState.permanentUserData;\n                if (pud) {\n                    pud.dss.forEach((ds)=>{\n                        yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, ds, (_item)=>{});\n                    });\n                }\n                /**\n         * @param {'removed'|'added'} type\n         * @param {Y.ID} id\n         */ const computeYChange = (type, id)=>{\n                    const user = type === \"added\" ? pud.getUserByClientId(id.client) : pud.getUserByDeletedId(id);\n                    return {\n                        user,\n                        type,\n                        color: getUserColor(pluginState.colorMapping, pluginState.colors, user)\n                    };\n                };\n                // Create document fragment and render\n                const fragmentContent = yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(historyType, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)).map((t)=>{\n                    if (!t._item.deleted || isVisible(t._item, snapshot) || isVisible(t._item, prevSnapshot)) {\n                        return createNodeFromYElement(t, this.prosemirrorView.state.schema, {\n                            mapping: new Map(),\n                            isOMark: new Map()\n                        }, snapshot, prevSnapshot, computeYChange);\n                    } else {\n                        // No need to render elements that are not visible by either snapshot.\n                        // If a client adds and deletes content in the same snapshot the element is not visible by either snapshot.\n                        return null;\n                    }\n                }).filter((n)=>n !== null);\n                // @ts-ignore\n                const tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n                this.prosemirrorView.dispatch(tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                    isChangeOrigin: true\n                }));\n            }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n        });\n    }\n    /**\n   * @param {Array<Y.YEvent<any>>} events\n   * @param {Y.Transaction} transaction\n   */ _typeChanged(events, transaction) {\n        if (this.prosemirrorView == null) return;\n        const syncState = _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey.getState(this.prosemirrorView.state);\n        if (events.length === 0 || syncState.snapshot != null || syncState.prevSnapshot != null) {\n            // drop out if snapshot is active\n            this.renderSnapshot(syncState.snapshot, syncState.prevSnapshot);\n            return;\n        }\n        this.mux(()=>{\n            /**\n       * @param {any} _\n       * @param {Y.AbstractType<any>} type\n       */ const delType = (_, type)=>this.mapping.delete(type);\n            yjs__WEBPACK_IMPORTED_MODULE_0__.iterateDeletedStructs(transaction, transaction.deleteSet, (struct)=>{\n                if (struct.constructor === yjs__WEBPACK_IMPORTED_MODULE_0__.Item) {\n                    const type = /** @type {Y.ContentType} */ /** @type {Y.Item} */ struct.content.type;\n                    type && this.mapping.delete(type);\n                }\n            });\n            transaction.changed.forEach(delType);\n            transaction.changedParentTypes.forEach(delType);\n            const fragmentContent = this.type.toArray().map((t)=>createNodeIfNotExists(/** @type {Y.XmlElement | Y.XmlHook} */ t, this.prosemirrorView.state.schema, this)).filter((n)=>n !== null);\n            // @ts-ignore\n            let tr = this._tr.replace(0, this.prosemirrorView.state.doc.content.size, new prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_10__.Fragment.from(fragmentContent), 0, 0));\n            restoreRelativeSelection(tr, this.beforeTransactionSelection, this);\n            tr = tr.setMeta(_keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey, {\n                isChangeOrigin: true,\n                isUndoRedoOperation: transaction.origin instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.UndoManager\n            });\n            if (this.beforeTransactionSelection !== null && this._isLocalCursorInView()) {\n                tr.scrollIntoView();\n            }\n            this.prosemirrorView.dispatch(tr);\n        });\n    }\n    /**\n   * @param {import('prosemirror-model').Node} doc\n   */ _prosemirrorChanged(doc) {\n        this.doc.transact(()=>{\n            updateYFragment(this.doc, this.type, doc, this);\n            this.beforeTransactionSelection = getRelativeSelection(this, this.prosemirrorView.state);\n        }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n    }\n    /**\n   * View is ready to listen to changes. Register observers.\n   * @param {any} prosemirrorView\n   */ initView(prosemirrorView) {\n        if (this.prosemirrorView != null) this.destroy();\n        this.prosemirrorView = prosemirrorView;\n        this.doc.on(\"beforeAllTransactions\", this.beforeAllTransactions);\n        this.doc.on(\"afterAllTransactions\", this.afterAllTransactions);\n        this.type.observeDeep(this._observeFunction);\n    }\n    destroy() {\n        if (this.prosemirrorView == null) return;\n        this.prosemirrorView = null;\n        this.type.unobserveDeep(this._observeFunction);\n        this.doc.off(\"beforeAllTransactions\", this.beforeAllTransactions);\n        this.doc.off(\"afterAllTransactions\", this.afterAllTransactions);\n    }\n}\n/**\n * @private\n * @param {Y.XmlElement | Y.XmlHook} el\n * @param {PModel.Schema} schema\n * @param {BindingMetadata} meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null}\n */ const createNodeIfNotExists = (el, schema, meta, snapshot, prevSnapshot, computeYChange)=>{\n    const node = /** @type {PModel.Node} */ meta.mapping.get(el);\n    if (node === undefined) {\n        if (el instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n            return createNodeFromYElement(el, schema, meta, snapshot, prevSnapshot, computeYChange);\n        } else {\n            throw lib0_error__WEBPACK_IMPORTED_MODULE_12__.methodUnimplemented() // we are currently not handling hooks\n            ;\n        }\n    }\n    return node;\n};\n/**\n * @private\n * @param {Y.XmlElement} el\n * @param {any} schema\n * @param {BindingMetadata} meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {PModel.Node | null} Returns node if node could be created. Otherwise it deletes the yjs type and returns null\n */ const createNodeFromYElement = (el, schema, meta, snapshot, prevSnapshot, computeYChange)=>{\n    const children = [];\n    /**\n   * @param {Y.XmlElement | Y.XmlText} type\n   */ const createChildren = (type)=>{\n        if (type instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n            const n = createNodeIfNotExists(type, schema, meta, snapshot, prevSnapshot, computeYChange);\n            if (n !== null) {\n                children.push(n);\n            }\n        } else {\n            // If the next ytext exists and was created by us, move the content to the current ytext.\n            // This is a fix for #160 -- duplication of characters when two Y.Text exist next to each\n            // other.\n            const nextytext = /** @type {Y.ContentType} */ (type._item.right?.content)?.type;\n            if (nextytext instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.Text && !nextytext._item.deleted && nextytext._item.id.client === nextytext.doc.clientID) {\n                type.applyDelta([\n                    {\n                        retain: type.length\n                    },\n                    ...nextytext.toDelta()\n                ]);\n                nextytext.doc.transact((tr)=>{\n                    nextytext._item.delete(tr);\n                });\n            }\n            // now create the prosemirror text nodes\n            const ns = createTextNodesFromYText(type, schema, meta, snapshot, prevSnapshot, computeYChange);\n            if (ns !== null) {\n                ns.forEach((textchild)=>{\n                    if (textchild !== null) {\n                        children.push(textchild);\n                    }\n                });\n            }\n        }\n    };\n    if (snapshot === undefined || prevSnapshot === undefined) {\n        el.toArray().forEach(createChildren);\n    } else {\n        yjs__WEBPACK_IMPORTED_MODULE_0__.typeListToArraySnapshot(el, new yjs__WEBPACK_IMPORTED_MODULE_0__.Snapshot(prevSnapshot.ds, snapshot.sv)).forEach(createChildren);\n    }\n    try {\n        const attrs = el.getAttributes(snapshot);\n        if (snapshot !== undefined) {\n            if (!isVisible(/** @type {Y.Item} */ el._item, snapshot)) {\n                attrs.ychange = computeYChange ? computeYChange(\"removed\", /** @type {Y.Item} */ el._item.id) : {\n                    type: \"removed\"\n                };\n            } else if (!isVisible(/** @type {Y.Item} */ el._item, prevSnapshot)) {\n                attrs.ychange = computeYChange ? computeYChange(\"added\", /** @type {Y.Item} */ el._item.id) : {\n                    type: \"added\"\n                };\n            }\n        }\n        const node = schema.node(el.nodeName, attrs, children);\n        meta.mapping.set(el, node);\n        return node;\n    } catch (e) {\n        // an error occured while creating the node. This is probably a result of a concurrent action.\n        /** @type {Y.Doc} */ el.doc.transact((transaction)=>{\n            /** @type {Y.Item} */ el._item.delete(transaction);\n        }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n        meta.mapping.delete(el);\n        return null;\n    }\n};\n/**\n * @private\n * @param {Y.XmlText} text\n * @param {import('prosemirror-model').Schema} schema\n * @param {BindingMetadata} _meta\n * @param {Y.Snapshot} [snapshot]\n * @param {Y.Snapshot} [prevSnapshot]\n * @param {function('removed' | 'added', Y.ID):any} [computeYChange]\n * @return {Array<PModel.Node>|null}\n */ const createTextNodesFromYText = (text, schema, _meta, snapshot, prevSnapshot, computeYChange)=>{\n    const nodes = [];\n    const deltas = text.toDelta(snapshot, prevSnapshot, computeYChange);\n    try {\n        for(let i = 0; i < deltas.length; i++){\n            const delta = deltas[i];\n            nodes.push(schema.text(delta.insert, attributesToMarks(delta.attributes, schema)));\n        }\n    } catch (e) {\n        // an error occured while creating the node. This is probably a result of a concurrent action.\n        /** @type {Y.Doc} */ text.doc.transact((transaction)=>{\n            /** @type {Y.Item} */ text._item.delete(transaction);\n        }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n        return null;\n    }\n    // @ts-ignore\n    return nodes;\n};\n/**\n * @private\n * @param {Array<any>} nodes prosemirror node\n * @param {BindingMetadata} meta\n * @return {Y.XmlText}\n */ const createTypeFromTextNodes = (nodes, meta)=>{\n    const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText();\n    const delta = nodes.map((node)=>({\n            // @ts-ignore\n            insert: node.text,\n            attributes: marksToAttributes(node.marks, meta)\n        }));\n    type.applyDelta(delta);\n    meta.mapping.set(type, nodes);\n    return type;\n};\n/**\n * @private\n * @param {any} node prosemirror node\n * @param {BindingMetadata} meta\n * @return {Y.XmlElement}\n */ const createTypeFromElementNode = (node, meta)=>{\n    const type = new yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement(node.type.name);\n    for(const key in node.attrs){\n        const val = node.attrs[key];\n        if (val !== null && key !== \"ychange\") {\n            type.setAttribute(key, val);\n        }\n    }\n    type.insert(0, normalizePNodeContent(node).map((n)=>createTypeFromTextOrElementNode(n, meta)));\n    meta.mapping.set(type, node);\n    return type;\n};\n/**\n * @private\n * @param {PModel.Node|Array<PModel.Node>} node prosemirror text node\n * @param {BindingMetadata} meta\n * @return {Y.XmlElement|Y.XmlText}\n */ const createTypeFromTextOrElementNode = (node, meta)=>node instanceof Array ? createTypeFromTextNodes(node, meta) : createTypeFromElementNode(node, meta);\n/**\n * @param {any} val\n */ const isObject = (val)=>typeof val === \"object\" && val !== null;\n/**\n * @param {any} pattrs\n * @param {any} yattrs\n */ const equalAttrs = (pattrs, yattrs)=>{\n    const keys = Object.keys(pattrs).filter((key)=>pattrs[key] !== null);\n    let eq = keys.length === (yattrs == null ? 0 : Object.keys(yattrs).filter((key)=>yattrs[key] !== null).length);\n    for(let i = 0; i < keys.length && eq; i++){\n        const key = keys[i];\n        const l = pattrs[key];\n        const r = yattrs[key];\n        eq = key === \"ychange\" || l === r || isObject(l) && isObject(r) && equalAttrs(l, r);\n    }\n    return eq;\n};\n/**\n * @typedef {Array<Array<PModel.Node>|PModel.Node>} NormalizedPNodeContent\n */ /**\n * @param {any} pnode\n * @return {NormalizedPNodeContent}\n */ const normalizePNodeContent = (pnode)=>{\n    const c = pnode.content.content;\n    const res = [];\n    for(let i = 0; i < c.length; i++){\n        const n = c[i];\n        if (n.isText) {\n            const textNodes = [];\n            for(let tnode = c[i]; i < c.length && tnode.isText; tnode = c[++i]){\n                textNodes.push(tnode);\n            }\n            i--;\n            res.push(textNodes);\n        } else {\n            res.push(n);\n        }\n    }\n    return res;\n};\n/**\n * @param {Y.XmlText} ytext\n * @param {Array<any>} ptexts\n */ const equalYTextPText = (ytext, ptexts)=>{\n    const delta = ytext.toDelta();\n    return delta.length === ptexts.length && delta.every(/** @type {(d:any,i:number) => boolean} */ (d, i)=>d.insert === /** @type {any} */ ptexts[i].text && lib0_object__WEBPACK_IMPORTED_MODULE_13__.keys(d.attributes || {}).length === ptexts[i].marks.length && lib0_object__WEBPACK_IMPORTED_MODULE_13__.every(d.attributes, (attr, yattrname)=>{\n            const markname = yattr2markname(yattrname);\n            const pmarks = ptexts[i].marks;\n            return equalAttrs(attr, pmarks.find(/** @param {any} mark */ (mark)=>mark.type.name === markname)?.attrs);\n        }));\n};\n/**\n * @param {Y.XmlElement|Y.XmlText|Y.XmlHook} ytype\n * @param {any|Array<any>} pnode\n */ const equalYTypePNode = (ytype, pnode)=>{\n    if (ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && !(pnode instanceof Array) && matchNodeName(ytype, pnode)) {\n        const normalizedContent = normalizePNodeContent(pnode);\n        return ytype._length === normalizedContent.length && equalAttrs(ytype.getAttributes(), pnode.attrs) && ytype.toArray().every((ychild, i)=>equalYTypePNode(ychild, normalizedContent[i]));\n    }\n    return ytype instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && pnode instanceof Array && equalYTextPText(ytype, pnode);\n};\n/**\n * @param {PModel.Node | Array<PModel.Node> | undefined} mapped\n * @param {PModel.Node | Array<PModel.Node>} pcontent\n */ const mappedIdentity = (mapped, pcontent)=>mapped === pcontent || mapped instanceof Array && pcontent instanceof Array && mapped.length === pcontent.length && mapped.every((a, i)=>pcontent[i] === a);\n/**\n * @param {Y.XmlElement} ytype\n * @param {PModel.Node} pnode\n * @param {BindingMetadata} meta\n * @return {{ foundMappedChild: boolean, equalityFactor: number }}\n */ const computeChildEqualityFactor = (ytype, pnode, meta)=>{\n    const yChildren = ytype.toArray();\n    const pChildren = normalizePNodeContent(pnode);\n    const pChildCnt = pChildren.length;\n    const yChildCnt = yChildren.length;\n    const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(yChildCnt, pChildCnt);\n    let left = 0;\n    let right = 0;\n    let foundMappedChild = false;\n    for(; left < minCnt; left++){\n        const leftY = yChildren[left];\n        const leftP = pChildren[left];\n        if (mappedIdentity(meta.mapping.get(leftY), leftP)) {\n            foundMappedChild = true // definite (good) match!\n            ;\n        } else if (!equalYTypePNode(leftY, leftP)) {\n            break;\n        }\n    }\n    for(; left + right < minCnt; right++){\n        const rightY = yChildren[yChildCnt - right - 1];\n        const rightP = pChildren[pChildCnt - right - 1];\n        if (mappedIdentity(meta.mapping.get(rightY), rightP)) {\n            foundMappedChild = true;\n        } else if (!equalYTypePNode(rightY, rightP)) {\n            break;\n        }\n    }\n    return {\n        equalityFactor: left + right,\n        foundMappedChild\n    };\n};\n/**\n * @param {Y.Text} ytext\n */ const ytextTrans = (ytext)=>{\n    let str = \"\";\n    /**\n   * @type {Y.Item|null}\n   */ let n = ytext._start;\n    const nAttrs = {};\n    while(n !== null){\n        if (!n.deleted) {\n            if (n.countable && n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentString) {\n                str += n.content.str;\n            } else if (n.content instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.ContentFormat) {\n                nAttrs[n.content.key] = null;\n            }\n        }\n        n = n.right;\n    }\n    return {\n        str,\n        nAttrs\n    };\n};\n/**\n * @todo test this more\n *\n * @param {Y.Text} ytext\n * @param {Array<any>} ptexts\n * @param {BindingMetadata} meta\n */ const updateYText = (ytext, ptexts, meta)=>{\n    meta.mapping.set(ytext, ptexts);\n    const { nAttrs, str } = ytextTrans(ytext);\n    const content = ptexts.map((p)=>({\n            insert: /** @type {any} */ p.text,\n            attributes: Object.assign({}, nAttrs, marksToAttributes(p.marks, meta))\n        }));\n    const { insert, remove, index } = (0,lib0_diff__WEBPACK_IMPORTED_MODULE_14__.simpleDiff)(str, content.map((c)=>c.insert).join(\"\"));\n    ytext.delete(index, remove);\n    ytext.insert(index, insert);\n    ytext.applyDelta(content.map((c)=>({\n            retain: c.insert.length,\n            attributes: c.attributes\n        })));\n};\nconst hashedMarkNameRegex = /(.*)(--[a-zA-Z0-9+/=]{8})$/;\n/**\n * @param {string} attrName\n */ const yattr2markname = (attrName)=>hashedMarkNameRegex.exec(attrName)?.[1] ?? attrName;\n/**\n * @todo move this to markstoattributes\n *\n * @param {Object<string, any>} attrs\n * @param {import('prosemirror-model').Schema} schema\n */ const attributesToMarks = (attrs, schema)=>{\n    /**\n   * @type {Array<import('prosemirror-model').Mark>}\n   */ const marks = [];\n    for(const markName in attrs){\n        // remove hashes if necessary\n        marks.push(schema.mark(yattr2markname(markName), attrs[markName]));\n    }\n    return marks;\n};\n/**\n * @param {Array<import('prosemirror-model').Mark>} marks\n * @param {BindingMetadata} meta\n */ const marksToAttributes = (marks, meta)=>{\n    const pattrs = {};\n    marks.forEach((mark)=>{\n        if (mark.type.name !== \"ychange\") {\n            const isOverlapping = lib0_map__WEBPACK_IMPORTED_MODULE_15__.setIfUndefined(meta.isOMark, mark.type, ()=>!mark.type.excludes(mark.type));\n            pattrs[isOverlapping ? `${mark.type.name}--${_utils_js__WEBPACK_IMPORTED_MODULE_16__.hashOfJSON(mark.toJSON())}` : mark.type.name] = mark.attrs;\n        }\n    });\n    return pattrs;\n};\n/**\n * Update a yDom node by syncing the current content of the prosemirror node.\n *\n * This is a y-prosemirror internal feature that you can use at your own risk.\n *\n * @private\n * @unstable\n *\n * @param {{transact: Function}} y\n * @param {Y.XmlFragment} yDomFragment\n * @param {any} pNode\n * @param {BindingMetadata} meta\n */ const updateYFragment = (y, yDomFragment, pNode, meta)=>{\n    if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && yDomFragment.nodeName !== pNode.type.name) {\n        throw new Error(\"node name mismatch!\");\n    }\n    meta.mapping.set(yDomFragment, pNode);\n    // update attributes\n    if (yDomFragment instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement) {\n        const yDomAttrs = yDomFragment.getAttributes();\n        const pAttrs = pNode.attrs;\n        for(const key in pAttrs){\n            if (pAttrs[key] !== null) {\n                if (yDomAttrs[key] !== pAttrs[key] && key !== \"ychange\") {\n                    yDomFragment.setAttribute(key, pAttrs[key]);\n                }\n            } else {\n                yDomFragment.removeAttribute(key);\n            }\n        }\n        // remove all keys that are no longer in pAttrs\n        for(const key in yDomAttrs){\n            if (pAttrs[key] === undefined) {\n                yDomFragment.removeAttribute(key);\n            }\n        }\n    }\n    // update children\n    const pChildren = normalizePNodeContent(pNode);\n    const pChildCnt = pChildren.length;\n    const yChildren = yDomFragment.toArray();\n    const yChildCnt = yChildren.length;\n    const minCnt = lib0_math__WEBPACK_IMPORTED_MODULE_11__.min(pChildCnt, yChildCnt);\n    let left = 0;\n    let right = 0;\n    // find number of matching elements from left\n    for(; left < minCnt; left++){\n        const leftY = yChildren[left];\n        const leftP = pChildren[left];\n        if (!mappedIdentity(meta.mapping.get(leftY), leftP)) {\n            if (equalYTypePNode(leftY, leftP)) {\n                // update mapping\n                meta.mapping.set(leftY, leftP);\n            } else {\n                break;\n            }\n        }\n    }\n    // find number of matching elements from right\n    for(; right + left < minCnt; right++){\n        const rightY = yChildren[yChildCnt - right - 1];\n        const rightP = pChildren[pChildCnt - right - 1];\n        if (!mappedIdentity(meta.mapping.get(rightY), rightP)) {\n            if (equalYTypePNode(rightY, rightP)) {\n                // update mapping\n                meta.mapping.set(rightY, rightP);\n            } else {\n                break;\n            }\n        }\n    }\n    y.transact(()=>{\n        // try to compare and update\n        while(yChildCnt - left - right > 0 && pChildCnt - left - right > 0){\n            const leftY = yChildren[left];\n            const leftP = pChildren[left];\n            const rightY = yChildren[yChildCnt - right - 1];\n            const rightP = pChildren[pChildCnt - right - 1];\n            if (leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText && leftP instanceof Array) {\n                if (!equalYTextPText(leftY, leftP)) {\n                    updateYText(leftY, leftP, meta);\n                }\n                left += 1;\n            } else {\n                let updateLeft = leftY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && matchNodeName(leftY, leftP);\n                let updateRight = rightY instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlElement && matchNodeName(rightY, rightP);\n                if (updateLeft && updateRight) {\n                    // decide which which element to update\n                    const equalityLeft = computeChildEqualityFactor(/** @type {Y.XmlElement} */ leftY, /** @type {PModel.Node} */ leftP, meta);\n                    const equalityRight = computeChildEqualityFactor(/** @type {Y.XmlElement} */ rightY, /** @type {PModel.Node} */ rightP, meta);\n                    if (equalityLeft.foundMappedChild && !equalityRight.foundMappedChild) {\n                        updateRight = false;\n                    } else if (!equalityLeft.foundMappedChild && equalityRight.foundMappedChild) {\n                        updateLeft = false;\n                    } else if (equalityLeft.equalityFactor < equalityRight.equalityFactor) {\n                        updateLeft = false;\n                    } else {\n                        updateRight = false;\n                    }\n                }\n                if (updateLeft) {\n                    updateYFragment(y, /** @type {Y.XmlFragment} */ leftY, /** @type {PModel.Node} */ leftP, meta);\n                    left += 1;\n                } else if (updateRight) {\n                    updateYFragment(y, /** @type {Y.XmlFragment} */ rightY, /** @type {PModel.Node} */ rightP, meta);\n                    right += 1;\n                } else {\n                    meta.mapping.delete(yDomFragment.get(left));\n                    yDomFragment.delete(left, 1);\n                    yDomFragment.insert(left, [\n                        createTypeFromTextOrElementNode(leftP, meta)\n                    ]);\n                    left += 1;\n                }\n            }\n        }\n        const yDelLen = yChildCnt - left - right;\n        if (yChildCnt === 1 && pChildCnt === 0 && yChildren[0] instanceof yjs__WEBPACK_IMPORTED_MODULE_0__.XmlText) {\n            meta.mapping.delete(yChildren[0]);\n            // Edge case handling https://github.com/yjs/y-prosemirror/issues/108\n            // Only delete the content of the Y.Text to retain remote changes on the same Y.Text object\n            yChildren[0].delete(0, yChildren[0].length);\n        } else if (yDelLen > 0) {\n            yDomFragment.slice(left, left + yDelLen).forEach((type)=>meta.mapping.delete(type));\n            yDomFragment.delete(left, yDelLen);\n        }\n        if (left + right < pChildCnt) {\n            const ins = [];\n            for(let i = left; i < pChildCnt - right; i++){\n                ins.push(createTypeFromTextOrElementNode(pChildren[i], meta));\n            }\n            yDomFragment.insert(left, ins);\n        }\n    }, _keys_js__WEBPACK_IMPORTED_MODULE_4__.ySyncPluginKey);\n};\n/**\n * @function\n * @param {Y.XmlElement} yElement\n * @param {any} pNode Prosemirror Node\n */ const matchNodeName = (yElement, pNode)=>!(pNode instanceof Array) && yElement.nodeName === pNode.type.name;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9zeW5jLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztDQUVDLEdBRXVDO0FBQ0c7QUFDNEMsQ0FBQyxzQkFBc0I7QUFDN0U7QUFDSTtBQUNOO0FBQ087QUFDSDtBQUN1QjtBQUNsQztBQUlOO0FBQ21CO0FBQ1U7QUFDaEI7QUFDWTtBQUNaO0FBQ0s7QUFFcEM7Ozs7Q0FJQyxHQUVEOztDQUVDLEdBQ00sTUFBTXNCLGtCQUFrQixJQUFPO1FBQ3BDQyxTQUFTLElBQUlDO1FBQ2JDLFNBQVMsSUFBSUQ7SUFDZixHQUFFO0FBRUY7OztDQUdDLEdBQ00sTUFBTUUsWUFBWSxDQUFDQyxNQUFNQyxXQUM5QkEsYUFBYUMsWUFDVCxDQUFDRixLQUFLRyxPQUFPLEdBQ1pGLFNBQVNHLEVBQUUsQ0FBQ0MsR0FBRyxDQUFDTCxLQUFLTSxFQUFFLENBQUNDLE1BQU0sS0FDL0IsbUJBRHVELEdBQ3RETixTQUFTRyxFQUFFLENBQUNJLEdBQUcsQ0FBQ1IsS0FBS00sRUFBRSxDQUFDQyxNQUFNLElBQUtQLEtBQUtNLEVBQUUsQ0FBQ0csS0FBSyxJQUNqRCxDQUFDdkIsMENBQVcsQ0FBQ2UsU0FBU1UsRUFBRSxFQUFFWCxLQUFLTSxFQUFFLEVBQUU7QUFFekM7OztDQUdDLEdBRUQ7Ozs7Q0FJQyxHQUVEOzs7Ozs7O0NBT0MsR0FFRDs7Q0FFQyxHQUNELE1BQU1NLGdCQUFnQjtJQUFDO1FBQUVDLE9BQU87UUFBYUMsTUFBTTtJQUFVO0NBQUU7QUFFL0Q7Ozs7O0NBS0MsR0FDRCxNQUFNQyxlQUFlLENBQUNDLGNBQWNDLFFBQVFDO0lBQzFDLG9EQUFvRDtJQUNwRCxJQUFJLENBQUNGLGFBQWFYLEdBQUcsQ0FBQ2EsT0FBTztRQUMzQixJQUFJRixhQUFhRyxJQUFJLEdBQUdGLE9BQU9HLE1BQU0sRUFBRTtZQUNyQyxNQUFNQyxhQUFheEMsNENBQVU7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TCxNQUFNLENBQUN4STtZQUM3RW1RLGFBQWEzSCxNQUFNLENBQUMxRCxNQUFNK0w7UUFDNUI7UUFDQSxJQUFJL0wsT0FBT0QsUUFBUXVKLFdBQVc7WUFDNUIsTUFBTTJDLE1BQU0sRUFBRTtZQUNkLElBQUssSUFBSS9GLElBQUlsRyxNQUFNa0csSUFBSW9ELFlBQVl2SixPQUFPbUcsSUFBSztnQkFDN0MrRixJQUFJbEgsSUFBSSxDQUFDaUMsZ0NBQWdDcUMsU0FBUyxDQUFDbkQsRUFBRSxFQUFFbEo7WUFDekQ7WUFDQXFPLGFBQWFqRixNQUFNLENBQUNwRyxNQUFNaU07UUFDNUI7SUFDRixHQUFHN1Usb0RBQWNBO0FBQ25CLEVBQUM7QUFFRDs7OztDQUlDLEdBQ0QsTUFBTXVSLGdCQUFnQixDQUFDdUQsVUFBVVosUUFDL0IsQ0FBRUEsQ0FBQUEsaUJBQWlCbEosS0FBSSxLQUFNOEosU0FBU3RHLFFBQVEsS0FBSzBGLE1BQU1wUSxJQUFJLENBQUMwTCxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy9zeW5jLXBsdWdpbi5qcz8wZWUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSBiaW5kaW5ncy9wcm9zZW1pcnJvclxuICovXG5cbmltcG9ydCB7IGNyZWF0ZU11dGV4IH0gZnJvbSAnbGliMC9tdXRleCdcbmltcG9ydCAqIGFzIFBNb2RlbCBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCdcbmltcG9ydCB7IEFsbFNlbGVjdGlvbiwgUGx1Z2luLCBUZXh0U2VsZWN0aW9uLCBOb2RlU2VsZWN0aW9uIH0gZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJ2xpYjAvb2JqZWN0J1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJ2xpYjAvc2V0J1xuaW1wb3J0IHsgc2ltcGxlRGlmZiB9IGZyb20gJ2xpYjAvZGlmZidcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgeyB5U3luY1BsdWdpbktleSwgeVVuZG9QbHVnaW5LZXkgfSBmcm9tICcuL2tleXMuanMnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7XG4gIGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24sXG4gIHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb25cbn0gZnJvbSAnLi4vbGliLmpzJ1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJ1xuaW1wb3J0ICogYXMgZW52aXJvbm1lbnQgZnJvbSAnbGliMC9lbnZpcm9ubWVudCdcbmltcG9ydCAqIGFzIGRvbSBmcm9tICdsaWIwL2RvbSdcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICdsaWIwL2V2ZW50bG9vcCdcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEJpbmRpbmdNZXRhZGF0YVxuICogQHByb3BlcnR5IHtQcm9zZW1pcnJvck1hcHBpbmd9IEJpbmRpbmdNZXRhZGF0YS5tYXBwaW5nXG4gKiBAcHJvcGVydHkge01hcDxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFya1R5cGUsIGJvb2xlYW4+fSBCaW5kaW5nTWV0YWRhdGEuaXNPTWFyayAtIGlzIG92ZXJsYXBwaW5nIG1hcmtcbiAqL1xuXG4vKipcbiAqIEByZXR1cm4ge0JpbmRpbmdNZXRhZGF0YX1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUVtcHR5TWV0YSA9ICgpID0+ICh7XG4gIG1hcHBpbmc6IG5ldyBNYXAoKSxcbiAgaXNPTWFyazogbmV3IE1hcCgpXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7WS5JdGVtfSBpdGVtXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmlzaWJsZSA9IChpdGVtLCBzbmFwc2hvdCkgPT5cbiAgc25hcHNob3QgPT09IHVuZGVmaW5lZFxuICAgID8gIWl0ZW0uZGVsZXRlZFxuICAgIDogKHNuYXBzaG90LnN2LmhhcyhpdGVtLmlkLmNsaWVudCkgJiYgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICAoc25hcHNob3Quc3YuZ2V0KGl0ZW0uaWQuY2xpZW50KSkgPiBpdGVtLmlkLmNsb2NrICYmXG4gICAgICAhWS5pc0RlbGV0ZWQoc25hcHNob3QuZHMsIGl0ZW0uaWQpKVxuXG4vKipcbiAqIEVpdGhlciBhIG5vZGUgaWYgdHlwZSBpcyBZWG1sRWxlbWVudCBvciBhbiBBcnJheSBvZiB0ZXh0IG5vZGVzIGlmIFlYbWxUZXh0XG4gKiBAdHlwZWRlZiB7TWFwPFkuQWJzdHJhY3RUeXBlPGFueT4sIFBNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+Pn0gUHJvc2VtaXJyb3JNYXBwaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb2xvckRlZlxuICogQHByb3BlcnR5IHtzdHJpbmd9IENvbG9yRGVmLmxpZ2h0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gQ29sb3JEZWYuZGFya1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gWVN5bmNPcHRzXG4gKiBAcHJvcGVydHkge0FycmF5PENvbG9yRGVmPn0gW1lTeW5jT3B0cy5jb2xvcnNdXG4gKiBAcHJvcGVydHkge01hcDxzdHJpbmcsQ29sb3JEZWY+fSBbWVN5bmNPcHRzLmNvbG9yTWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7WS5QZXJtYW5lbnRVc2VyRGF0YXxudWxsfSBbWVN5bmNPcHRzLnBlcm1hbmVudFVzZXJEYXRhXVxuICogQHByb3BlcnR5IHtQcm9zZW1pcnJvck1hcHBpbmd9IFtZU3luY09wdHMubWFwcGluZ11cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtZU3luY09wdHMub25GaXJzdFJlbmRlcl0gRmlyZWQgd2hlbiB0aGUgY29udGVudCBmcm9tIFlqcyBpcyBpbml0aWFsbHkgcmVuZGVyZWQgdG8gUHJvc2VNaXJyb3JcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxDb2xvckRlZj59XG4gKi9cbmNvbnN0IGRlZmF1bHRDb2xvcnMgPSBbeyBsaWdodDogJyNlY2Q0NDQzMycsIGRhcms6ICcjZWNkNDQ0JyB9XVxuXG4vKipcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxDb2xvckRlZj59IGNvbG9yTWFwcGluZ1xuICogQHBhcmFtIHtBcnJheTxDb2xvckRlZj59IGNvbG9yc1xuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJcbiAqIEByZXR1cm4ge0NvbG9yRGVmfVxuICovXG5jb25zdCBnZXRVc2VyQ29sb3IgPSAoY29sb3JNYXBwaW5nLCBjb2xvcnMsIHVzZXIpID0+IHtcbiAgLy8gQHRvZG8gZG8gbm90IGhpdCB0aGUgc2FtZSBjb2xvciB0d2ljZSBpZiBwb3NzaWJsZVxuICBpZiAoIWNvbG9yTWFwcGluZy5oYXModXNlcikpIHtcbiAgICBpZiAoY29sb3JNYXBwaW5nLnNpemUgPCBjb2xvcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1c2VkQ29sb3JzID0gc2V0LmNyZWF0ZSgpXG4gICAgICBjb2xvck1hcHBpbmcuZm9yRWFjaCgoY29sb3IpID0+IHVzZWRDb2xvcnMuYWRkKGNvbG9yKSlcbiAgICAgIGNvbG9ycyA9IGNvbG9ycy5maWx0ZXIoKGNvbG9yKSA9PiAhdXNlZENvbG9ycy5oYXMoY29sb3IpKVxuICAgIH1cbiAgICBjb2xvck1hcHBpbmcuc2V0KHVzZXIsIHJhbmRvbS5vbmVPZihjb2xvcnMpKVxuICB9XG4gIHJldHVybiAvKiogQHR5cGUge0NvbG9yRGVmfSAqLyAoY29sb3JNYXBwaW5nLmdldCh1c2VyKSlcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBsaXN0ZW5zIHRvIGNoYW5nZXMgaW4gcHJvc2VtaXJyb3IgdmlldyBhbmQga2VlcHMgeVhtbFN0YXRlIGFuZCB2aWV3IGluIHN5bmMuXG4gKlxuICogVGhpcyBwbHVnaW4gYWxzbyBrZWVwcyByZWZlcmVuY2VzIHRvIHRoZSB0eXBlIGFuZCB0aGUgc2hhcmVkIGRvY3VtZW50IHNvIG90aGVyIHBsdWdpbnMgY2FuIGFjY2VzcyBpdC5cbiAqIEBwYXJhbSB7WS5YbWxGcmFnbWVudH0geVhtbEZyYWdtZW50XG4gKiBAcGFyYW0ge1lTeW5jT3B0c30gb3B0c1xuICogQHJldHVybiB7YW55fSBSZXR1cm5zIGEgcHJvc2VtaXJyb3IgcGx1Z2luIHRoYXQgYmluZHMgdG8gdGhpcyB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCB5U3luY1BsdWdpbiA9ICh5WG1sRnJhZ21lbnQsIHtcbiAgY29sb3JzID0gZGVmYXVsdENvbG9ycyxcbiAgY29sb3JNYXBwaW5nID0gbmV3IE1hcCgpLFxuICBwZXJtYW5lbnRVc2VyRGF0YSA9IG51bGwsXG4gIG9uRmlyc3RSZW5kZXIgPSAoKSA9PiB7fSxcbiAgbWFwcGluZ1xufSA9IHt9KSA9PiB7XG4gIGxldCBpbml0aWFsQ29udGVudENoYW5nZWQgPSBmYWxzZVxuICBjb25zdCBiaW5kaW5nID0gbmV3IFByb3NlbWlycm9yQmluZGluZyh5WG1sRnJhZ21lbnQsIG1hcHBpbmcpXG4gIGNvbnN0IHBsdWdpbiA9IG5ldyBQbHVnaW4oe1xuICAgIHByb3BzOiB7XG4gICAgICBlZGl0YWJsZTogKHN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHN5bmNTdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgICByZXR1cm4gc3luY1N0YXRlLnNuYXBzaG90ID09IG51bGwgJiYgc3luY1N0YXRlLnByZXZTbmFwc2hvdCA9PSBudWxsXG4gICAgICB9XG4gICAgfSxcbiAgICBrZXk6IHlTeW5jUGx1Z2luS2V5LFxuICAgIHN0YXRlOiB7XG4gICAgICAvKipcbiAgICAgICAqIEByZXR1cm5zIHthbnl9XG4gICAgICAgKi9cbiAgICAgIGluaXQ6IChfaW5pdGFyZ3MsIF9zdGF0ZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6IHlYbWxGcmFnbWVudCxcbiAgICAgICAgICBkb2M6IHlYbWxGcmFnbWVudC5kb2MsXG4gICAgICAgICAgYmluZGluZyxcbiAgICAgICAgICBzbmFwc2hvdDogbnVsbCxcbiAgICAgICAgICBwcmV2U25hcHNob3Q6IG51bGwsXG4gICAgICAgICAgaXNDaGFuZ2VPcmlnaW46IGZhbHNlLFxuICAgICAgICAgIGlzVW5kb1JlZG9PcGVyYXRpb246IGZhbHNlLFxuICAgICAgICAgIGFkZFRvSGlzdG9yeTogdHJ1ZSxcbiAgICAgICAgICBjb2xvcnMsXG4gICAgICAgICAgY29sb3JNYXBwaW5nLFxuICAgICAgICAgIHBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhcHBseTogKHRyLCBwbHVnaW5TdGF0ZSkgPT4ge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSB0ci5nZXRNZXRhKHlTeW5jUGx1Z2luS2V5KVxuICAgICAgICBpZiAoY2hhbmdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwbHVnaW5TdGF0ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBsdWdpblN0YXRlKVxuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNoYW5nZSkge1xuICAgICAgICAgICAgcGx1Z2luU3RhdGVba2V5XSA9IGNoYW5nZVtrZXldXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBsdWdpblN0YXRlLmFkZFRvSGlzdG9yeSA9IHRyLmdldE1ldGEoJ2FkZFRvSGlzdG9yeScpICE9PSBmYWxzZVxuICAgICAgICAvLyBhbHdheXMgc2V0IGlzQ2hhbmdlT3JpZ2luLiBJZiB1bmRlZmluZWQsIHRoaXMgaXMgbm90IGNoYW5nZSBvcmlnaW4uXG4gICAgICAgIHBsdWdpblN0YXRlLmlzQ2hhbmdlT3JpZ2luID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAhIWNoYW5nZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICBwbHVnaW5TdGF0ZS5pc1VuZG9SZWRvT3BlcmF0aW9uID0gY2hhbmdlICE9PSB1bmRlZmluZWQgJiYgISFjaGFuZ2UuaXNDaGFuZ2VPcmlnaW4gJiYgISFjaGFuZ2UuaXNVbmRvUmVkb09wZXJhdGlvblxuICAgICAgICBpZiAoYmluZGluZy5wcm9zZW1pcnJvclZpZXcgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBjaGFuZ2UgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgKGNoYW5nZS5zbmFwc2hvdCAhPSBudWxsIHx8IGNoYW5nZS5wcmV2U25hcHNob3QgIT0gbnVsbClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIHNuYXBzaG90IGNoYW5nZWQsIHJlcmVuZGVyIG5leHRcbiAgICAgICAgICAgIGV2ZW50bG9vcC50aW1lb3V0KDAsICgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGJpbmRpbmcucHJvc2VtaXJyb3JWaWV3ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY2hhbmdlLnJlc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnByZXZTbmFwc2hvdCxcbiAgICAgICAgICAgICAgICAgIHBsdWdpblN0YXRlXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuX3JlbmRlclNuYXBzaG90KFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgY2hhbmdlLnNuYXBzaG90LFxuICAgICAgICAgICAgICAgICAgcGx1Z2luU3RhdGVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgdG8gY3VycmVudCBwcm9zZW1pcnJvciBzdGF0ZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwbHVnaW5TdGF0ZS5yZXN0b3JlXG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnNuYXBzaG90XG4gICAgICAgICAgICAgICAgZGVsZXRlIHBsdWdpblN0YXRlLnByZXZTbmFwc2hvdFxuICAgICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGJpbmRpbmcuX3Byb3NlbWlycm9yQ2hhbmdlZChcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBsdWdpblN0YXRlXG4gICAgICB9XG4gICAgfSxcbiAgICB2aWV3OiAodmlldykgPT4ge1xuICAgICAgYmluZGluZy5pbml0Vmlldyh2aWV3KVxuICAgICAgaWYgKG1hcHBpbmcgPT0gbnVsbCkge1xuICAgICAgICAvLyBmb3JjZSByZXJlbmRlciB0byB1cGRhdGUgdGhlIGJpbmRpbmdzIG1hcHBpbmdcbiAgICAgICAgYmluZGluZy5fZm9yY2VSZXJlbmRlcigpXG4gICAgICB9XG4gICAgICBvbkZpcnN0UmVuZGVyKClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHBsdWdpblN0YXRlID0gcGx1Z2luLmdldFN0YXRlKHZpZXcuc3RhdGUpXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgcGx1Z2luU3RhdGUuc25hcHNob3QgPT0gbnVsbCAmJiBwbHVnaW5TdGF0ZS5wcmV2U25hcHNob3QgPT0gbnVsbFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAvLyBJZiB0aGUgY29udGVudCBkb2Vzbid0IGNoYW5nZSBpbml0aWFsbHksIHdlIGRvbid0IHJlbmRlciBhbnl0aGluZyB0byBZanNcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRlbnQgd2FzIGNsZWFyZWQgYnkgYSB1c2VyIGFjdGlvbiwgd2Ugd2FudCB0byBjYXRjaCB0aGUgY2hhbmdlIGFuZFxuICAgICAgICAgICAgICAvLyByZXByZXNlbnQgaXQgaW4gWWpzXG4gICAgICAgICAgICAgIGluaXRpYWxDb250ZW50Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICB2aWV3LnN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoXG4gICAgICAgICAgICAgICAgdmlldy5zdGF0ZS5kb2MudHlwZS5jcmVhdGVBbmRGaWxsKCkuY29udGVudFxuICAgICAgICAgICAgICApICE9PSBudWxsXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaW5pdGlhbENvbnRlbnRDaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuYWRkVG9IaXN0b3J5ID09PSBmYWxzZSAmJlxuICAgICAgICAgICAgICAgICFwbHVnaW5TdGF0ZS5pc0NoYW5nZU9yaWdpblxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBjb25zdCB5VW5kb1BsdWdpblN0YXRlID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7WS5VbmRvTWFuYWdlcn1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB1bSA9IHlVbmRvUGx1Z2luU3RhdGUgJiYgeVVuZG9QbHVnaW5TdGF0ZS51bmRvTWFuYWdlclxuICAgICAgICAgICAgICAgIGlmICh1bSkge1xuICAgICAgICAgICAgICAgICAgdW0uc3RvcENhcHR1cmluZygpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJpbmRpbmcubXV4KCgpID0+IHtcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge1kuRG9jfSAqLyAocGx1Z2luU3RhdGUuZG9jKS50cmFuc2FjdCgodHIpID0+IHtcbiAgICAgICAgICAgICAgICAgIHRyLm1ldGEuc2V0KCdhZGRUb0hpc3RvcnknLCBwbHVnaW5TdGF0ZS5hZGRUb0hpc3RvcnkpXG4gICAgICAgICAgICAgICAgICBiaW5kaW5nLl9wcm9zZW1pcnJvckNoYW5nZWQodmlldy5zdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkZXN0cm95OiAoKSA9PiB7XG4gICAgICAgICAgYmluZGluZy5kZXN0cm95KClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHBsdWdpblxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCdwcm9zZW1pcnJvci1zdGF0ZScpLlRyYW5zYWN0aW9ufSB0clxuICogQHBhcmFtIHtSZXR1cm5UeXBlPHR5cGVvZiBnZXRSZWxhdGl2ZVNlbGVjdGlvbj59IHJlbFNlbFxuICogQHBhcmFtIHtQcm9zZW1pcnJvckJpbmRpbmd9IGJpbmRpbmdcbiAqL1xuY29uc3QgcmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uID0gKHRyLCByZWxTZWwsIGJpbmRpbmcpID0+IHtcbiAgaWYgKHJlbFNlbCAhPT0gbnVsbCAmJiByZWxTZWwuYW5jaG9yICE9PSBudWxsICYmIHJlbFNlbC5oZWFkICE9PSBudWxsKSB7XG4gICAgaWYgKHJlbFNlbC50eXBlID09PSAnYWxsJykge1xuICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBBbGxTZWxlY3Rpb24odHIuZG9jKSlcbiAgICB9IGVsc2UgaWYgKHJlbFNlbC50eXBlID09PSAnbm9kZScpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHJlbGF0aXZlUG9zaXRpb25Ub0Fic29sdXRlUG9zaXRpb24oXG4gICAgICAgIGJpbmRpbmcuZG9jLFxuICAgICAgICBiaW5kaW5nLnR5cGUsXG4gICAgICAgIHJlbFNlbC5hbmNob3IsXG4gICAgICAgIGJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYW5jaG9yKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYW5jaG9yID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgYmluZGluZy5kb2MsXG4gICAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgICAgcmVsU2VsLmFuY2hvcixcbiAgICAgICAgYmluZGluZy5tYXBwaW5nXG4gICAgICApXG4gICAgICBjb25zdCBoZWFkID0gcmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbihcbiAgICAgICAgYmluZGluZy5kb2MsXG4gICAgICAgIGJpbmRpbmcudHlwZSxcbiAgICAgICAgcmVsU2VsLmhlYWQsXG4gICAgICAgIGJpbmRpbmcubWFwcGluZ1xuICAgICAgKVxuICAgICAgaWYgKGFuY2hvciAhPT0gbnVsbCAmJiBoZWFkICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNlbCA9IFRleHRTZWxlY3Rpb24uYmV0d2Vlbih0ci5kb2MucmVzb2x2ZShhbmNob3IpLCB0ci5kb2MucmVzb2x2ZShoZWFkKSlcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Byb3NlbWlycm9yQmluZGluZ30gcG1iaW5kaW5nXG4gKiBAcGFyYW0ge2ltcG9ydCgncHJvc2VtaXJyb3Itc3RhdGUnKS5FZGl0b3JTdGF0ZX0gc3RhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGdldFJlbGF0aXZlU2VsZWN0aW9uID0gKHBtYmluZGluZywgc3RhdGUpID0+ICh7XG4gIHR5cGU6IC8qKiBAdHlwZSB7YW55fSAqLyAoc3RhdGUuc2VsZWN0aW9uKS5qc29uSUQsXG4gIGFuY2hvcjogYWJzb2x1dGVQb3NpdGlvblRvUmVsYXRpdmVQb3NpdGlvbihcbiAgICBzdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLFxuICAgIHBtYmluZGluZy50eXBlLFxuICAgIHBtYmluZGluZy5tYXBwaW5nXG4gICksXG4gIGhlYWQ6IGFic29sdXRlUG9zaXRpb25Ub1JlbGF0aXZlUG9zaXRpb24oXG4gICAgc3RhdGUuc2VsZWN0aW9uLmhlYWQsXG4gICAgcG1iaW5kaW5nLnR5cGUsXG4gICAgcG1iaW5kaW5nLm1hcHBpbmdcbiAgKVxufSlcblxuLyoqXG4gKiBCaW5kaW5nIGZvciBwcm9zZW1pcnJvci5cbiAqXG4gKiBAcHJvdGVjdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9zZW1pcnJvckJpbmRpbmcge1xuICAvKipcbiAgICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5WG1sRnJhZ21lbnQgVGhlIGJpbmQgc291cmNlXG4gICAqIEBwYXJhbSB7UHJvc2VtaXJyb3JNYXBwaW5nfSBtYXBwaW5nXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeVhtbEZyYWdtZW50LCBtYXBwaW5nID0gbmV3IE1hcCgpKSB7XG4gICAgdGhpcy50eXBlID0geVhtbEZyYWdtZW50XG4gICAgLyoqXG4gICAgICogdGhpcyB3aWxsIGJlIHNldCBvbmNlIHRoZSB2aWV3IGlzIGNyZWF0ZWRcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3ID0gbnVsbFxuICAgIHRoaXMubXV4ID0gY3JlYXRlTXV0ZXgoKVxuICAgIHRoaXMubWFwcGluZyA9IG1hcHBpbmdcbiAgICAvKipcbiAgICAgKiBJcyBvdmVybGFwcGluZyBtYXJrIC0gaS5lLiBtYXJrIGRvZXMgbm90IGV4Y2x1ZGUgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFya1R5cGUsIGJvb2xlYW4+fVxuICAgICAqL1xuICAgIHRoaXMuaXNPTWFyayA9IG5ldyBNYXAoKVxuICAgIHRoaXMuX29ic2VydmVGdW5jdGlvbiA9IHRoaXMuX3R5cGVDaGFuZ2VkLmJpbmQodGhpcylcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7WS5Eb2N9XG4gICAgICovXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHRoaXMuZG9jID0geVhtbEZyYWdtZW50LmRvY1xuICAgIC8qKlxuICAgICAqIGN1cnJlbnQgc2VsZWN0aW9uIGFzIHJlbGF0aXZlIHBvc2l0aW9ucyBpbiB0aGUgWWpzIG1vZGVsXG4gICAgICovXG4gICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB0aGlzLmJlZm9yZUFsbFRyYW5zYWN0aW9ucyA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID09PSBudWxsICYmIHRoaXMucHJvc2VtaXJyb3JWaWV3ICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IGdldFJlbGF0aXZlU2VsZWN0aW9uKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGVcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zID0gKCkgPT4ge1xuICAgICAgdGhpcy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvbiA9IG51bGxcbiAgICB9XG4gICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHRyYW5zYWN0aW9uIGZvciBjaGFuZ2luZyB0aGUgcHJvc2VtaXJyb3Igc3RhdGUuXG4gICAqXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICBnZXQgX3RyICgpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUudHIuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpXG4gIH1cblxuICBfaXNMb2NhbEN1cnNvckluVmlldyAoKSB7XG4gICAgaWYgKCF0aGlzLnByb3NlbWlycm9yVmlldy5oYXNGb2N1cygpKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoZW52aXJvbm1lbnQuaXNCcm93c2VyICYmIHRoaXMuX2RvbVNlbGVjdGlvbkluVmlldyA9PT0gbnVsbCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkb21TZWxlY3Rpb25JblZpZXcgYW5kIGNsZWFyIGJ5IG5leHQgdGljayBhZnRlciBhbGwgZXZlbnRzIGFyZSBmaW5pc2hlZFxuICAgICAgZXZlbnRsb29wLnRpbWVvdXQoMCwgKCkgPT4ge1xuICAgICAgICB0aGlzLl9kb21TZWxlY3Rpb25JblZpZXcgPSBudWxsXG4gICAgICB9KVxuICAgICAgdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3ID0gdGhpcy5faXNEb21TZWxlY3Rpb25JblZpZXcoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZG9tU2VsZWN0aW9uSW5WaWV3XG4gIH1cblxuICBfaXNEb21TZWxlY3Rpb25JblZpZXcgKCkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmdldFNlbGVjdGlvbigpXG5cbiAgICBpZiAoc2VsZWN0aW9uID09IG51bGwgfHwgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT0gbnVsbCkgcmV0dXJuIGZhbHNlXG5cbiAgICBjb25zdCByYW5nZSA9IHRoaXMucHJvc2VtaXJyb3JWaWV3Ll9yb290LmNyZWF0ZVJhbmdlKClcbiAgICByYW5nZS5zZXRTdGFydChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldClcbiAgICByYW5nZS5zZXRFbmQoc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KVxuXG4gICAgLy8gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yIGFuIGVkZ2VjYXNlIHdoZXJlIGdldEJvdW5kaW5nQ2xpZW50UmVjdCB3aWxsXG4gICAgLy8gcmV0dXJuIHplcm8gdmFsdWVzIGlmIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkIGF0IHRoZSBzdGFydCBvZiBhIG5ld2xpbmVcbiAgICAvLyBzZWUgcmVmZXJlbmNlIGhlcmU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81OTc4MDk1NFxuICAgIGNvbnN0IHJlY3RzID0gcmFuZ2UuZ2V0Q2xpZW50UmVjdHMoKVxuICAgIGlmIChyZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIHByb2JhYmx5IGJ1Z2d5IG5ld2xpbmUgYmVoYXZpb3IsIGV4cGxpY2l0bHkgc2VsZWN0IHRoZSBub2RlIGNvbnRlbnRzXG4gICAgICBpZiAocmFuZ2Uuc3RhcnRDb250YWluZXIgJiYgcmFuZ2UuY29sbGFwc2VkKSB7XG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhyYW5nZS5zdGFydENvbnRhaW5lcilcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBib3VuZGluZyA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZG9tLmRvYy5kb2N1bWVudEVsZW1lbnRcblxuICAgIHJldHVybiBib3VuZGluZy5ib3R0b20gPj0gMCAmJiBib3VuZGluZy5yaWdodCA+PSAwICYmXG4gICAgICBib3VuZGluZy5sZWZ0IDw9XG4gICAgICAgICh3aW5kb3cuaW5uZXJXaWR0aCB8fCBkb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggfHwgMCkgJiZcbiAgICAgIGJvdW5kaW5nLnRvcCA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgfHwgMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R9IHNuYXBzaG90XG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gcHJldlNuYXBzaG90XG4gICAqL1xuICByZW5kZXJTbmFwc2hvdCAoc25hcHNob3QsIHByZXZTbmFwc2hvdCkge1xuICAgIGlmICghcHJldlNuYXBzaG90KSB7XG4gICAgICBwcmV2U25hcHNob3QgPSBZLmNyZWF0ZVNuYXBzaG90KFkuY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSlcbiAgICB9XG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICB0aGlzLl90ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IHNuYXBzaG90LCBwcmV2U25hcHNob3QgfSlcbiAgICApXG4gIH1cblxuICB1bnJlbmRlclNuYXBzaG90ICgpIHtcbiAgICB0aGlzLm1hcHBpbmcuY2xlYXIoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIGNvbnN0IGZyYWdtZW50Q29udGVudCA9IHRoaXMudHlwZS50b0FycmF5KCkubWFwKCh0KSA9PlxuICAgICAgICBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAodCksXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuc2NoZW1hLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKVxuICAgICAgKS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCB0ciA9IHRoaXMuX3RyLnJlcGxhY2UoXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsXG4gICAgICAgIG5ldyBQTW9kZWwuU2xpY2UoUE1vZGVsLkZyYWdtZW50LmZyb20oZnJhZ21lbnRDb250ZW50KSwgMCwgMClcbiAgICAgIClcbiAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgc25hcHNob3Q6IG51bGwsIHByZXZTbmFwc2hvdDogbnVsbCB9KVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIpXG4gICAgfSlcbiAgfVxuXG4gIF9mb3JjZVJlcmVuZGVyICgpIHtcbiAgICB0aGlzLm1hcHBpbmcuY2xlYXIoKVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBmb3JjZWQgcmVyZW5kZXIsIHRoaXMgbWlnaHQgbmVpdGhlciBoYXBwZW4gYXMgYSBwbSBjaGFuZ2Ugbm9yIHdpdGhpbiBhIFlqc1xuICAgICAgLy8gdHJhbnNhY3Rpb24uIFRoZW4gdGhlIFwiYmVmb3JlIHNlbGVjdGlvblwiIGRvZXNuJ3QgZXhpc3QuIEluIHRoaXMgY2FzZSwgd2UgbmVlZCB0byBjcmVhdGUgYVxuICAgICAgLy8gcmVsYXRpdmUgcG9zaXRpb24gYmVmb3JlIHJlcGxhY2luZyBjb250ZW50LiBGaXhlcyAjMTI2XG4gICAgICBjb25zdCBzZWwgPSB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uICE9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNlbGVjdGlvblxuICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gdGhpcy50eXBlLnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgICAgIGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQoXG4gICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovICh0KSxcbiAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgdGhpc1xuICAgICAgICApXG4gICAgICApLmZpbHRlcigobikgPT4gbiAhPT0gbnVsbClcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKVxuICAgICAgaWYgKHNlbCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIFByb3NlbWlycm9yIGRvY3VtZW50IHdlIGp1c3QgY3JlYXRlZCBmcm9tIHRoaXMudHlwZSBpc1xuICAgICAgICAgKiBzbWFsbGVyIHRoYW4gdGhlIHByZXZpb3VzIGRvY3VtZW50LCB0aGUgc2VsZWN0aW9uIG1pZ2h0IGJlXG4gICAgICAgICAqIG91dCBvZiBib3VuZCwgd2hpY2ggd291bGQgbWFrZSBQcm9zZW1pcnJvciB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGNsYW1wZWRBbmNob3IgPSBtYXRoLm1pbihtYXRoLm1heChzZWwuYW5jaG9yLCAwKSwgdHIuZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgY29uc3QgY2xhbXBlZEhlYWQgPSBtYXRoLm1pbihtYXRoLm1heChzZWwuaGVhZCwgMCksIHRyLmRvYy5jb250ZW50LnNpemUpXG5cbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgY2xhbXBlZEFuY2hvciwgY2xhbXBlZEhlYWQpKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICAgIHRyLnNldE1ldGEoeVN5bmNQbHVnaW5LZXksIHsgaXNDaGFuZ2VPcmlnaW46IHRydWUsIGJpbmRpbmc6IHRoaXMgfSlcbiAgICAgIClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5TbmFwc2hvdHxVaW50OEFycmF5fSBzbmFwc2hvdFxuICAgKiBAcGFyYW0ge1kuU25hcHNob3R8VWludDhBcnJheX0gcHJldlNuYXBzaG90XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW5TdGF0ZVxuICAgKi9cbiAgX3JlbmRlclNuYXBzaG90IChzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBwbHVnaW5TdGF0ZSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBkb2N1bWVudCB0aGF0IGNvbnRhaW5zIHRoZSBmdWxsIGhpc3Rvcnkgb2YgdGhpcyBkb2N1bWVudC5cbiAgICAgKiBAdHlwZSB7WS5Eb2N9XG4gICAgICovXG4gICAgbGV0IGhpc3RvcnlEb2MgPSB0aGlzLmRvY1xuICAgIGxldCBoaXN0b3J5VHlwZSA9IHRoaXMudHlwZVxuICAgIGlmICghc25hcHNob3QpIHtcbiAgICAgIHNuYXBzaG90ID0gWS5zbmFwc2hvdCh0aGlzLmRvYylcbiAgICB9XG4gICAgaWYgKHNuYXBzaG90IGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBwcmV2U25hcHNob3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICBpZiAoIShzbmFwc2hvdCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHx8ICEocHJldlNuYXBzaG90IGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgLy8gZXhwZWN0ZWQgYm90aCBzbmFwc2hvdHMgdG8gYmUgdjIgdXBkYXRlc1xuICAgICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgICB9XG4gICAgICBoaXN0b3J5RG9jID0gbmV3IFkuRG9jKHsgZ2M6IGZhbHNlIH0pXG4gICAgICBZLmFwcGx5VXBkYXRlVjIoaGlzdG9yeURvYywgcHJldlNuYXBzaG90KVxuICAgICAgcHJldlNuYXBzaG90ID0gWS5zbmFwc2hvdChoaXN0b3J5RG9jKVxuICAgICAgWS5hcHBseVVwZGF0ZVYyKGhpc3RvcnlEb2MsIHNuYXBzaG90KVxuICAgICAgc25hcHNob3QgPSBZLnNuYXBzaG90KGhpc3RvcnlEb2MpXG4gICAgICBpZiAoaGlzdG9yeVR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGlzIGEgcm9vdCB0eXBlLCB3ZSBuZWVkIHRvIGZpbmQgdGhlIHJvb3Qga2V5IGluIHRoZSBpbml0aWFsIGRvY3VtZW50XG4gICAgICAgICAqIGFuZCB1c2UgaXQgdG8gZ2V0IHRoZSBoaXN0b3J5IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByb290S2V5ID0gQXJyYXkuZnJvbSh0aGlzLmRvYy5zaGFyZS5rZXlzKCkpLmZpbmQoXG4gICAgICAgICAgKGtleSkgPT4gdGhpcy5kb2Muc2hhcmUuZ2V0KGtleSkgPT09IHRoaXMudHlwZVxuICAgICAgICApXG4gICAgICAgIGhpc3RvcnlUeXBlID0gaGlzdG9yeURvYy5nZXRYbWxGcmFnbWVudChyb290S2V5KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGl0IGlzIGEgc3ViIHR5cGUsIHdlIHVzZSB0aGUgaXRlbSBpZCB0byBmaW5kIHRoZSBoaXN0b3J5IHR5cGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBoaXN0b3J5U3RydWN0cyA9XG4gICAgICAgICAgaGlzdG9yeURvYy5zdG9yZS5jbGllbnRzLmdldChoaXN0b3J5VHlwZS5faXRlbS5pZC5jbGllbnQpID8/IFtdXG4gICAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IFkuZmluZEluZGV4U1MoXG4gICAgICAgICAgaGlzdG9yeVN0cnVjdHMsXG4gICAgICAgICAgaGlzdG9yeVR5cGUuX2l0ZW0uaWQuY2xvY2tcbiAgICAgICAgKVxuICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtZLkl0ZW19ICovIChoaXN0b3J5U3RydWN0c1tpdGVtSW5kZXhdKVxuICAgICAgICBjb25zdCBjb250ZW50ID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoaXRlbS5jb250ZW50KVxuICAgICAgICBoaXN0b3J5VHlwZSA9IC8qKiBAdHlwZSB7WS5YbWxGcmFnbWVudH0gKi8gKGNvbnRlbnQudHlwZSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2xlYXIgbWFwcGluZyBiZWNhdXNlIHdlIGFyZSBnb2luZyB0byByZXJlbmRlclxuICAgIHRoaXMubWFwcGluZy5jbGVhcigpXG4gICAgdGhpcy5tdXgoKCkgPT4ge1xuICAgICAgaGlzdG9yeURvYy50cmFuc2FjdCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gYmVmb3JlIHJlbmRlcmluZywgd2UgYXJlIGdvaW5nIHRvIHNhbml0aXplIG9wcyBhbmQgc3BsaXQgZGVsZXRlZCBvcHNcbiAgICAgICAgLy8gaWYgdGhleSB3ZXJlIGRlbGV0ZWQgYnkgc2VwZXJhdGUgdXNlcnMuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7WS5QZXJtYW5lbnRVc2VyRGF0YX1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHB1ZCA9IHBsdWdpblN0YXRlLnBlcm1hbmVudFVzZXJEYXRhXG4gICAgICAgIGlmIChwdWQpIHtcbiAgICAgICAgICBwdWQuZHNzLmZvckVhY2goKGRzKSA9PiB7XG4gICAgICAgICAgICBZLml0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgZHMsIChfaXRlbSkgPT4ge30pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHsncmVtb3ZlZCd8J2FkZGVkJ30gdHlwZVxuICAgICAgICAgKiBAcGFyYW0ge1kuSUR9IGlkXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb21wdXRlWUNoYW5nZSA9ICh0eXBlLCBpZCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHVzZXIgPSB0eXBlID09PSAnYWRkZWQnXG4gICAgICAgICAgICA/IHB1ZC5nZXRVc2VyQnlDbGllbnRJZChpZC5jbGllbnQpXG4gICAgICAgICAgICA6IHB1ZC5nZXRVc2VyQnlEZWxldGVkSWQoaWQpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVzZXIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgY29sb3I6IGdldFVzZXJDb2xvcihcbiAgICAgICAgICAgICAgcGx1Z2luU3RhdGUuY29sb3JNYXBwaW5nLFxuICAgICAgICAgICAgICBwbHVnaW5TdGF0ZS5jb2xvcnMsXG4gICAgICAgICAgICAgIHVzZXJcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGRvY3VtZW50IGZyYWdtZW50IGFuZCByZW5kZXJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gWS50eXBlTGlzdFRvQXJyYXlTbmFwc2hvdChcbiAgICAgICAgICBoaXN0b3J5VHlwZSxcbiAgICAgICAgICBuZXcgWS5TbmFwc2hvdChwcmV2U25hcHNob3QuZHMsIHNuYXBzaG90LnN2KVxuICAgICAgICApLm1hcCgodCkgPT4ge1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICF0Ll9pdGVtLmRlbGV0ZWQgfHwgaXNWaXNpYmxlKHQuX2l0ZW0sIHNuYXBzaG90KSB8fFxuICAgICAgICAgICAgaXNWaXNpYmxlKHQuX2l0ZW0sIHByZXZTbmFwc2hvdClcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbVlFbGVtZW50KFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICB0aGlzLnByb3NlbWlycm9yVmlldy5zdGF0ZS5zY2hlbWEsXG4gICAgICAgICAgICAgIHsgbWFwcGluZzogbmV3IE1hcCgpLCBpc09NYXJrOiBuZXcgTWFwKCkgfSxcbiAgICAgICAgICAgICAgc25hcHNob3QsXG4gICAgICAgICAgICAgIHByZXZTbmFwc2hvdCxcbiAgICAgICAgICAgICAgY29tcHV0ZVlDaGFuZ2VcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byByZW5kZXIgZWxlbWVudHMgdGhhdCBhcmUgbm90IHZpc2libGUgYnkgZWl0aGVyIHNuYXBzaG90LlxuICAgICAgICAgICAgLy8gSWYgYSBjbGllbnQgYWRkcyBhbmQgZGVsZXRlcyBjb250ZW50IGluIHRoZSBzYW1lIHNuYXBzaG90IHRoZSBlbGVtZW50IGlzIG5vdCB2aXNpYmxlIGJ5IGVpdGhlciBzbmFwc2hvdC5cbiAgICAgICAgICAgIHJldHVybiBudWxsXG4gICAgICAgICAgfVxuICAgICAgICB9KS5maWx0ZXIoKG4pID0+IG4gIT09IG51bGwpXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgdHIgPSB0aGlzLl90ci5yZXBsYWNlKFxuICAgICAgICAgIDAsXG4gICAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgICBuZXcgUE1vZGVsLlNsaWNlKFBNb2RlbC5GcmFnbWVudC5mcm9tKGZyYWdtZW50Q29udGVudCksIDAsIDApXG4gICAgICAgIClcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2goXG4gICAgICAgICAgdHIuc2V0TWV0YSh5U3luY1BsdWdpbktleSwgeyBpc0NoYW5nZU9yaWdpbjogdHJ1ZSB9KVxuICAgICAgICApXG4gICAgICB9LCB5U3luY1BsdWdpbktleSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8WS5ZRXZlbnQ8YW55Pj59IGV2ZW50c1xuICAgKiBAcGFyYW0ge1kuVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBfdHlwZUNoYW5nZWQgKGV2ZW50cywgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAodGhpcy5wcm9zZW1pcnJvclZpZXcgPT0gbnVsbCkgcmV0dXJuXG4gICAgY29uc3Qgc3luY1N0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUpXG4gICAgaWYgKFxuICAgICAgZXZlbnRzLmxlbmd0aCA9PT0gMCB8fCBzeW5jU3RhdGUuc25hcHNob3QgIT0gbnVsbCB8fFxuICAgICAgc3luY1N0YXRlLnByZXZTbmFwc2hvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICAvLyBkcm9wIG91dCBpZiBzbmFwc2hvdCBpcyBhY3RpdmVcbiAgICAgIHRoaXMucmVuZGVyU25hcHNob3Qoc3luY1N0YXRlLnNuYXBzaG90LCBzeW5jU3RhdGUucHJldlNuYXBzaG90KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMubXV4KCgpID0+IHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHthbnl9IF9cbiAgICAgICAqIEBwYXJhbSB7WS5BYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWxUeXBlID0gKF8sIHR5cGUpID0+IHRoaXMubWFwcGluZy5kZWxldGUodHlwZSlcbiAgICAgIFkuaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKFxuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgdHJhbnNhY3Rpb24uZGVsZXRlU2V0LFxuICAgICAgICAoc3RydWN0KSA9PiB7XG4gICAgICAgICAgaWYgKHN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gWS5JdGVtKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAoLyoqIEB0eXBlIHtZLkl0ZW19ICovIChzdHJ1Y3QpLmNvbnRlbnQpLnR5cGVcbiAgICAgICAgICAgIHR5cGUgJiYgdGhpcy5tYXBwaW5nLmRlbGV0ZSh0eXBlKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKGRlbFR5cGUpXG4gICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaChkZWxUeXBlKVxuICAgICAgY29uc3QgZnJhZ21lbnRDb250ZW50ID0gdGhpcy50eXBlLnRvQXJyYXkoKS5tYXAoKHQpID0+XG4gICAgICAgIGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyhcbiAgICAgICAgICAvKiogQHR5cGUge1kuWG1sRWxlbWVudCB8IFkuWG1sSG9va30gKi8gKHQpLFxuICAgICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlLnNjaGVtYSxcbiAgICAgICAgICB0aGlzXG4gICAgICAgIClcbiAgICAgICkuZmlsdGVyKChuKSA9PiBuICE9PSBudWxsKVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgbGV0IHRyID0gdGhpcy5fdHIucmVwbGFjZShcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSxcbiAgICAgICAgbmV3IFBNb2RlbC5TbGljZShQTW9kZWwuRnJhZ21lbnQuZnJvbShmcmFnbWVudENvbnRlbnQpLCAwLCAwKVxuICAgICAgKVxuICAgICAgcmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uKHRyLCB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uLCB0aGlzKVxuICAgICAgdHIgPSB0ci5zZXRNZXRhKHlTeW5jUGx1Z2luS2V5LCB7IGlzQ2hhbmdlT3JpZ2luOiB0cnVlLCBpc1VuZG9SZWRvT3BlcmF0aW9uOiB0cmFuc2FjdGlvbi5vcmlnaW4gaW5zdGFuY2VvZiBZLlVuZG9NYW5hZ2VyIH0pXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gIT09IG51bGwgJiYgdGhpcy5faXNMb2NhbEN1cnNvckluVmlldygpXG4gICAgICApIHtcbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKVxuICAgICAgfVxuICAgICAgdGhpcy5wcm9zZW1pcnJvclZpZXcuZGlzcGF0Y2godHIpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2ltcG9ydCgncHJvc2VtaXJyb3ItbW9kZWwnKS5Ob2RlfSBkb2NcbiAgICovXG4gIF9wcm9zZW1pcnJvckNoYW5nZWQgKGRvYykge1xuICAgIHRoaXMuZG9jLnRyYW5zYWN0KCgpID0+IHtcbiAgICAgIHVwZGF0ZVlGcmFnbWVudCh0aGlzLmRvYywgdGhpcy50eXBlLCBkb2MsIHRoaXMpXG4gICAgICB0aGlzLmJlZm9yZVRyYW5zYWN0aW9uU2VsZWN0aW9uID0gZ2V0UmVsYXRpdmVTZWxlY3Rpb24oXG4gICAgICAgIHRoaXMsXG4gICAgICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3LnN0YXRlXG4gICAgICApXG4gICAgfSwgeVN5bmNQbHVnaW5LZXkpXG4gIH1cblxuICAvKipcbiAgICogVmlldyBpcyByZWFkeSB0byBsaXN0ZW4gdG8gY2hhbmdlcy4gUmVnaXN0ZXIgb2JzZXJ2ZXJzLlxuICAgKiBAcGFyYW0ge2FueX0gcHJvc2VtaXJyb3JWaWV3XG4gICAqL1xuICBpbml0VmlldyAocHJvc2VtaXJyb3JWaWV3KSB7XG4gICAgaWYgKHRoaXMucHJvc2VtaXJyb3JWaWV3ICE9IG51bGwpIHRoaXMuZGVzdHJveSgpXG4gICAgdGhpcy5wcm9zZW1pcnJvclZpZXcgPSBwcm9zZW1pcnJvclZpZXdcbiAgICB0aGlzLmRvYy5vbignYmVmb3JlQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5iZWZvcmVBbGxUcmFuc2FjdGlvbnMpXG4gICAgdGhpcy5kb2Mub24oJ2FmdGVyQWxsVHJhbnNhY3Rpb25zJywgdGhpcy5hZnRlckFsbFRyYW5zYWN0aW9ucylcbiAgICB0aGlzLnR5cGUub2JzZXJ2ZURlZXAodGhpcy5fb2JzZXJ2ZUZ1bmN0aW9uKVxuICB9XG5cbiAgZGVzdHJveSAoKSB7XG4gICAgaWYgKHRoaXMucHJvc2VtaXJyb3JWaWV3ID09IG51bGwpIHJldHVyblxuICAgIHRoaXMucHJvc2VtaXJyb3JWaWV3ID0gbnVsbFxuICAgIHRoaXMudHlwZS51bm9ic2VydmVEZWVwKHRoaXMuX29ic2VydmVGdW5jdGlvbilcbiAgICB0aGlzLmRvYy5vZmYoJ2JlZm9yZUFsbFRyYW5zYWN0aW9ucycsIHRoaXMuYmVmb3JlQWxsVHJhbnNhY3Rpb25zKVxuICAgIHRoaXMuZG9jLm9mZignYWZ0ZXJBbGxUcmFuc2FjdGlvbnMnLCB0aGlzLmFmdGVyQWxsVHJhbnNhY3Rpb25zKVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50IHwgWS5YbWxIb29rfSBlbFxuICogQHBhcmFtIHtQTW9kZWwuU2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7QmluZGluZ01ldGFkYXRhfSBtZXRhXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtzbmFwc2hvdF1cbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3ByZXZTbmFwc2hvdF1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgWS5JRCk6YW55fSBbY29tcHV0ZVlDaGFuZ2VdXG4gKiBAcmV0dXJuIHtQTW9kZWwuTm9kZSB8IG51bGx9XG4gKi9cbmNvbnN0IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyA9IChcbiAgZWwsXG4gIHNjaGVtYSxcbiAgbWV0YSxcbiAgc25hcHNob3QsXG4gIHByZXZTbmFwc2hvdCxcbiAgY29tcHV0ZVlDaGFuZ2VcbikgPT4ge1xuICBjb25zdCBub2RlID0gLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKG1ldGEubWFwcGluZy5nZXQoZWwpKVxuICBpZiAobm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGVsIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21ZRWxlbWVudChcbiAgICAgICAgZWwsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgbWV0YSxcbiAgICAgICAgc25hcHNob3QsXG4gICAgICAgIHByZXZTbmFwc2hvdCxcbiAgICAgICAgY29tcHV0ZVlDaGFuZ2VcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpIC8vIHdlIGFyZSBjdXJyZW50bHkgbm90IGhhbmRsaW5nIGhvb2tzXG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fSBlbFxuICogQHBhcmFtIHthbnl9IHNjaGVtYVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEBwYXJhbSB7WS5TbmFwc2hvdH0gW3NuYXBzaG90XVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbcHJldlNuYXBzaG90XVxuICogQHBhcmFtIHtmdW5jdGlvbigncmVtb3ZlZCcgfCAnYWRkZWQnLCBZLklEKTphbnl9IFtjb21wdXRlWUNoYW5nZV1cbiAqIEByZXR1cm4ge1BNb2RlbC5Ob2RlIHwgbnVsbH0gUmV0dXJucyBub2RlIGlmIG5vZGUgY291bGQgYmUgY3JlYXRlZC4gT3RoZXJ3aXNlIGl0IGRlbGV0ZXMgdGhlIHlqcyB0eXBlIGFuZCByZXR1cm5zIG51bGxcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZU5vZGVGcm9tWUVsZW1lbnQgPSAoXG4gIGVsLFxuICBzY2hlbWEsXG4gIG1ldGEsXG4gIHNuYXBzaG90LFxuICBwcmV2U25hcHNob3QsXG4gIGNvbXB1dGVZQ2hhbmdlXG4pID0+IHtcbiAgY29uc3QgY2hpbGRyZW4gPSBbXVxuICAvKipcbiAgICogQHBhcmFtIHtZLlhtbEVsZW1lbnQgfCBZLlhtbFRleHR9IHR5cGVcbiAgICovXG4gIGNvbnN0IGNyZWF0ZUNoaWxkcmVuID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgICAgY29uc3QgbiA9IGNyZWF0ZU5vZGVJZk5vdEV4aXN0cyhcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtZXRhLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgY2hpbGRyZW4ucHVzaChuKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgbmV4dCB5dGV4dCBleGlzdHMgYW5kIHdhcyBjcmVhdGVkIGJ5IHVzLCBtb3ZlIHRoZSBjb250ZW50IHRvIHRoZSBjdXJyZW50IHl0ZXh0LlxuICAgICAgLy8gVGhpcyBpcyBhIGZpeCBmb3IgIzE2MCAtLSBkdXBsaWNhdGlvbiBvZiBjaGFyYWN0ZXJzIHdoZW4gdHdvIFkuVGV4dCBleGlzdCBuZXh0IHRvIGVhY2hcbiAgICAgIC8vIG90aGVyLlxuICAgICAgY29uc3QgbmV4dHl0ZXh0ID0gLyoqIEB0eXBlIHtZLkNvbnRlbnRUeXBlfSAqLyAodHlwZS5faXRlbS5yaWdodD8uY29udGVudCk/LnR5cGVcbiAgICAgIGlmIChuZXh0eXRleHQgaW5zdGFuY2VvZiBZLlRleHQgJiYgIW5leHR5dGV4dC5faXRlbS5kZWxldGVkICYmIG5leHR5dGV4dC5faXRlbS5pZC5jbGllbnQgPT09IG5leHR5dGV4dC5kb2MuY2xpZW50SUQpIHtcbiAgICAgICAgdHlwZS5hcHBseURlbHRhKFtcbiAgICAgICAgICB7IHJldGFpbjogdHlwZS5sZW5ndGggfSxcbiAgICAgICAgICAuLi5uZXh0eXRleHQudG9EZWx0YSgpXG4gICAgICAgIF0pXG4gICAgICAgIG5leHR5dGV4dC5kb2MudHJhbnNhY3QodHIgPT4ge1xuICAgICAgICAgIG5leHR5dGV4dC5faXRlbS5kZWxldGUodHIpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICAvLyBub3cgY3JlYXRlIHRoZSBwcm9zZW1pcnJvciB0ZXh0IG5vZGVzXG4gICAgICBjb25zdCBucyA9IGNyZWF0ZVRleHROb2Rlc0Zyb21ZVGV4dChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBtZXRhLFxuICAgICAgICBzbmFwc2hvdCxcbiAgICAgICAgcHJldlNuYXBzaG90LFxuICAgICAgICBjb21wdXRlWUNoYW5nZVxuICAgICAgKVxuICAgICAgaWYgKG5zICE9PSBudWxsKSB7XG4gICAgICAgIG5zLmZvckVhY2goKHRleHRjaGlsZCkgPT4ge1xuICAgICAgICAgIGlmICh0ZXh0Y2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2godGV4dGNoaWxkKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgfHwgcHJldlNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbC50b0FycmF5KCkuZm9yRWFjaChjcmVhdGVDaGlsZHJlbilcbiAgfSBlbHNlIHtcbiAgICBZLnR5cGVMaXN0VG9BcnJheVNuYXBzaG90KGVsLCBuZXcgWS5TbmFwc2hvdChwcmV2U25hcHNob3QuZHMsIHNuYXBzaG90LnN2KSlcbiAgICAgIC5mb3JFYWNoKGNyZWF0ZUNoaWxkcmVuKVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgYXR0cnMgPSBlbC5nZXRBdHRyaWJ1dGVzKHNuYXBzaG90KVxuICAgIGlmIChzbmFwc2hvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIWlzVmlzaWJsZSgvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKSwgc25hcHNob3QpKSB7XG4gICAgICAgIGF0dHJzLnljaGFuZ2UgPSBjb21wdXRlWUNoYW5nZVxuICAgICAgICAgID8gY29tcHV0ZVlDaGFuZ2UoJ3JlbW92ZWQnLCAvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKS5pZClcbiAgICAgICAgICA6IHsgdHlwZTogJ3JlbW92ZWQnIH1cbiAgICAgIH0gZWxzZSBpZiAoIWlzVmlzaWJsZSgvKiogQHR5cGUge1kuSXRlbX0gKi8gKGVsLl9pdGVtKSwgcHJldlNuYXBzaG90KSkge1xuICAgICAgICBhdHRycy55Y2hhbmdlID0gY29tcHV0ZVlDaGFuZ2VcbiAgICAgICAgICA/IGNvbXB1dGVZQ2hhbmdlKCdhZGRlZCcsIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAoZWwuX2l0ZW0pLmlkKVxuICAgICAgICAgIDogeyB0eXBlOiAnYWRkZWQnIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9kZSA9IHNjaGVtYS5ub2RlKGVsLm5vZGVOYW1lLCBhdHRycywgY2hpbGRyZW4pXG4gICAgbWV0YS5tYXBwaW5nLnNldChlbCwgbm9kZSlcbiAgICByZXR1cm4gbm9kZVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gYW4gZXJyb3Igb2NjdXJlZCB3aGlsZSBjcmVhdGluZyB0aGUgbm9kZS4gVGhpcyBpcyBwcm9iYWJseSBhIHJlc3VsdCBvZiBhIGNvbmN1cnJlbnQgYWN0aW9uLlxuICAgIC8qKiBAdHlwZSB7WS5Eb2N9ICovIChlbC5kb2MpLnRyYW5zYWN0KCh0cmFuc2FjdGlvbikgPT4ge1xuICAgICAgLyoqIEB0eXBlIHtZLkl0ZW19ICovIChlbC5faXRlbSkuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIG1ldGEubWFwcGluZy5kZWxldGUoZWwpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1kuWG1sVGV4dH0gdGV4dFxuICogQHBhcmFtIHtpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuU2NoZW1hfSBzY2hlbWFcbiAqIEBwYXJhbSB7QmluZGluZ01ldGFkYXRhfSBfbWV0YVxuICogQHBhcmFtIHtZLlNuYXBzaG90fSBbc25hcHNob3RdXG4gKiBAcGFyYW0ge1kuU25hcHNob3R9IFtwcmV2U25hcHNob3RdXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCdyZW1vdmVkJyB8ICdhZGRlZCcsIFkuSUQpOmFueX0gW2NvbXB1dGVZQ2hhbmdlXVxuICogQHJldHVybiB7QXJyYXk8UE1vZGVsLk5vZGU+fG51bGx9XG4gKi9cbmNvbnN0IGNyZWF0ZVRleHROb2Rlc0Zyb21ZVGV4dCA9IChcbiAgdGV4dCxcbiAgc2NoZW1hLFxuICBfbWV0YSxcbiAgc25hcHNob3QsXG4gIHByZXZTbmFwc2hvdCxcbiAgY29tcHV0ZVlDaGFuZ2VcbikgPT4ge1xuICBjb25zdCBub2RlcyA9IFtdXG4gIGNvbnN0IGRlbHRhcyA9IHRleHQudG9EZWx0YShzbmFwc2hvdCwgcHJldlNuYXBzaG90LCBjb21wdXRlWUNoYW5nZSlcbiAgdHJ5IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVsdGEgPSBkZWx0YXNbaV1cbiAgICAgIG5vZGVzLnB1c2goc2NoZW1hLnRleHQoZGVsdGEuaW5zZXJ0LCBhdHRyaWJ1dGVzVG9NYXJrcyhkZWx0YS5hdHRyaWJ1dGVzLCBzY2hlbWEpKSlcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBhbiBlcnJvciBvY2N1cmVkIHdoaWxlIGNyZWF0aW5nIHRoZSBub2RlLiBUaGlzIGlzIHByb2JhYmx5IGEgcmVzdWx0IG9mIGEgY29uY3VycmVudCBhY3Rpb24uXG4gICAgLyoqIEB0eXBlIHtZLkRvY30gKi8gKHRleHQuZG9jKS50cmFuc2FjdCgodHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIC8qKiBAdHlwZSB7WS5JdGVtfSAqLyAodGV4dC5faXRlbSkuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH0sIHlTeW5jUGx1Z2luS2V5KVxuICAgIHJldHVybiBudWxsXG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gbm9kZXNcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxhbnk+fSBub2RlcyBwcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0ge0JpbmRpbmdNZXRhZGF0YX0gbWV0YVxuICogQHJldHVybiB7WS5YbWxUZXh0fVxuICovXG5jb25zdCBjcmVhdGVUeXBlRnJvbVRleHROb2RlcyA9IChub2RlcywgbWV0YSkgPT4ge1xuICBjb25zdCB0eXBlID0gbmV3IFkuWG1sVGV4dCgpXG4gIGNvbnN0IGRlbHRhID0gbm9kZXMubWFwKChub2RlKSA9PiAoe1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpbnNlcnQ6IG5vZGUudGV4dCxcbiAgICBhdHRyaWJ1dGVzOiBtYXJrc1RvQXR0cmlidXRlcyhub2RlLm1hcmtzLCBtZXRhKVxuICB9KSlcbiAgdHlwZS5hcHBseURlbHRhKGRlbHRhKVxuICBtZXRhLm1hcHBpbmcuc2V0KHR5cGUsIG5vZGVzKVxuICByZXR1cm4gdHlwZVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge2FueX0gbm9kZSBwcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0ge0JpbmRpbmdNZXRhZGF0YX0gbWV0YVxuICogQHJldHVybiB7WS5YbWxFbGVtZW50fVxuICovXG5jb25zdCBjcmVhdGVUeXBlRnJvbUVsZW1lbnROb2RlID0gKG5vZGUsIG1ldGEpID0+IHtcbiAgY29uc3QgdHlwZSA9IG5ldyBZLlhtbEVsZW1lbnQobm9kZS50eXBlLm5hbWUpXG4gIGZvciAoY29uc3Qga2V5IGluIG5vZGUuYXR0cnMpIHtcbiAgICBjb25zdCB2YWwgPSBub2RlLmF0dHJzW2tleV1cbiAgICBpZiAodmFsICE9PSBudWxsICYmIGtleSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICB0eXBlLnNldEF0dHJpYnV0ZShrZXksIHZhbClcbiAgICB9XG4gIH1cbiAgdHlwZS5pbnNlcnQoXG4gICAgMCxcbiAgICBub3JtYWxpemVQTm9kZUNvbnRlbnQobm9kZSkubWFwKChuKSA9PlxuICAgICAgY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZShuLCBtZXRhKVxuICAgIClcbiAgKVxuICBtZXRhLm1hcHBpbmcuc2V0KHR5cGUsIG5vZGUpXG4gIHJldHVybiB0eXBlXG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGV8QXJyYXk8UE1vZGVsLk5vZGU+fSBub2RlIHByb3NlbWlycm9yIHRleHQgbm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEByZXR1cm4ge1kuWG1sRWxlbWVudHxZLlhtbFRleHR9XG4gKi9cbmNvbnN0IGNyZWF0ZVR5cGVGcm9tVGV4dE9yRWxlbWVudE5vZGUgPSAobm9kZSwgbWV0YSkgPT5cbiAgbm9kZSBpbnN0YW5jZW9mIEFycmF5XG4gICAgPyBjcmVhdGVUeXBlRnJvbVRleHROb2Rlcyhub2RlLCBtZXRhKVxuICAgIDogY3JlYXRlVHlwZUZyb21FbGVtZW50Tm9kZShub2RlLCBtZXRhKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWxcbiAqL1xuY29uc3QgaXNPYmplY3QgPSAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JyAmJiB2YWwgIT09IG51bGxcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcGF0dHJzXG4gKiBAcGFyYW0ge2FueX0geWF0dHJzXG4gKi9cbmNvbnN0IGVxdWFsQXR0cnMgPSAocGF0dHJzLCB5YXR0cnMpID0+IHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHBhdHRycykuZmlsdGVyKChrZXkpID0+IHBhdHRyc1trZXldICE9PSBudWxsKVxuICBsZXQgZXEgPVxuICAgIGtleXMubGVuZ3RoID09PVxuICAgICAgKHlhdHRycyA9PSBudWxsID8gMCA6IE9iamVjdC5rZXlzKHlhdHRycykuZmlsdGVyKChrZXkpID0+IHlhdHRyc1trZXldICE9PSBudWxsKS5sZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGggJiYgZXE7IGkrKykge1xuICAgIGNvbnN0IGtleSA9IGtleXNbaV1cbiAgICBjb25zdCBsID0gcGF0dHJzW2tleV1cbiAgICBjb25zdCByID0geWF0dHJzW2tleV1cbiAgICBlcSA9IGtleSA9PT0gJ3ljaGFuZ2UnIHx8IGwgPT09IHIgfHxcbiAgICAgIChpc09iamVjdChsKSAmJiBpc09iamVjdChyKSAmJiBlcXVhbEF0dHJzKGwsIHIpKVxuICB9XG4gIHJldHVybiBlcVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtBcnJheTxBcnJheTxQTW9kZWwuTm9kZT58UE1vZGVsLk5vZGU+fSBOb3JtYWxpemVkUE5vZGVDb250ZW50XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gcG5vZGVcbiAqIEByZXR1cm4ge05vcm1hbGl6ZWRQTm9kZUNvbnRlbnR9XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVBOb2RlQ29udGVudCA9IChwbm9kZSkgPT4ge1xuICBjb25zdCBjID0gcG5vZGUuY29udGVudC5jb250ZW50XG4gIGNvbnN0IHJlcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG4gPSBjW2ldXG4gICAgaWYgKG4uaXNUZXh0KSB7XG4gICAgICBjb25zdCB0ZXh0Tm9kZXMgPSBbXVxuICAgICAgZm9yIChsZXQgdG5vZGUgPSBjW2ldOyBpIDwgYy5sZW5ndGggJiYgdG5vZGUuaXNUZXh0OyB0bm9kZSA9IGNbKytpXSkge1xuICAgICAgICB0ZXh0Tm9kZXMucHVzaCh0bm9kZSlcbiAgICAgIH1cbiAgICAgIGktLVxuICAgICAgcmVzLnB1c2godGV4dE5vZGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXMucHVzaChuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbFRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHB0ZXh0c1xuICovXG5jb25zdCBlcXVhbFlUZXh0UFRleHQgPSAoeXRleHQsIHB0ZXh0cykgPT4ge1xuICBjb25zdCBkZWx0YSA9IHl0ZXh0LnRvRGVsdGEoKVxuICByZXR1cm4gZGVsdGEubGVuZ3RoID09PSBwdGV4dHMubGVuZ3RoICYmXG4gICAgZGVsdGEuZXZlcnkoLyoqIEB0eXBlIHsoZDphbnksaTpudW1iZXIpID0+IGJvb2xlYW59ICovIChkLCBpKSA9PlxuICAgICAgZC5pbnNlcnQgPT09IC8qKiBAdHlwZSB7YW55fSAqLyAocHRleHRzW2ldKS50ZXh0ICYmXG4gICAgICBvYmplY3Qua2V5cyhkLmF0dHJpYnV0ZXMgfHwge30pLmxlbmd0aCA9PT0gcHRleHRzW2ldLm1hcmtzLmxlbmd0aCAmJlxuICAgICAgb2JqZWN0LmV2ZXJ5KGQuYXR0cmlidXRlcywgKGF0dHIsIHlhdHRybmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBtYXJrbmFtZSA9IHlhdHRyMm1hcmtuYW1lKHlhdHRybmFtZSlcbiAgICAgICAgY29uc3QgcG1hcmtzID0gcHRleHRzW2ldLm1hcmtzXG4gICAgICAgIHJldHVybiBlcXVhbEF0dHJzKGF0dHIsIHBtYXJrcy5maW5kKC8qKiBAcGFyYW0ge2FueX0gbWFyayAqLyBtYXJrID0+IG1hcmsudHlwZS5uYW1lID09PSBtYXJrbmFtZSk/LmF0dHJzKVxuICAgICAgfSlcbiAgICApXG59XG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR8WS5YbWxUZXh0fFkuWG1sSG9va30geXR5cGVcbiAqIEBwYXJhbSB7YW55fEFycmF5PGFueT59IHBub2RlXG4gKi9cbmNvbnN0IGVxdWFsWVR5cGVQTm9kZSA9ICh5dHlwZSwgcG5vZGUpID0+IHtcbiAgaWYgKFxuICAgIHl0eXBlIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50ICYmICEocG5vZGUgaW5zdGFuY2VvZiBBcnJheSkgJiZcbiAgICBtYXRjaE5vZGVOYW1lKHl0eXBlLCBwbm9kZSlcbiAgKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZENvbnRlbnQgPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocG5vZGUpXG4gICAgcmV0dXJuIHl0eXBlLl9sZW5ndGggPT09IG5vcm1hbGl6ZWRDb250ZW50Lmxlbmd0aCAmJlxuICAgICAgZXF1YWxBdHRycyh5dHlwZS5nZXRBdHRyaWJ1dGVzKCksIHBub2RlLmF0dHJzKSAmJlxuICAgICAgeXR5cGUudG9BcnJheSgpLmV2ZXJ5KCh5Y2hpbGQsIGkpID0+XG4gICAgICAgIGVxdWFsWVR5cGVQTm9kZSh5Y2hpbGQsIG5vcm1hbGl6ZWRDb250ZW50W2ldKVxuICAgICAgKVxuICB9XG4gIHJldHVybiB5dHlwZSBpbnN0YW5jZW9mIFkuWG1sVGV4dCAmJiBwbm9kZSBpbnN0YW5jZW9mIEFycmF5ICYmXG4gICAgZXF1YWxZVGV4dFBUZXh0KHl0eXBlLCBwbm9kZSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlIHwgQXJyYXk8UE1vZGVsLk5vZGU+IHwgdW5kZWZpbmVkfSBtYXBwZWRcbiAqIEBwYXJhbSB7UE1vZGVsLk5vZGUgfCBBcnJheTxQTW9kZWwuTm9kZT59IHBjb250ZW50XG4gKi9cbmNvbnN0IG1hcHBlZElkZW50aXR5ID0gKG1hcHBlZCwgcGNvbnRlbnQpID0+XG4gIG1hcHBlZCA9PT0gcGNvbnRlbnQgfHxcbiAgKG1hcHBlZCBpbnN0YW5jZW9mIEFycmF5ICYmIHBjb250ZW50IGluc3RhbmNlb2YgQXJyYXkgJiZcbiAgICBtYXBwZWQubGVuZ3RoID09PSBwY29udGVudC5sZW5ndGggJiYgbWFwcGVkLmV2ZXJ5KChhLCBpKSA9PlxuICAgIHBjb250ZW50W2ldID09PSBhXG4gICkpXG5cbi8qKlxuICogQHBhcmFtIHtZLlhtbEVsZW1lbnR9IHl0eXBlXG4gKiBAcGFyYW0ge1BNb2RlbC5Ob2RlfSBwbm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqIEByZXR1cm4ge3sgZm91bmRNYXBwZWRDaGlsZDogYm9vbGVhbiwgZXF1YWxpdHlGYWN0b3I6IG51bWJlciB9fVxuICovXG5jb25zdCBjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvciA9ICh5dHlwZSwgcG5vZGUsIG1ldGEpID0+IHtcbiAgY29uc3QgeUNoaWxkcmVuID0geXR5cGUudG9BcnJheSgpXG4gIGNvbnN0IHBDaGlsZHJlbiA9IG5vcm1hbGl6ZVBOb2RlQ29udGVudChwbm9kZSlcbiAgY29uc3QgcENoaWxkQ250ID0gcENoaWxkcmVuLmxlbmd0aFxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHlDaGlsZENudCwgcENoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICBsZXQgZm91bmRNYXBwZWRDaGlsZCA9IGZhbHNlXG4gIGZvciAoOyBsZWZ0IDwgbWluQ250OyBsZWZ0KyspIHtcbiAgICBjb25zdCBsZWZ0WSA9IHlDaGlsZHJlbltsZWZ0XVxuICAgIGNvbnN0IGxlZnRQID0gcENoaWxkcmVuW2xlZnRdXG4gICAgaWYgKG1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGZvdW5kTWFwcGVkQ2hpbGQgPSB0cnVlIC8vIGRlZmluaXRlIChnb29kKSBtYXRjaCFcbiAgICB9IGVsc2UgaWYgKCFlcXVhbFlUeXBlUE5vZGUobGVmdFksIGxlZnRQKSkge1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgZm9yICg7IGxlZnQgKyByaWdodCA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAobWFwcGVkSWRlbnRpdHkobWV0YS5tYXBwaW5nLmdldChyaWdodFkpLCByaWdodFApKSB7XG4gICAgICBmb3VuZE1hcHBlZENoaWxkID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAoIWVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgZXF1YWxpdHlGYWN0b3I6IGxlZnQgKyByaWdodCxcbiAgICBmb3VuZE1hcHBlZENoaWxkXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuVGV4dH0geXRleHRcbiAqL1xuY29uc3QgeXRleHRUcmFucyA9ICh5dGV4dCkgPT4ge1xuICBsZXQgc3RyID0gJydcbiAgLyoqXG4gICAqIEB0eXBlIHtZLkl0ZW18bnVsbH1cbiAgICovXG4gIGxldCBuID0geXRleHQuX3N0YXJ0XG4gIGNvbnN0IG5BdHRycyA9IHt9XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKCFuLmRlbGV0ZWQpIHtcbiAgICAgIGlmIChuLmNvdW50YWJsZSAmJiBuLmNvbnRlbnQgaW5zdGFuY2VvZiBZLkNvbnRlbnRTdHJpbmcpIHtcbiAgICAgICAgc3RyICs9IG4uY29udGVudC5zdHJcbiAgICAgIH0gZWxzZSBpZiAobi5jb250ZW50IGluc3RhbmNlb2YgWS5Db250ZW50Rm9ybWF0KSB7XG4gICAgICAgIG5BdHRyc1tuLmNvbnRlbnQua2V5XSA9IG51bGxcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0cixcbiAgICBuQXR0cnNcbiAgfVxufVxuXG4vKipcbiAqIEB0b2RvIHRlc3QgdGhpcyBtb3JlXG4gKlxuICogQHBhcmFtIHtZLlRleHR9IHl0ZXh0XG4gKiBAcGFyYW0ge0FycmF5PGFueT59IHB0ZXh0c1xuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuY29uc3QgdXBkYXRlWVRleHQgPSAoeXRleHQsIHB0ZXh0cywgbWV0YSkgPT4ge1xuICBtZXRhLm1hcHBpbmcuc2V0KHl0ZXh0LCBwdGV4dHMpXG4gIGNvbnN0IHsgbkF0dHJzLCBzdHIgfSA9IHl0ZXh0VHJhbnMoeXRleHQpXG4gIGNvbnN0IGNvbnRlbnQgPSBwdGV4dHMubWFwKChwKSA9PiAoe1xuICAgIGluc2VydDogLyoqIEB0eXBlIHthbnl9ICovIChwKS50ZXh0LFxuICAgIGF0dHJpYnV0ZXM6IE9iamVjdC5hc3NpZ24oe30sIG5BdHRycywgbWFya3NUb0F0dHJpYnV0ZXMocC5tYXJrcywgbWV0YSkpXG4gIH0pKVxuICBjb25zdCB7IGluc2VydCwgcmVtb3ZlLCBpbmRleCB9ID0gc2ltcGxlRGlmZihcbiAgICBzdHIsXG4gICAgY29udGVudC5tYXAoKGMpID0+IGMuaW5zZXJ0KS5qb2luKCcnKVxuICApXG4gIHl0ZXh0LmRlbGV0ZShpbmRleCwgcmVtb3ZlKVxuICB5dGV4dC5pbnNlcnQoaW5kZXgsIGluc2VydClcbiAgeXRleHQuYXBwbHlEZWx0YShcbiAgICBjb250ZW50Lm1hcCgoYykgPT4gKHsgcmV0YWluOiBjLmluc2VydC5sZW5ndGgsIGF0dHJpYnV0ZXM6IGMuYXR0cmlidXRlcyB9KSlcbiAgKVxufVxuXG5jb25zdCBoYXNoZWRNYXJrTmFtZVJlZ2V4ID0gLyguKikoLS1bYS16QS1aMC05Ky89XXs4fSkkL1xuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IHlhdHRyMm1hcmtuYW1lID0gYXR0ck5hbWUgPT4gaGFzaGVkTWFya05hbWVSZWdleC5leGVjKGF0dHJOYW1lKT8uWzFdID8/IGF0dHJOYW1lXG5cbi8qKlxuICogQHRvZG8gbW92ZSB0aGlzIHRvIG1hcmtzdG9hdHRyaWJ1dGVzXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBhdHRyc1xuICogQHBhcmFtIHtpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuU2NoZW1hfSBzY2hlbWFcbiAqL1xuZXhwb3J0IGNvbnN0IGF0dHJpYnV0ZXNUb01hcmtzID0gKGF0dHJzLCBzY2hlbWEpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJ3Byb3NlbWlycm9yLW1vZGVsJykuTWFyaz59XG4gICAqL1xuICBjb25zdCBtYXJrcyA9IFtdXG4gIGZvciAoY29uc3QgbWFya05hbWUgaW4gYXR0cnMpIHtcbiAgICAvLyByZW1vdmUgaGFzaGVzIGlmIG5lY2Vzc2FyeVxuICAgIG1hcmtzLnB1c2goc2NoZW1hLm1hcmsoeWF0dHIybWFya25hbWUobWFya05hbWUpLCBhdHRyc1ttYXJrTmFtZV0pKVxuICB9XG4gIHJldHVybiBtYXJrc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCdwcm9zZW1pcnJvci1tb2RlbCcpLk1hcms+fSBtYXJrc1xuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuY29uc3QgbWFya3NUb0F0dHJpYnV0ZXMgPSAobWFya3MsIG1ldGEpID0+IHtcbiAgY29uc3QgcGF0dHJzID0ge31cbiAgbWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgIGlmIChtYXJrLnR5cGUubmFtZSAhPT0gJ3ljaGFuZ2UnKSB7XG4gICAgICBjb25zdCBpc092ZXJsYXBwaW5nID0gbWFwLnNldElmVW5kZWZpbmVkKG1ldGEuaXNPTWFyaywgbWFyay50eXBlLCAoKSA9PiAhbWFyay50eXBlLmV4Y2x1ZGVzKG1hcmsudHlwZSkpXG4gICAgICBwYXR0cnNbaXNPdmVybGFwcGluZyA/IGAke21hcmsudHlwZS5uYW1lfS0tJHt1dGlscy5oYXNoT2ZKU09OKG1hcmsudG9KU09OKCkpfWAgOiBtYXJrLnR5cGUubmFtZV0gPSBtYXJrLmF0dHJzXG4gICAgfVxuICB9KVxuICByZXR1cm4gcGF0dHJzXG59XG5cbi8qKlxuICogVXBkYXRlIGEgeURvbSBub2RlIGJ5IHN5bmNpbmcgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgcHJvc2VtaXJyb3Igbm9kZS5cbiAqXG4gKiBUaGlzIGlzIGEgeS1wcm9zZW1pcnJvciBpbnRlcm5hbCBmZWF0dXJlIHRoYXQgeW91IGNhbiB1c2UgYXQgeW91ciBvd24gcmlzay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHVuc3RhYmxlXG4gKlxuICogQHBhcmFtIHt7dHJhbnNhY3Q6IEZ1bmN0aW9ufX0geVxuICogQHBhcmFtIHtZLlhtbEZyYWdtZW50fSB5RG9tRnJhZ21lbnRcbiAqIEBwYXJhbSB7YW55fSBwTm9kZVxuICogQHBhcmFtIHtCaW5kaW5nTWV0YWRhdGF9IG1ldGFcbiAqL1xuZXhwb3J0IGNvbnN0IHVwZGF0ZVlGcmFnbWVudCA9ICh5LCB5RG9tRnJhZ21lbnQsIHBOb2RlLCBtZXRhKSA9PiB7XG4gIGlmIChcbiAgICB5RG9tRnJhZ21lbnQgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiZcbiAgICB5RG9tRnJhZ21lbnQubm9kZU5hbWUgIT09IHBOb2RlLnR5cGUubmFtZVxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vZGUgbmFtZSBtaXNtYXRjaCEnKVxuICB9XG4gIG1ldGEubWFwcGluZy5zZXQoeURvbUZyYWdtZW50LCBwTm9kZSlcbiAgLy8gdXBkYXRlIGF0dHJpYnV0ZXNcbiAgaWYgKHlEb21GcmFnbWVudCBpbnN0YW5jZW9mIFkuWG1sRWxlbWVudCkge1xuICAgIGNvbnN0IHlEb21BdHRycyA9IHlEb21GcmFnbWVudC5nZXRBdHRyaWJ1dGVzKClcbiAgICBjb25zdCBwQXR0cnMgPSBwTm9kZS5hdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHBBdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldICE9PSBudWxsKSB7XG4gICAgICAgIGlmICh5RG9tQXR0cnNba2V5XSAhPT0gcEF0dHJzW2tleV0gJiYga2V5ICE9PSAneWNoYW5nZScpIHtcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuc2V0QXR0cmlidXRlKGtleSwgcEF0dHJzW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlEb21GcmFnbWVudC5yZW1vdmVBdHRyaWJ1dGUoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgICAvLyByZW1vdmUgYWxsIGtleXMgdGhhdCBhcmUgbm8gbG9uZ2VyIGluIHBBdHRyc1xuICAgIGZvciAoY29uc3Qga2V5IGluIHlEb21BdHRycykge1xuICAgICAgaWYgKHBBdHRyc1trZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgeURvbUZyYWdtZW50LnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIHVwZGF0ZSBjaGlsZHJlblxuICBjb25zdCBwQ2hpbGRyZW4gPSBub3JtYWxpemVQTm9kZUNvbnRlbnQocE5vZGUpXG4gIGNvbnN0IHBDaGlsZENudCA9IHBDaGlsZHJlbi5sZW5ndGhcbiAgY29uc3QgeUNoaWxkcmVuID0geURvbUZyYWdtZW50LnRvQXJyYXkoKVxuICBjb25zdCB5Q2hpbGRDbnQgPSB5Q2hpbGRyZW4ubGVuZ3RoXG4gIGNvbnN0IG1pbkNudCA9IG1hdGgubWluKHBDaGlsZENudCwgeUNoaWxkQ250KVxuICBsZXQgbGVmdCA9IDBcbiAgbGV0IHJpZ2h0ID0gMFxuICAvLyBmaW5kIG51bWJlciBvZiBtYXRjaGluZyBlbGVtZW50cyBmcm9tIGxlZnRcbiAgZm9yICg7IGxlZnQgPCBtaW5DbnQ7IGxlZnQrKykge1xuICAgIGNvbnN0IGxlZnRZID0geUNoaWxkcmVuW2xlZnRdXG4gICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQobGVmdFkpLCBsZWZ0UCkpIHtcbiAgICAgIGlmIChlcXVhbFlUeXBlUE5vZGUobGVmdFksIGxlZnRQKSkge1xuICAgICAgICAvLyB1cGRhdGUgbWFwcGluZ1xuICAgICAgICBtZXRhLm1hcHBpbmcuc2V0KGxlZnRZLCBsZWZ0UClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGZpbmQgbnVtYmVyIG9mIG1hdGNoaW5nIGVsZW1lbnRzIGZyb20gcmlnaHRcbiAgZm9yICg7IHJpZ2h0ICsgbGVmdCA8IG1pbkNudDsgcmlnaHQrKykge1xuICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgY29uc3QgcmlnaHRQID0gcENoaWxkcmVuW3BDaGlsZENudCAtIHJpZ2h0IC0gMV1cbiAgICBpZiAoIW1hcHBlZElkZW50aXR5KG1ldGEubWFwcGluZy5nZXQocmlnaHRZKSwgcmlnaHRQKSkge1xuICAgICAgaWYgKGVxdWFsWVR5cGVQTm9kZShyaWdodFksIHJpZ2h0UCkpIHtcbiAgICAgICAgLy8gdXBkYXRlIG1hcHBpbmdcbiAgICAgICAgbWV0YS5tYXBwaW5nLnNldChyaWdodFksIHJpZ2h0UClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHkudHJhbnNhY3QoKCkgPT4ge1xuICAgIC8vIHRyeSB0byBjb21wYXJlIGFuZCB1cGRhdGVcbiAgICB3aGlsZSAoeUNoaWxkQ250IC0gbGVmdCAtIHJpZ2h0ID4gMCAmJiBwQ2hpbGRDbnQgLSBsZWZ0IC0gcmlnaHQgPiAwKSB7XG4gICAgICBjb25zdCBsZWZ0WSA9IHlDaGlsZHJlbltsZWZ0XVxuICAgICAgY29uc3QgbGVmdFAgPSBwQ2hpbGRyZW5bbGVmdF1cbiAgICAgIGNvbnN0IHJpZ2h0WSA9IHlDaGlsZHJlblt5Q2hpbGRDbnQgLSByaWdodCAtIDFdXG4gICAgICBjb25zdCByaWdodFAgPSBwQ2hpbGRyZW5bcENoaWxkQ250IC0gcmlnaHQgLSAxXVxuICAgICAgaWYgKGxlZnRZIGluc3RhbmNlb2YgWS5YbWxUZXh0ICYmIGxlZnRQIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgaWYgKCFlcXVhbFlUZXh0UFRleHQobGVmdFksIGxlZnRQKSkge1xuICAgICAgICAgIHVwZGF0ZVlUZXh0KGxlZnRZLCBsZWZ0UCwgbWV0YSlcbiAgICAgICAgfVxuICAgICAgICBsZWZ0ICs9IDFcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB1cGRhdGVMZWZ0ID0gbGVmdFkgaW5zdGFuY2VvZiBZLlhtbEVsZW1lbnQgJiZcbiAgICAgICAgICBtYXRjaE5vZGVOYW1lKGxlZnRZLCBsZWZ0UClcbiAgICAgICAgbGV0IHVwZGF0ZVJpZ2h0ID0gcmlnaHRZIGluc3RhbmNlb2YgWS5YbWxFbGVtZW50ICYmXG4gICAgICAgICAgbWF0Y2hOb2RlTmFtZShyaWdodFksIHJpZ2h0UClcbiAgICAgICAgaWYgKHVwZGF0ZUxlZnQgJiYgdXBkYXRlUmlnaHQpIHtcbiAgICAgICAgICAvLyBkZWNpZGUgd2hpY2ggd2hpY2ggZWxlbWVudCB0byB1cGRhdGVcbiAgICAgICAgICBjb25zdCBlcXVhbGl0eUxlZnQgPSBjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvcihcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxFbGVtZW50fSAqLyAobGVmdFkpLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKGxlZnRQKSxcbiAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICApXG4gICAgICAgICAgY29uc3QgZXF1YWxpdHlSaWdodCA9IGNvbXB1dGVDaGlsZEVxdWFsaXR5RmFjdG9yKFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtZLlhtbEVsZW1lbnR9ICovIChyaWdodFkpLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtQTW9kZWwuTm9kZX0gKi8gKHJpZ2h0UCksXG4gICAgICAgICAgICBtZXRhXG4gICAgICAgICAgKVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGVxdWFsaXR5TGVmdC5mb3VuZE1hcHBlZENoaWxkICYmICFlcXVhbGl0eVJpZ2h0LmZvdW5kTWFwcGVkQ2hpbGRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHVwZGF0ZVJpZ2h0ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgIWVxdWFsaXR5TGVmdC5mb3VuZE1hcHBlZENoaWxkICYmIGVxdWFsaXR5UmlnaHQuZm91bmRNYXBwZWRDaGlsZFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdXBkYXRlTGVmdCA9IGZhbHNlXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgIGVxdWFsaXR5TGVmdC5lcXVhbGl0eUZhY3RvciA8IGVxdWFsaXR5UmlnaHQuZXF1YWxpdHlGYWN0b3JcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHVwZGF0ZUxlZnQgPSBmYWxzZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVSaWdodCA9IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh1cGRhdGVMZWZ0KSB7XG4gICAgICAgICAgdXBkYXRlWUZyYWdtZW50KFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxGcmFnbWVudH0gKi8gKGxlZnRZKSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7UE1vZGVsLk5vZGV9ICovIChsZWZ0UCksXG4gICAgICAgICAgICBtZXRhXG4gICAgICAgICAgKVxuICAgICAgICAgIGxlZnQgKz0gMVxuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZVJpZ2h0KSB7XG4gICAgICAgICAgdXBkYXRlWUZyYWdtZW50KFxuICAgICAgICAgICAgeSxcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7WS5YbWxGcmFnbWVudH0gKi8gKHJpZ2h0WSksXG4gICAgICAgICAgICAvKiogQHR5cGUge1BNb2RlbC5Ob2RlfSAqLyAocmlnaHRQKSxcbiAgICAgICAgICAgIG1ldGFcbiAgICAgICAgICApXG4gICAgICAgICAgcmlnaHQgKz0gMVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGEubWFwcGluZy5kZWxldGUoeURvbUZyYWdtZW50LmdldChsZWZ0KSlcbiAgICAgICAgICB5RG9tRnJhZ21lbnQuZGVsZXRlKGxlZnQsIDEpXG4gICAgICAgICAgeURvbUZyYWdtZW50Lmluc2VydChsZWZ0LCBbXG4gICAgICAgICAgICBjcmVhdGVUeXBlRnJvbVRleHRPckVsZW1lbnROb2RlKGxlZnRQLCBtZXRhKVxuICAgICAgICAgIF0pXG4gICAgICAgICAgbGVmdCArPSAxXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeURlbExlbiA9IHlDaGlsZENudCAtIGxlZnQgLSByaWdodFxuICAgIGlmIChcbiAgICAgIHlDaGlsZENudCA9PT0gMSAmJiBwQ2hpbGRDbnQgPT09IDAgJiYgeUNoaWxkcmVuWzBdIGluc3RhbmNlb2YgWS5YbWxUZXh0XG4gICAgKSB7XG4gICAgICBtZXRhLm1hcHBpbmcuZGVsZXRlKHlDaGlsZHJlblswXSlcbiAgICAgIC8vIEVkZ2UgY2FzZSBoYW5kbGluZyBodHRwczovL2dpdGh1Yi5jb20veWpzL3ktcHJvc2VtaXJyb3IvaXNzdWVzLzEwOFxuICAgICAgLy8gT25seSBkZWxldGUgdGhlIGNvbnRlbnQgb2YgdGhlIFkuVGV4dCB0byByZXRhaW4gcmVtb3RlIGNoYW5nZXMgb24gdGhlIHNhbWUgWS5UZXh0IG9iamVjdFxuICAgICAgeUNoaWxkcmVuWzBdLmRlbGV0ZSgwLCB5Q2hpbGRyZW5bMF0ubGVuZ3RoKVxuICAgIH0gZWxzZSBpZiAoeURlbExlbiA+IDApIHtcbiAgICAgIHlEb21GcmFnbWVudC5zbGljZShsZWZ0LCBsZWZ0ICsgeURlbExlbikuZm9yRWFjaCh0eXBlID0+IG1ldGEubWFwcGluZy5kZWxldGUodHlwZSkpXG4gICAgICB5RG9tRnJhZ21lbnQuZGVsZXRlKGxlZnQsIHlEZWxMZW4pXG4gICAgfVxuICAgIGlmIChsZWZ0ICsgcmlnaHQgPCBwQ2hpbGRDbnQpIHtcbiAgICAgIGNvbnN0IGlucyA9IFtdXG4gICAgICBmb3IgKGxldCBpID0gbGVmdDsgaSA8IHBDaGlsZENudCAtIHJpZ2h0OyBpKyspIHtcbiAgICAgICAgaW5zLnB1c2goY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZShwQ2hpbGRyZW5baV0sIG1ldGEpKVxuICAgICAgfVxuICAgICAgeURvbUZyYWdtZW50Lmluc2VydChsZWZ0LCBpbnMpXG4gICAgfVxuICB9LCB5U3luY1BsdWdpbktleSlcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7WS5YbWxFbGVtZW50fSB5RWxlbWVudFxuICogQHBhcmFtIHthbnl9IHBOb2RlIFByb3NlbWlycm9yIE5vZGVcbiAqL1xuY29uc3QgbWF0Y2hOb2RlTmFtZSA9ICh5RWxlbWVudCwgcE5vZGUpID0+XG4gICEocE5vZGUgaW5zdGFuY2VvZiBBcnJheSkgJiYgeUVsZW1lbnQubm9kZU5hbWUgPT09IHBOb2RlLnR5cGUubmFtZVxuIl0sIm5hbWVzIjpbImNyZWF0ZU11dGV4IiwiUE1vZGVsIiwiQWxsU2VsZWN0aW9uIiwiUGx1Z2luIiwiVGV4dFNlbGVjdGlvbiIsIk5vZGVTZWxlY3Rpb24iLCJtYXRoIiwib2JqZWN0Iiwic2V0Iiwic2ltcGxlRGlmZiIsImVycm9yIiwieVN5bmNQbHVnaW5LZXkiLCJ5VW5kb1BsdWdpbktleSIsIlkiLCJhYnNvbHV0ZVBvc2l0aW9uVG9SZWxhdGl2ZVBvc2l0aW9uIiwicmVsYXRpdmVQb3NpdGlvblRvQWJzb2x1dGVQb3NpdGlvbiIsInJhbmRvbSIsImVudmlyb25tZW50IiwiZG9tIiwiZXZlbnRsb29wIiwibWFwIiwidXRpbHMiLCJjcmVhdGVFbXB0eU1ldGEiLCJtYXBwaW5nIiwiTWFwIiwiaXNPTWFyayIsImlzVmlzaWJsZSIsIml0ZW0iLCJzbmFwc2hvdCIsInVuZGVmaW5lZCIsImRlbGV0ZWQiLCJzdiIsImhhcyIsImlkIiwiY2xpZW50IiwiZ2V0IiwiY2xvY2siLCJpc0RlbGV0ZWQiLCJkcyIsImRlZmF1bHRDb2xvcnMiLCJsaWdodCIsImRhcmsiLCJnZXRVc2VyQ29sb3IiLCJjb2xvck1hcHBpbmciLCJjb2xvcnMiLCJ1c2VyIiwic2l6ZSIsImxlbmd0aCIsInVzZWRDb2xvcnMiLCJjcmVhdGUiLCJmb3JFYWNoIiwiY29sb3IiLCJhZGQiLCJmaWx0ZXIiLCJvbmVPZiIsInlTeW5jUGx1Z2luIiwieVhtbEZyYWdtZW50IiwicGVybWFuZW50VXNlckRhdGEiLCJvbkZpcnN0UmVuZGVyIiwiaW5pdGlhbENvbnRlbnRDaGFuZ2VkIiwiYmluZGluZyIsIlByb3NlbWlycm9yQmluZGluZyIsInBsdWdpbiIsInByb3BzIiwiZWRpdGFibGUiLCJzdGF0ZSIsInN5bmNTdGF0ZSIsImdldFN0YXRlIiwicHJldlNuYXBzaG90Iiwia2V5IiwiaW5pdCIsIl9pbml0YXJncyIsIl9zdGF0ZSIsInR5cGUiLCJkb2MiLCJpc0NoYW5nZU9yaWdpbiIsImlzVW5kb1JlZG9PcGVyYXRpb24iLCJhZGRUb0hpc3RvcnkiLCJhcHBseSIsInRyIiwicGx1Z2luU3RhdGUiLCJjaGFuZ2UiLCJnZXRNZXRhIiwiT2JqZWN0IiwiYXNzaWduIiwicHJvc2VtaXJyb3JWaWV3IiwidGltZW91dCIsInJlc3RvcmUiLCJfcmVuZGVyU25hcHNob3QiLCJtdXgiLCJfcHJvc2VtaXJyb3JDaGFuZ2VkIiwidmlldyIsImluaXRWaWV3IiwiX2ZvcmNlUmVyZW5kZXIiLCJ1cGRhdGUiLCJjb250ZW50IiwiZmluZERpZmZTdGFydCIsImNyZWF0ZUFuZEZpbGwiLCJ5VW5kb1BsdWdpblN0YXRlIiwidW0iLCJ1bmRvTWFuYWdlciIsInN0b3BDYXB0dXJpbmciLCJ0cmFuc2FjdCIsIm1ldGEiLCJkZXN0cm95IiwicmVzdG9yZVJlbGF0aXZlU2VsZWN0aW9uIiwicmVsU2VsIiwiYW5jaG9yIiwiaGVhZCIsInNldFNlbGVjdGlvbiIsInNlbCIsImJldHdlZW4iLCJyZXNvbHZlIiwiZ2V0UmVsYXRpdmVTZWxlY3Rpb24iLCJwbWJpbmRpbmciLCJzZWxlY3Rpb24iLCJqc29uSUQiLCJjb25zdHJ1Y3RvciIsIl9vYnNlcnZlRnVuY3Rpb24iLCJfdHlwZUNoYW5nZWQiLCJiaW5kIiwiYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24iLCJiZWZvcmVBbGxUcmFuc2FjdGlvbnMiLCJhZnRlckFsbFRyYW5zYWN0aW9ucyIsIl9kb21TZWxlY3Rpb25JblZpZXciLCJfdHIiLCJzZXRNZXRhIiwiX2lzTG9jYWxDdXJzb3JJblZpZXciLCJoYXNGb2N1cyIsImlzQnJvd3NlciIsIl9pc0RvbVNlbGVjdGlvbkluVmlldyIsIl9yb290IiwiZ2V0U2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsImFuY2hvck9mZnNldCIsInNldEVuZCIsImZvY3VzTm9kZSIsImZvY3VzT2Zmc2V0IiwicmVjdHMiLCJnZXRDbGllbnRSZWN0cyIsInN0YXJ0Q29udGFpbmVyIiwiY29sbGFwc2VkIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwiYm91bmRpbmciLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJkb2N1bWVudEVsZW1lbnQiLCJib3R0b20iLCJyaWdodCIsImxlZnQiLCJ3aW5kb3ciLCJpbm5lcldpZHRoIiwiY2xpZW50V2lkdGgiLCJ0b3AiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsInJlbmRlclNuYXBzaG90IiwiY3JlYXRlU25hcHNob3QiLCJjcmVhdGVEZWxldGVTZXQiLCJkaXNwYXRjaCIsInVucmVuZGVyU25hcHNob3QiLCJjbGVhciIsImZyYWdtZW50Q29udGVudCIsInRvQXJyYXkiLCJ0IiwiY3JlYXRlTm9kZUZyb21ZRWxlbWVudCIsInNjaGVtYSIsIm4iLCJyZXBsYWNlIiwiU2xpY2UiLCJGcmFnbWVudCIsImZyb20iLCJjbGFtcGVkQW5jaG9yIiwibWluIiwibWF4IiwiY2xhbXBlZEhlYWQiLCJoaXN0b3J5RG9jIiwiaGlzdG9yeVR5cGUiLCJVaW50OEFycmF5IiwidW5leHBlY3RlZENhc2UiLCJEb2MiLCJnYyIsImFwcGx5VXBkYXRlVjIiLCJfaXRlbSIsInJvb3RLZXkiLCJBcnJheSIsInNoYXJlIiwia2V5cyIsImZpbmQiLCJnZXRYbWxGcmFnbWVudCIsImhpc3RvcnlTdHJ1Y3RzIiwic3RvcmUiLCJjbGllbnRzIiwiaXRlbUluZGV4IiwiZmluZEluZGV4U1MiLCJ0cmFuc2FjdGlvbiIsInB1ZCIsImRzcyIsIml0ZXJhdGVEZWxldGVkU3RydWN0cyIsImNvbXB1dGVZQ2hhbmdlIiwiZ2V0VXNlckJ5Q2xpZW50SWQiLCJnZXRVc2VyQnlEZWxldGVkSWQiLCJ0eXBlTGlzdFRvQXJyYXlTbmFwc2hvdCIsIlNuYXBzaG90IiwiZXZlbnRzIiwiZGVsVHlwZSIsIl8iLCJkZWxldGUiLCJkZWxldGVTZXQiLCJzdHJ1Y3QiLCJJdGVtIiwiY2hhbmdlZCIsImNoYW5nZWRQYXJlbnRUeXBlcyIsImNyZWF0ZU5vZGVJZk5vdEV4aXN0cyIsIm9yaWdpbiIsIlVuZG9NYW5hZ2VyIiwic2Nyb2xsSW50b1ZpZXciLCJ1cGRhdGVZRnJhZ21lbnQiLCJvbiIsIm9ic2VydmVEZWVwIiwidW5vYnNlcnZlRGVlcCIsIm9mZiIsImVsIiwibm9kZSIsIlhtbEVsZW1lbnQiLCJtZXRob2RVbmltcGxlbWVudGVkIiwiY2hpbGRyZW4iLCJjcmVhdGVDaGlsZHJlbiIsInB1c2giLCJuZXh0eXRleHQiLCJUZXh0IiwiY2xpZW50SUQiLCJhcHBseURlbHRhIiwicmV0YWluIiwidG9EZWx0YSIsIm5zIiwiY3JlYXRlVGV4dE5vZGVzRnJvbVlUZXh0IiwidGV4dGNoaWxkIiwiYXR0cnMiLCJnZXRBdHRyaWJ1dGVzIiwieWNoYW5nZSIsIm5vZGVOYW1lIiwiZSIsInRleHQiLCJfbWV0YSIsIm5vZGVzIiwiZGVsdGFzIiwiaSIsImRlbHRhIiwiaW5zZXJ0IiwiYXR0cmlidXRlc1RvTWFya3MiLCJhdHRyaWJ1dGVzIiwiY3JlYXRlVHlwZUZyb21UZXh0Tm9kZXMiLCJYbWxUZXh0IiwibWFya3NUb0F0dHJpYnV0ZXMiLCJtYXJrcyIsImNyZWF0ZVR5cGVGcm9tRWxlbWVudE5vZGUiLCJuYW1lIiwidmFsIiwic2V0QXR0cmlidXRlIiwibm9ybWFsaXplUE5vZGVDb250ZW50IiwiY3JlYXRlVHlwZUZyb21UZXh0T3JFbGVtZW50Tm9kZSIsImlzT2JqZWN0IiwiZXF1YWxBdHRycyIsInBhdHRycyIsInlhdHRycyIsImVxIiwibCIsInIiLCJwbm9kZSIsImMiLCJyZXMiLCJpc1RleHQiLCJ0ZXh0Tm9kZXMiLCJ0bm9kZSIsImVxdWFsWVRleHRQVGV4dCIsInl0ZXh0IiwicHRleHRzIiwiZXZlcnkiLCJkIiwiYXR0ciIsInlhdHRybmFtZSIsIm1hcmtuYW1lIiwieWF0dHIybWFya25hbWUiLCJwbWFya3MiLCJtYXJrIiwiZXF1YWxZVHlwZVBOb2RlIiwieXR5cGUiLCJtYXRjaE5vZGVOYW1lIiwibm9ybWFsaXplZENvbnRlbnQiLCJfbGVuZ3RoIiwieWNoaWxkIiwibWFwcGVkSWRlbnRpdHkiLCJtYXBwZWQiLCJwY29udGVudCIsImEiLCJjb21wdXRlQ2hpbGRFcXVhbGl0eUZhY3RvciIsInlDaGlsZHJlbiIsInBDaGlsZHJlbiIsInBDaGlsZENudCIsInlDaGlsZENudCIsIm1pbkNudCIsImZvdW5kTWFwcGVkQ2hpbGQiLCJsZWZ0WSIsImxlZnRQIiwicmlnaHRZIiwicmlnaHRQIiwiZXF1YWxpdHlGYWN0b3IiLCJ5dGV4dFRyYW5zIiwic3RyIiwiX3N0YXJ0IiwibkF0dHJzIiwiY291bnRhYmxlIiwiQ29udGVudFN0cmluZyIsIkNvbnRlbnRGb3JtYXQiLCJ1cGRhdGVZVGV4dCIsInAiLCJyZW1vdmUiLCJpbmRleCIsImpvaW4iLCJoYXNoZWRNYXJrTmFtZVJlZ2V4IiwiYXR0ck5hbWUiLCJleGVjIiwibWFya05hbWUiLCJpc092ZXJsYXBwaW5nIiwic2V0SWZVbmRlZmluZWQiLCJleGNsdWRlcyIsImhhc2hPZkpTT04iLCJ0b0pTT04iLCJ5IiwieURvbUZyYWdtZW50IiwicE5vZGUiLCJFcnJvciIsInlEb21BdHRycyIsInBBdHRycyIsInJlbW92ZUF0dHJpYnV0ZSIsInVwZGF0ZUxlZnQiLCJ1cGRhdGVSaWdodCIsImVxdWFsaXR5TGVmdCIsImVxdWFsaXR5UmlnaHQiLCJ5RGVsTGVuIiwic2xpY2UiLCJpbnMiLCJ5RWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js":
/*!***************************************************************!*\
  !*** ./node_modules/y-prosemirror/src/plugins/undo-plugin.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defaultDeleteFilter: () => (/* binding */ defaultDeleteFilter),\n/* harmony export */   defaultProtectedNodes: () => (/* binding */ defaultProtectedNodes),\n/* harmony export */   redo: () => (/* binding */ redo),\n/* harmony export */   redoCommand: () => (/* binding */ redoCommand),\n/* harmony export */   undo: () => (/* binding */ undo),\n/* harmony export */   undoCommand: () => (/* binding */ undoCommand),\n/* harmony export */   yUndoPlugin: () => (/* binding */ yUndoPlugin)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var _sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sync-plugin.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var yjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! yjs */ \"(ssr)/./node_modules/yjs/dist/yjs.mjs\");\n/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keys.js */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n\n\n\n\n/**\n * @typedef {Object} UndoPluginState\n * @property {import('yjs').UndoManager} undoManager\n * @property {ReturnType<typeof getRelativeSelection> | null} prevSel\n * @property {boolean} hasUndoOps\n * @property {boolean} hasRedoOps\n */ /**\n * Undo the last user action\n *\n * @param {import('prosemirror-state').EditorState} state\n * @return {boolean} whether a change was undone\n */ const undo = (state)=>_keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.undo() != null;\n/**\n * Redo the last user action\n *\n * @param {import('prosemirror-state').EditorState} state\n * @return {boolean} whether a change was undone\n */ const redo = (state)=>_keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.redo() != null;\n/**\n * Undo the last user action if there are undo operations available\n * @type {import('prosemirror-state').Command}\n */ const undoCommand = (state, dispatch)=>dispatch == null ? _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.canUndo() : undo(state);\n/**\n * Redo the last user action if there are redo operations available\n * @type {import('prosemirror-state').Command}\n */ const redoCommand = (state, dispatch)=>dispatch == null ? _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(state)?.undoManager?.canRedo() : redo(state);\nconst defaultProtectedNodes = new Set([\n    \"paragraph\"\n]);\n/**\n * @param {import('yjs').Item} item\n * @param {Set<string>} protectedNodes\n * @returns {boolean}\n */ const defaultDeleteFilter = (item, protectedNodes)=>!(item instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Item) || !(item.content instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.ContentType) || !(item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.Text || item.content.type instanceof yjs__WEBPACK_IMPORTED_MODULE_1__.XmlElement && protectedNodes.has(item.content.type.nodeName)) || item.content.type._length === 0;\n/**\n * @param {object} [options]\n * @param {Set<string>} [options.protectedNodes]\n * @param {any[]} [options.trackedOrigins]\n * @param {import('yjs').UndoManager | null} [options.undoManager]\n */ const yUndoPlugin = ({ protectedNodes = defaultProtectedNodes, trackedOrigins = [], undoManager = null } = {})=>new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey,\n        state: {\n            init: (initargs, state)=>{\n                // TODO: check if plugin order matches and fix\n                const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state);\n                const _undoManager = undoManager || new yjs__WEBPACK_IMPORTED_MODULE_1__.UndoManager(ystate.type, {\n                    trackedOrigins: new Set([\n                        _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey\n                    ].concat(trackedOrigins)),\n                    deleteFilter: (item)=>defaultDeleteFilter(item, protectedNodes),\n                    captureTransaction: (tr)=>tr.meta.get(\"addToHistory\") !== false\n                });\n                return {\n                    undoManager: _undoManager,\n                    prevSel: null,\n                    hasUndoOps: _undoManager.undoStack.length > 0,\n                    hasRedoOps: _undoManager.redoStack.length > 0\n                };\n            },\n            apply: (tr, val, oldState, state)=>{\n                const binding = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(state).binding;\n                const undoManager = val.undoManager;\n                const hasUndoOps = undoManager.undoStack.length > 0;\n                const hasRedoOps = undoManager.redoStack.length > 0;\n                if (binding) {\n                    return {\n                        undoManager,\n                        prevSel: (0,_sync_plugin_js__WEBPACK_IMPORTED_MODULE_3__.getRelativeSelection)(binding, oldState),\n                        hasUndoOps,\n                        hasRedoOps\n                    };\n                } else {\n                    if (hasUndoOps !== val.hasUndoOps || hasRedoOps !== val.hasRedoOps) {\n                        return Object.assign({}, val, {\n                            hasUndoOps: undoManager.undoStack.length > 0,\n                            hasRedoOps: undoManager.redoStack.length > 0\n                        });\n                    } else {\n                        return val;\n                    }\n                }\n            }\n        },\n        view: (view)=>{\n            const ystate = _keys_js__WEBPACK_IMPORTED_MODULE_0__.ySyncPluginKey.getState(view.state);\n            const undoManager = _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).undoManager;\n            undoManager.on(\"stack-item-added\", ({ stackItem })=>{\n                const binding = ystate.binding;\n                if (binding) {\n                    stackItem.meta.set(binding, _keys_js__WEBPACK_IMPORTED_MODULE_0__.yUndoPluginKey.getState(view.state).prevSel);\n                }\n            });\n            undoManager.on(\"stack-item-popped\", ({ stackItem })=>{\n                const binding = ystate.binding;\n                if (binding) {\n                    binding.beforeTransactionSelection = stackItem.meta.get(binding) || binding.beforeTransactionSelection;\n                }\n            });\n            return {\n                destroy: ()=>{\n                    undoManager.destroy();\n                }\n            };\n        }\n    });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvcGx1Z2lucy91bmRvLXBsdWdpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwQztBQUVhO0FBQ2U7QUFDWjtBQUUxRDs7Ozs7O0NBTUMsR0FFRDs7Ozs7Q0FLQyxHQUNNLE1BQU1TLE9BQU9DLENBQUFBLFFBQVNILG9EQUFjQSxDQUFDSSxRQUFRLENBQUNELFFBQVFFLGFBQWFILFVBQVUsS0FBSTtBQUV4Rjs7Ozs7Q0FLQyxHQUNNLE1BQU1JLE9BQU9ILENBQUFBLFFBQVNILG9EQUFjQSxDQUFDSSxRQUFRLENBQUNELFFBQVFFLGFBQWFDLFVBQVUsS0FBSTtBQUV4Rjs7O0NBR0MsR0FDTSxNQUFNQyxjQUFjLENBQUNKLE9BQU9LLFdBQWFBLFlBQVksT0FBT1Isb0RBQWNBLENBQUNJLFFBQVEsQ0FBQ0QsUUFBUUUsYUFBYUksWUFBWVAsS0FBS0MsT0FBTTtBQUV2STs7O0NBR0MsR0FDTSxNQUFNTyxjQUFjLENBQUNQLE9BQU9LLFdBQWFBLFlBQVksT0FBT1Isb0RBQWNBLENBQUNJLFFBQVEsQ0FBQ0QsUUFBUUUsYUFBYU0sWUFBWUwsS0FBS0gsT0FBTTtBQUVoSSxNQUFNUyx3QkFBd0IsSUFBSUMsSUFBSTtJQUFDO0NBQVksRUFBQztBQUUzRDs7OztDQUlDLEdBQ00sTUFBTUMsc0JBQXNCLENBQUNDLE1BQU1DLGlCQUFtQixDQUFFRCxDQUFBQSxnQkFBZ0JuQixxQ0FBRyxLQUNoRixDQUFFbUIsQ0FBQUEsS0FBS0UsT0FBTyxZQUFZcEIsNENBQVUsS0FDcEMsQ0FBRWtCLENBQUFBLEtBQUtFLE9BQU8sQ0FBQ0MsSUFBSSxZQUFZbkIscUNBQUlBLElBQ2xDZ0IsS0FBS0UsT0FBTyxDQUFDQyxJQUFJLFlBQVlwQiwyQ0FBVUEsSUFBSWtCLGVBQWVHLEdBQUcsQ0FBQ0osS0FBS0UsT0FBTyxDQUFDQyxJQUFJLENBQUNFLFFBQVEsQ0FBQyxLQUMxRkwsS0FBS0UsT0FBTyxDQUFDQyxJ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QUNGO0lBQ0YsR0FBRSIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3BsdWdpbnMvdW5kby1wbHVnaW4uanM/YWIzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSdcblxuaW1wb3J0IHsgZ2V0UmVsYXRpdmVTZWxlY3Rpb24gfSBmcm9tICcuL3N5bmMtcGx1Z2luLmpzJ1xuaW1wb3J0IHsgVW5kb01hbmFnZXIsIEl0ZW0sIENvbnRlbnRUeXBlLCBYbWxFbGVtZW50LCBUZXh0IH0gZnJvbSAneWpzJ1xuaW1wb3J0IHsgeVVuZG9QbHVnaW5LZXksIHlTeW5jUGx1Z2luS2V5IH0gZnJvbSAnLi9rZXlzLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFVuZG9QbHVnaW5TdGF0ZVxuICogQHByb3BlcnR5IHtpbXBvcnQoJ3lqcycpLlVuZG9NYW5hZ2VyfSB1bmRvTWFuYWdlclxuICogQHByb3BlcnR5IHtSZXR1cm5UeXBlPHR5cGVvZiBnZXRSZWxhdGl2ZVNlbGVjdGlvbj4gfCBudWxsfSBwcmV2U2VsXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGhhc1VuZG9PcHNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaGFzUmVkb09wc1xuICovXG5cbi8qKlxuICogVW5kbyB0aGUgbGFzdCB1c2VyIGFjdGlvblxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCdwcm9zZW1pcnJvci1zdGF0ZScpLkVkaXRvclN0YXRlfSBzdGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciBhIGNoYW5nZSB3YXMgdW5kb25lXG4gKi9cbmV4cG9ydCBjb25zdCB1bmRvID0gc3RhdGUgPT4geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpPy51bmRvTWFuYWdlcj8udW5kbygpICE9IG51bGxcblxuLyoqXG4gKiBSZWRvIHRoZSBsYXN0IHVzZXIgYWN0aW9uXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJ3Byb3NlbWlycm9yLXN0YXRlJykuRWRpdG9yU3RhdGV9IHN0YXRlXG4gKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIGEgY2hhbmdlIHdhcyB1bmRvbmVcbiAqL1xuZXhwb3J0IGNvbnN0IHJlZG8gPSBzdGF0ZSA9PiB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSk/LnVuZG9NYW5hZ2VyPy5yZWRvKCkgIT0gbnVsbFxuXG4vKipcbiAqIFVuZG8gdGhlIGxhc3QgdXNlciBhY3Rpb24gaWYgdGhlcmUgYXJlIHVuZG8gb3BlcmF0aW9ucyBhdmFpbGFibGVcbiAqIEB0eXBlIHtpbXBvcnQoJ3Byb3NlbWlycm9yLXN0YXRlJykuQ29tbWFuZH1cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZG9Db21tYW5kID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4gZGlzcGF0Y2ggPT0gbnVsbCA/IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKT8udW5kb01hbmFnZXI/LmNhblVuZG8oKSA6IHVuZG8oc3RhdGUpXG5cbi8qKlxuICogUmVkbyB0aGUgbGFzdCB1c2VyIGFjdGlvbiBpZiB0aGVyZSBhcmUgcmVkbyBvcGVyYXRpb25zIGF2YWlsYWJsZVxuICogQHR5cGUge2ltcG9ydCgncHJvc2VtaXJyb3Itc3RhdGUnKS5Db21tYW5kfVxuICovXG5leHBvcnQgY29uc3QgcmVkb0NvbW1hbmQgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiBkaXNwYXRjaCA9PSBudWxsID8geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUoc3RhdGUpPy51bmRvTWFuYWdlcj8uY2FuUmVkbygpIDogcmVkbyhzdGF0ZSlcblxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm90ZWN0ZWROb2RlcyA9IG5ldyBTZXQoWydwYXJhZ3JhcGgnXSlcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgneWpzJykuSXRlbX0gaXRlbVxuICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gcHJvdGVjdGVkTm9kZXNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZGVmYXVsdERlbGV0ZUZpbHRlciA9IChpdGVtLCBwcm90ZWN0ZWROb2RlcykgPT4gIShpdGVtIGluc3RhbmNlb2YgSXRlbSkgfHxcbiAgIShpdGVtLmNvbnRlbnQgaW5zdGFuY2VvZiBDb250ZW50VHlwZSkgfHxcbiAgIShpdGVtLmNvbnRlbnQudHlwZSBpbnN0YW5jZW9mIFRleHQgfHxcbiAgKGl0ZW0uY29udGVudC50eXBlIGluc3RhbmNlb2YgWG1sRWxlbWVudCAmJiBwcm90ZWN0ZWROb2Rlcy5oYXMoaXRlbS5jb250ZW50LnR5cGUubm9kZU5hbWUpKSkgfHxcbiAgaXRlbS5jb250ZW50LnR5cGUuX2xlbmd0aCA9PT0gMFxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7U2V0PHN0cmluZz59IFtvcHRpb25zLnByb3RlY3RlZE5vZGVzXVxuICogQHBhcmFtIHthbnlbXX0gW29wdGlvbnMudHJhY2tlZE9yaWdpbnNdXG4gKiBAcGFyYW0ge2ltcG9ydCgneWpzJykuVW5kb01hbmFnZXIgfCBudWxsfSBbb3B0aW9ucy51bmRvTWFuYWdlcl1cbiAqL1xuZXhwb3J0IGNvbnN0IHlVbmRvUGx1Z2luID0gKHsgcHJvdGVjdGVkTm9kZXMgPSBkZWZhdWx0UHJvdGVjdGVkTm9kZXMsIHRyYWNrZWRPcmlnaW5zID0gW10sIHVuZG9NYW5hZ2VyID0gbnVsbCB9ID0ge30pID0+IG5ldyBQbHVnaW4oe1xuICBrZXk6IHlVbmRvUGx1Z2luS2V5LFxuICBzdGF0ZToge1xuICAgIGluaXQ6IChpbml0YXJncywgc3RhdGUpID0+IHtcbiAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHBsdWdpbiBvcmRlciBtYXRjaGVzIGFuZCBmaXhcbiAgICAgIGNvbnN0IHlzdGF0ZSA9IHlTeW5jUGx1Z2luS2V5LmdldFN0YXRlKHN0YXRlKVxuICAgICAgY29uc3QgX3VuZG9NYW5hZ2VyID0gdW5kb01hbmFnZXIgfHwgbmV3IFVuZG9NYW5hZ2VyKHlzdGF0ZS50eXBlLCB7XG4gICAgICAgIHRyYWNrZWRPcmlnaW5zOiBuZXcgU2V0KFt5U3luY1BsdWdpbktleV0uY29uY2F0KHRyYWNrZWRPcmlnaW5zKSksXG4gICAgICAgIGRlbGV0ZUZpbHRlcjogKGl0ZW0pID0+IGRlZmF1bHREZWxldGVGaWx0ZXIoaXRlbSwgcHJvdGVjdGVkTm9kZXMpLFxuICAgICAgICBjYXB0dXJlVHJhbnNhY3Rpb246IHRyID0+IHRyLm1ldGEuZ2V0KCdhZGRUb0hpc3RvcnknKSAhPT0gZmFsc2VcbiAgICAgIH0pXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bmRvTWFuYWdlcjogX3VuZG9NYW5hZ2VyLFxuICAgICAgICBwcmV2U2VsOiBudWxsLFxuICAgICAgICBoYXNVbmRvT3BzOiBfdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDAsXG4gICAgICAgIGhhc1JlZG9PcHM6IF91bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgfVxuICAgIH0sXG4gICAgYXBwbHk6ICh0ciwgdmFsLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGJpbmRpbmcgPSB5U3luY1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkuYmluZGluZ1xuICAgICAgY29uc3QgdW5kb01hbmFnZXIgPSB2YWwudW5kb01hbmFnZXJcbiAgICAgIGNvbnN0IGhhc1VuZG9PcHMgPSB1bmRvTWFuYWdlci51bmRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgY29uc3QgaGFzUmVkb09wcyA9IHVuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPiAwXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHVuZG9NYW5hZ2VyLFxuICAgICAgICAgIHByZXZTZWw6IGdldFJlbGF0aXZlU2VsZWN0aW9uKGJpbmRpbmcsIG9sZFN0YXRlKSxcbiAgICAgICAgICBoYXNVbmRvT3BzLFxuICAgICAgICAgIGhhc1JlZG9PcHNcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGhhc1VuZG9PcHMgIT09IHZhbC5oYXNVbmRvT3BzIHx8IGhhc1JlZG9PcHMgIT09IHZhbC5oYXNSZWRvT3BzKSB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHZhbCwge1xuICAgICAgICAgICAgaGFzVW5kb09wczogdW5kb01hbmFnZXIudW5kb1N0YWNrLmxlbmd0aCA+IDAsXG4gICAgICAgICAgICBoYXNSZWRvT3BzOiB1bmRvTWFuYWdlci5yZWRvU3RhY2subGVuZ3RoID4gMFxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7IC8vIG5vdGhpbmcgY2hhbmdlZFxuICAgICAgICAgIHJldHVybiB2YWxcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgdmlldzogdmlldyA9PiB7XG4gICAgY29uc3QgeXN0YXRlID0geVN5bmNQbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSlcbiAgICBjb25zdCB1bmRvTWFuYWdlciA9IHlVbmRvUGx1Z2luS2V5LmdldFN0YXRlKHZpZXcuc3RhdGUpLnVuZG9NYW5hZ2VyXG4gICAgdW5kb01hbmFnZXIub24oJ3N0YWNrLWl0ZW0tYWRkZWQnLCAoeyBzdGFja0l0ZW0gfSkgPT4ge1xuICAgICAgY29uc3QgYmluZGluZyA9IHlzdGF0ZS5iaW5kaW5nXG4gICAgICBpZiAoYmluZGluZykge1xuICAgICAgICBzdGFja0l0ZW0ubWV0YS5zZXQoYmluZGluZywgeVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSkucHJldlNlbClcbiAgICAgIH1cbiAgICB9KVxuICAgIHVuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLXBvcHBlZCcsICh7IHN0YWNrSXRlbSB9KSA9PiB7XG4gICAgICBjb25zdCBiaW5kaW5nID0geXN0YXRlLmJpbmRpbmdcbiAgICAgIGlmIChiaW5kaW5nKSB7XG4gICAgICAgIGJpbmRpbmcuYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24gPSBzdGFja0l0ZW0ubWV0YS5nZXQoYmluZGluZykgfHwgYmluZGluZy5iZWZvcmVUcmFuc2FjdGlvblNlbGVjdGlvblxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIHtcbiAgICAgIGRlc3Ryb3k6ICgpID0+IHtcbiAgICAgICAgdW5kb01hbmFnZXIuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbIlBsdWdpbiIsImdldFJlbGF0aXZlU2VsZWN0aW9uIiwiVW5kb01hbmFnZXIiLCJJdGVtIiwiQ29udGVudFR5cGUiLCJYbWxFbGVtZW50IiwiVGV4dCIsInlVbmRvUGx1Z2luS2V5IiwieVN5bmNQbHVnaW5LZXkiLCJ1bmRvIiwic3RhdGUiLCJnZXRTdGF0ZSIsInVuZG9NYW5hZ2VyIiwicmVkbyIsInVuZG9Db21tYW5kIiwiZGlzcGF0Y2giLCJjYW5VbmRvIiwicmVkb0NvbW1hbmQiLCJjYW5SZWRvIiwiZGVmYXVsdFByb3RlY3RlZE5vZGVzIiwiU2V0IiwiZGVmYXVsdERlbGV0ZUZpbHRlciIsIml0ZW0iLCJwcm90ZWN0ZWROb2RlcyIsImNvbnRlbnQiLCJ0eXBlIiwiaGFzIiwibm9kZU5hbWUiLCJfbGVuZ3RoIiwieVVuZG9QbHVnaW4iLCJ0cmFja2VkT3JpZ2lucyIsImtleSIsImluaXQiLCJpbml0YXJncyIsInlzdGF0ZSIsIl91bmRvTWFuYWdlciIsImNvbmNhdCIsImRlbGV0ZUZpbHRlciIsImNhcHR1cmVUcmFuc2FjdGlvbiIsInRyIiwibWV0YSIsImdldCIsInByZXZTZWwiLCJoYXNVbmRvT3BzIiwidW5kb1N0YWNrIiwibGVuZ3RoIiwiaGFzUmVkb09wcyIsInJlZG9TdGFjayIsImFwcGx5IiwidmFsIiwib2xkU3RhdGUiLCJiaW5kaW5nIiwiT2JqZWN0IiwiYXNzaWduIiwidmlldyIsIm9uIiwic3RhY2tJdGVtIiwic2V0IiwiYmVmb3JlVHJhbnNhY3Rpb25TZWxlY3Rpb24iLCJkZXN0cm95Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/y-prosemirror/src/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/y-prosemirror/src/utils.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hashOfJSON: () => (/* binding */ hashOfJSON)\n/* harmony export */ });\n/* harmony import */ var lib0_hash_sha256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lib0/hash/sha256 */ \"(ssr)/./node_modules/lib0/hash/sha256.node.js\");\n/* harmony import */ var lib0_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lib0/buffer */ \"(ssr)/./node_modules/lib0/buffer.js\");\n\n\n/**\n * Custom function to transform sha256 hash to N byte\n *\n * @param {Uint8Array} digest\n */ const _convolute = (digest)=>{\n    const N = 6;\n    for(let i = N; i < digest.length; i++){\n        digest[i % N] = digest[i % N] ^ digest[i];\n    }\n    return digest.slice(0, N);\n};\n/**\n * @param {any} json\n */ const hashOfJSON = (json)=>lib0_buffer__WEBPACK_IMPORTED_MODULE_0__.toBase64(_convolute(lib0_hash_sha256__WEBPACK_IMPORTED_MODULE_1__.digest(lib0_buffer__WEBPACK_IMPORTED_MODULE_0__.encodeAny(json))));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMveS1wcm9zZW1pcnJvci9zcmMvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBDO0FBQ1I7QUFFbEM7Ozs7Q0FJQyxHQUNELE1BQU1FLGFBQWFDLENBQUFBO0lBQ2pCLE1BQU1DLElBQUk7SUFDVixJQUFLLElBQUlDLElBQUlELEdBQUdDLElBQUlGLE9BQU9HLE1BQU0sRUFBRUQsSUFBSztRQUN0Q0YsTUFBTSxDQUFDRSxJQUFJRCxFQUFFLEdBQUdELE1BQU0sQ0FBQ0UsSUFBSUQsRUFBRSxHQUFHRCxNQUFNLENBQUNFLEVBQUU7SUFDM0M7SUFDQSxPQUFPRixPQUFPSSxLQUFLLENBQUMsR0FBR0g7QUFDekI7QUFFQTs7Q0FFQyxHQUNNLE1BQU1JLGFBQWEsQ0FBQ0MsT0FBU1IsaURBQVksQ0FBQ0MsV0FBV0Ysb0RBQWEsQ0FBQ0Msa0RBQWEsQ0FBQ1EsU0FBUSIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL3ktcHJvc2VtaXJyb3Ivc3JjL3V0aWxzLmpzPzZhM2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgc2hhMjU2IGZyb20gJ2xpYjAvaGFzaC9zaGEyNTYnXG5pbXBvcnQgKiBhcyBidWYgZnJvbSAnbGliMC9idWZmZXInXG5cbi8qKlxuICogQ3VzdG9tIGZ1bmN0aW9uIHRvIHRyYW5zZm9ybSBzaGEyNTYgaGFzaCB0byBOIGJ5dGVcbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGRpZ2VzdFxuICovXG5jb25zdCBfY29udm9sdXRlID0gZGlnZXN0ID0+IHtcbiAgY29uc3QgTiA9IDZcbiAgZm9yIChsZXQgaSA9IE47IGkgPCBkaWdlc3QubGVuZ3RoOyBpKyspIHtcbiAgICBkaWdlc3RbaSAlIE5dID0gZGlnZXN0W2kgJSBOXSBeIGRpZ2VzdFtpXVxuICB9XG4gIHJldHVybiBkaWdlc3Quc2xpY2UoMCwgTilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0ganNvblxuICovXG5leHBvcnQgY29uc3QgaGFzaE9mSlNPTiA9IChqc29uKSA9PiBidWYudG9CYXNlNjQoX2NvbnZvbHV0ZShzaGEyNTYuZGlnZXN0KGJ1Zi5lbmNvZGVBbnkoanNvbikpKSlcbiJdLCJuYW1lcyI6WyJzaGEyNTYiLCJidWYiLCJfY29udm9sdXRlIiwiZGlnZXN0IiwiTiIsImkiLCJsZW5ndGgiLCJzbGljZSIsImhhc2hPZkpTT04iLCJqc29uIiwidG9CYXNlNjQiLCJlbmNvZGVBbnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/y-prosemirror/src/utils.js\n");

/***/ })

};
;
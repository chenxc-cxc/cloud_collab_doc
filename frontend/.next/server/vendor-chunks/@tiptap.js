"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tiptap";
exports.ids = ["vendor-chunks/@tiptap"];
exports.modules = {

/***/ "(ssr)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: () => (/* binding */ CommandManager),\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Extension: () => (/* binding */ Extension),\n/* harmony export */   InputRule: () => (/* binding */ InputRule),\n/* harmony export */   Mark: () => (/* binding */ Mark),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   NodePos: () => (/* binding */ NodePos),\n/* harmony export */   NodeView: () => (/* binding */ NodeView),\n/* harmony export */   PasteRule: () => (/* binding */ PasteRule),\n/* harmony export */   Tracker: () => (/* binding */ Tracker),\n/* harmony export */   callOrReturn: () => (/* binding */ callOrReturn),\n/* harmony export */   canInsertNode: () => (/* binding */ canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* binding */ combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* binding */ createChainableState),\n/* harmony export */   createDocument: () => (/* binding */ createDocument),\n/* harmony export */   createNodeFromContent: () => (/* binding */ createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* binding */ createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* binding */ defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* binding */ deleteProps),\n/* harmony export */   elementFromString: () => (/* binding */ elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* binding */ escapeForRegEx),\n/* harmony export */   extensions: () => (/* binding */ index),\n/* harmony export */   findChildren: () => (/* binding */ findChildren),\n/* harmony export */   findChildrenInRange: () => (/* binding */ findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* binding */ findDuplicates),\n/* harmony export */   findParentNode: () => (/* binding */ findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* binding */ findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* binding */ fromString),\n/* harmony export */   generateHTML: () => (/* binding */ generateHTML),\n/* harmony export */   generateJSON: () => (/* binding */ generateJSON),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   getAttributes: () => (/* binding */ getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* binding */ getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* binding */ getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* binding */ getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* binding */ getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* binding */ getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* binding */ getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* binding */ getMarkRange),\n/* harmony export */   getMarkType: () => (/* binding */ getMarkType),\n/* harmony export */   getMarksBetween: () => (/* binding */ getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* binding */ getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* binding */ getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* binding */ getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* binding */ getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* binding */ getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* binding */ getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* binding */ getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* binding */ getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* binding */ getSplittedAttributes),\n/* harmony export */   getText: () => (/* binding */ getText),\n/* harmony export */   getTextBetween: () => (/* binding */ getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* binding */ getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* binding */ getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* binding */ injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* binding */ inputRulesPlugin),\n/* harmony export */   isActive: () => (/* binding */ isActive),\n/* harmony export */   isAtEndOfNode: () => (/* binding */ isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* binding */ isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* binding */ isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* binding */ isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isList: () => (/* binding */ isList),\n/* harmony export */   isMacOS: () => (/* binding */ isMacOS),\n/* harmony export */   isMarkActive: () => (/* binding */ isMarkActive),\n/* harmony export */   isNodeActive: () => (/* binding */ isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* binding */ isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* binding */ isNodeSelection),\n/* harmony export */   isNumber: () => (/* binding */ isNumber),\n/* harmony export */   isPlainObject: () => (/* binding */ isPlainObject),\n/* harmony export */   isRegExp: () => (/* binding */ isRegExp),\n/* harmony export */   isString: () => (/* binding */ isString),\n/* harmony export */   isTextSelection: () => (/* binding */ isTextSelection),\n/* harmony export */   isiOS: () => (/* binding */ isiOS),\n/* harmony export */   markInputRule: () => (/* binding */ markInputRule),\n/* harmony export */   markPasteRule: () => (/* binding */ markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* binding */ mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* binding */ mergeDeep),\n/* harmony export */   minMax: () => (/* binding */ minMax),\n/* harmony export */   nodeInputRule: () => (/* binding */ nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* binding */ nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* binding */ objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* binding */ pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* binding */ posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* binding */ removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* binding */ resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* binding */ rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* binding */ selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* binding */ splitExtensions),\n/* harmony export */   textInputRule: () => (/* binding */ textInputRule),\n/* harmony export */   textPasteRule: () => (/* binding */ textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* binding */ textblockTypeInputRule),\n/* harmony export */   wrappingInputRule: () => (/* binding */ wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js\");\n\n\n\n\n\n\n\n/**\n * Takes a Transaction & Editor State and turns it into a chainable state object\n * @param config The transaction and state to create the chainable state from\n * @returns A chainable Editor state object\n */ function createChainableState(config) {\n    const { state, transaction } = config;\n    let { selection } = transaction;\n    let { doc } = transaction;\n    let { storedMarks } = transaction;\n    return {\n        ...state,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        plugins: state.plugins,\n        schema: state.schema,\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n        get storedMarks () {\n            return storedMarks;\n        },\n        get selection () {\n            return selection;\n        },\n        get doc () {\n            return doc;\n        },\n        get tr () {\n            selection = transaction.selection;\n            doc = transaction.doc;\n            storedMarks = transaction.storedMarks;\n            return transaction;\n        }\n    };\n}\nclass CommandManager {\n    constructor(props){\n        this.editor = props.editor;\n        this.rawCommands = this.editor.extensionManager.commands;\n        this.customState = props.state;\n    }\n    get hasCustomState() {\n        return !!this.customState;\n    }\n    get state() {\n        return this.customState || this.editor.state;\n    }\n    get commands() {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const { tr } = state;\n        const props = this.buildProps(tr);\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n            const method = (...args)=>{\n                const callback = command(...args)(props);\n                if (!tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                    view.dispatch(tr);\n                }\n                return callback;\n            };\n            return [\n                name,\n                method\n            ];\n        }));\n    }\n    get chain() {\n        return ()=>this.createChain();\n    }\n    get can() {\n        return ()=>this.createCan();\n    }\n    createChain(startTr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const callbacks = [];\n        const hasStartTransaction = !!startTr;\n        const tr = startTr || state.tr;\n        const run = ()=>{\n            if (!hasStartTransaction && shouldDispatch && !tr.getMeta(\"preventDispatch\") && !this.hasCustomState) {\n                view.dispatch(tr);\n            }\n            return callbacks.every((callback)=>callback === true);\n        };\n        const chain = {\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n                const chainedCommand = (...args)=>{\n                    const props = this.buildProps(tr, shouldDispatch);\n                    const callback = command(...args)(props);\n                    callbacks.push(callback);\n                    return chain;\n                };\n                return [\n                    name,\n                    chainedCommand\n                ];\n            })),\n            run\n        };\n        return chain;\n    }\n    createCan(startTr) {\n        const { rawCommands, state } = this;\n        const dispatch = false;\n        const tr = startTr || state.tr;\n        const props = this.buildProps(tr, dispatch);\n        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n            return [\n                name,\n                (...args)=>command(...args)({\n                        ...props,\n                        dispatch: undefined\n                    })\n            ];\n        }));\n        return {\n            ...formattedCommands,\n            chain: ()=>this.createChain(tr, dispatch)\n        };\n    }\n    buildProps(tr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const props = {\n            tr,\n            editor,\n            view,\n            state: createChainableState({\n                state,\n                transaction: tr\n            }),\n            dispatch: shouldDispatch ? ()=>undefined : undefined,\n            chain: ()=>this.createChain(tr, shouldDispatch),\n            can: ()=>this.createCan(tr),\n            get commands () {\n                return Object.fromEntries(Object.entries(rawCommands).map(([name, command])=>{\n                    return [\n                        name,\n                        (...args)=>command(...args)(props)\n                    ];\n                }));\n            }\n        };\n        return props;\n    }\n}\nclass EventEmitter {\n    constructor(){\n        this.callbacks = {};\n    }\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach((callback)=>callback.apply(this, args));\n        }\n        return this;\n    }\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter((callback)=>callback !== fn);\n            } else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    once(event, fn) {\n        const onceFn = (...args)=>{\n            this.off(event, onceFn);\n            fn.apply(this, args);\n        };\n        return this.on(event, onceFn);\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n/**\n * Returns a field from an extension\n * @param extension The Tiptap extension\n * @param field The field, for example `renderHTML` or `priority`\n * @param context The context object that should be passed as `this` into the function\n * @returns The field value\n */ function getExtensionField(extension, field, context) {\n    if (extension.config[field] === undefined && extension.parent) {\n        return getExtensionField(extension.parent, field, context);\n    }\n    if (typeof extension.config[field] === \"function\") {\n        const value = extension.config[field].bind({\n            ...context,\n            parent: extension.parent ? getExtensionField(extension.parent, field, context) : null\n        });\n        return value;\n    }\n    return extension.config[field];\n}\nfunction splitExtensions(extensions) {\n    const baseExtensions = extensions.filter((extension)=>extension.type === \"extension\");\n    const nodeExtensions = extensions.filter((extension)=>extension.type === \"node\");\n    const markExtensions = extensions.filter((extension)=>extension.type === \"mark\");\n    return {\n        baseExtensions,\n        nodeExtensions,\n        markExtensions\n    };\n}\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */ function getAttributesFromExtensions(extensions) {\n    const extensionAttributes = [];\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const nodeAndMarkExtensions = [\n        ...nodeExtensions,\n        ...markExtensions\n    ];\n    const defaultAttribute = {\n        default: null,\n        rendered: true,\n        renderHTML: null,\n        parseHTML: null,\n        keepOnSplit: true,\n        isRequired: false\n    };\n    extensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            extensions: nodeAndMarkExtensions\n        };\n        const addGlobalAttributes = getExtensionField(extension, \"addGlobalAttributes\", context);\n        if (!addGlobalAttributes) {\n            return;\n        }\n        const globalAttributes = addGlobalAttributes();\n        globalAttributes.forEach((globalAttribute)=>{\n            globalAttribute.types.forEach((type)=>{\n                Object.entries(globalAttribute.attributes).forEach(([name, attribute])=>{\n                    extensionAttributes.push({\n                        type,\n                        name,\n                        attribute: {\n                            ...defaultAttribute,\n                            ...attribute\n                        }\n                    });\n                });\n            });\n        });\n    });\n    nodeAndMarkExtensions.forEach((extension)=>{\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        const addAttributes = getExtensionField(extension, \"addAttributes\", context);\n        if (!addAttributes) {\n            return;\n        }\n        // TODO: remove `as Attributes`\n        const attributes = addAttributes();\n        Object.entries(attributes).forEach(([name, attribute])=>{\n            const mergedAttr = {\n                ...defaultAttribute,\n                ...attribute\n            };\n            if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === \"function\") {\n                mergedAttr.default = mergedAttr.default();\n            }\n            if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n                delete mergedAttr.default;\n            }\n            extensionAttributes.push({\n                type: extension.name,\n                name,\n                attribute: mergedAttr\n            });\n        });\n    });\n    return extensionAttributes;\n}\nfunction getNodeType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.nodes[nameOrType]) {\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.nodes[nameOrType];\n    }\n    return nameOrType;\n}\nfunction mergeAttributes(...objects) {\n    return objects.filter((item)=>!!item).reduce((items, item)=>{\n        const mergedAttributes = {\n            ...items\n        };\n        Object.entries(item).forEach(([key, value])=>{\n            const exists = mergedAttributes[key];\n            if (!exists) {\n                mergedAttributes[key] = value;\n                return;\n            }\n            if (key === \"class\") {\n                const valueClasses = value ? String(value).split(\" \") : [];\n                const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(\" \") : [];\n                const insertClasses = valueClasses.filter((valueClass)=>!existingClasses.includes(valueClass));\n                mergedAttributes[key] = [\n                    ...existingClasses,\n                    ...insertClasses\n                ].join(\" \");\n            } else if (key === \"style\") {\n                const newStyles = value ? value.split(\";\").map((style)=>style.trim()).filter(Boolean) : [];\n                const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(\";\").map((style)=>style.trim()).filter(Boolean) : [];\n                const styleMap = new Map();\n                existingStyles.forEach((style)=>{\n                    const [property, val] = style.split(\":\").map((part)=>part.trim());\n                    styleMap.set(property, val);\n                });\n                newStyles.forEach((style)=>{\n                    const [property, val] = style.split(\":\").map((part)=>part.trim());\n                    styleMap.set(property, val);\n                });\n                mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val])=>`${property}: ${val}`).join(\"; \");\n            } else {\n                mergedAttributes[key] = value;\n            }\n        });\n        return mergedAttributes;\n    }, {});\n}\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n    return extensionAttributes.filter((attribute)=>attribute.type === nodeOrMark.type.name).filter((item)=>item.attribute.rendered).map((item)=>{\n        if (!item.attribute.renderHTML) {\n            return {\n                [item.name]: nodeOrMark.attrs[item.name]\n            };\n        }\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n    }).reduce((attributes, attribute)=>mergeAttributes(attributes, attribute), {});\n}\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction isFunction(value) {\n    return typeof value === \"function\";\n}\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */ function callOrReturn(value, context = undefined, ...props) {\n    if (isFunction(value)) {\n        if (context) {\n            return value.bind(context)(...props);\n        }\n        return value(...props);\n    }\n    return value;\n}\nfunction isEmptyObject(value = {}) {\n    return Object.keys(value).length === 0 && value.constructor === Object;\n}\nfunction fromString(value) {\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n        return Number(value);\n    }\n    if (value === \"true\") {\n        return true;\n    }\n    if (value === \"false\") {\n        return false;\n    }\n    return value;\n}\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */ function injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n    if (\"style\" in parseRule) {\n        return parseRule;\n    }\n    return {\n        ...parseRule,\n        getAttrs: (node)=>{\n            const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n            if (oldAttributes === false) {\n                return false;\n            }\n            const newAttributes = extensionAttributes.reduce((items, item)=>{\n                const value = item.attribute.parseHTML ? item.attribute.parseHTML(node) : fromString(node.getAttribute(item.name));\n                if (value === null || value === undefined) {\n                    return items;\n                }\n                return {\n                    ...items,\n                    [item.name]: value\n                };\n            }, {});\n            return {\n                ...oldAttributes,\n                ...newAttributes\n            };\n        }\n    };\n}\nfunction cleanUpSchemaItem(data) {\n    return Object.fromEntries(// @ts-ignore\n    Object.entries(data).filter(([key, value])=>{\n        if (key === \"attrs\" && isEmptyObject(value)) {\n            return false;\n        }\n        return value !== null && value !== undefined;\n    }));\n}\n/**\n * Creates a new Prosemirror schema based on the given extensions.\n * @param extensions An array of Tiptap extensions\n * @param editor The editor instance\n * @returns A Prosemirror schema\n */ function getSchemaByResolvedExtensions(extensions, editor) {\n    var _a;\n    const allAttributes = getAttributesFromExtensions(extensions);\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const topNode = (_a = nodeExtensions.find((extension)=>getExtensionField(extension, \"topNode\"))) === null || _a === void 0 ? void 0 : _a.name;\n    const nodes = Object.fromEntries(nodeExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraNodeFields = extensions.reduce((fields, e)=>{\n            const extendNodeSchema = getExtensionField(e, \"extendNodeSchema\", context);\n            return {\n                ...fields,\n                ...extendNodeSchema ? extendNodeSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraNodeFields,\n            content: callOrReturn(getExtensionField(extension, \"content\", context)),\n            marks: callOrReturn(getExtensionField(extension, \"marks\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            inline: callOrReturn(getExtensionField(extension, \"inline\", context)),\n            atom: callOrReturn(getExtensionField(extension, \"atom\", context)),\n            selectable: callOrReturn(getExtensionField(extension, \"selectable\", context)),\n            draggable: callOrReturn(getExtensionField(extension, \"draggable\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            whitespace: callOrReturn(getExtensionField(extension, \"whitespace\", context)),\n            linebreakReplacement: callOrReturn(getExtensionField(extension, \"linebreakReplacement\", context)),\n            defining: callOrReturn(getExtensionField(extension, \"defining\", context)),\n            isolating: callOrReturn(getExtensionField(extension, \"isolating\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute)=>{\n                var _a;\n                return [\n                    extensionAttribute.name,\n                    {\n                        default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n                    }\n                ];\n            }))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (node)=>renderHTML({\n                    node,\n                    HTMLAttributes: getRenderedAttributes(node, extensionAttributes)\n                });\n        }\n        const renderText = getExtensionField(extension, \"renderText\", context);\n        if (renderText) {\n            schema.toText = renderText;\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    const marks = Object.fromEntries(markExtensions.map((extension)=>{\n        const extensionAttributes = allAttributes.filter((attribute)=>attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor\n        };\n        const extraMarkFields = extensions.reduce((fields, e)=>{\n            const extendMarkSchema = getExtensionField(e, \"extendMarkSchema\", context);\n            return {\n                ...fields,\n                ...extendMarkSchema ? extendMarkSchema(extension) : {}\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraMarkFields,\n            inclusive: callOrReturn(getExtensionField(extension, \"inclusive\", context)),\n            excludes: callOrReturn(getExtensionField(extension, \"excludes\", context)),\n            group: callOrReturn(getExtensionField(extension, \"group\", context)),\n            spanning: callOrReturn(getExtensionField(extension, \"spanning\", context)),\n            code: callOrReturn(getExtensionField(extension, \"code\", context)),\n            attrs: Object.fromEntries(extensionAttributes.map((extensionAttribute)=>{\n                var _a;\n                return [\n                    extensionAttribute.name,\n                    {\n                        default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default\n                    }\n                ];\n            }))\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, \"parseHTML\", context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map((parseRule)=>injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, \"renderHTML\", context);\n        if (renderHTML) {\n            schema.toDOM = (mark)=>renderHTML({\n                    mark,\n                    HTMLAttributes: getRenderedAttributes(mark, extensionAttributes)\n                });\n        }\n        return [\n            extension.name,\n            schema\n        ];\n    }));\n    return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode,\n        nodes,\n        marks\n    });\n}\n/**\n * Tries to get a node or mark type by its name.\n * @param name The name of the node or mark type\n * @param schema The Prosemiror schema to search in\n * @returns The node or mark type, or null if it doesn't exist\n */ function getSchemaTypeByName(name, schema) {\n    return schema.nodes[name] || schema.marks[name] || null;\n}\nfunction isExtensionRulesEnabled(extension, enabled) {\n    if (Array.isArray(enabled)) {\n        return enabled.some((enabledExtension)=>{\n            const name = typeof enabledExtension === \"string\" ? enabledExtension : enabledExtension.name;\n            return name === extension.name;\n        });\n    }\n    return enabled;\n}\nfunction getHTMLFromFragment(fragment, schema) {\n    const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n    const temporaryDocument = document.implementation.createHTMLDocument();\n    const container = temporaryDocument.createElement(\"div\");\n    container.appendChild(documentFragment);\n    return container.innerHTML;\n}\n/**\n * Returns the text content of a resolved prosemirror position\n * @param $from The resolved position to get the text content from\n * @param maxMatch The maximum number of characters to match\n * @returns The text content\n */ const getTextContentFromNodes = ($from, maxMatch = 500)=>{\n    let textBefore = \"\";\n    const sliceEndPos = $from.parentOffset;\n    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index)=>{\n        var _a, _b;\n        const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            node,\n            pos,\n            parent,\n            index\n        })) || node.textContent || \"%leaf%\";\n        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n    });\n    return textBefore;\n};\nfunction isRegExp(value) {\n    return Object.prototype.toString.call(value) === \"[object RegExp]\";\n}\nclass InputRule {\n    constructor(config){\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst inputRuleMatcherHandler = (text, find)=>{\n    if (isRegExp(find)) {\n        return find.exec(text);\n    }\n    const inputRuleMatch = find(text);\n    if (!inputRuleMatch) {\n        return null;\n    }\n    const result = [\n        inputRuleMatch.text\n    ];\n    result.index = inputRuleMatch.index;\n    result.input = text;\n    result.data = inputRuleMatch.data;\n    if (inputRuleMatch.replaceWith) {\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n        }\n        result.push(inputRuleMatch.replaceWith);\n    }\n    return result;\n};\nfunction run$1(config) {\n    var _a;\n    const { editor, from, to, text, rules, plugin } = config;\n    const { view } = editor;\n    if (view.composing) {\n        return false;\n    }\n    const $from = view.state.doc.resolve(from);\n    if (// check for code node\n    $from.parent.type.spec.code || !!((_a = $from.nodeBefore || $from.nodeAfter) === null || _a === void 0 ? void 0 : _a.marks.find((mark)=>mark.type.spec.code))) {\n        return false;\n    }\n    let matched = false;\n    const textBefore = getTextContentFromNodes($from) + text;\n    rules.forEach((rule)=>{\n        if (matched) {\n            return;\n        }\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\n        if (!match) {\n            return;\n        }\n        const tr = view.state.tr;\n        const state = createChainableState({\n            state: view.state,\n            transaction: tr\n        });\n        const range = {\n            from: from - (match[0].length - text.length),\n            to\n        };\n        const { commands, chain, can } = new CommandManager({\n            editor,\n            state\n        });\n        const handler = rule.handler({\n            state,\n            range,\n            match,\n            commands,\n            chain,\n            can\n        });\n        // stop if there are no changes\n        if (handler === null || !tr.steps.length) {\n            return;\n        }\n        // store transform as meta data\n        // so we can undo input rules within the `undoInputRules` command\n        tr.setMeta(plugin, {\n            transform: tr,\n            from,\n            to,\n            text\n        });\n        view.dispatch(tr);\n        matched = true;\n    });\n    return matched;\n}\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */ function inputRulesPlugin(props) {\n    const { editor, rules } = props;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        state: {\n            init () {\n                return null;\n            },\n            apply (tr, prev, state) {\n                const stored = tr.getMeta(plugin);\n                if (stored) {\n                    return stored;\n                }\n                // if InputRule is triggered by insertContent()\n                const simulatedInputMeta = tr.getMeta(\"applyInputRules\");\n                const isSimulatedInput = !!simulatedInputMeta;\n                if (isSimulatedInput) {\n                    setTimeout(()=>{\n                        let { text } = simulatedInputMeta;\n                        if (typeof text === \"string\") {\n                            text = text;\n                        } else {\n                            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                        }\n                        const { from } = simulatedInputMeta;\n                        const to = from + text.length;\n                        run$1({\n                            editor,\n                            from,\n                            to,\n                            text,\n                            rules,\n                            plugin\n                        });\n                    });\n                }\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            }\n        },\n        props: {\n            handleTextInput (view, from, to, text) {\n                return run$1({\n                    editor,\n                    from,\n                    to,\n                    text,\n                    rules,\n                    plugin\n                });\n            },\n            handleDOMEvents: {\n                compositionend: (view)=>{\n                    setTimeout(()=>{\n                        const { $cursor } = view.state.selection;\n                        if ($cursor) {\n                            run$1({\n                                editor,\n                                from: $cursor.pos,\n                                to: $cursor.pos,\n                                text: \"\",\n                                rules,\n                                plugin\n                            });\n                        }\n                    });\n                    return false;\n                }\n            },\n            // add support for input rules to trigger on enter\n            // this is useful for example for code blocks\n            handleKeyDown (view, event) {\n                if (event.key !== \"Enter\") {\n                    return false;\n                }\n                const { $cursor } = view.state.selection;\n                if ($cursor) {\n                    return run$1({\n                        editor,\n                        from: $cursor.pos,\n                        to: $cursor.pos,\n                        text: \"\\n\",\n                        rules,\n                        plugin\n                    });\n                }\n                return false;\n            }\n        },\n        // @ts-ignore\n        isInputRules: true\n    });\n    return plugin;\n}\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n    if (getType(value) !== \"Object\") {\n        return false;\n    }\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\nfunction mergeDeep(target, source) {\n    const output = {\n        ...target\n    };\n    if (isPlainObject(target) && isPlainObject(source)) {\n        Object.keys(source).forEach((key)=>{\n            if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n                output[key] = mergeDeep(target[key], source[key]);\n            } else {\n                output[key] = source[key];\n            }\n        });\n    }\n    return output;\n}\n/**\n * The Mark class is used to create custom mark extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */ class Mark {\n    constructor(config = {}){\n        this.type = \"mark\";\n        this.name = \"mark\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Mark(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: ()=>{\n                return mergeDeep(this.options, options);\n            }\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Mark(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n    static handleExit({ editor, mark }) {\n        const { tr } = editor.state;\n        const currentPos = editor.state.selection.$from;\n        const isAtEnd = currentPos.pos === currentPos.end();\n        if (isAtEnd) {\n            const currentMarks = currentPos.marks();\n            const isInMark = !!currentMarks.find((m)=>(m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (!isInMark) {\n                return false;\n            }\n            const removeMark = currentMarks.find((m)=>(m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (removeMark) {\n                tr.removeStoredMark(removeMark);\n            }\n            tr.insertText(\" \", currentPos.pos);\n            editor.view.dispatch(tr);\n            return true;\n        }\n        return false;\n    }\n}\nfunction isNumber(value) {\n    return typeof value === \"number\";\n}\n/**\n * Paste rules are used to react to pasted content.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ class PasteRule {\n    constructor(config){\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst pasteRuleMatcherHandler = (text, find, event)=>{\n    if (isRegExp(find)) {\n        return [\n            ...text.matchAll(find)\n        ];\n    }\n    const matches = find(text, event);\n    if (!matches) {\n        return [];\n    }\n    return matches.map((pasteRuleMatch)=>{\n        const result = [\n            pasteRuleMatch.text\n        ];\n        result.index = pasteRuleMatch.index;\n        result.input = text;\n        result.data = pasteRuleMatch.data;\n        if (pasteRuleMatch.replaceWith) {\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n            }\n            result.push(pasteRuleMatch.replaceWith);\n        }\n        return result;\n    });\n};\nfunction run(config) {\n    const { editor, state, from, to, rule, pasteEvent, dropEvent } = config;\n    const { commands, chain, can } = new CommandManager({\n        editor,\n        state\n    });\n    const handlers = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        if (!node.isTextblock || node.type.spec.code) {\n            return;\n        }\n        const resolvedFrom = Math.max(from, pos);\n        const resolvedTo = Math.min(to, pos + node.content.size);\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, \"￼\");\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n        matches.forEach((match)=>{\n            if (match.index === undefined) {\n                return;\n            }\n            const start = resolvedFrom + match.index + 1;\n            const end = start + match[0].length;\n            const range = {\n                from: state.tr.mapping.map(start),\n                to: state.tr.mapping.map(end)\n            };\n            const handler = rule.handler({\n                state,\n                range,\n                match,\n                commands,\n                chain,\n                can,\n                pasteEvent,\n                dropEvent\n            });\n            handlers.push(handler);\n        });\n    });\n    const success = handlers.every((handler)=>handler !== null);\n    return success;\n}\n// When dragging across editors, must get another editor instance to delete selection content.\nlet tiptapDragFromOtherEditor = null;\nconst createClipboardPasteEvent = (text)=>{\n    var _a;\n    const event = new ClipboardEvent(\"paste\", {\n        clipboardData: new DataTransfer()\n    });\n    (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData(\"text/html\", text);\n    return event;\n};\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */ function pasteRulesPlugin(props) {\n    const { editor, rules } = props;\n    let dragSourceElement = null;\n    let isPastedFromProseMirror = false;\n    let isDroppedFromProseMirror = false;\n    let pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n    let dropEvent;\n    try {\n        dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n    } catch  {\n        dropEvent = null;\n    }\n    const processEvent = ({ state, from, to, rule, pasteEvt })=>{\n        const tr = state.tr;\n        const chainableState = createChainableState({\n            state,\n            transaction: tr\n        });\n        const handler = run({\n            editor,\n            state: chainableState,\n            from: Math.max(from - 1, 0),\n            to: to.b - 1,\n            rule,\n            pasteEvent: pasteEvt,\n            dropEvent\n        });\n        if (!handler || !tr.steps.length) {\n            return;\n        }\n        try {\n            dropEvent = typeof DragEvent !== \"undefined\" ? new DragEvent(\"drop\") : null;\n        } catch  {\n            dropEvent = null;\n        }\n        pasteEvent = typeof ClipboardEvent !== \"undefined\" ? new ClipboardEvent(\"paste\") : null;\n        return tr;\n    };\n    const plugins = rules.map((rule)=>{\n        return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n            // we register a global drag handler to track the current drag source element\n            view (view) {\n                const handleDragstart = (event)=>{\n                    var _a;\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target)) ? view.dom.parentElement : null;\n                    if (dragSourceElement) {\n                        tiptapDragFromOtherEditor = editor;\n                    }\n                };\n                const handleDragend = ()=>{\n                    if (tiptapDragFromOtherEditor) {\n                        tiptapDragFromOtherEditor = null;\n                    }\n                };\n                window.addEventListener(\"dragstart\", handleDragstart);\n                window.addEventListener(\"dragend\", handleDragend);\n                return {\n                    destroy () {\n                        window.removeEventListener(\"dragstart\", handleDragstart);\n                        window.removeEventListener(\"dragend\", handleDragend);\n                    }\n                };\n            },\n            props: {\n                handleDOMEvents: {\n                    drop: (view, event)=>{\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n                        dropEvent = event;\n                        if (!isDroppedFromProseMirror) {\n                            const dragFromOtherEditor = tiptapDragFromOtherEditor;\n                            if (dragFromOtherEditor === null || dragFromOtherEditor === void 0 ? void 0 : dragFromOtherEditor.isEditable) {\n                                // setTimeout to avoid the wrong content after drop, timeout arg can't be empty or 0\n                                setTimeout(()=>{\n                                    const selection = dragFromOtherEditor.state.selection;\n                                    if (selection) {\n                                        dragFromOtherEditor.commands.deleteRange({\n                                            from: selection.from,\n                                            to: selection.to\n                                        });\n                                    }\n                                }, 10);\n                            }\n                        }\n                        return false;\n                    },\n                    paste: (_view, event)=>{\n                        var _a;\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData(\"text/html\");\n                        pasteEvent = event;\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes(\"data-pm-slice\"));\n                        return false;\n                    }\n                }\n            },\n            appendTransaction: (transactions, oldState, state)=>{\n                const transaction = transactions[0];\n                const isPaste = transaction.getMeta(\"uiEvent\") === \"paste\" && !isPastedFromProseMirror;\n                const isDrop = transaction.getMeta(\"uiEvent\") === \"drop\" && !isDroppedFromProseMirror;\n                // if PasteRule is triggered by insertContent()\n                const simulatedPasteMeta = transaction.getMeta(\"applyPasteRules\");\n                const isSimulatedPaste = !!simulatedPasteMeta;\n                if (!isPaste && !isDrop && !isSimulatedPaste) {\n                    return;\n                }\n                // Handle simulated paste\n                if (isSimulatedPaste) {\n                    let { text } = simulatedPasteMeta;\n                    if (typeof text === \"string\") {\n                        text = text;\n                    } else {\n                        text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                    }\n                    const { from } = simulatedPasteMeta;\n                    const to = from + text.length;\n                    const pasteEvt = createClipboardPasteEvent(text);\n                    return processEvent({\n                        rule,\n                        state,\n                        from,\n                        to: {\n                            b: to\n                        },\n                        pasteEvt\n                    });\n                }\n                // handle actual paste/drop\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\n                // stop if there is no changed range\n                if (!isNumber(from) || !to || from === to.b) {\n                    return;\n                }\n                return processEvent({\n                    rule,\n                    state,\n                    from,\n                    to,\n                    pasteEvt: pasteEvent\n                });\n            }\n        });\n    });\n    return plugins;\n}\nfunction findDuplicates(items) {\n    const filtered = items.filter((el, index)=>items.indexOf(el) !== index);\n    return Array.from(new Set(filtered));\n}\nclass ExtensionManager {\n    constructor(extensions, editor){\n        this.splittableMarks = [];\n        this.editor = editor;\n        this.extensions = ExtensionManager.resolve(extensions);\n        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n        this.setupExtensions();\n    }\n    /**\n     * Returns a flattened and sorted extension list while\n     * also checking for duplicated extensions and warns the user.\n     * @param extensions An array of Tiptap extensions\n     * @returns An flattened and sorted array of Tiptap extensions\n     */ static resolve(extensions) {\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n        const duplicatedNames = findDuplicates(resolvedExtensions.map((extension)=>extension.name));\n        if (duplicatedNames.length) {\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames.map((item)=>`'${item}'`).join(\", \")}]. This can lead to issues.`);\n        }\n        return resolvedExtensions;\n    }\n    /**\n     * Create a flattened array of extensions by traversing the `addExtensions` field.\n     * @param extensions An array of Tiptap extensions\n     * @returns A flattened array of Tiptap extensions\n     */ static flatten(extensions) {\n        return extensions.map((extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage\n            };\n            const addExtensions = getExtensionField(extension, \"addExtensions\", context);\n            if (addExtensions) {\n                return [\n                    extension,\n                    ...this.flatten(addExtensions())\n                ];\n            }\n            return extension;\n        })// `Infinity` will break TypeScript so we set a number that is probably high enough\n        .flat(10);\n    }\n    /**\n     * Sort extensions by priority.\n     * @param extensions An array of Tiptap extensions\n     * @returns A sorted array of Tiptap extensions by priority\n     */ static sort(extensions) {\n        const defaultPriority = 100;\n        return extensions.sort((a, b)=>{\n            const priorityA = getExtensionField(a, \"priority\") || defaultPriority;\n            const priorityB = getExtensionField(b, \"priority\") || defaultPriority;\n            if (priorityA > priorityB) {\n                return -1;\n            }\n            if (priorityA < priorityB) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    /**\n     * Get all commands from the extensions.\n     * @returns An object with all commands where the key is the command name and the value is the command function\n     */ get commands() {\n        return this.extensions.reduce((commands, extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const addCommands = getExtensionField(extension, \"addCommands\", context);\n            if (!addCommands) {\n                return commands;\n            }\n            return {\n                ...commands,\n                ...addCommands()\n            };\n        }, {});\n    }\n    /**\n     * Get all registered Prosemirror plugins from the extensions.\n     * @returns An array of Prosemirror plugins\n     */ get plugins() {\n        const { editor } = this;\n        // With ProseMirror, first plugins within an array are executed first.\n        // In Tiptap, we provide the ability to override plugins,\n        // so it feels more natural to run plugins at the end of an array first.\n        // That’s why we have to reverse the `extensions` array and sort again\n        // based on the `priority` option.\n        const extensions = ExtensionManager.sort([\n            ...this.extensions\n        ].reverse());\n        const inputRules = [];\n        const pasteRules = [];\n        const allPlugins = extensions.map((extension)=>{\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            const plugins = [];\n            const addKeyboardShortcuts = getExtensionField(extension, \"addKeyboardShortcuts\", context);\n            let defaultBindings = {};\n            // bind exit handling\n            if (extension.type === \"mark\" && getExtensionField(extension, \"exitable\", context)) {\n                defaultBindings.ArrowRight = ()=>Mark.handleExit({\n                        editor,\n                        mark: extension\n                    });\n            }\n            if (addKeyboardShortcuts) {\n                const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method])=>{\n                    return [\n                        shortcut,\n                        ()=>method({\n                                editor\n                            })\n                    ];\n                }));\n                defaultBindings = {\n                    ...defaultBindings,\n                    ...bindings\n                };\n            }\n            const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\n            plugins.push(keyMapPlugin);\n            const addInputRules = getExtensionField(extension, \"addInputRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n                inputRules.push(...addInputRules());\n            }\n            const addPasteRules = getExtensionField(extension, \"addPasteRules\", context);\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n                pasteRules.push(...addPasteRules());\n            }\n            const addProseMirrorPlugins = getExtensionField(extension, \"addProseMirrorPlugins\", context);\n            if (addProseMirrorPlugins) {\n                const proseMirrorPlugins = addProseMirrorPlugins();\n                plugins.push(...proseMirrorPlugins);\n            }\n            return plugins;\n        }).flat();\n        return [\n            inputRulesPlugin({\n                editor,\n                rules: inputRules\n            }),\n            ...pasteRulesPlugin({\n                editor,\n                rules: pasteRules\n            }),\n            ...allPlugins\n        ];\n    }\n    /**\n     * Get all attributes from the extensions.\n     * @returns An array of attributes\n     */ get attributes() {\n        return getAttributesFromExtensions(this.extensions);\n    }\n    /**\n     * Get all node views from the extensions.\n     * @returns An object with all node views where the key is the node name and the value is the node view function\n     */ get nodeViews() {\n        const { editor } = this;\n        const { nodeExtensions } = splitExtensions(this.extensions);\n        return Object.fromEntries(nodeExtensions.filter((extension)=>!!getExtensionField(extension, \"addNodeView\")).map((extension)=>{\n            const extensionAttributes = this.attributes.filter((attribute)=>attribute.type === extension.name);\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getNodeType(extension.name, this.schema)\n            };\n            const addNodeView = getExtensionField(extension, \"addNodeView\", context);\n            if (!addNodeView) {\n                return [];\n            }\n            const nodeview = (node, view, getPos, decorations, innerDecorations)=>{\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n                return addNodeView()({\n                    // pass-through\n                    node,\n                    view,\n                    getPos: getPos,\n                    decorations,\n                    innerDecorations,\n                    // tiptap-specific\n                    editor,\n                    extension,\n                    HTMLAttributes\n                });\n            };\n            return [\n                extension.name,\n                nodeview\n            ];\n        }));\n    }\n    /**\n     * Go through all extensions, create extension storages & setup marks\n     * & bind editor event listener.\n     */ setupExtensions() {\n        this.extensions.forEach((extension)=>{\n            var _a;\n            // store extension storage in editor\n            this.editor.extensionStorage[extension.name] = extension.storage;\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema)\n            };\n            if (extension.type === \"mark\") {\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, \"keepOnSplit\", context))) !== null && _a !== void 0 ? _a : true;\n                if (keepOnSplit) {\n                    this.splittableMarks.push(extension.name);\n                }\n            }\n            const onBeforeCreate = getExtensionField(extension, \"onBeforeCreate\", context);\n            const onCreate = getExtensionField(extension, \"onCreate\", context);\n            const onUpdate = getExtensionField(extension, \"onUpdate\", context);\n            const onSelectionUpdate = getExtensionField(extension, \"onSelectionUpdate\", context);\n            const onTransaction = getExtensionField(extension, \"onTransaction\", context);\n            const onFocus = getExtensionField(extension, \"onFocus\", context);\n            const onBlur = getExtensionField(extension, \"onBlur\", context);\n            const onDestroy = getExtensionField(extension, \"onDestroy\", context);\n            if (onBeforeCreate) {\n                this.editor.on(\"beforeCreate\", onBeforeCreate);\n            }\n            if (onCreate) {\n                this.editor.on(\"create\", onCreate);\n            }\n            if (onUpdate) {\n                this.editor.on(\"update\", onUpdate);\n            }\n            if (onSelectionUpdate) {\n                this.editor.on(\"selectionUpdate\", onSelectionUpdate);\n            }\n            if (onTransaction) {\n                this.editor.on(\"transaction\", onTransaction);\n            }\n            if (onFocus) {\n                this.editor.on(\"focus\", onFocus);\n            }\n            if (onBlur) {\n                this.editor.on(\"blur\", onBlur);\n            }\n            if (onDestroy) {\n                this.editor.on(\"destroy\", onDestroy);\n            }\n        });\n    }\n}\n/**\n * The Extension class is the base class for all extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */ class Extension {\n    constructor(config = {}){\n        this.type = \"extension\";\n        this.name = \"extension\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Extension(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: ()=>{\n                return mergeDeep(this.options, options);\n            }\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Extension({\n            ...this.config,\n            ...extendedConfig\n        });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n}\n/**\n * Gets the text between two positions in a Prosemirror node\n * and serializes it using the given text serializers and block separator (see getText)\n * @param startNode The Prosemirror node to start from\n * @param range The range of the text to get\n * @param options Options for the text serializer & block separator\n * @returns The text between the two positions\n */ function getTextBetween(startNode, range, options) {\n    const { from, to } = range;\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    let text = \"\";\n    startNode.nodesBetween(from, to, (node, pos, parent, index)=>{\n        var _a;\n        if (node.isBlock && pos > from) {\n            text += blockSeparator;\n        }\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n        if (textSerializer) {\n            if (parent) {\n                text += textSerializer({\n                    node,\n                    pos,\n                    parent,\n                    index,\n                    range\n                });\n            }\n            // do not descend into child nodes when there exists a serializer\n            return false;\n        }\n        if (node.isText) {\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n        }\n    });\n    return text;\n}\n/**\n * Find text serializers `toText` in a Prosemirror schema\n * @param schema The Prosemirror schema to search in\n * @returns A record of text serializers by node name\n */ function getTextSerializersFromSchema(schema) {\n    return Object.fromEntries(Object.entries(schema.nodes).filter(([, node])=>node.spec.toText).map(([name, node])=>[\n            name,\n            node.spec.toText\n        ]));\n}\nconst ClipboardTextSerializer = Extension.create({\n    name: \"clipboardTextSerializer\",\n    addOptions () {\n        return {\n            blockSeparator: undefined\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clipboardTextSerializer\"),\n                props: {\n                    clipboardTextSerializer: ()=>{\n                        const { editor } = this;\n                        const { state, schema } = editor;\n                        const { doc, selection } = state;\n                        const { ranges } = selection;\n                        const from = Math.min(...ranges.map((range)=>range.$from.pos));\n                        const to = Math.max(...ranges.map((range)=>range.$to.pos));\n                        const textSerializers = getTextSerializersFromSchema(schema);\n                        const range = {\n                            from,\n                            to\n                        };\n                        return getTextBetween(doc, range, {\n                            ...this.options.blockSeparator !== undefined ? {\n                                blockSeparator: this.options.blockSeparator\n                            } : {},\n                            textSerializers\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\nconst blur = ()=>({ editor, view })=>{\n        requestAnimationFrame(()=>{\n            var _a;\n            if (!editor.isDestroyed) {\n                view.dom.blur();\n                // Browsers should remove the caret on blur but safari does not.\n                // See: https://github.com/ueberdosis/tiptap/issues/2405\n                (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n            }\n        });\n        return true;\n    };\nconst clearContent = (emitUpdate = false)=>({ commands })=>{\n        return commands.setContent(\"\", emitUpdate);\n    };\nconst clearNodes = ()=>({ state, tr, dispatch })=>{\n        const { selection } = tr;\n        const { ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        ranges.forEach(({ $from, $to })=>{\n            state.doc.nodesBetween($from.pos, $to.pos, (node, pos)=>{\n                if (node.type.isText) {\n                    return;\n                }\n                const { doc, mapping } = tr;\n                const $mappedFrom = doc.resolve(mapping.map(pos));\n                const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n                const nodeRange = $mappedFrom.blockRange($mappedTo);\n                if (!nodeRange) {\n                    return;\n                }\n                const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.liftTarget)(nodeRange);\n                if (node.type.isTextblock) {\n                    const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n                    tr.setNodeMarkup(nodeRange.start, defaultType);\n                }\n                if (targetLiftDepth || targetLiftDepth === 0) {\n                    tr.lift(nodeRange, targetLiftDepth);\n                }\n            });\n        });\n        return true;\n    };\nconst command = (fn)=>(props)=>{\n        return fn(props);\n    };\nconst createParagraphNear = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);\n    };\nconst cut = (originRange, targetPos)=>({ editor, tr })=>{\n        const { state } = editor;\n        const contentSlice = state.doc.slice(originRange.from, originRange.to);\n        tr.deleteRange(originRange.from, originRange.to);\n        const newPos = tr.mapping.map(targetPos);\n        tr.insert(newPos, contentSlice.content);\n        tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));\n        return true;\n    };\nconst deleteCurrentNode = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const currentNode = selection.$anchor.node();\n        // if there is content inside the current node, break out of this command\n        if (currentNode.content.size > 0) {\n            return false;\n        }\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === currentNode.type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst deleteNode = (typeOrName)=>({ tr, state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const $pos = tr.selection.$anchor;\n        for(let depth = $pos.depth; depth > 0; depth -= 1){\n            const node = $pos.node(depth);\n            if (node.type === type) {\n                if (dispatch) {\n                    const from = $pos.before(depth);\n                    const to = $pos.after(depth);\n                    tr.delete(from, to).scrollIntoView();\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst deleteRange = (range)=>({ tr, dispatch })=>{\n        const { from, to } = range;\n        if (dispatch) {\n            tr.delete(from, to);\n        }\n        return true;\n    };\nconst deleteSelection = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);\n    };\nconst enter = ()=>({ commands })=>{\n        return commands.keyboardShortcut(\"Enter\");\n    };\nconst exitCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);\n    };\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */ function objectIncludes(object1, object2, options = {\n    strict: true\n}) {\n    const keys = Object.keys(object2);\n    if (!keys.length) {\n        return true;\n    }\n    return keys.every((key)=>{\n        if (options.strict) {\n            return object2[key] === object1[key];\n        }\n        if (isRegExp(object2[key])) {\n            return object2[key].test(object1[key]);\n        }\n        return object2[key] === object1[key];\n    });\n}\nfunction findMarkInSet(marks, type, attributes = {}) {\n    return marks.find((item)=>{\n        return item.type === type && objectIncludes(// Only check equality for the attributes that are provided\n        Object.fromEntries(Object.keys(attributes).map((k)=>[\n                k,\n                item.attrs[k]\n            ])), attributes);\n    });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n    return !!findMarkInSet(marks, type, attributes);\n}\n/**\n * Get the range of a mark at a resolved position.\n */ function getMarkRange(/**\n * The position to get the mark range for.\n */ $pos, /**\n * The mark type to get the range for.\n */ type, /**\n * The attributes to match against.\n * If not provided, only the first mark at the position will be matched.\n */ attributes) {\n    var _a;\n    if (!$pos || !type) {\n        return;\n    }\n    let start = $pos.parent.childAfter($pos.parentOffset);\n    // If the cursor is at the start of a text node that does not have the mark, look backward\n    if (!start.node || !start.node.marks.some((mark)=>mark.type === type)) {\n        start = $pos.parent.childBefore($pos.parentOffset);\n    }\n    // If there is no text node with the mark even backward, return undefined\n    if (!start.node || !start.node.marks.some((mark)=>mark.type === type)) {\n        return;\n    }\n    // Default to only matching against the first mark's attributes\n    attributes = attributes || ((_a = start.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);\n    // We now know that the cursor is either at the start, middle or end of a text node with the specified mark\n    // so we can look it up on the targeted mark\n    const mark = findMarkInSet([\n        ...start.node.marks\n    ], type, attributes);\n    if (!mark) {\n        return;\n    }\n    let startIndex = start.index;\n    let startPos = $pos.start() + start.offset;\n    let endIndex = startIndex + 1;\n    let endPos = startPos + start.node.nodeSize;\n    while(startIndex > 0 && isMarkInSet([\n        ...$pos.parent.child(startIndex - 1).marks\n    ], type, attributes)){\n        startIndex -= 1;\n        startPos -= $pos.parent.child(startIndex).nodeSize;\n    }\n    while(endIndex < $pos.parent.childCount && isMarkInSet([\n        ...$pos.parent.child(endIndex).marks\n    ], type, attributes)){\n        endPos += $pos.parent.child(endIndex).nodeSize;\n        endIndex += 1;\n    }\n    return {\n        from: startPos,\n        to: endPos\n    };\n}\nfunction getMarkType(nameOrType, schema) {\n    if (typeof nameOrType === \"string\") {\n        if (!schema.marks[nameOrType]) {\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.marks[nameOrType];\n    }\n    return nameOrType;\n}\nconst extendMarkRange = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const type = getMarkType(typeOrName, state.schema);\n        const { doc, selection } = tr;\n        const { $from, from, to } = selection;\n        if (dispatch) {\n            const range = getMarkRange($from, type, attributes);\n            if (range && range.from <= from && range.to >= to) {\n                const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);\n                tr.setSelection(newSelection);\n            }\n        }\n        return true;\n    };\nconst first = (commands)=>(props)=>{\n        const items = typeof commands === \"function\" ? commands(props) : commands;\n        for(let i = 0; i < items.length; i += 1){\n            if (items[i](props)) {\n                return true;\n            }\n        }\n        return false;\n    };\nfunction isTextSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n}\nfunction minMax(value = 0, min = 0, max = 0) {\n    return Math.min(Math.max(value, min), max);\n}\nfunction resolveFocusPosition(doc, position = null) {\n    if (!position) {\n        return null;\n    }\n    const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);\n    const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);\n    if (position === \"start\" || position === true) {\n        return selectionAtStart;\n    }\n    if (position === \"end\") {\n        return selectionAtEnd;\n    }\n    const minPos = selectionAtStart.from;\n    const maxPos = selectionAtEnd.to;\n    if (position === \"all\") {\n        return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n    }\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\nfunction isAndroid() {\n    return navigator.platform === \"Android\" || /android/i.test(navigator.userAgent);\n}\nfunction isiOS() {\n    return [\n        \"iPad Simulator\",\n        \"iPhone Simulator\",\n        \"iPod Simulator\",\n        \"iPad\",\n        \"iPhone\",\n        \"iPod\"\n    ].includes(navigator.platform) || navigator.userAgent.includes(\"Mac\") && \"ontouchend\" in document;\n}\nconst focus = (position = null, options = {})=>({ editor, view, tr, dispatch })=>{\n        options = {\n            scrollIntoView: true,\n            ...options\n        };\n        const delayedFocus = ()=>{\n            // focus within `requestAnimationFrame` breaks focus on iOS and Android\n            // so we have to call this\n            if (isiOS() || isAndroid()) {\n                view.dom.focus();\n            }\n            // For React we have to focus asynchronously. Otherwise wild things happen.\n            // see: https://github.com/ueberdosis/tiptap/issues/1520\n            requestAnimationFrame(()=>{\n                if (!editor.isDestroyed) {\n                    view.focus();\n                    if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n                        editor.commands.scrollIntoView();\n                    }\n                }\n            });\n        };\n        if (view.hasFocus() && position === null || position === false) {\n            return true;\n        }\n        // we don’t try to resolve a NodeSelection or CellSelection\n        if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n            delayedFocus();\n            return true;\n        }\n        // pass through tr.doc instead of editor.state.doc\n        // since transactions could change the editors state before this command has been run\n        const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n        const isSameSelection = editor.state.selection.eq(selection);\n        if (dispatch) {\n            if (!isSameSelection) {\n                tr.setSelection(selection);\n            }\n            // `tr.setSelection` resets the stored marks\n            // so we’ll restore them if the selection is the same as before\n            if (isSameSelection && tr.storedMarks) {\n                tr.setStoredMarks(tr.storedMarks);\n            }\n            delayedFocus();\n        }\n        return true;\n    };\nconst forEach = (items, fn)=>(props)=>{\n        return items.every((item, index)=>fn(item, {\n                ...props,\n                index\n            }));\n    };\nconst insertContent = (value, options)=>({ tr, commands })=>{\n        return commands.insertContentAt({\n            from: tr.selection.from,\n            to: tr.selection.to\n        }, value, options);\n    };\nconst removeWhitespaces = (node)=>{\n    const children = node.childNodes;\n    for(let i = children.length - 1; i >= 0; i -= 1){\n        const child = children[i];\n        if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n            node.removeChild(child);\n        } else if (child.nodeType === 1) {\n            removeWhitespaces(child);\n        }\n    }\n    return node;\n};\nfunction elementFromString(value) {\n    // add a wrapper to preserve leading and trailing whitespace\n    const wrappedValue = `<body>${value}</body>`;\n    const html = new window.DOMParser().parseFromString(wrappedValue, \"text/html\").body;\n    return removeWhitespaces(html);\n}\n/**\n * Takes a JSON or HTML content and creates a Prosemirror node or fragment from it.\n * @param content The JSON or HTML content to create the node from\n * @param schema The Prosemirror schema to use for the node\n * @param options Options for the parser\n * @returns The created Prosemirror node or fragment\n */ function createNodeFromContent(content, schema, options) {\n    if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n        return content;\n    }\n    options = {\n        slice: true,\n        parseOptions: {},\n        ...options\n    };\n    const isJSONContent = typeof content === \"object\" && content !== null;\n    const isTextContent = typeof content === \"string\";\n    if (isJSONContent) {\n        try {\n            const isArrayContent = Array.isArray(content) && content.length > 0;\n            // if the JSON Content is an array of nodes, create a fragment for each node\n            if (isArrayContent) {\n                return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map((item)=>schema.nodeFromJSON(item)));\n            }\n            const node = schema.nodeFromJSON(content);\n            if (options.errorOnInvalidContent) {\n                node.check();\n            }\n            return node;\n        } catch (error) {\n            if (options.errorOnInvalidContent) {\n                throw new Error(\"[tiptap error]: Invalid JSON content\", {\n                    cause: error\n                });\n            }\n            console.warn(\"[tiptap warn]: Invalid content.\", \"Passed value:\", content, \"Error:\", error);\n            return createNodeFromContent(\"\", schema, options);\n        }\n    }\n    if (isTextContent) {\n        // Check for invalid content\n        if (options.errorOnInvalidContent) {\n            let hasInvalidContent = false;\n            let invalidContent = \"\";\n            // A copy of the current schema with a catch-all node at the end\n            const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n                topNode: schema.spec.topNode,\n                marks: schema.spec.marks,\n                // Prosemirror's schemas are executed such that: the last to execute, matches last\n                // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n                nodes: schema.spec.nodes.append({\n                    __tiptap__private__unknown__catch__all__node: {\n                        content: \"inline*\",\n                        group: \"block\",\n                        parseDOM: [\n                            {\n                                tag: \"*\",\n                                getAttrs: (e)=>{\n                                    // If this is ever called, we know that the content has something that we don't know how to handle in the schema\n                                    hasInvalidContent = true;\n                                    // Try to stringify the element for a more helpful error message\n                                    invalidContent = typeof e === \"string\" ? e : e.outerHTML;\n                                    return null;\n                                }\n                            }\n                        ]\n                    }\n                })\n            });\n            if (options.slice) {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n            } else {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n            }\n            if (options.errorOnInvalidContent && hasInvalidContent) {\n                throw new Error(\"[tiptap error]: Invalid HTML content\", {\n                    cause: new Error(`Invalid element found: ${invalidContent}`)\n                });\n            }\n        }\n        const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n        if (options.slice) {\n            return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n        }\n        return parser.parse(elementFromString(content), options.parseOptions);\n    }\n    return createNodeFromContent(\"\", schema, options);\n}\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    const last = tr.steps.length - 1;\n    if (last < startLen) {\n        return;\n    }\n    const step = tr.steps[last];\n    if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceAroundStep)) {\n        return;\n    }\n    const map = tr.mapping.maps[last];\n    let end = 0;\n    map.forEach((_from, _to, _newFrom, newTo)=>{\n        if (end === 0) {\n            end = newTo;\n        }\n    });\n    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));\n}\nconst isFragment = (nodeOrFragment)=>{\n    return !(\"type\" in nodeOrFragment);\n};\nconst insertContentAt = (position, value, options)=>({ tr, dispatch, editor })=>{\n        var _a;\n        if (dispatch) {\n            options = {\n                parseOptions: editor.options.parseOptions,\n                updateSelection: true,\n                applyInputRules: false,\n                applyPasteRules: false,\n                ...options\n            };\n            let content;\n            const emitContentError = (error)=>{\n                editor.emit(\"contentError\", {\n                    editor,\n                    error,\n                    disableCollaboration: ()=>{\n                        if (editor.storage.collaboration) {\n                            editor.storage.collaboration.isDisabled = true;\n                        }\n                    }\n                });\n            };\n            const parseOptions = {\n                preserveWhitespace: \"full\",\n                ...options.parseOptions\n            };\n            // If `emitContentError` is enabled, we want to check the content for errors\n            // but ignore them (do not remove the invalid content from the document)\n            if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {\n                try {\n                    createNodeFromContent(value, editor.schema, {\n                        parseOptions,\n                        errorOnInvalidContent: true\n                    });\n                } catch (e) {\n                    emitContentError(e);\n                }\n            }\n            try {\n                content = createNodeFromContent(value, editor.schema, {\n                    parseOptions,\n                    errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck\n                });\n            } catch (e) {\n                emitContentError(e);\n                return false;\n            }\n            let { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : {\n                from: position.from,\n                to: position.to\n            };\n            let isOnlyTextContent = true;\n            let isOnlyBlockContent = true;\n            const nodes = isFragment(content) ? content : [\n                content\n            ];\n            nodes.forEach((node)=>{\n                // check if added node is valid\n                node.check();\n                isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n                isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n            });\n            // check if we can replace the wrapping node by\n            // the newly inserted content\n            // example:\n            // replace an empty paragraph by an inserted image\n            // instead of inserting the image below the paragraph\n            if (from === to && isOnlyBlockContent) {\n                const { parent } = tr.doc.resolve(from);\n                const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n                if (isEmptyTextBlock) {\n                    from -= 1;\n                    to += 1;\n                }\n            }\n            let newContent;\n            // if there is only plain text we have to use `insertText`\n            // because this will keep the current marks\n            if (isOnlyTextContent) {\n                // if value is string, we can use it directly\n                // otherwise if it is an array, we have to join it\n                if (Array.isArray(value)) {\n                    newContent = value.map((v)=>v.text || \"\").join(\"\");\n                } else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n                    let text = \"\";\n                    value.forEach((node)=>{\n                        if (node.text) {\n                            text += node.text;\n                        }\n                    });\n                    newContent = text;\n                } else if (typeof value === \"object\" && !!value && !!value.text) {\n                    newContent = value.text;\n                } else {\n                    newContent = value;\n                }\n                tr.insertText(newContent, from, to);\n            } else {\n                newContent = content;\n                tr.replaceWith(from, to, newContent);\n            }\n            // set cursor at end of inserted content\n            if (options.updateSelection) {\n                selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n            }\n            if (options.applyInputRules) {\n                tr.setMeta(\"applyInputRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n            if (options.applyPasteRules) {\n                tr.setMeta(\"applyPasteRules\", {\n                    from,\n                    text: newContent\n                });\n            }\n        }\n        return true;\n    };\nconst joinUp = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);\n    };\nconst joinDown = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);\n    };\nconst joinBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);\n    };\nconst joinForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);\n    };\nconst joinItemBackward = ()=>({ state, dispatch, tr })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n            if (point === null || point === undefined) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    };\nconst joinItemForward = ()=>({ state, dispatch, tr })=>{\n        try {\n            const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, +1);\n            if (point === null || point === undefined) {\n                return false;\n            }\n            tr.join(point, 2);\n            if (dispatch) {\n                dispatch(tr);\n            }\n            return true;\n        } catch  {\n            return false;\n        }\n    };\nconst joinTextblockBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockBackward)(state, dispatch);\n    };\nconst joinTextblockForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockForward)(state, dispatch);\n    };\nfunction isMacOS() {\n    return typeof navigator !== \"undefined\" ? /Mac/.test(navigator.platform) : false;\n}\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result === \"Space\") {\n        result = \" \";\n    }\n    let alt;\n    let ctrl;\n    let shift;\n    let meta;\n    for(let i = 0; i < parts.length - 1; i += 1){\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n            meta = true;\n        } else if (/^a(lt)?$/i.test(mod)) {\n            alt = true;\n        } else if (/^(c|ctrl|control)$/i.test(mod)) {\n            ctrl = true;\n        } else if (/^s(hift)?$/i.test(mod)) {\n            shift = true;\n        } else if (/^mod$/i.test(mod)) {\n            if (isiOS() || isMacOS()) {\n                meta = true;\n            } else {\n                ctrl = true;\n            }\n        } else {\n            throw new Error(`Unrecognized modifier name: ${mod}`);\n        }\n    }\n    if (alt) {\n        result = `Alt-${result}`;\n    }\n    if (ctrl) {\n        result = `Ctrl-${result}`;\n    }\n    if (meta) {\n        result = `Meta-${result}`;\n    }\n    if (shift) {\n        result = `Shift-${result}`;\n    }\n    return result;\n}\nconst keyboardShortcut = (name)=>({ editor, view, tr, dispatch })=>{\n        const keys = normalizeKeyName(name).split(/-(?!$)/);\n        const key = keys.find((item)=>![\n                \"Alt\",\n                \"Ctrl\",\n                \"Meta\",\n                \"Shift\"\n            ].includes(item));\n        const event = new KeyboardEvent(\"keydown\", {\n            key: key === \"Space\" ? \" \" : key,\n            altKey: keys.includes(\"Alt\"),\n            ctrlKey: keys.includes(\"Ctrl\"),\n            metaKey: keys.includes(\"Meta\"),\n            shiftKey: keys.includes(\"Shift\"),\n            bubbles: true,\n            cancelable: true\n        });\n        const capturedTransaction = editor.captureTransaction(()=>{\n            view.someProp(\"handleKeyDown\", (f)=>f(view, event));\n        });\n        capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach((step)=>{\n            const newStep = step.map(tr.mapping);\n            if (newStep && dispatch) {\n                tr.maybeStep(newStep);\n            }\n        });\n        return true;\n    };\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n    const { from, to, empty } = state.selection;\n    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n    const nodeRanges = [];\n    state.doc.nodesBetween(from, to, (node, pos)=>{\n        if (node.isText) {\n            return;\n        }\n        const relativeFrom = Math.max(from, pos);\n        const relativeTo = Math.min(to, pos + node.nodeSize);\n        nodeRanges.push({\n            node,\n            from: relativeFrom,\n            to: relativeTo\n        });\n    });\n    const selectionRange = to - from;\n    const matchedNodeRanges = nodeRanges.filter((nodeRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === nodeRange.node.type.name;\n    }).filter((nodeRange)=>objectIncludes(nodeRange.node.attrs, attributes, {\n            strict: false\n        }));\n    if (empty) {\n        return !!matchedNodeRanges.length;\n    }\n    const range = matchedNodeRanges.reduce((sum, nodeRange)=>sum + nodeRange.to - nodeRange.from, 0);\n    return range >= selectionRange;\n}\nconst lift = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        if (!isActive) {\n            return false;\n        }\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);\n    };\nconst liftEmptyBlock = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);\n    };\nconst liftListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);\n    };\nconst newlineInCode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);\n    };\n/**\n * Get the type of a schema item by its name.\n * @param name The name of the schema item\n * @param schema The Prosemiror schema to search in\n * @returns The type of the schema item (`node` or `mark`), or null if it doesn't exist\n */ function getSchemaTypeNameByName(name, schema) {\n    if (schema.nodes[name]) {\n        return \"node\";\n    }\n    if (schema.marks[name]) {\n        return \"mark\";\n    }\n    return null;\n}\n/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */ function deleteProps(obj, propOrProps) {\n    const props = typeof propOrProps === \"string\" ? [\n        propOrProps\n    ] : propOrProps;\n    return Object.keys(obj).reduce((newObj, prop)=>{\n        if (!props.includes(prop)) {\n            newObj[prop] = obj[prop];\n        }\n        return newObj;\n    }, {});\n}\nconst resetAttributes = (typeOrName, attributes)=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        if (dispatch) {\n            tr.selection.ranges.forEach((range)=>{\n                state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos)=>{\n                    if (nodeType && nodeType === node.type) {\n                        tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n                    }\n                    if (markType && node.marks.length) {\n                        node.marks.forEach((mark)=>{\n                            if (markType === mark.type) {\n                                tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n                            }\n                        });\n                    }\n                });\n            });\n        }\n        return true;\n    };\nconst scrollIntoView = ()=>({ tr, dispatch })=>{\n        if (dispatch) {\n            tr.scrollIntoView();\n        }\n        return true;\n    };\nconst selectAll = ()=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection(tr.doc);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst selectNodeBackward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);\n    };\nconst selectNodeForward = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);\n    };\nconst selectParentNode = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);\n    };\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockEnd = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);\n    };\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockStart = ()=>({ state, dispatch })=>{\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);\n    };\n/**\n * Create a new Prosemirror document node from content.\n * @param content The JSON or HTML content to create the document from\n * @param schema The Prosemirror schema to use for the document\n * @param parseOptions Options for the parser\n * @returns The created Prosemirror document node\n */ function createDocument(content, schema, parseOptions = {}, options = {}) {\n    return createNodeFromContent(content, schema, {\n        slice: false,\n        parseOptions,\n        errorOnInvalidContent: options.errorOnInvalidContent\n    });\n}\nconst setContent = (content, emitUpdate = false, parseOptions = {}, options = {})=>({ editor, tr, dispatch, commands })=>{\n        var _a, _b;\n        const { doc } = tr;\n        // This is to keep backward compatibility with the previous behavior\n        // TODO remove this in the next major version\n        if (parseOptions.preserveWhitespace !== \"full\") {\n            const document1 = createDocument(content, editor.schema, parseOptions, {\n                errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck\n            });\n            if (dispatch) {\n                tr.replaceWith(0, doc.content.size, document1).setMeta(\"preventUpdate\", !emitUpdate);\n            }\n            return true;\n        }\n        if (dispatch) {\n            tr.setMeta(\"preventUpdate\", !emitUpdate);\n        }\n        return commands.insertContentAt({\n            from: 0,\n            to: doc.content.size\n        }, content, {\n            parseOptions,\n            errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck\n        });\n    };\nfunction getMarkAttributes(state, typeOrName) {\n    const type = getMarkType(typeOrName, state.schema);\n    const { from, to, empty } = state.selection;\n    const marks = [];\n    if (empty) {\n        if (state.storedMarks) {\n            marks.push(...state.storedMarks);\n        }\n        marks.push(...state.selection.$head.marks());\n    } else {\n        state.doc.nodesBetween(from, to, (node)=>{\n            marks.push(...node.marks);\n        });\n    }\n    const mark = marks.find((markItem)=>markItem.type.name === type.name);\n    if (!mark) {\n        return {};\n    }\n    return {\n        ...mark.attrs\n    };\n}\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n * @param oldDoc The Prosemirror node to start from\n * @param transactions The transactions to combine\n * @returns A new `Transform` with all steps of the passed transactions\n */ function combineTransactionSteps(oldDoc, transactions) {\n    const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.Transform(oldDoc);\n    transactions.forEach((transaction)=>{\n        transaction.steps.forEach((step)=>{\n            transform.step(step);\n        });\n    });\n    return transform;\n}\n/**\n * Gets the default block type at a given match\n * @param match The content match to get the default block type from\n * @returns The default block type or null\n */ function defaultBlockAt(match) {\n    for(let i = 0; i < match.edgeCount; i += 1){\n        const { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\n            return type;\n        }\n    }\n    return null;\n}\n/**\n * Find children inside a Prosemirror node that match a predicate.\n * @param node The Prosemirror node to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */ function findChildren(node, predicate) {\n    const nodesWithPos = [];\n    node.descendants((child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n/**\n * Same as `findChildren` but searches only within a `range`.\n * @param node The Prosemirror node to search in\n * @param range The range to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */ function findChildrenInRange(node, range, predicate) {\n    const nodesWithPos = [];\n    // if (range.from === range.to) {\n    //   const nodeAt = node.nodeAt(range.from)\n    //   if (nodeAt) {\n    //     nodesWithPos.push({\n    //       node: nodeAt,\n    //       pos: range.from,\n    //     })\n    //   }\n    // }\n    node.nodesBetween(range.from, range.to, (child, pos)=>{\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos\n            });\n        }\n    });\n    return nodesWithPos;\n}\n/**\n * Finds the closest parent node to a resolved position that matches a predicate.\n * @param $pos The resolved position to search from\n * @param predicate The predicate to match\n * @returns The closest parent node to the resolved position that matches the predicate\n * @example ```js\n * findParentNodeClosestToPos($from, node => node.type.name === 'paragraph')\n * ```\n */ function findParentNodeClosestToPos($pos, predicate) {\n    for(let i = $pos.depth; i > 0; i -= 1){\n        const node = $pos.node(i);\n        if (predicate(node)) {\n            return {\n                pos: i > 0 ? $pos.before(i) : 0,\n                start: $pos.start(i),\n                depth: i,\n                node\n            };\n        }\n    }\n}\n/**\n * Finds the closest parent node to the current selection that matches a predicate.\n * @param predicate The predicate to match\n * @returns A command that finds the closest parent node to the current selection that matches the predicate\n * @example ```js\n * findParentNode(node => node.type.name === 'paragraph')\n * ```\n */ function findParentNode(predicate) {\n    return (selection)=>findParentNodeClosestToPos(selection.$from, predicate);\n}\nfunction getSchema(extensions, editor) {\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\n    return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n/**\n * Generate HTML from a JSONContent\n * @param doc The JSONContent to generate HTML from\n * @param extensions The extensions to use for the schema\n * @returns The generated HTML\n */ function generateHTML(doc, extensions) {\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getHTMLFromFragment(contentNode.content, schema);\n}\n/**\n * Generate JSONContent from HTML\n * @param html The HTML to generate JSONContent from\n * @param extensions The extensions to use for the schema\n * @returns The generated JSONContent\n */ function generateJSON(html, extensions) {\n    const schema = getSchema(extensions);\n    const dom = elementFromString(html);\n    return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n/**\n * Gets the text of a Prosemirror node\n * @param node The Prosemirror node\n * @param options Options for the text serializer & block separator\n * @returns The text of the node\n * @example ```js\n * const text = getText(node, { blockSeparator: '\\n' })\n * ```\n */ function getText(node, options) {\n    const range = {\n        from: 0,\n        to: node.content.size\n    };\n    return getTextBetween(node, range, options);\n}\n/**\n * Generate raw text from a JSONContent\n * @param doc The JSONContent to generate text from\n * @param extensions The extensions to use for the schema\n * @param options Options for the text generation f.e. blockSeparator or textSerializers\n * @returns The generated text\n */ function generateText(doc, extensions, options) {\n    const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getText(contentNode, {\n        blockSeparator,\n        textSerializers: {\n            ...getTextSerializersFromSchema(schema),\n            ...textSerializers\n        }\n    });\n}\nfunction getNodeAttributes(state, typeOrName) {\n    const type = getNodeType(typeOrName, state.schema);\n    const { from, to } = state.selection;\n    const nodes = [];\n    state.doc.nodesBetween(from, to, (node)=>{\n        nodes.push(node);\n    });\n    const node = nodes.reverse().find((nodeItem)=>nodeItem.type.name === type.name);\n    if (!node) {\n        return {};\n    }\n    return {\n        ...node.attrs\n    };\n}\n/**\n * Get node or mark attributes by type or name on the current editor state\n * @param state The current editor state\n * @param typeOrName The node or mark type or name\n * @returns The attributes of the node or mark or an empty object\n */ function getAttributes(state, typeOrName) {\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n    if (schemaType === \"node\") {\n        return getNodeAttributes(state, typeOrName);\n    }\n    if (schemaType === \"mark\") {\n        return getMarkAttributes(state, typeOrName);\n    }\n    return {};\n}\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */ function removeDuplicates(array, by = JSON.stringify) {\n    const seen = {};\n    return array.filter((item)=>{\n        const key = by(item);\n        return Object.prototype.hasOwnProperty.call(seen, key) ? false : seen[key] = true;\n    });\n}\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */ function simplifyChangedRanges(changes) {\n    const uniqueChanges = removeDuplicates(changes);\n    return uniqueChanges.length === 1 ? uniqueChanges : uniqueChanges.filter((change, index)=>{\n        const rest = uniqueChanges.filter((_, i)=>i !== index);\n        return !rest.some((otherChange)=>{\n            return change.oldRange.from >= otherChange.oldRange.from && change.oldRange.to <= otherChange.oldRange.to && change.newRange.from >= otherChange.newRange.from && change.newRange.to <= otherChange.newRange.to;\n        });\n    });\n}\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */ function getChangedRanges(transform) {\n    const { mapping, steps } = transform;\n    const changes = [];\n    mapping.maps.forEach((stepMap, index)=>{\n        const ranges = [];\n        // This accounts for step changes where no range was actually altered\n        // e.g. when setting a mark, node attribute, etc.\n        // @ts-ignore\n        if (!stepMap.ranges.length) {\n            const { from, to } = steps[index];\n            if (from === undefined || to === undefined) {\n                return;\n            }\n            ranges.push({\n                from,\n                to\n            });\n        } else {\n            stepMap.forEach((from, to)=>{\n                ranges.push({\n                    from,\n                    to\n                });\n            });\n        }\n        ranges.forEach(({ from, to })=>{\n            const newStart = mapping.slice(index).map(from, -1);\n            const newEnd = mapping.slice(index).map(to);\n            const oldStart = mapping.invert().map(newStart, -1);\n            const oldEnd = mapping.invert().map(newEnd);\n            changes.push({\n                oldRange: {\n                    from: oldStart,\n                    to: oldEnd\n                },\n                newRange: {\n                    from: newStart,\n                    to: newEnd\n                }\n            });\n        });\n    });\n    return simplifyChangedRanges(changes);\n}\nfunction getDebugJSON(node, startOffset = 0) {\n    const isTopNode = node.type === node.type.schema.topNodeType;\n    const increment = isTopNode ? 0 : 1;\n    const from = startOffset;\n    const to = from + node.nodeSize;\n    const marks = node.marks.map((mark)=>{\n        const output = {\n            type: mark.type.name\n        };\n        if (Object.keys(mark.attrs).length) {\n            output.attrs = {\n                ...mark.attrs\n            };\n        }\n        return output;\n    });\n    const attrs = {\n        ...node.attrs\n    };\n    const output = {\n        type: node.type.name,\n        from,\n        to\n    };\n    if (Object.keys(attrs).length) {\n        output.attrs = attrs;\n    }\n    if (marks.length) {\n        output.marks = marks;\n    }\n    if (node.content.childCount) {\n        output.content = [];\n        node.forEach((child, offset)=>{\n            var _a;\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n        });\n    }\n    if (node.text) {\n        output.text = node.text;\n    }\n    return output;\n}\nfunction getMarksBetween(from, to, doc) {\n    const marks = [];\n    // get all inclusive marks on empty selection\n    if (from === to) {\n        doc.resolve(from).marks().forEach((mark)=>{\n            const $pos = doc.resolve(from);\n            const range = getMarkRange($pos, mark.type);\n            if (!range) {\n                return;\n            }\n            marks.push({\n                mark,\n                ...range\n            });\n        });\n    } else {\n        doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === undefined) {\n                return;\n            }\n            marks.push(...node.marks.map((mark)=>({\n                    from: pos,\n                    to: pos + node.nodeSize,\n                    mark\n                })));\n        });\n    }\n    return marks;\n}\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */ const getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20)=>{\n    const $pos = state.doc.resolve(pos);\n    let currentDepth = maxDepth;\n    let node = null;\n    while(currentDepth > 0 && node === null){\n        const currentNode = $pos.node(currentDepth);\n        if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n            node = currentNode;\n        } else {\n            currentDepth -= 1;\n        }\n    }\n    return [\n        node,\n        currentDepth\n    ];\n};\n/**\n * Return attributes of an extension that should be splitted by keepOnSplit flag\n * @param extensionAttributes Array of extension attributes\n * @param typeName The type of the extension\n * @param attributes The attributes of the extension\n * @returns The splitted attributes\n */ function getSplittedAttributes(extensionAttributes, typeName, attributes) {\n    return Object.fromEntries(Object.entries(attributes).filter(([name])=>{\n        const extensionAttribute = extensionAttributes.find((item)=>{\n            return item.type === typeName && item.name === name;\n        });\n        if (!extensionAttribute) {\n            return false;\n        }\n        return extensionAttribute.attribute.keepOnSplit;\n    }));\n}\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n    const { empty, ranges } = state.selection;\n    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n    if (empty) {\n        return !!(state.storedMarks || state.selection.$from.marks()).filter((mark)=>{\n            if (!type) {\n                return true;\n            }\n            return type.name === mark.type.name;\n        }).find((mark)=>objectIncludes(mark.attrs, attributes, {\n                strict: false\n            }));\n    }\n    let selectionRange = 0;\n    const markRanges = [];\n    ranges.forEach(({ $from, $to })=>{\n        const from = $from.pos;\n        const to = $to.pos;\n        state.doc.nodesBetween(from, to, (node, pos)=>{\n            if (!node.isText && !node.marks.length) {\n                return;\n            }\n            const relativeFrom = Math.max(from, pos);\n            const relativeTo = Math.min(to, pos + node.nodeSize);\n            const range = relativeTo - relativeFrom;\n            selectionRange += range;\n            markRanges.push(...node.marks.map((mark)=>({\n                    mark,\n                    from: relativeFrom,\n                    to: relativeTo\n                })));\n        });\n    });\n    if (selectionRange === 0) {\n        return false;\n    }\n    // calculate range of matched mark\n    const matchedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return type.name === markRange.mark.type.name;\n    }).filter((markRange)=>objectIncludes(markRange.mark.attrs, attributes, {\n            strict: false\n        })).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    // calculate range of marks that excludes the searched mark\n    // for example `code` doesn’t allow any other marks\n    const excludedRange = markRanges.filter((markRange)=>{\n        if (!type) {\n            return true;\n        }\n        return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n    }).reduce((sum, markRange)=>sum + markRange.to - markRange.from, 0);\n    // we only include the result of `excludedRange`\n    // if there is a match at all\n    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n    return range >= selectionRange;\n}\nfunction isActive(state, name, attributes = {}) {\n    if (!name) {\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n    }\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\n    if (schemaType === \"node\") {\n        return isNodeActive(state, name, attributes);\n    }\n    if (schemaType === \"mark\") {\n        return isMarkActive(state, name, attributes);\n    }\n    return false;\n}\nconst isAtEndOfNode = (state, nodeType)=>{\n    const { $from, $to, $anchor } = state.selection;\n    if (nodeType) {\n        const parentNode = findParentNode((node)=>node.type.name === nodeType)(state.selection);\n        if (!parentNode) {\n            return false;\n        }\n        const $parentPos = state.doc.resolve(parentNode.pos + 1);\n        if ($anchor.pos + 1 === $parentPos.end()) {\n            return true;\n        }\n        return false;\n    }\n    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\nconst isAtStartOfNode = (state)=>{\n    const { $from, $to } = state.selection;\n    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\nfunction isList(name, extensions) {\n    const { nodeExtensions } = splitExtensions(extensions);\n    const extension = nodeExtensions.find((item)=>item.name === name);\n    if (!extension) {\n        return false;\n    }\n    const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage\n    };\n    const group = callOrReturn(getExtensionField(extension, \"group\", context));\n    if (typeof group !== \"string\") {\n        return false;\n    }\n    return group.split(\" \").includes(\"list\");\n}\n/**\n * Returns true if the given prosemirror node is empty.\n */ function isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false } = {}) {\n    var _a;\n    if (ignoreWhitespace) {\n        if (node.type.name === \"hardBreak\") {\n            // Hard breaks are considered empty\n            return true;\n        }\n        if (node.isText) {\n            return /^\\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : \"\");\n        }\n    }\n    if (node.isText) {\n        return !node.text;\n    }\n    if (node.isAtom || node.isLeaf) {\n        return false;\n    }\n    if (node.content.childCount === 0) {\n        return true;\n    }\n    if (checkChildren) {\n        let isContentEmpty = true;\n        node.content.forEach((childNode)=>{\n            if (isContentEmpty === false) {\n                // Exit early for perf\n                return;\n            }\n            if (!isNodeEmpty(childNode, {\n                ignoreWhitespace,\n                checkChildren\n            })) {\n                isContentEmpty = false;\n            }\n        });\n        return isContentEmpty;\n    }\n    return false;\n}\nfunction isNodeSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;\n}\nfunction posToDOMRect(view, from, to) {\n    const minPos = 0;\n    const maxPos = view.state.doc.content.size;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const start = view.coordsAtPos(resolvedFrom);\n    const end = view.coordsAtPos(resolvedEnd, -1);\n    const top = Math.min(start.top, end.top);\n    const bottom = Math.max(start.bottom, end.bottom);\n    const left = Math.min(start.left, end.left);\n    const right = Math.max(start.right, end.right);\n    const width = right - left;\n    const height = bottom - top;\n    const x = left;\n    const y = top;\n    const data = {\n        top,\n        bottom,\n        left,\n        right,\n        width,\n        height,\n        x,\n        y\n    };\n    return {\n        ...data,\n        toJSON: ()=>data\n    };\n}\n/**\n * The actual implementation of the rewriteUnknownContent function\n */ function rewriteUnknownContentInner({ json, validMarks, validNodes, options, rewrittenContent = [] }) {\n    if (json.marks && Array.isArray(json.marks)) {\n        json.marks = json.marks.filter((mark)=>{\n            const name = typeof mark === \"string\" ? mark : mark.type;\n            if (validMarks.has(name)) {\n                return true;\n            }\n            rewrittenContent.push({\n                original: JSON.parse(JSON.stringify(mark)),\n                unsupported: name\n            });\n            // Just ignore any unknown marks\n            return false;\n        });\n    }\n    if (json.content && Array.isArray(json.content)) {\n        json.content = json.content.map((value)=>rewriteUnknownContentInner({\n                json: value,\n                validMarks,\n                validNodes,\n                options,\n                rewrittenContent\n            }).json).filter((a)=>a !== null && a !== undefined);\n    }\n    if (json.type && !validNodes.has(json.type)) {\n        rewrittenContent.push({\n            original: JSON.parse(JSON.stringify(json)),\n            unsupported: json.type\n        });\n        if (json.content && Array.isArray(json.content) && (options === null || options === void 0 ? void 0 : options.fallbackToParagraph) !== false) {\n            // Just treat it like a paragraph and hope for the best\n            json.type = \"paragraph\";\n            return {\n                json,\n                rewrittenContent\n            };\n        }\n        // or just omit it entirely\n        return {\n            json: null,\n            rewrittenContent\n        };\n    }\n    return {\n        json,\n        rewrittenContent\n    };\n}\n/**\n * Rewrite unknown nodes and marks within JSON content\n * Allowing for user within the editor\n */ function rewriteUnknownContent(/**\n * The JSON content to clean of unknown nodes and marks\n */ json, /**\n * The schema to use for validation\n */ schema, /**\n * Options for the cleaning process\n */ options) {\n    return rewriteUnknownContentInner({\n        json,\n        validNodes: new Set(Object.keys(schema.nodes)),\n        validMarks: new Set(Object.keys(schema.marks)),\n        options\n    });\n}\nfunction canSetMark(state, tr, newMarkType) {\n    var _a;\n    const { selection } = tr;\n    let cursor = null;\n    if (isTextSelection(selection)) {\n        cursor = selection.$cursor;\n    }\n    if (cursor) {\n        const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n        // There can be no current marks that exclude the new mark\n        return !!newMarkType.isInSet(currentMarks) || !currentMarks.some((mark)=>mark.type.excludes(newMarkType));\n    }\n    const { ranges } = selection;\n    return ranges.some(({ $from, $to })=>{\n        let someNodeSupportsMark = $from.depth === 0 ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType) : false;\n        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent)=>{\n            // If we already found a mark that we can enable, return false to bypass the remaining search\n            if (someNodeSupportsMark) {\n                return false;\n            }\n            if (node.isInline) {\n                const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n                const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks) || !node.marks.some((otherMark)=>otherMark.type.excludes(newMarkType));\n                someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n            }\n            return !someNodeSupportsMark;\n        });\n        return someNodeSupportsMark;\n    });\n}\nconst setMark = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        const type = getMarkType(typeOrName, state.schema);\n        if (dispatch) {\n            if (empty) {\n                const oldAttributes = getMarkAttributes(state, type);\n                tr.addStoredMark(type.create({\n                    ...oldAttributes,\n                    ...attributes\n                }));\n            } else {\n                ranges.forEach((range)=>{\n                    const from = range.$from.pos;\n                    const to = range.$to.pos;\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        const trimmedFrom = Math.max(pos, from);\n                        const trimmedTo = Math.min(pos + node.nodeSize, to);\n                        const someHasMark = node.marks.find((mark)=>mark.type === type);\n                        // if there is already a mark of this type\n                        // we know that we have to merge its attributes\n                        // otherwise we add a fresh new mark\n                        if (someHasMark) {\n                            node.marks.forEach((mark)=>{\n                                if (type === mark.type) {\n                                    tr.addMark(trimmedFrom, trimmedTo, type.create({\n                                        ...mark.attrs,\n                                        ...attributes\n                                    }));\n                                }\n                            });\n                        } else {\n                            tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n                        }\n                    });\n                });\n            }\n        }\n        return canSetMark(state, tr, type);\n    };\nconst setMeta = (key, value)=>({ tr })=>{\n        tr.setMeta(key, value);\n        return true;\n    };\nconst setNode = (typeOrName, attributes = {})=>({ state, dispatch, chain })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        let attributesToCopy;\n        if (state.selection.$anchor.sameParent(state.selection.$head)) {\n            // only copy attributes if the selection is pointing to a node of the same type\n            attributesToCopy = state.selection.$anchor.parent.attrs;\n        }\n        // TODO: use a fallback like insertContent?\n        if (!type.isTextblock) {\n            console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n            return false;\n        }\n        return chain()// try to convert node to default node if needed\n        .command(({ commands })=>{\n            const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, {\n                ...attributesToCopy,\n                ...attributes\n            })(state);\n            if (canSetBlock) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).command(({ state: updatedState })=>{\n            return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, {\n                ...attributesToCopy,\n                ...attributes\n            })(updatedState, dispatch);\n        }).run();\n    };\nconst setNodeSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const from = minMax(position, 0, doc.content.size);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst setTextSelection = (position)=>({ tr, dispatch })=>{\n        if (dispatch) {\n            const { doc } = tr;\n            const { from, to } = typeof position === \"number\" ? {\n                from: position,\n                to: position\n            } : position;\n            const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;\n            const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;\n            const resolvedFrom = minMax(from, minPos, maxPos);\n            const resolvedEnd = minMax(to, minPos, maxPos);\n            const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n            tr.setSelection(selection);\n        }\n        return true;\n    };\nconst sinkListItem = (typeOrName)=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);\n    };\nfunction ensureMarks(state, splittableMarks) {\n    const marks = state.storedMarks || state.selection.$to.parentOffset && state.selection.$from.marks();\n    if (marks) {\n        const filteredMarks = marks.filter((mark)=>splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n        state.tr.ensureMarks(filteredMarks);\n    }\n}\nconst splitBlock = ({ keepMarks = true } = {})=>({ tr, state, dispatch, editor })=>{\n        const { selection, doc } = tr;\n        const { $from, $to } = selection;\n        const extensionAttributes = editor.extensionManager.attributes;\n        const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n        if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(doc, $from.pos)) {\n                return false;\n            }\n            if (dispatch) {\n                if (keepMarks) {\n                    ensureMarks(state, editor.extensionManager.splittableMarks);\n                }\n                tr.split($from.pos).scrollIntoView();\n            }\n            return true;\n        }\n        if (!$from.parent.isBlock) {\n            return false;\n        }\n        const atEnd = $to.parentOffset === $to.parent.content.size;\n        const deflt = $from.depth === 0 ? undefined : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n        let types = atEnd && deflt ? [\n            {\n                type: deflt,\n                attrs: newAttributes\n            }\n        ] : undefined;\n        let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n        if (!types && !can && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [\n            {\n                type: deflt\n            }\n        ] : undefined)) {\n            can = true;\n            types = deflt ? [\n                {\n                    type: deflt,\n                    attrs: newAttributes\n                }\n            ] : undefined;\n        }\n        if (dispatch) {\n            if (can) {\n                if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n                    tr.deleteSelection();\n                }\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n                    const first = tr.mapping.map($from.before());\n                    const $first = tr.doc.resolve(first);\n                    if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n                        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                    }\n                }\n            }\n            if (keepMarks) {\n                ensureMarks(state, editor.extensionManager.splittableMarks);\n            }\n            tr.scrollIntoView();\n        }\n        return can;\n    };\nconst splitListItem = (typeOrName, overrideAttrs = {})=>({ tr, state, dispatch, editor })=>{\n        var _a;\n        const type = getNodeType(typeOrName, state.schema);\n        const { $from, $to } = state.selection;\n        // @ts-ignore\n        // eslint-disable-next-line\n        const node = state.selection.node;\n        if (node && node.isBlock || $from.depth < 2 || !$from.sameParent($to)) {\n            return false;\n        }\n        const grandParent = $from.node(-1);\n        if (grandParent.type !== type) {\n            return false;\n        }\n        const extensionAttributes = editor.extensionManager.attributes;\n        if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth === 2 || $from.node(-3).type !== type || $from.index(-2) !== $from.node(-2).childCount - 1) {\n                return false;\n            }\n            if (dispatch) {\n                let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n                // eslint-disable-next-line\n                const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for(let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1){\n                    wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n                }\n                // eslint-disable-next-line\n                const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                const newNextTypeAttributes = {\n                    ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n                    ...overrideAttrs\n                };\n                const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n                wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType) || undefined));\n                const start = $from.before($from.depth - (depthBefore - 1));\n                tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos)=>{\n                    if (sel > -1) {\n                        return false;\n                    }\n                    if (n.isTextblock && n.content.size === 0) {\n                        sel = pos + 1;\n                    }\n                });\n                if (sel > -1) {\n                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));\n                }\n                tr.scrollIntoView();\n            }\n            return true;\n        }\n        const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        const newTypeAttributes = {\n            ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n            ...overrideAttrs\n        };\n        const newNextTypeAttributes = {\n            ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n            ...overrideAttrs\n        };\n        tr.delete($from.pos, $to.pos);\n        const types = nextType ? [\n            {\n                type,\n                attrs: newTypeAttributes\n            },\n            {\n                type: nextType,\n                attrs: newNextTypeAttributes\n            }\n        ] : [\n            {\n                type,\n                attrs: newTypeAttributes\n            }\n        ];\n        if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, $from.pos, 2)) {\n            return false;\n        }\n        if (dispatch) {\n            const { selection, storedMarks } = state;\n            const { splittableMarks } = editor.extensionManager;\n            const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n            tr.split($from.pos, 2, types).scrollIntoView();\n            if (!marks || !dispatch) {\n                return true;\n            }\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n        }\n        return true;\n    };\nconst joinListBackwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n    if (before === undefined) {\n        return true;\n    }\n    const nodeBefore = tr.doc.nodeAt(before);\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, list.pos);\n    if (!canJoinBackwards) {\n        return true;\n    }\n    tr.join(list.pos);\n    return true;\n};\nconst joinListForwards = (tr, listType)=>{\n    const list = findParentNode((node)=>node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const after = tr.doc.resolve(list.start).after(list.depth);\n    if (after === undefined) {\n        return true;\n    }\n    const nodeAfter = tr.doc.nodeAt(after);\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, after);\n    if (!canJoinForwards) {\n        return true;\n    }\n    tr.join(after);\n    return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {})=>({ editor, tr, state, dispatch, chain, commands, can })=>{\n        const { extensions, splittableMarks } = editor.extensionManager;\n        const listType = getNodeType(listTypeOrName, state.schema);\n        const itemType = getNodeType(itemTypeOrName, state.schema);\n        const { selection, storedMarks } = state;\n        const { $from, $to } = selection;\n        const range = $from.blockRange($to);\n        const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n        if (!range) {\n            return false;\n        }\n        const parentList = findParentNode((node)=>isList(node.type.name, extensions))(selection);\n        if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n            // remove list\n            if (parentList.node.type === listType) {\n                return commands.liftListItem(itemType);\n            }\n            // change list type\n            if (isList(parentList.node.type.name, extensions) && listType.validContent(parentList.node.content) && dispatch) {\n                return chain().command(()=>{\n                    tr.setNodeMarkup(parentList.pos, listType);\n                    return true;\n                }).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n            }\n        }\n        if (!keepMarks || !marks || !dispatch) {\n            return chain()// try to convert node to default node if needed\n            .command(()=>{\n                const canWrapInList = can().wrapInList(listType, attributes);\n                if (canWrapInList) {\n                    return true;\n                }\n                return commands.clearNodes();\n            }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n        }\n        return chain()// try to convert node to default node if needed\n        .command(()=>{\n            const canWrapInList = can().wrapInList(listType, attributes);\n            const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n            tr.ensureMarks(filteredMarks);\n            if (canWrapInList) {\n                return true;\n            }\n            return commands.clearNodes();\n        }).wrapInList(listType, attributes).command(()=>joinListBackwards(tr, listType)).command(()=>joinListForwards(tr, listType)).run();\n    };\nconst toggleMark = (typeOrName, attributes = {}, options = {})=>({ state, commands })=>{\n        const { extendEmptyMarkRange = false } = options;\n        const type = getMarkType(typeOrName, state.schema);\n        const isActive = isMarkActive(state, type, attributes);\n        if (isActive) {\n            return commands.unsetMark(type, {\n                extendEmptyMarkRange\n            });\n        }\n        return commands.setMark(type, attributes);\n    };\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const toggleType = getNodeType(toggleTypeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        let attributesToCopy;\n        if (state.selection.$anchor.sameParent(state.selection.$head)) {\n            // only copy attributes if the selection is pointing to a node of the same type\n            attributesToCopy = state.selection.$anchor.parent.attrs;\n        }\n        if (isActive) {\n            return commands.setNode(toggleType, attributesToCopy);\n        }\n        // If the node is not active, we want to set the new node type with the given attributes\n        // Copying over the attributes from the current node if the selection is pointing to a node of the same type\n        return commands.setNode(type, {\n            ...attributesToCopy,\n            ...attributes\n        });\n    };\nconst toggleWrap = (typeOrName, attributes = {})=>({ state, commands })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        const isActive = isNodeActive(state, type, attributes);\n        if (isActive) {\n            return commands.lift(type);\n        }\n        return commands.wrapIn(type, attributes);\n    };\nconst undoInputRule = ()=>({ state, dispatch })=>{\n        const plugins = state.plugins;\n        for(let i = 0; i < plugins.length; i += 1){\n            const plugin = plugins[i];\n            let undoable;\n            // @ts-ignore\n            // eslint-disable-next-line\n            if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n                if (dispatch) {\n                    const tr = state.tr;\n                    const toUndo = undoable.transform;\n                    for(let j = toUndo.steps.length - 1; j >= 0; j -= 1){\n                        tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                    }\n                    if (undoable.text) {\n                        const marks = tr.doc.resolve(undoable.from).marks();\n                        tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                    } else {\n                        tr.delete(undoable.from, undoable.to);\n                    }\n                }\n                return true;\n            }\n        }\n        return false;\n    };\nconst unsetAllMarks = ()=>({ tr, dispatch })=>{\n        const { selection } = tr;\n        const { empty, ranges } = selection;\n        if (empty) {\n            return true;\n        }\n        if (dispatch) {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos);\n            });\n        }\n        return true;\n    };\nconst unsetMark = (typeOrName, options = {})=>({ tr, state, dispatch })=>{\n        var _a;\n        const { extendEmptyMarkRange = false } = options;\n        const { selection } = tr;\n        const type = getMarkType(typeOrName, state.schema);\n        const { $from, empty, ranges } = selection;\n        if (!dispatch) {\n            return true;\n        }\n        if (empty && extendEmptyMarkRange) {\n            let { from, to } = selection;\n            const attrs = (_a = $from.marks().find((mark)=>mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n            const range = getMarkRange($from, type, attrs);\n            if (range) {\n                from = range.from;\n                to = range.to;\n            }\n            tr.removeMark(from, to, type);\n        } else {\n            ranges.forEach((range)=>{\n                tr.removeMark(range.$from.pos, range.$to.pos, type);\n            });\n        }\n        tr.removeStoredMark(type);\n        return true;\n    };\nconst updateAttributes = (typeOrName, attributes = {})=>({ tr, state, dispatch })=>{\n        let nodeType = null;\n        let markType = null;\n        const schemaType = getSchemaTypeNameByName(typeof typeOrName === \"string\" ? typeOrName : typeOrName.name, state.schema);\n        if (!schemaType) {\n            return false;\n        }\n        if (schemaType === \"node\") {\n            nodeType = getNodeType(typeOrName, state.schema);\n        }\n        if (schemaType === \"mark\") {\n            markType = getMarkType(typeOrName, state.schema);\n        }\n        if (dispatch) {\n            tr.selection.ranges.forEach((range)=>{\n                const from = range.$from.pos;\n                const to = range.$to.pos;\n                let lastPos;\n                let lastNode;\n                let trimmedFrom;\n                let trimmedTo;\n                if (tr.selection.empty) {\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        if (nodeType && nodeType === node.type) {\n                            trimmedFrom = Math.max(pos, from);\n                            trimmedTo = Math.min(pos + node.nodeSize, to);\n                            lastPos = pos;\n                            lastNode = node;\n                        }\n                    });\n                } else {\n                    state.doc.nodesBetween(from, to, (node, pos)=>{\n                        if (pos < from && nodeType && nodeType === node.type) {\n                            trimmedFrom = Math.max(pos, from);\n                            trimmedTo = Math.min(pos + node.nodeSize, to);\n                            lastPos = pos;\n                            lastNode = node;\n                        }\n                        if (pos >= from && pos <= to) {\n                            if (nodeType && nodeType === node.type) {\n                                tr.setNodeMarkup(pos, undefined, {\n                                    ...node.attrs,\n                                    ...attributes\n                                });\n                            }\n                            if (markType && node.marks.length) {\n                                node.marks.forEach((mark)=>{\n                                    if (markType === mark.type) {\n                                        const trimmedFrom2 = Math.max(pos, from);\n                                        const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                                        tr.addMark(trimmedFrom2, trimmedTo2, markType.create({\n                                            ...mark.attrs,\n                                            ...attributes\n                                        }));\n                                    }\n                                });\n                            }\n                        }\n                    });\n                }\n                if (lastNode) {\n                    if (lastPos !== undefined) {\n                        tr.setNodeMarkup(lastPos, undefined, {\n                            ...lastNode.attrs,\n                            ...attributes\n                        });\n                    }\n                    if (markType && lastNode.marks.length) {\n                        lastNode.marks.forEach((mark)=>{\n                            if (markType === mark.type) {\n                                tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                                    ...mark.attrs,\n                                    ...attributes\n                                }));\n                            }\n                        });\n                    }\n                }\n            });\n        }\n        return true;\n    };\nconst wrapIn = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);\n    };\nconst wrapInList = (typeOrName, attributes = {})=>({ state, dispatch })=>{\n        const type = getNodeType(typeOrName, state.schema);\n        return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);\n    };\nvar commands = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    blur: blur,\n    clearContent: clearContent,\n    clearNodes: clearNodes,\n    command: command,\n    createParagraphNear: createParagraphNear,\n    cut: cut,\n    deleteCurrentNode: deleteCurrentNode,\n    deleteNode: deleteNode,\n    deleteRange: deleteRange,\n    deleteSelection: deleteSelection,\n    enter: enter,\n    exitCode: exitCode,\n    extendMarkRange: extendMarkRange,\n    first: first,\n    focus: focus,\n    forEach: forEach,\n    insertContent: insertContent,\n    insertContentAt: insertContentAt,\n    joinBackward: joinBackward,\n    joinDown: joinDown,\n    joinForward: joinForward,\n    joinItemBackward: joinItemBackward,\n    joinItemForward: joinItemForward,\n    joinTextblockBackward: joinTextblockBackward,\n    joinTextblockForward: joinTextblockForward,\n    joinUp: joinUp,\n    keyboardShortcut: keyboardShortcut,\n    lift: lift,\n    liftEmptyBlock: liftEmptyBlock,\n    liftListItem: liftListItem,\n    newlineInCode: newlineInCode,\n    resetAttributes: resetAttributes,\n    scrollIntoView: scrollIntoView,\n    selectAll: selectAll,\n    selectNodeBackward: selectNodeBackward,\n    selectNodeForward: selectNodeForward,\n    selectParentNode: selectParentNode,\n    selectTextblockEnd: selectTextblockEnd,\n    selectTextblockStart: selectTextblockStart,\n    setContent: setContent,\n    setMark: setMark,\n    setMeta: setMeta,\n    setNode: setNode,\n    setNodeSelection: setNodeSelection,\n    setTextSelection: setTextSelection,\n    sinkListItem: sinkListItem,\n    splitBlock: splitBlock,\n    splitListItem: splitListItem,\n    toggleList: toggleList,\n    toggleMark: toggleMark,\n    toggleNode: toggleNode,\n    toggleWrap: toggleWrap,\n    undoInputRule: undoInputRule,\n    unsetAllMarks: unsetAllMarks,\n    unsetMark: unsetMark,\n    updateAttributes: updateAttributes,\n    wrapIn: wrapIn,\n    wrapInList: wrapInList\n});\nconst Commands = Extension.create({\n    name: \"commands\",\n    addCommands () {\n        return {\n            ...commands\n        };\n    }\n});\nconst Drop = Extension.create({\n    name: \"drop\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tiptapDrop\"),\n                props: {\n                    handleDrop: (_, e, slice, moved)=>{\n                        this.editor.emit(\"drop\", {\n                            editor: this.editor,\n                            event: e,\n                            slice,\n                            moved\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\nconst Editable = Extension.create({\n    name: \"editable\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"editable\"),\n                props: {\n                    editable: ()=>this.editor.options.editable\n                }\n            })\n        ];\n    }\n});\nconst focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"focusEvents\");\nconst FocusEvents = Extension.create({\n    name: \"focusEvents\",\n    addProseMirrorPlugins () {\n        const { editor } = this;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: focusEventsPluginKey,\n                props: {\n                    handleDOMEvents: {\n                        focus: (view, event)=>{\n                            editor.isFocused = true;\n                            const transaction = editor.state.tr.setMeta(\"focus\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                        blur: (view, event)=>{\n                            editor.isFocused = false;\n                            const transaction = editor.state.tr.setMeta(\"blur\", {\n                                event\n                            }).setMeta(\"addToHistory\", false);\n                            view.dispatch(transaction);\n                            return false;\n                        }\n                    }\n                }\n            })\n        ];\n    }\n});\nconst Keymap = Extension.create({\n    name: \"keymap\",\n    addKeyboardShortcuts () {\n        const handleBackspace = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.undoInputRule(),\n                    // maybe convert first text block node to default node\n                    ()=>commands.command(({ tr })=>{\n                            const { selection, doc } = tr;\n                            const { empty, $anchor } = selection;\n                            const { pos, parent } = $anchor;\n                            const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n                            const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n                            const parentPos = $anchor.pos - $anchor.parentOffset;\n                            const isAtStart = parentIsIsolating && $parentPos.parent.childCount === 1 ? parentPos === $anchor.pos : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;\n                            if (!empty || !parent.type.isTextblock || parent.textContent.length || !isAtStart || isAtStart && $anchor.parent.type.name === \"paragraph\" // prevent clearNodes when no nodes to clear, otherwise history stack is appended\n                            ) {\n                                return false;\n                            }\n                            return commands.clearNodes();\n                        }),\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.joinBackward(),\n                    ()=>commands.selectNodeBackward()\n                ]);\n        const handleDelete = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.deleteSelection(),\n                    ()=>commands.deleteCurrentNode(),\n                    ()=>commands.joinForward(),\n                    ()=>commands.selectNodeForward()\n                ]);\n        const handleEnter = ()=>this.editor.commands.first(({ commands })=>[\n                    ()=>commands.newlineInCode(),\n                    ()=>commands.createParagraphNear(),\n                    ()=>commands.liftEmptyBlock(),\n                    ()=>commands.splitBlock()\n                ]);\n        const baseKeymap = {\n            Enter: handleEnter,\n            \"Mod-Enter\": ()=>this.editor.commands.exitCode(),\n            Backspace: handleBackspace,\n            \"Mod-Backspace\": handleBackspace,\n            \"Shift-Backspace\": handleBackspace,\n            Delete: handleDelete,\n            \"Mod-Delete\": handleDelete,\n            \"Mod-a\": ()=>this.editor.commands.selectAll()\n        };\n        const pcKeymap = {\n            ...baseKeymap\n        };\n        const macKeymap = {\n            ...baseKeymap,\n            \"Ctrl-h\": handleBackspace,\n            \"Alt-Backspace\": handleBackspace,\n            \"Ctrl-d\": handleDelete,\n            \"Ctrl-Alt-Backspace\": handleDelete,\n            \"Alt-Delete\": handleDelete,\n            \"Alt-d\": handleDelete,\n            \"Ctrl-a\": ()=>this.editor.commands.selectTextblockStart(),\n            \"Ctrl-e\": ()=>this.editor.commands.selectTextblockEnd()\n        };\n        if (isiOS() || isMacOS()) {\n            return macKeymap;\n        }\n        return pcKeymap;\n    },\n    addProseMirrorPlugins () {\n        return [\n            // With this plugin we check if the whole document was selected and deleted.\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n            // to a paragraph if necessary.\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n            // with many other commands.\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"clearDocument\"),\n                appendTransaction: (transactions, oldState, newState)=>{\n                    if (transactions.some((tr)=>tr.getMeta(\"composition\"))) {\n                        return;\n                    }\n                    const docChanges = transactions.some((transaction)=>transaction.docChanged) && !oldState.doc.eq(newState.doc);\n                    const ignoreTr = transactions.some((transaction)=>transaction.getMeta(\"preventClearDocument\"));\n                    if (!docChanges || ignoreTr) {\n                        return;\n                    }\n                    const { empty, from, to } = oldState.selection;\n                    const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;\n                    const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;\n                    const allWasSelected = from === allFrom && to === allEnd;\n                    if (empty || !allWasSelected) {\n                        return;\n                    }\n                    const isEmpty = isNodeEmpty(newState.doc);\n                    if (!isEmpty) {\n                        return;\n                    }\n                    const tr = newState.tr;\n                    const state = createChainableState({\n                        state: newState,\n                        transaction: tr\n                    });\n                    const { commands } = new CommandManager({\n                        editor: this.editor,\n                        state\n                    });\n                    commands.clearNodes();\n                    if (!tr.steps.length) {\n                        return;\n                    }\n                    return tr;\n                }\n            })\n        ];\n    }\n});\nconst Paste = Extension.create({\n    name: \"paste\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tiptapPaste\"),\n                props: {\n                    handlePaste: (_view, e, slice)=>{\n                        this.editor.emit(\"paste\", {\n                            editor: this.editor,\n                            event: e,\n                            slice\n                        });\n                    }\n                }\n            })\n        ];\n    }\n});\nconst Tabindex = Extension.create({\n    name: \"tabindex\",\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"tabindex\"),\n                props: {\n                    attributes: ()=>this.editor.isEditable ? {\n                            tabindex: \"0\"\n                        } : {}\n                }\n            })\n        ];\n    }\n});\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    ClipboardTextSerializer: ClipboardTextSerializer,\n    Commands: Commands,\n    Drop: Drop,\n    Editable: Editable,\n    FocusEvents: FocusEvents,\n    Keymap: Keymap,\n    Paste: Paste,\n    Tabindex: Tabindex,\n    focusEventsPluginKey: focusEventsPluginKey\n});\nclass NodePos {\n    get name() {\n        return this.node.type.name;\n    }\n    constructor(pos, editor, isBlock = false, node = null){\n        this.currentNode = null;\n        this.actualDepth = null;\n        this.isBlock = isBlock;\n        this.resolvedPos = pos;\n        this.editor = editor;\n        this.currentNode = node;\n    }\n    get node() {\n        return this.currentNode || this.resolvedPos.node();\n    }\n    get element() {\n        return this.editor.view.domAtPos(this.pos).node;\n    }\n    get depth() {\n        var _a;\n        return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;\n    }\n    get pos() {\n        return this.resolvedPos.pos;\n    }\n    get content() {\n        return this.node.content;\n    }\n    set content(content) {\n        let from = this.from;\n        let to = this.to;\n        if (this.isBlock) {\n            if (this.content.size === 0) {\n                console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n                return;\n            }\n            from = this.from + 1;\n            to = this.to - 1;\n        }\n        this.editor.commands.insertContentAt({\n            from,\n            to\n        }, content);\n    }\n    get attributes() {\n        return this.node.attrs;\n    }\n    get textContent() {\n        return this.node.textContent;\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get from() {\n        if (this.isBlock) {\n            return this.pos;\n        }\n        return this.resolvedPos.start(this.resolvedPos.depth);\n    }\n    get range() {\n        return {\n            from: this.from,\n            to: this.to\n        };\n    }\n    get to() {\n        if (this.isBlock) {\n            return this.pos + this.size;\n        }\n        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n    }\n    get parent() {\n        if (this.depth === 0) {\n            return null;\n        }\n        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n        const $pos = this.resolvedPos.doc.resolve(parentPos);\n        return new NodePos($pos, this.editor);\n    }\n    get before() {\n        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.from - 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get after() {\n        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.to + 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get children() {\n        const children = [];\n        this.node.content.forEach((node, offset)=>{\n            const isBlock = node.isBlock && !node.isTextblock;\n            const isNonTextAtom = node.isAtom && !node.isText;\n            const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n            // Check if targetPos is within valid document range\n            if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {\n                return;\n            }\n            const $pos = this.resolvedPos.doc.resolve(targetPos);\n            if (!isBlock && $pos.depth <= this.depth) {\n                return;\n            }\n            const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n            if (isBlock) {\n                childNodePos.actualDepth = this.depth + 1;\n            }\n            children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n        });\n        return children;\n    }\n    get firstChild() {\n        return this.children[0] || null;\n    }\n    get lastChild() {\n        const children = this.children;\n        return children[children.length - 1] || null;\n    }\n    closest(selector, attributes = {}) {\n        let node = null;\n        let currentNode = this.parent;\n        while(currentNode && !node){\n            if (currentNode.node.type.name === selector) {\n                if (Object.keys(attributes).length > 0) {\n                    const nodeAttributes = currentNode.node.attrs;\n                    const attrKeys = Object.keys(attributes);\n                    for(let index = 0; index < attrKeys.length; index += 1){\n                        const key = attrKeys[index];\n                        if (nodeAttributes[key] !== attributes[key]) {\n                            break;\n                        }\n                    }\n                } else {\n                    node = currentNode;\n                }\n            }\n            currentNode = currentNode.parent;\n        }\n        return node;\n    }\n    querySelector(selector, attributes = {}) {\n        return this.querySelectorAll(selector, attributes, true)[0] || null;\n    }\n    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n        let nodes = [];\n        if (!this.children || this.children.length === 0) {\n            return nodes;\n        }\n        const attrKeys = Object.keys(attributes);\n        /**\n         * Finds all children recursively that match the selector and attributes\n         * If firstItemOnly is true, it will return the first item found\n         */ this.children.forEach((childPos)=>{\n            // If we already found a node and we only want the first item, we dont need to keep going\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            if (childPos.node.type.name === selector) {\n                const doesAllAttributesMatch = attrKeys.every((key)=>attributes[key] === childPos.node.attrs[key]);\n                if (doesAllAttributesMatch) {\n                    nodes.push(childPos);\n                }\n            }\n            // If we already found a node and we only want the first item, we can stop here and skip the recursion\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n        });\n        return nodes;\n    }\n    setAttribute(attributes) {\n        const { tr } = this.editor.state;\n        tr.setNodeMarkup(this.from, undefined, {\n            ...this.node.attrs,\n            ...attributes\n        });\n        this.editor.view.dispatch(tr);\n    }\n}\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\nfunction createStyleTag(style, nonce, suffix) {\n    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : \"\"}]`);\n    if (tiptapStyleTag !== null) {\n        return tiptapStyleTag;\n    }\n    const styleNode = document.createElement(\"style\");\n    if (nonce) {\n        styleNode.setAttribute(\"nonce\", nonce);\n    }\n    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : \"\"}`, \"\");\n    styleNode.innerHTML = style;\n    document.getElementsByTagName(\"head\")[0].appendChild(styleNode);\n    return styleNode;\n}\nclass Editor extends EventEmitter {\n    constructor(options = {}){\n        super();\n        this.isFocused = false;\n        /**\n         * The editor is considered initialized after the `create` event has been emitted.\n         */ this.isInitialized = false;\n        this.extensionStorage = {};\n        this.options = {\n            element: document.createElement(\"div\"),\n            content: \"\",\n            injectCSS: true,\n            injectNonce: undefined,\n            extensions: [],\n            autofocus: false,\n            editable: true,\n            editorProps: {},\n            parseOptions: {},\n            coreExtensionOptions: {},\n            enableInputRules: true,\n            enablePasteRules: true,\n            enableCoreExtensions: true,\n            enableContentCheck: false,\n            emitContentError: false,\n            onBeforeCreate: ()=>null,\n            onCreate: ()=>null,\n            onUpdate: ()=>null,\n            onSelectionUpdate: ()=>null,\n            onTransaction: ()=>null,\n            onFocus: ()=>null,\n            onBlur: ()=>null,\n            onDestroy: ()=>null,\n            onContentError: ({ error })=>{\n                throw error;\n            },\n            onPaste: ()=>null,\n            onDrop: ()=>null\n        };\n        this.isCapturingTransaction = false;\n        this.capturedTransaction = null;\n        this.setOptions(options);\n        this.createExtensionManager();\n        this.createCommandManager();\n        this.createSchema();\n        this.on(\"beforeCreate\", this.options.onBeforeCreate);\n        this.emit(\"beforeCreate\", {\n            editor: this\n        });\n        this.on(\"contentError\", this.options.onContentError);\n        this.createView();\n        this.injectCSS();\n        this.on(\"create\", this.options.onCreate);\n        this.on(\"update\", this.options.onUpdate);\n        this.on(\"selectionUpdate\", this.options.onSelectionUpdate);\n        this.on(\"transaction\", this.options.onTransaction);\n        this.on(\"focus\", this.options.onFocus);\n        this.on(\"blur\", this.options.onBlur);\n        this.on(\"destroy\", this.options.onDestroy);\n        this.on(\"drop\", ({ event, slice, moved })=>this.options.onDrop(event, slice, moved));\n        this.on(\"paste\", ({ event, slice })=>this.options.onPaste(event, slice));\n        window.setTimeout(()=>{\n            if (this.isDestroyed) {\n                return;\n            }\n            this.commands.focus(this.options.autofocus);\n            this.emit(\"create\", {\n                editor: this\n            });\n            this.isInitialized = true;\n        }, 0);\n    }\n    /**\n     * Returns the editor storage.\n     */ get storage() {\n        return this.extensionStorage;\n    }\n    /**\n     * An object of all registered commands.\n     */ get commands() {\n        return this.commandManager.commands;\n    }\n    /**\n     * Create a command chain to call multiple commands at once.\n     */ chain() {\n        return this.commandManager.chain();\n    }\n    /**\n     * Check if a command or a command chain can be executed. Without executing it.\n     */ can() {\n        return this.commandManager.can();\n    }\n    /**\n     * Inject CSS styles.\n     */ injectCSS() {\n        if (this.options.injectCSS && document) {\n            this.css = createStyleTag(style, this.options.injectNonce);\n        }\n    }\n    /**\n     * Update editor options.\n     *\n     * @param options A list of options\n     */ setOptions(options = {}) {\n        this.options = {\n            ...this.options,\n            ...options\n        };\n        if (!this.view || !this.state || this.isDestroyed) {\n            return;\n        }\n        if (this.options.editorProps) {\n            this.view.setProps(this.options.editorProps);\n        }\n        this.view.updateState(this.state);\n    }\n    /**\n     * Update editable state of the editor.\n     */ setEditable(editable, emitUpdate = true) {\n        this.setOptions({\n            editable\n        });\n        if (emitUpdate) {\n            this.emit(\"update\", {\n                editor: this,\n                transaction: this.state.tr\n            });\n        }\n    }\n    /**\n     * Returns whether the editor is editable.\n     */ get isEditable() {\n        // since plugins are applied after creating the view\n        // `editable` is always `true` for one tick.\n        // that’s why we also have to check for `options.editable`\n        return this.options.editable && this.view && this.view.editable;\n    }\n    /**\n     * Returns the editor state.\n     */ get state() {\n        return this.view.state;\n    }\n    /**\n     * Register a ProseMirror plugin.\n     *\n     * @param plugin A ProseMirror plugin\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\n     * @returns The new editor state\n     */ registerPlugin(plugin, handlePlugins) {\n        const plugins = isFunction(handlePlugins) ? handlePlugins(plugin, [\n            ...this.state.plugins\n        ]) : [\n            ...this.state.plugins,\n            plugin\n        ];\n        const state = this.state.reconfigure({\n            plugins\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Unregister a ProseMirror plugin.\n     *\n     * @param nameOrPluginKeyToRemove The plugins name\n     * @returns The new editor state or undefined if the editor is destroyed\n     */ unregisterPlugin(nameOrPluginKeyToRemove) {\n        if (this.isDestroyed) {\n            return undefined;\n        }\n        const prevPlugins = this.state.plugins;\n        let plugins = prevPlugins;\n        [].concat(nameOrPluginKeyToRemove).forEach((nameOrPluginKey)=>{\n            // @ts-ignore\n            const name = typeof nameOrPluginKey === \"string\" ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n            // @ts-ignore\n            plugins = plugins.filter((plugin)=>!plugin.key.startsWith(name));\n        });\n        if (prevPlugins.length === plugins.length) {\n            // No plugin was removed, so we don’t need to update the state\n            return undefined;\n        }\n        const state = this.state.reconfigure({\n            plugins\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Creates an extension manager.\n     */ createExtensionManager() {\n        var _a, _b;\n        const coreExtensions = this.options.enableCoreExtensions ? [\n            Editable,\n            ClipboardTextSerializer.configure({\n                blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator\n            }),\n            Commands,\n            FocusEvents,\n            Keymap,\n            Tabindex,\n            Drop,\n            Paste\n        ].filter((ext)=>{\n            if (typeof this.options.enableCoreExtensions === \"object\") {\n                return this.options.enableCoreExtensions[ext.name] !== false;\n            }\n            return true;\n        }) : [];\n        const allExtensions = [\n            ...coreExtensions,\n            ...this.options.extensions\n        ].filter((extension)=>{\n            return [\n                \"extension\",\n                \"node\",\n                \"mark\"\n            ].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n        });\n        this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\n     * Creates an command manager.\n     */ createCommandManager() {\n        this.commandManager = new CommandManager({\n            editor: this\n        });\n    }\n    /**\n     * Creates a ProseMirror schema.\n     */ createSchema() {\n        this.schema = this.extensionManager.schema;\n    }\n    /**\n     * Creates a ProseMirror view.\n     */ createView() {\n        var _a;\n        let doc;\n        try {\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n                errorOnInvalidContent: this.options.enableContentCheck\n            });\n        } catch (e) {\n            if (!(e instanceof Error) || ![\n                \"[tiptap error]: Invalid JSON content\",\n                \"[tiptap error]: Invalid HTML content\"\n            ].includes(e.message)) {\n                // Not the content error we were expecting\n                throw e;\n            }\n            this.emit(\"contentError\", {\n                editor: this,\n                error: e,\n                disableCollaboration: ()=>{\n                    if (this.storage.collaboration) {\n                        this.storage.collaboration.isDisabled = true;\n                    }\n                    // To avoid syncing back invalid content, reinitialize the extensions without the collaboration extension\n                    this.options.extensions = this.options.extensions.filter((extension)=>extension.name !== \"collaboration\");\n                    // Restart the initialization process by recreating the extension manager with the new set of extensions\n                    this.createExtensionManager();\n                }\n            });\n            // Content is invalid, but attempt to create it anyway, stripping out the invalid parts\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, {\n                errorOnInvalidContent: false\n            });\n        }\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\n        this.view = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(this.options.element, {\n            ...this.options.editorProps,\n            attributes: {\n                // add `role=\"textbox\"` to the editor element\n                role: \"textbox\",\n                ...(_a = this.options.editorProps) === null || _a === void 0 ? void 0 : _a.attributes\n            },\n            dispatchTransaction: this.dispatchTransaction.bind(this),\n            state: _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                doc,\n                selection: selection || undefined\n            })\n        });\n        // `editor.view` is not yet available at this time.\n        // Therefore we will add all plugins and node views directly afterwards.\n        const newState = this.state.reconfigure({\n            plugins: this.extensionManager.plugins\n        });\n        this.view.updateState(newState);\n        this.createNodeViews();\n        this.prependClass();\n        // Let’s store the editor instance in the DOM element.\n        // So we’ll have access to it for tests.\n        // @ts-ignore\n        const dom = this.view.dom;\n        dom.editor = this;\n    }\n    /**\n     * Creates all node views.\n     */ createNodeViews() {\n        if (this.view.isDestroyed) {\n            return;\n        }\n        this.view.setProps({\n            nodeViews: this.extensionManager.nodeViews\n        });\n    }\n    /**\n     * Prepend class name to element.\n     */ prependClass() {\n        this.view.dom.className = `tiptap ${this.view.dom.className}`;\n    }\n    captureTransaction(fn) {\n        this.isCapturingTransaction = true;\n        fn();\n        this.isCapturingTransaction = false;\n        const tr = this.capturedTransaction;\n        this.capturedTransaction = null;\n        return tr;\n    }\n    /**\n     * The callback over which to send transactions (state updates) produced by the view.\n     *\n     * @param transaction An editor state transaction\n     */ dispatchTransaction(transaction) {\n        // if the editor / the view of the editor was destroyed\n        // the transaction should not be dispatched as there is no view anymore.\n        if (this.view.isDestroyed) {\n            return;\n        }\n        if (this.isCapturingTransaction) {\n            if (!this.capturedTransaction) {\n                this.capturedTransaction = transaction;\n                return;\n            }\n            transaction.steps.forEach((step)=>{\n                var _a;\n                return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step);\n            });\n            return;\n        }\n        const state = this.state.apply(transaction);\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\n        this.emit(\"beforeTransaction\", {\n            editor: this,\n            transaction,\n            nextState: state\n        });\n        this.view.updateState(state);\n        this.emit(\"transaction\", {\n            editor: this,\n            transaction\n        });\n        if (selectionHasChanged) {\n            this.emit(\"selectionUpdate\", {\n                editor: this,\n                transaction\n            });\n        }\n        const focus = transaction.getMeta(\"focus\");\n        const blur = transaction.getMeta(\"blur\");\n        if (focus) {\n            this.emit(\"focus\", {\n                editor: this,\n                event: focus.event,\n                transaction\n            });\n        }\n        if (blur) {\n            this.emit(\"blur\", {\n                editor: this,\n                event: blur.event,\n                transaction\n            });\n        }\n        if (!transaction.docChanged || transaction.getMeta(\"preventUpdate\")) {\n            return;\n        }\n        this.emit(\"update\", {\n            editor: this,\n            transaction\n        });\n    }\n    /**\n     * Get attributes of the currently selected node or mark.\n     */ getAttributes(nameOrType) {\n        return getAttributes(this.state, nameOrType);\n    }\n    isActive(nameOrAttributes, attributesOrUndefined) {\n        const name = typeof nameOrAttributes === \"string\" ? nameOrAttributes : null;\n        const attributes = typeof nameOrAttributes === \"string\" ? attributesOrUndefined : nameOrAttributes;\n        return isActive(this.state, name, attributes);\n    }\n    /**\n     * Get the document as JSON.\n     */ getJSON() {\n        return this.state.doc.toJSON();\n    }\n    /**\n     * Get the document as HTML.\n     */ getHTML() {\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\n    }\n    /**\n     * Get the document as text.\n     */ getText(options) {\n        const { blockSeparator = \"\\n\\n\", textSerializers = {} } = options || {};\n        return getText(this.state.doc, {\n            blockSeparator,\n            textSerializers: {\n                ...getTextSerializersFromSchema(this.schema),\n                ...textSerializers\n            }\n        });\n    }\n    /**\n     * Check if there is no content.\n     */ get isEmpty() {\n        return isNodeEmpty(this.state.doc);\n    }\n    /**\n     * Get the number of characters for the current document.\n     *\n     * @deprecated\n     */ getCharacterCount() {\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n        return this.state.doc.content.size - 2;\n    }\n    /**\n     * Destroy the editor.\n     */ destroy() {\n        this.emit(\"destroy\");\n        if (this.view) {\n            // Cleanup our reference to prevent circular references which caused memory leaks\n            // @ts-ignore\n            const dom = this.view.dom;\n            if (dom && dom.editor) {\n                delete dom.editor;\n            }\n            this.view.destroy();\n        }\n        this.removeAllListeners();\n    }\n    /**\n     * Check if the editor is already destroyed.\n     */ get isDestroyed() {\n        var _a;\n        // @ts-ignore\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n    }\n    $node(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;\n    }\n    $nodes(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n    }\n    $pos(pos) {\n        const $pos = this.state.doc.resolve(pos);\n        return new NodePos($pos, this);\n    }\n    get $doc() {\n        return this.$pos(0);\n    }\n}\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function markInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                const markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        }\n    });\n}\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function nodeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const { tr } = state;\n            const start = range.from;\n            let end = range.to;\n            const newNode = config.type.create(attributes);\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                let matchStart = start + offset;\n                if (matchStart > end) {\n                    matchStart = end;\n                } else {\n                    end = matchStart + match[1].length;\n                }\n                // insert last typed character\n                const lastChar = match[0][match[0].length - 1];\n                tr.insertText(lastChar, start + match[0].length - 1);\n                // insert node from input rule\n                tr.replaceWith(matchStart, end, newNode);\n            } else if (match[0]) {\n                const insertionStart = config.type.isInline ? start : start - 1;\n                tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n            }\n            tr.scrollIntoView();\n        }\n    });\n}\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function textblockTypeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            const $start = state.doc.resolve(range.from);\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n                return null;\n            }\n            state.tr.delete(range.from, range.to).setBlockType(range.from, range.from, config.type, attributes);\n        }\n    });\n}\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function textInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        }\n    });\n}\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */ function wrappingInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match, chain })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const tr = state.tr.delete(range.from, range.to);\n            const $start = tr.doc.resolve(range.from);\n            const blockRange = $start.blockRange();\n            const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.findWrapping)(blockRange, config.type, attributes);\n            if (!wrapping) {\n                return null;\n            }\n            tr.wrap(blockRange, wrapping);\n            if (config.keepMarks && config.editor) {\n                const { selection, storedMarks } = state;\n                const { splittableMarks } = config.editor.extensionManager;\n                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                if (marks) {\n                    const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                    tr.ensureMarks(filteredMarks);\n                }\n            }\n            if (config.keepAttributes) {\n                /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */ const nodeType = config.type.name === \"bulletList\" || config.type.name === \"orderedList\" ? \"listItem\" : \"taskList\";\n                chain().updateAttributes(nodeType, attributes).run();\n            }\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\n            if (before && before.type === config.type && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, range.from - 1) && (!config.joinPredicate || config.joinPredicate(match, before))) {\n                tr.join(range.from - 1);\n            }\n        }\n    });\n}\n/**\n * The Node class is used to create custom node extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */ class Node {\n    constructor(config = {}){\n        this.type = \"node\";\n        this.name = \"node\";\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {}\n        };\n        this.config = {\n            ...this.config,\n            ...config\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, \"addOptions\", {\n                name: this.name\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, \"addStorage\", {\n            name: this.name,\n            options: this.options\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Node(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: ()=>{\n                return mergeDeep(this.options, options);\n            }\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Node(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, \"addOptions\", {\n            name: extension.name\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, \"addStorage\", {\n            name: extension.name,\n            options: extension.options\n        }));\n        return extension;\n    }\n}\n/**\n * Node views are used to customize the rendered DOM structure of a node.\n * @see https://tiptap.dev/guide/node-views\n */ class NodeView {\n    constructor(component, props, options){\n        this.isDragging = false;\n        this.component = component;\n        this.editor = props.editor;\n        this.options = {\n            stopEvent: null,\n            ignoreMutation: null,\n            ...options\n        };\n        this.extension = props.extension;\n        this.node = props.node;\n        this.decorations = props.decorations;\n        this.innerDecorations = props.innerDecorations;\n        this.view = props.view;\n        this.HTMLAttributes = props.HTMLAttributes;\n        this.getPos = props.getPos;\n        this.mount();\n    }\n    mount() {\n        // eslint-disable-next-line\n        return;\n    }\n    get dom() {\n        return this.editor.view.dom;\n    }\n    get contentDOM() {\n        return null;\n    }\n    onDragStart(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const { view } = this.editor;\n        const target = event.target;\n        // get the drag handle element\n        // `closest` is not available for text nodes so we may have to use its parent\n        const dragHandle = target.nodeType === 3 ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest(\"[data-drag-handle]\") : target.closest(\"[data-drag-handle]\");\n        if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        // calculate offset for drag element if we use a different drag handle element\n        if (this.dom !== dragHandle) {\n            const domBox = this.dom.getBoundingClientRect();\n            const handleBox = dragHandle.getBoundingClientRect();\n            // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n            const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n            const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n            x = handleBox.x - domBox.x + offsetX;\n            y = handleBox.y - domBox.y + offsetY;\n        }\n        const clonedNode = this.dom.cloneNode(true);\n        (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(clonedNode, x, y);\n        const pos = this.getPos();\n        if (typeof pos !== \"number\") {\n            return;\n        }\n        // we need to tell ProseMirror that we want to move the whole node\n        // so we create a NodeSelection\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, pos);\n        const transaction = view.state.tr.setSelection(selection);\n        view.dispatch(transaction);\n    }\n    stopEvent(event) {\n        var _a;\n        if (!this.dom) {\n            return false;\n        }\n        if (typeof this.options.stopEvent === \"function\") {\n            return this.options.stopEvent({\n                event\n            });\n        }\n        const target = event.target;\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n        // any event from child nodes should be handled by ProseMirror\n        if (!isInElement) {\n            return false;\n        }\n        const isDragEvent = event.type.startsWith(\"drag\");\n        const isDropEvent = event.type === \"drop\";\n        const isInput = [\n            \"INPUT\",\n            \"BUTTON\",\n            \"SELECT\",\n            \"TEXTAREA\"\n        ].includes(target.tagName) || target.isContentEditable;\n        // any input event within node views should be ignored by ProseMirror\n        if (isInput && !isDropEvent && !isDragEvent) {\n            return true;\n        }\n        const { isEditable } = this.editor;\n        const { isDragging } = this;\n        const isDraggable = !!this.node.type.spec.draggable;\n        const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);\n        const isCopyEvent = event.type === \"copy\";\n        const isPasteEvent = event.type === \"paste\";\n        const isCutEvent = event.type === \"cut\";\n        const isClickEvent = event.type === \"mousedown\";\n        // ProseMirror tries to drag selectable nodes\n        // even if `draggable` is set to `false`\n        // this fix prevents that\n        if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n            event.preventDefault();\n        }\n        if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n            event.preventDefault();\n            return false;\n        }\n        // we have to store that dragging started\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\n            const dragHandle = target.closest(\"[data-drag-handle]\");\n            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n            if (isValidDragHandle) {\n                this.isDragging = true;\n                document.addEventListener(\"dragend\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"drop\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n                document.addEventListener(\"mouseup\", ()=>{\n                    this.isDragging = false;\n                }, {\n                    once: true\n                });\n            }\n        }\n        // these events are handled by prosemirror\n        if (isDragging || isDropEvent || isCopyEvent || isPasteEvent || isCutEvent || isClickEvent && isSelectable) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n     * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n     * @return `true` if it can safely be ignored.\n     */ ignoreMutation(mutation) {\n        if (!this.dom || !this.contentDOM) {\n            return true;\n        }\n        if (typeof this.options.ignoreMutation === \"function\") {\n            return this.options.ignoreMutation({\n                mutation\n            });\n        }\n        // a leaf/atom node is like a black box for ProseMirror\n        // and should be fully handled by the node view\n        if (this.node.isLeaf || this.node.isAtom) {\n            return true;\n        }\n        // ProseMirror should handle any selections\n        if (mutation.type === \"selection\") {\n            return false;\n        }\n        // try to prevent a bug on iOS and Android that will break node views on enter\n        // this is because ProseMirror can’t preventDispatch on enter\n        // this will lead to a re-render of the node view on enter\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\n        // see: https://github.com/ueberdosis/tiptap/issues/2534\n        if (this.dom.contains(mutation.target) && mutation.type === \"childList\" && (isiOS() || isAndroid()) && this.editor.isFocused) {\n            const changedNodes = [\n                ...Array.from(mutation.addedNodes),\n                ...Array.from(mutation.removedNodes)\n            ];\n            // we’ll check if every changed node is contentEditable\n            // to make sure it’s probably mutated by ProseMirror\n            if (changedNodes.every((node)=>node.isContentEditable)) {\n                return false;\n            }\n        }\n        // we will allow mutation contentDOM with attributes\n        // so we can for example adding classes within our node view\n        if (this.contentDOM === mutation.target && mutation.type === \"attributes\") {\n            return true;\n        }\n        // ProseMirror should handle any changes within contentDOM\n        if (this.contentDOM.contains(mutation.target)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Update the attributes of the prosemirror node.\n     */ updateAttributes(attributes) {\n        this.editor.commands.command(({ tr })=>{\n            const pos = this.getPos();\n            if (typeof pos !== \"number\") {\n                return false;\n            }\n            tr.setNodeMarkup(pos, undefined, {\n                ...this.node.attrs,\n                ...attributes\n            });\n            return true;\n        });\n    }\n    /**\n     * Delete the node.\n     */ deleteNode() {\n        const from = this.getPos();\n        if (typeof from !== \"number\") {\n            return;\n        }\n        const to = from + this.node.nodeSize;\n        this.editor.commands.deleteRange({\n            from,\n            to\n        });\n    }\n}\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ function markPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match, pasteEvent })=>{\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            let markEnd = range.to;\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc).filter((item)=>{\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find((type)=>type === config.type && type !== item.mark.type);\n                }).filter((item)=>item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        }\n    });\n}\nfunction canInsertNode(state, nodeType) {\n    const { selection } = state;\n    const { $from } = selection;\n    // Special handling for NodeSelection\n    if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) {\n        const index = $from.index();\n        const parent = $from.parent;\n        // Can we replace the selected node with the horizontal rule?\n        return parent.canReplaceWith(index, index + 1, nodeType);\n    }\n    // Default: check if we can insert at the current position\n    let depth = $from.depth;\n    while(depth >= 0){\n        const index = $from.index(depth);\n        const parent = $from.node(depth);\n        const match = parent.contentMatchAt(index);\n        if (match.matchType(nodeType)) {\n            return true;\n        }\n        depth -= 1;\n    }\n    return false;\n}\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n}\nfunction isString(value) {\n    return typeof value === \"string\";\n}\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ function nodePasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler ({ match, chain, range, pasteEvent }) {\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            const content = callOrReturn(config.getContent, undefined, attributes);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const node = {\n                type: config.type.name,\n                attrs: attributes\n            };\n            if (content) {\n                node.content = content;\n            }\n            if (match.input) {\n                chain().deleteRange(range).insertContentAt(range.from, node);\n            }\n        }\n    });\n}\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */ function textPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match })=>{\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        }\n    });\n}\nclass Tracker {\n    constructor(transaction){\n        this.transaction = transaction;\n        this.currentStep = this.transaction.steps.length;\n    }\n    map(position) {\n        let deleted = false;\n        const mappedPosition = this.transaction.steps.slice(this.currentStep).reduce((newPosition, step)=>{\n            const mapResult = step.getMap().mapResult(newPosition);\n            if (mapResult.deleted) {\n                deleted = true;\n            }\n            return mapResult.pos;\n        }, position);\n        return {\n            position: mappedPosition,\n            deleted\n        };\n    }\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5SDtBQUM1RTtBQUNGO0FBQzBEO0FBQ29DO0FBQ3NpQjtBQUMzaUI7QUFFcEk7Ozs7Q0FJQyxHQUNELFNBQVNtRSxxQkFBcUJDLE1BQU07SUFDaEMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLFdBQVcsRUFBRSxHQUFHRjtJQUMvQixJQUFJLEVBQUVHLFNBQVMsRUFBRSxHQUFHRDtJQUNwQixJQUFJLEVBQUVFLEdBQUcsRUFBRSxHQUFHRjtJQUNkLElBQUksRUFBRUcsV0FBVyxFQUFFLEdBQUdIO0lBQ3RCLE9BQU87UUFDSCxHQUFHRCxLQUFLO1FBQ1JLLE9BQU9MLE1BQU1LLEtBQUssQ0FBQ0MsSUFBSSxDQUFDTjtRQUN4Qk8sa0JBQWtCUCxNQUFNTyxnQkFBZ0IsQ0FBQ0QsSUFBSSxDQUFDTjtRQUM5Q1EsU0FBU1IsTUFBTVEsT0FBTztRQUN0QkMsUUFBUVQsTUFBTVMsTUFBTTtRQUNwQkMsYUFBYVYsTUFBTVUsV0FBVyxDQUFDSixJQUFJLENBQUNOO1FBQ3BDVyxRQUFRWCxNQUFNVyxNQUFNLENBQUNMLElBQUksQ0FBQ047UUFDMUIsSUFBSUksZUFBYztZQUNkLE9BQU9BO1FBQ1g7UUFDQSxJQUFJRixhQUFZO1lBQ1osT0FBT0E7UUFDWDtRQUNBLElBQUlDLE9BQU07WUFDTixPQUFPQTtRQUNYO1FBQ0EsSUFBSVMsTUFBSztZQUNMVixZQUFZRCxZQUFZQyxTQUFTO1lBQ2pDQyxNQUFNRixZQUFZRSxHQUFHO1lBQ3JCQyxjQUFjSCxZQUFZRyxXQUFXO1lBQ3JDLE9BQU9IO1FBQ1g7SUFDSjtBQUNKO0FBRUEsTUFBTVk7SUFDRkMsWUFBWUMsS0FBSyxDQUFFO1FBQ2Ys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QUFLLENBQUNrUCxTQUFTMmIsUUFBUTNiLFVBQVU1QjtvQkFDbkRqSSxRQUFRdkI7Z0JBQ1o7WUFDSjtZQUNBclIsTUFBTVksRUFBRSxDQUFDK1EsVUFBVSxDQUFDa0osUUFBUWpJLE9BQU92QjtRQUN2QztJQUNKO0FBQ0o7QUFFQSxNQUFNdXFCO0lBQ0Y5NkIsWUFBWWIsV0FBVyxDQUFFO1FBQ3JCLElBQUksQ0FBQ0EsV0FBVyxHQUFHQTtRQUNuQixJQUFJLENBQUM0N0IsV0FBVyxHQUFHLElBQUksQ0FBQzU3QixXQUFXLENBQUNnUCxLQUFLLENBQUM3RyxNQUFNO0lBQ3BEO0lBQ0F6RyxJQUFJMGIsUUFBUSxFQUFFO1FBQ1YsSUFBSXllLFVBQVU7UUFDZCxNQUFNQyxpQkFBaUIsSUFBSSxDQUFDOTdCLFdBQVcsQ0FBQ2dQLEtBQUssQ0FDeEMxQixLQUFLLENBQUMsSUFBSSxDQUFDc3VCLFdBQVcsRUFDdEIxMUIsTUFBTSxDQUFDLENBQUM2MUIsYUFBYXBiO1lBQ3RCLE1BQU1xYixZQUFZcmIsS0FBS3NiLE1BQU0sR0FBR0QsU0FBUyxDQUFDRDtZQUMxQyxJQUFJQyxVQUFVSCxPQUFPLEVBQUU7Z0JBQ25CQSxVQUFVO1lBQ2Q7WUFDQSxPQUFPRyxVQUFVbnZCLEdBQUc7UUFDeEIsR0FBR3VRO1FBQ0gsT0FBTztZQUNIQSxVQUFVMGU7WUFDVkQ7UUFDSjtJQUNKO0FBQ0o7QUFFNC9DLENBQzUvQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9pbmRleC5qcz9lNTQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5LCBUZXh0U2VsZWN0aW9uLCBTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgRWRpdG9yU3RhdGUgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IEVkaXRvclZpZXcgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnO1xuaW1wb3J0IHsga2V5bWFwIH0gZnJvbSAnQHRpcHRhcC9wbS9rZXltYXAnO1xuaW1wb3J0IHsgU2NoZW1hLCBET01TZXJpYWxpemVyLCBGcmFnbWVudCwgTm9kZSBhcyBOb2RlJDEsIERPTVBhcnNlciwgU2xpY2UgfSBmcm9tICdAdGlwdGFwL3BtL21vZGVsJztcbmltcG9ydCB7IGxpZnRUYXJnZXQsIFJlcGxhY2VTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgam9pblBvaW50LCBUcmFuc2Zvcm0sIGNhblNwbGl0LCBjYW5Kb2luLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdAdGlwdGFwL3BtL3RyYW5zZm9ybSc7XG5pbXBvcnQgeyBjcmVhdGVQYXJhZ3JhcGhOZWFyIGFzIGNyZWF0ZVBhcmFncmFwaE5lYXIkMSwgZGVsZXRlU2VsZWN0aW9uIGFzIGRlbGV0ZVNlbGVjdGlvbiQxLCBleGl0Q29kZSBhcyBleGl0Q29kZSQxLCBqb2luVXAgYXMgam9pblVwJDEsIGpvaW5Eb3duIGFzIGpvaW5Eb3duJDEsIGpvaW5CYWNrd2FyZCBhcyBqb2luQmFja3dhcmQkMSwgam9pbkZvcndhcmQgYXMgam9pbkZvcndhcmQkMSwgam9pblRleHRibG9ja0JhY2t3YXJkIGFzIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCQxLCBqb2luVGV4dGJsb2NrRm9yd2FyZCBhcyBqb2luVGV4dGJsb2NrRm9yd2FyZCQxLCBsaWZ0IGFzIGxpZnQkMSwgbGlmdEVtcHR5QmxvY2sgYXMgbGlmdEVtcHR5QmxvY2skMSwgbmV3bGluZUluQ29kZSBhcyBuZXdsaW5lSW5Db2RlJDEsIHNlbGVjdE5vZGVCYWNrd2FyZCBhcyBzZWxlY3ROb2RlQmFja3dhcmQkMSwgc2VsZWN0Tm9kZUZvcndhcmQgYXMgc2VsZWN0Tm9kZUZvcndhcmQkMSwgc2VsZWN0UGFyZW50Tm9kZSBhcyBzZWxlY3RQYXJlbnROb2RlJDEsIHNlbGVjdFRleHRibG9ja0VuZCBhcyBzZWxlY3RUZXh0YmxvY2tFbmQkMSwgc2VsZWN0VGV4dGJsb2NrU3RhcnQgYXMgc2VsZWN0VGV4dGJsb2NrU3RhcnQkMSwgc2V0QmxvY2tUeXBlLCB3cmFwSW4gYXMgd3JhcEluJDEgfSBmcm9tICdAdGlwdGFwL3BtL2NvbW1hbmRzJztcbmltcG9ydCB7IGxpZnRMaXN0SXRlbSBhcyBsaWZ0TGlzdEl0ZW0kMSwgc2lua0xpc3RJdGVtIGFzIHNpbmtMaXN0SXRlbSQxLCB3cmFwSW5MaXN0IGFzIHdyYXBJbkxpc3QkMSB9IGZyb20gJ0B0aXB0YXAvcG0vc2NoZW1hLWxpc3QnO1xuXG4vKipcbiAqIFRha2VzIGEgVHJhbnNhY3Rpb24gJiBFZGl0b3IgU3RhdGUgYW5kIHR1cm5zIGl0IGludG8gYSBjaGFpbmFibGUgc3RhdGUgb2JqZWN0XG4gKiBAcGFyYW0gY29uZmlnIFRoZSB0cmFuc2FjdGlvbiBhbmQgc3RhdGUgdG8gY3JlYXRlIHRoZSBjaGFpbmFibGUgc3RhdGUgZnJvbVxuICogQHJldHVybnMgQSBjaGFpbmFibGUgRWRpdG9yIHN0YXRlIG9iamVjdFxuICovXG5mdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVTdGF0ZShjb25maWcpIHtcbiAgICBjb25zdCB7IHN0YXRlLCB0cmFuc2FjdGlvbiB9ID0gY29uZmlnO1xuICAgIGxldCB7IHNlbGVjdGlvbiB9ID0gdHJhbnNhY3Rpb247XG4gICAgbGV0IHsgZG9jIH0gPSB0cmFuc2FjdGlvbjtcbiAgICBsZXQgeyBzdG9yZWRNYXJrcyB9ID0gdHJhbnNhY3Rpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGFwcGx5OiBzdGF0ZS5hcHBseS5iaW5kKHN0YXRlKSxcbiAgICAgICAgYXBwbHlUcmFuc2FjdGlvbjogc3RhdGUuYXBwbHlUcmFuc2FjdGlvbi5iaW5kKHN0YXRlKSxcbiAgICAgICAgcGx1Z2luczogc3RhdGUucGx1Z2lucyxcbiAgICAgICAgc2NoZW1hOiBzdGF0ZS5zY2hlbWEsXG4gICAgICAgIHJlY29uZmlndXJlOiBzdGF0ZS5yZWNvbmZpZ3VyZS5iaW5kKHN0YXRlKSxcbiAgICAgICAgdG9KU09OOiBzdGF0ZS50b0pTT04uYmluZChzdGF0ZSksXG4gICAgICAgIGdldCBzdG9yZWRNYXJrcygpIHtcbiAgICAgICAgICAgIHJldHVybiBzdG9yZWRNYXJrcztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHNlbGVjdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBkb2MoKSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgdHIoKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB0cmFuc2FjdGlvbi5zZWxlY3Rpb247XG4gICAgICAgICAgICBkb2MgPSB0cmFuc2FjdGlvbi5kb2M7XG4gICAgICAgICAgICBzdG9yZWRNYXJrcyA9IHRyYW5zYWN0aW9uLnN0b3JlZE1hcmtzO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNsYXNzIENvbW1hbmRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICAgICAgdGhpcy5yYXdDb21tYW5kcyA9IHRoaXMuZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuY29tbWFuZHM7XG4gICAgICAgIHRoaXMuY3VzdG9tU3RhdGUgPSBwcm9wcy5zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGhhc0N1c3RvbVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmN1c3RvbVN0YXRlO1xuICAgIH1cbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1c3RvbVN0YXRlIHx8IHRoaXMuZWRpdG9yLnN0YXRlO1xuICAgIH1cbiAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpO1xuICAgICAgICAgICAgICAgIGlmICghdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJykgJiYgIXRoaXMuaGFzQ3VzdG9tU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gW25hbWUsIG1ldGhvZF07XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0IGNoYWluKCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDaGFpbigpO1xuICAgIH1cbiAgICBnZXQgY2FuKCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jcmVhdGVDYW4oKTtcbiAgICB9XG4gICAgY3JlYXRlQ2hhaW4oc3RhcnRUciwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBbXTtcbiAgICAgICAgY29uc3QgaGFzU3RhcnRUcmFuc2FjdGlvbiA9ICEhc3RhcnRUcjtcbiAgICAgICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgICAgICBjb25zdCBydW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWhhc1N0YXJ0VHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAmJiBzaG91bGREaXNwYXRjaFxuICAgICAgICAgICAgICAgICYmICF0ci5nZXRNZXRhKCdwcmV2ZW50RGlzcGF0Y2gnKVxuICAgICAgICAgICAgICAgICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2tzLmV2ZXJ5KGNhbGxiYWNrID0+IGNhbGxiYWNrID09PSB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2hhaW4gPSB7XG4gICAgICAgICAgICAuLi5PYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMocmF3Q29tbWFuZHMpLm1hcCgoW25hbWUsIGNvbW1hbmRdKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhaW5lZENvbW1hbmQgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGNvbW1hbmQoLi4uYXJncykocHJvcHMpO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBbbmFtZSwgY2hhaW5lZENvbW1hbmRdO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgcnVuLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgfVxuICAgIGNyZWF0ZUNhbihzdGFydFRyKSB7XG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkaXNwYXRjaCA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0ciA9IHN0YXJ0VHIgfHwgc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyLCBkaXNwYXRjaCk7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZENvbW1hbmRzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZCguLi5hcmdzKSh7IC4uLnByb3BzLCBkaXNwYXRjaDogdW5kZWZpbmVkIH0pXTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZm9ybWF0dGVkQ29tbWFuZHMsXG4gICAgICAgICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgZGlzcGF0Y2gpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZFByb3BzKHRyLCBzaG91bGREaXNwYXRjaCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgeyByYXdDb21tYW5kcywgZWRpdG9yLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSBlZGl0b3I7XG4gICAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAgICAgdHIsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgc3RhdGU6IGNyZWF0ZUNoYWluYWJsZVN0YXRlKHtcbiAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGRpc3BhdGNoOiBzaG91bGREaXNwYXRjaCA/ICgpID0+IHVuZGVmaW5lZCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNoYWluOiAoKSA9PiB0aGlzLmNyZWF0ZUNoYWluKHRyLCBzaG91bGREaXNwYXRjaCksXG4gICAgICAgICAgICBjYW46ICgpID0+IHRoaXMuY3JlYXRlQ2FuKHRyKSxcbiAgICAgICAgICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW25hbWUsICguLi5hcmdzKSA9PiBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKV07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cbn1cblxuY2xhc3MgRXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSB7fTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGZuKSB7XG4gICAgICAgIGlmICghdGhpcy5jYWxsYmFja3NbZXZlbnRdKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbGxiYWNrc1tldmVudF0ucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBvZmYoZXZlbnQsIGZuKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gY2FsbGJhY2tzLmZpbHRlcihjYWxsYmFjayA9PiBjYWxsYmFjayAhPT0gZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzW2V2ZW50XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb25jZShldmVudCwgZm4pIHtcbiAgICAgICAgY29uc3Qgb25jZUZuID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50LCBvbmNlRm4pO1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBvbmNlRm4pO1xuICAgIH1cbiAgICByZW1vdmVBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYSBmaWVsZCBmcm9tIGFuIGV4dGVuc2lvblxuICogQHBhcmFtIGV4dGVuc2lvbiBUaGUgVGlwdGFwIGV4dGVuc2lvblxuICogQHBhcmFtIGZpZWxkIFRoZSBmaWVsZCwgZm9yIGV4YW1wbGUgYHJlbmRlckhUTUxgIG9yIGBwcmlvcml0eWBcbiAqIEBwYXJhbSBjb250ZXh0IFRoZSBjb250ZXh0IG9iamVjdCB0aGF0IHNob3VsZCBiZSBwYXNzZWQgYXMgYHRoaXNgIGludG8gdGhlIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyBUaGUgZmllbGQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCBmaWVsZCwgY29udGV4dCkge1xuICAgIGlmIChleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gdW5kZWZpbmVkICYmIGV4dGVuc2lvbi5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24uY29uZmlnW2ZpZWxkXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5jb25maWdbZmllbGRdLmJpbmQoe1xuICAgICAgICAgICAgLi4uY29udGV4dCxcbiAgICAgICAgICAgIHBhcmVudDogZXh0ZW5zaW9uLnBhcmVudFxuICAgICAgICAgICAgICAgID8gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLnBhcmVudCwgZmllbGQsIGNvbnRleHQpXG4gICAgICAgICAgICAgICAgOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF07XG59XG5cbmZ1bmN0aW9uIHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgY29uc3QgYmFzZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdleHRlbnNpb24nKTtcbiAgICBjb25zdCBub2RlRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ25vZGUnKTtcbiAgICBjb25zdCBtYXJrRXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYXNlRXh0ZW5zaW9ucyxcbiAgICAgICAgbm9kZUV4dGVuc2lvbnMsXG4gICAgICAgIG1hcmtFeHRlbnNpb25zLFxuICAgIH07XG59XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBhbGwgZXh0ZW5zaW9uIGF0dHJpYnV0ZXMgZGVmaW5lZCBpbiBgYWRkQXR0cmlidXRlYCBhbmQgYGFkZEdsb2JhbEF0dHJpYnV0ZWAuXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBMaXN0IG9mIGV4dGVuc2lvbnNcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKGV4dGVuc2lvbnMpIHtcbiAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gW107XG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCBub2RlQW5kTWFya0V4dGVuc2lvbnMgPSBbLi4ubm9kZUV4dGVuc2lvbnMsIC4uLm1hcmtFeHRlbnNpb25zXTtcbiAgICBjb25zdCBkZWZhdWx0QXR0cmlidXRlID0ge1xuICAgICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgICByZW5kZXJlZDogdHJ1ZSxcbiAgICAgICAgcmVuZGVySFRNTDogbnVsbCxcbiAgICAgICAgcGFyc2VIVE1MOiBudWxsLFxuICAgICAgICBrZWVwT25TcGxpdDogdHJ1ZSxcbiAgICAgICAgaXNSZXF1aXJlZDogZmFsc2UsXG4gICAgfTtcbiAgICBleHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IG5vZGVBbmRNYXJrRXh0ZW5zaW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWRkR2xvYmFsQXR0cmlidXRlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEdsb2JhbEF0dHJpYnV0ZXMnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKCFhZGRHbG9iYWxBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2xvYmFsQXR0cmlidXRlcyA9IGFkZEdsb2JhbEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgZ2xvYmFsQXR0cmlidXRlcy5mb3JFYWNoKGdsb2JhbEF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICBnbG9iYWxBdHRyaWJ1dGUudHlwZXMuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3RcbiAgICAgICAgICAgICAgICAgICAgLmVudHJpZXMoZ2xvYmFsQXR0cmlidXRlLmF0dHJpYnV0ZXMpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIG5vZGVBbmRNYXJrRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRBdHRyaWJ1dGVzJywgY29udGV4dCk7XG4gICAgICAgIGlmICghYWRkQXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBgYXMgQXR0cmlidXRlc2BcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGFkZEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgT2JqZWN0XG4gICAgICAgICAgICAuZW50cmllcyhhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgLmZvckVhY2goKFtuYW1lLCBhdHRyaWJ1dGVdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRBdHRyID0ge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG1lcmdlZEF0dHIgPT09IG51bGwgfHwgbWVyZ2VkQXR0ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHIuZGVmYXVsdCA9IG1lcmdlZEF0dHIuZGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuaXNSZXF1aXJlZCkgJiYgKG1lcmdlZEF0dHIgPT09IG51bGwgfHwgbWVyZ2VkQXR0ciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWVyZ2VkQXR0ci5kZWZhdWx0KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1lcmdlZEF0dHIuZGVmYXVsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuc2lvbkF0dHJpYnV0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IG1lcmdlZEF0dHIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZXM7XG59XG5cbmZ1bmN0aW9uIGdldE5vZGVUeXBlKG5hbWVPclR5cGUsIHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV0pIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBUaGVyZSBpcyBubyBub2RlIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEubm9kZXNbbmFtZU9yVHlwZV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lT3JUeXBlO1xufVxuXG5mdW5jdGlvbiBtZXJnZUF0dHJpYnV0ZXMoLi4ub2JqZWN0cykge1xuICAgIHJldHVybiBvYmplY3RzXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiAhIWl0ZW0pXG4gICAgICAgIC5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lcmdlZEF0dHJpYnV0ZXMgPSB7IC4uLml0ZW1zIH07XG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGl0ZW0pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldO1xuICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnY2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVDbGFzc2VzID0gdmFsdWUgPyBTdHJpbmcodmFsdWUpLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0NsYXNzZXMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPyBtZXJnZWRBdHRyaWJ1dGVzW2tleV0uc3BsaXQoJyAnKSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc2VydENsYXNzZXMgPSB2YWx1ZUNsYXNzZXMuZmlsdGVyKHZhbHVlQ2xhc3MgPT4gIWV4aXN0aW5nQ2xhc3Nlcy5pbmNsdWRlcyh2YWx1ZUNsYXNzKSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gWy4uLmV4aXN0aW5nQ2xhc3NlcywgLi4uaW5zZXJ0Q2xhc3Nlc10uam9pbignICcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U3R5bGVzID0gdmFsdWUgPyB2YWx1ZS5zcGxpdCgnOycpLm1hcCgoc3R5bGUpID0+IHN0eWxlLnRyaW0oKSkuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdTdHlsZXMgPSBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPyBtZXJnZWRBdHRyaWJ1dGVzW2tleV0uc3BsaXQoJzsnKS5tYXAoKHN0eWxlKSA9PiBzdHlsZS50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nU3R5bGVzLmZvckVhY2goc3R5bGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbcHJvcGVydHksIHZhbF0gPSBzdHlsZS5zcGxpdCgnOicpLm1hcChwYXJ0ID0+IHBhcnQudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVNYXAuc2V0KHByb3BlcnR5LCB2YWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5ld1N0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWxdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlTWFwLnNldChwcm9wZXJ0eSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSBBcnJheS5mcm9tKHN0eWxlTWFwLmVudHJpZXMoKSkubWFwKChbcHJvcGVydHksIHZhbF0pID0+IGAke3Byb3BlcnR5fTogJHt2YWx9YCkuam9pbignOyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZEF0dHJpYnV0ZXM7XG4gICAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZU9yTWFyaywgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xuICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzXG4gICAgICAgIC5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBub2RlT3JNYXJrLnR5cGUubmFtZSlcbiAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0uYXR0cmlidXRlLnJlbmRlcmVkKVxuICAgICAgICAubWFwKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoIWl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgW2l0ZW0ubmFtZV06IG5vZGVPck1hcmsuYXR0cnNbaXRlbS5uYW1lXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW0uYXR0cmlidXRlLnJlbmRlckhUTUwobm9kZU9yTWFyay5hdHRycykgfHwge307XG4gICAgfSlcbiAgICAgICAgLnJlZHVjZSgoYXR0cmlidXRlcywgYXR0cmlidXRlKSA9PiBtZXJnZUF0dHJpYnV0ZXMoYXR0cmlidXRlcywgYXR0cmlidXRlKSwge30pO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1mdW5jdGlvbi10eXBlXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqXG4gKiBPcHRpb25hbGx5IGNhbGxzIGB2YWx1ZWAgYXMgYSBmdW5jdGlvbi5cbiAqIE90aGVyd2lzZSBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS5cbiAqIEBwYXJhbSB2YWx1ZSBGdW5jdGlvbiBvciBhbnkgdmFsdWUuXG4gKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IHRvIGJpbmQgdG8gZnVuY3Rpb24uXG4gKiBAcGFyYW0gcHJvcHMgT3B0aW9uYWwgcHJvcHMgdG8gcGFzcyB0byBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FsbE9yUmV0dXJuKHZhbHVlLCBjb250ZXh0ID0gdW5kZWZpbmVkLCAuLi5wcm9wcykge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmJpbmQoY29udGV4dCkoLi4ucHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSguLi5wcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdCh2YWx1ZSA9IHt9KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPT09IDAgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLm1hdGNoKC9eWystXT8oPzpcXGQqXFwuKT9cXGQrJC8pKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09ICd0cnVlJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWVyZ2VzIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGludG8gcGFyc2VydWxlIGF0dHJpYnV0ZXMgKGBhdHRyc2Agb3IgYGdldEF0dHJzYCkuXG4gKiBDYW5jZWxzIHdoZW4gYGdldEF0dHJzYCByZXR1cm5lZCBgZmFsc2VgLlxuICogQHBhcmFtIHBhcnNlUnVsZSBQcm9zZU1pcnJvciBQYXJzZVJ1bGVcbiAqIEBwYXJhbSBleHRlbnNpb25BdHRyaWJ1dGVzIExpc3Qgb2YgYXR0cmlidXRlcyB0byBpbmplY3RcbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykge1xuICAgIGlmICgnc3R5bGUnIGluIHBhcnNlUnVsZSkge1xuICAgICAgICByZXR1cm4gcGFyc2VSdWxlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5wYXJzZVJ1bGUsXG4gICAgICAgIGdldEF0dHJzOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IHBhcnNlUnVsZS5nZXRBdHRycyA/IHBhcnNlUnVsZS5nZXRBdHRycyhub2RlKSA6IHBhcnNlUnVsZS5hdHRycztcbiAgICAgICAgICAgIGlmIChvbGRBdHRyaWJ1dGVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld0F0dHJpYnV0ZXMgPSBleHRlbnNpb25BdHRyaWJ1dGVzLnJlZHVjZSgoaXRlbXMsIGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTFxuICAgICAgICAgICAgICAgICAgICA/IGl0ZW0uYXR0cmlidXRlLnBhcnNlSFRNTChub2RlKVxuICAgICAgICAgICAgICAgICAgICA6IGZyb21TdHJpbmcoKG5vZGUpLmdldEF0dHJpYnV0ZShpdGVtLm5hbWUpKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLml0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBbaXRlbS5uYW1lXTogdmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIHJldHVybiB7IC4uLm9sZEF0dHJpYnV0ZXMsIC4uLm5ld0F0dHJpYnV0ZXMgfTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjbGVhblVwU2NoZW1hSXRlbShkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmVudHJpZXMoZGF0YSkuZmlsdGVyKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKGtleSA9PT0gJ2F0dHJzJyAmJiBpc0VtcHR5T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQcm9zZW1pcnJvciBzY2hlbWEgYmFzZWQgb24gdGhlIGdpdmVuIGV4dGVuc2lvbnMuXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yIGluc3RhbmNlXG4gKiBAcmV0dXJucyBBIFByb3NlbWlycm9yIHNjaGVtYVxuICovXG5mdW5jdGlvbiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhleHRlbnNpb25zLCBlZGl0b3IpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYWxsQXR0cmlidXRlcyA9IGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zLCBtYXJrRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICAgIGNvbnN0IHRvcE5vZGUgPSAoX2EgPSBub2RlRXh0ZW5zaW9ucy5maW5kKGV4dGVuc2lvbiA9PiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICd0b3BOb2RlJykpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZTtcbiAgICBjb25zdCBub2RlcyA9IE9iamVjdC5mcm9tRW50cmllcyhub2RlRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGFsbEF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBleHRyYU5vZGVGaWVsZHMgPSBleHRlbnNpb25zLnJlZHVjZSgoZmllbGRzLCBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleHRlbmROb2RlU2NoZW1hID0gZ2V0RXh0ZW5zaW9uRmllbGQoZSwgJ2V4dGVuZE5vZGVTY2hlbWEnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgICAgIC4uLihleHRlbmROb2RlU2NoZW1hID8gZXh0ZW5kTm9kZVNjaGVtYShleHRlbnNpb24pIDoge30pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBjbGVhblVwU2NoZW1hSXRlbSh7XG4gICAgICAgICAgICAuLi5leHRyYU5vZGVGaWVsZHMsXG4gICAgICAgICAgICBjb250ZW50OiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnY29udGVudCcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIG1hcmtzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnbWFya3MnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICAgICAgaW5saW5lOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnaW5saW5lJywgY29udGV4dCkpLFxuICAgICAgICAgICAgYXRvbTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2F0b20nLCBjb250ZXh0KSksXG4gICAgICAgICAgICBzZWxlY3RhYmxlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnc2VsZWN0YWJsZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2RyYWdnYWJsZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgd2hpdGVzcGFjZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3doaXRlc3BhY2UnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBsaW5lYnJlYWtSZXBsYWNlbWVudDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2xpbmVicmVha1JlcGxhY2VtZW50JywgY29udGV4dCkpLFxuICAgICAgICAgICAgZGVmaW5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdkZWZpbmluZycsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGlzb2xhdGluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2lzb2xhdGluZycsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGF0dHJzOiBPYmplY3QuZnJvbUVudHJpZXMoZXh0ZW5zaW9uQXR0cmlidXRlcy5tYXAoZXh0ZW5zaW9uQXR0cmlidXRlID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25BdHRyaWJ1dGUubmFtZSwgeyBkZWZhdWx0OiAoX2EgPSBleHRlbnNpb25BdHRyaWJ1dGUgPT09IG51bGwgfHwgZXh0ZW5zaW9uQXR0cmlidXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVmYXVsdCB9XTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHBhcnNlSFRNTCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdwYXJzZUhUTUwnLCBjb250ZXh0KSk7XG4gICAgICAgIGlmIChwYXJzZUhUTUwpIHtcbiAgICAgICAgICAgIHNjaGVtYS5wYXJzZURPTSA9IHBhcnNlSFRNTC5tYXAocGFyc2VSdWxlID0+IGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJIVE1MID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncmVuZGVySFRNTCcsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVuZGVySFRNTCkge1xuICAgICAgICAgICAgc2NoZW1hLnRvRE9NID0gbm9kZSA9PiByZW5kZXJIVE1MKHtcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZW5kZXJUZXh0ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncmVuZGVyVGV4dCcsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVuZGVyVGV4dCkge1xuICAgICAgICAgICAgc2NoZW1hLnRvVGV4dCA9IHJlbmRlclRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXTtcbiAgICB9KSk7XG4gICAgY29uc3QgbWFya3MgPSBPYmplY3QuZnJvbUVudHJpZXMobWFya0V4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXh0cmFNYXJrRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTWFya1NjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmRNYXJrU2NoZW1hJywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTWFya1NjaGVtYSA/IGV4dGVuZE1hcmtTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAgICAgLi4uZXh0cmFNYXJrRmllbGRzLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnaW5jbHVzaXZlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgZXhjbHVkZXM6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdleGNsdWRlcycsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGdyb3VwOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZ3JvdXAnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBzcGFubmluZzogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3NwYW5uaW5nJywgY29udGV4dCkpLFxuICAgICAgICAgICAgY29kZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2NvZGUnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogKF9hID0gZXh0ZW5zaW9uQXR0cmlidXRlID09PSBudWxsIHx8IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQgfV07XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCkpO1xuICAgICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlckhUTUwnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgICAgIHNjaGVtYS50b0RPTSA9IG1hcmsgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtleHRlbnNpb24ubmFtZSwgc2NoZW1hXTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIG5ldyBTY2hlbWEoe1xuICAgICAgICB0b3BOb2RlLFxuICAgICAgICBub2RlcyxcbiAgICAgICAgbWFya3MsXG4gICAgfSk7XG59XG5cbi8qKlxuICogVHJpZXMgdG8gZ2V0IGEgbm9kZSBvciBtYXJrIHR5cGUgYnkgaXRzIG5hbWUuXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgbm9kZSBvciBtYXJrIHR5cGVcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlyb3Igc2NoZW1hIHRvIHNlYXJjaCBpblxuICogQHJldHVybnMgVGhlIG5vZGUgb3IgbWFyayB0eXBlLCBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcbiAgICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVdIHx8IHNjaGVtYS5tYXJrc1tuYW1lXSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVuYWJsZWQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlbmFibGVkKSkge1xuICAgICAgICByZXR1cm4gZW5hYmxlZC5zb21lKGVuYWJsZWRFeHRlbnNpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBlbmFibGVkRXh0ZW5zaW9uID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gZW5hYmxlZEV4dGVuc2lvblxuICAgICAgICAgICAgICAgIDogZW5hYmxlZEV4dGVuc2lvbi5uYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09IGV4dGVuc2lvbi5uYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVuYWJsZWQ7XG59XG5cbmZ1bmN0aW9uIGdldEhUTUxGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHNjaGVtYSkge1xuICAgIGNvbnN0IGRvY3VtZW50RnJhZ21lbnQgPSBET01TZXJpYWxpemVyLmZyb21TY2hlbWEoc2NoZW1hKS5zZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCk7XG4gICAgY29uc3QgdGVtcG9yYXJ5RG9jdW1lbnQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB0ZW1wb3JhcnlEb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnRGcmFnbWVudCk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5pbm5lckhUTUw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdGV4dCBjb250ZW50IG9mIGEgcmVzb2x2ZWQgcHJvc2VtaXJyb3IgcG9zaXRpb25cbiAqIEBwYXJhbSAkZnJvbSBUaGUgcmVzb2x2ZWQgcG9zaXRpb24gdG8gZ2V0IHRoZSB0ZXh0IGNvbnRlbnQgZnJvbVxuICogQHBhcmFtIG1heE1hdGNoIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBjb250ZW50XG4gKi9cbmNvbnN0IGdldFRleHRDb250ZW50RnJvbU5vZGVzID0gKCRmcm9tLCBtYXhNYXRjaCA9IDUwMCkgPT4ge1xuICAgIGxldCB0ZXh0QmVmb3JlID0gJyc7XG4gICAgY29uc3Qgc2xpY2VFbmRQb3MgPSAkZnJvbS5wYXJlbnRPZmZzZXQ7XG4gICAgJGZyb20ucGFyZW50Lm5vZGVzQmV0d2VlbihNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIG1heE1hdGNoKSwgc2xpY2VFbmRQb3MsIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY2h1bmsgPSAoKF9iID0gKF9hID0gbm9kZS50eXBlLnNwZWMpLnRvVGV4dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgfSkpXG4gICAgICAgICAgICB8fCBub2RlLnRleHRDb250ZW50XG4gICAgICAgICAgICB8fCAnJWxlYWYlJztcbiAgICAgICAgdGV4dEJlZm9yZSArPSBub2RlLmlzQXRvbSAmJiAhbm9kZS5pc1RleHQgPyBjaHVuayA6IGNodW5rLnNsaWNlKDAsIE1hdGgubWF4KDAsIHNsaWNlRW5kUG9zIC0gcG9zKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRleHRCZWZvcmU7XG59O1xuXG5mdW5jdGlvbiBpc1JlZ0V4cCh2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cblxuY2xhc3MgSW5wdXRSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmQ7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyO1xuICAgIH1cbn1cbmNvbnN0IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyID0gKHRleHQsIGZpbmQpID0+IHtcbiAgICBpZiAoaXNSZWdFeHAoZmluZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpbmQuZXhlYyh0ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRSdWxlTWF0Y2ggPSBmaW5kKHRleHQpO1xuICAgIGlmICghaW5wdXRSdWxlTWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtpbnB1dFJ1bGVNYXRjaC50ZXh0XTtcbiAgICByZXN1bHQuaW5kZXggPSBpbnB1dFJ1bGVNYXRjaC5pbmRleDtcbiAgICByZXN1bHQuaW5wdXQgPSB0ZXh0O1xuICAgIHJlc3VsdC5kYXRhID0gaW5wdXRSdWxlTWF0Y2guZGF0YTtcbiAgICBpZiAoaW5wdXRSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICAgICAgaWYgKCFpbnB1dFJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoXCIgbXVzdCBiZSBwYXJ0IG9mIFwiaW5wdXRSdWxlTWF0Y2gudGV4dFwiLicpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5mdW5jdGlvbiBydW4kMShjb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBlZGl0b3IsIGZyb20sIHRvLCB0ZXh0LCBydWxlcywgcGx1Z2luLCB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgIGlmICh2aWV3LmNvbXBvc2luZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0ICRmcm9tID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICBpZiAoXG4gICAgLy8gY2hlY2sgZm9yIGNvZGUgbm9kZVxuICAgICRmcm9tLnBhcmVudC50eXBlLnNwZWMuY29kZVxuICAgICAgICAvLyBjaGVjayBmb3IgY29kZSBtYXJrXG4gICAgICAgIHx8ICEhKChfYSA9ICgkZnJvbS5ub2RlQmVmb3JlIHx8ICRmcm9tLm5vZGVBZnRlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlLnNwZWMuY29kZSkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IG1hdGNoZWQgPSBmYWxzZTtcbiAgICBjb25zdCB0ZXh0QmVmb3JlID0gZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMoJGZyb20pICsgdGV4dDtcbiAgICBydWxlcy5mb3JFYWNoKHJ1bGUgPT4ge1xuICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoID0gaW5wdXRSdWxlTWF0Y2hlckhhbmRsZXIodGV4dEJlZm9yZSwgcnVsZS5maW5kKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyID0gdmlldy5zdGF0ZS50cjtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICBzdGF0ZTogdmlldy5zdGF0ZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgZnJvbTogZnJvbSAtIChtYXRjaFswXS5sZW5ndGggLSB0ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICB0byxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgeyBjb21tYW5kcywgY2hhaW4sIGNhbiB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICBjb21tYW5kcyxcbiAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgY2FuLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlc1xuICAgICAgICBpZiAoaGFuZGxlciA9PT0gbnVsbCB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcmUgdHJhbnNmb3JtIGFzIG1ldGEgZGF0YVxuICAgICAgICAvLyBzbyB3ZSBjYW4gdW5kbyBpbnB1dCBydWxlcyB3aXRoaW4gdGhlIGB1bmRvSW5wdXRSdWxlc2AgY29tbWFuZFxuICAgICAgICB0ci5zZXRNZXRhKHBsdWdpbiwge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiB0cixcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgICAgIHRleHQsXG4gICAgICAgIH0pO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgbWF0Y2hlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdGNoZWQ7XG59XG4vKipcbiAqIENyZWF0ZSBhbiBpbnB1dCBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSB0ZXh0XG4gKiBpbnB1dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5mdW5jdGlvbiBpbnB1dFJ1bGVzUGx1Z2luKHByb3BzKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIHJ1bGVzIH0gPSBwcm9wcztcbiAgICBjb25zdCBwbHVnaW4gPSBuZXcgUGx1Z2luKHtcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXBwbHkodHIsIHByZXYsIHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0gdHIuZ2V0TWV0YShwbHVnaW4pO1xuICAgICAgICAgICAgICAgIGlmIChzdG9yZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaWYgSW5wdXRSdWxlIGlzIHRyaWdnZXJlZCBieSBpbnNlcnRDb250ZW50KClcbiAgICAgICAgICAgICAgICBjb25zdCBzaW11bGF0ZWRJbnB1dE1ldGEgPSB0ci5nZXRNZXRhKCdhcHBseUlucHV0UnVsZXMnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1NpbXVsYXRlZElucHV0ID0gISFzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgICAgICAgICAgaWYgKGlzU2ltdWxhdGVkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZ2V0SFRNTEZyb21GcmFnbWVudChGcmFnbWVudC5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmcm9tIH0gPSBzaW11bGF0ZWRJbnB1dE1ldGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1biQxKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRyLnNlbGVjdGlvblNldCB8fCB0ci5kb2NDaGFuZ2VkID8gbnVsbCA6IHByZXY7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgaGFuZGxlVGV4dElucHV0KHZpZXcsIGZyb20sIHRvLCB0ZXh0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJ1biQxKHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoYW5kbGVET01FdmVudHM6IHtcbiAgICAgICAgICAgICAgICBjb21wb3NpdGlvbmVuZDogdmlldyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuJDEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb206ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gYWRkIHN1cHBvcnQgZm9yIGlucHV0IHJ1bGVzIHRvIHRyaWdnZXIgb24gZW50ZXJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdXNlZnVsIGZvciBleGFtcGxlIGZvciBjb2RlIGJsb2Nrc1xuICAgICAgICAgICAgaGFuZGxlS2V5RG93bih2aWV3LCBldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgIT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7ICRjdXJzb3IgfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICgkY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBydW4kMSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6ICdcXG4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlzSW5wdXRSdWxlczogdHJ1ZSxcbiAgICB9KTtcbiAgICByZXR1cm4gcGx1Z2luO1xufVxuXG4vLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZXNxdWVlYi9pcy13aGF0L2Jsb2IvODhkNmU0Y2E5MmZiMmJhYWI2MDAzYzU0ZTAyZWVkZjRlNzI5ZTVhYi9zcmMvaW5kZXgudHNcbmZ1bmN0aW9uIGdldFR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSk7XG59XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgaWYgKGdldFR5cGUodmFsdWUpICE9PSAnT2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0ICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVlcCh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgLi4udGFyZ2V0IH07XG4gICAgaWYgKGlzUGxhaW5PYmplY3QodGFyZ2V0KSAmJiBpc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQbGFpbk9iamVjdChzb3VyY2Vba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRba2V5XSA9IG1lcmdlRGVlcCh0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbi8qKlxuICogVGhlIE1hcmsgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgY3VzdG9tIG1hcmsgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuY2xhc3MgTWFyayB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ21hcmsnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbWFyayc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pKSB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcmsoY29uZmlnKTtcbiAgICB9XG4gICAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoe1xuICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgICAgICBhZGRPcHRpb25zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSB0aGUgY3VycmVudCBuYW1lXG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCB0byBiZSBvdXIgcGFyZW50XG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG4gICAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE1hcmsoZXh0ZW5kZWRDb25maWcpO1xuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICB9KSk7XG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIHN0YXRpYyBoYW5kbGVFeGl0KHsgZWRpdG9yLCBtYXJrIH0pIHtcbiAgICAgICAgY29uc3QgeyB0ciB9ID0gZWRpdG9yLnN0YXRlO1xuICAgICAgICBjb25zdCBjdXJyZW50UG9zID0gZWRpdG9yLnN0YXRlLnNlbGVjdGlvbi4kZnJvbTtcbiAgICAgICAgY29uc3QgaXNBdEVuZCA9IGN1cnJlbnRQb3MucG9zID09PSBjdXJyZW50UG9zLmVuZCgpO1xuICAgICAgICBpZiAoaXNBdEVuZCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudE1hcmtzID0gY3VycmVudFBvcy5tYXJrcygpO1xuICAgICAgICAgICAgY29uc3QgaXNJbk1hcmsgPSAhIWN1cnJlbnRNYXJrcy5maW5kKG0gPT4gKG0gPT09IG51bGwgfHwgbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbS50eXBlLm5hbWUpID09PSBtYXJrLm5hbWUpO1xuICAgICAgICAgICAgaWYgKCFpc0luTWFyaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbW92ZU1hcmsgPSBjdXJyZW50TWFya3MuZmluZChtID0+IChtID09PSBudWxsIHx8IG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVNYXJrKSB7XG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhyZW1vdmVNYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmluc2VydFRleHQoJyAnLCBjdXJyZW50UG9zLnBvcyk7XG4gICAgICAgICAgICBlZGl0b3Iudmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc051bWJlcih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIFBhc3RlIHJ1bGVzIGFyZSB1c2VkIHRvIHJlYWN0IHRvIHBhc3RlZCBjb250ZW50LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjcGFzdGUtcnVsZXNcbiAqL1xuY2xhc3MgUGFzdGVSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICAgICAgdGhpcy5maW5kID0gY29uZmlnLmZpbmQ7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGNvbmZpZy5oYW5kbGVyO1xuICAgIH1cbn1cbmNvbnN0IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyID0gKHRleHQsIGZpbmQsIGV2ZW50KSA9PiB7XG4gICAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgICAgIHJldHVybiBbLi4udGV4dC5tYXRjaEFsbChmaW5kKV07XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZXMgPSBmaW5kKHRleHQsIGV2ZW50KTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcy5tYXAocGFzdGVSdWxlTWF0Y2ggPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbcGFzdGVSdWxlTWF0Y2gudGV4dF07XG4gICAgICAgIHJlc3VsdC5pbmRleCA9IHBhc3RlUnVsZU1hdGNoLmluZGV4O1xuICAgICAgICByZXN1bHQuaW5wdXQgPSB0ZXh0O1xuICAgICAgICByZXN1bHQuZGF0YSA9IHBhc3RlUnVsZU1hdGNoLmRhdGE7XG4gICAgICAgIGlmIChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkge1xuICAgICAgICAgICAgaWYgKCFwYXN0ZVJ1bGVNYXRjaC50ZXh0LmluY2x1ZGVzKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcInBhc3RlUnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhc3RlUnVsZU1hdGNoLnJlcGxhY2VXaXRoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufTtcbmZ1bmN0aW9uIHJ1bihjb25maWcpIHtcbiAgICBjb25zdCB7IGVkaXRvciwgc3RhdGUsIGZyb20sIHRvLCBydWxlLCBwYXN0ZUV2ZW50LCBkcm9wRXZlbnQsIH0gPSBjb25maWc7XG4gICAgY29uc3QgeyBjb21tYW5kcywgY2hhaW4sIGNhbiB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgZWRpdG9yLFxuICAgICAgICBzdGF0ZSxcbiAgICB9KTtcbiAgICBjb25zdCBoYW5kbGVycyA9IFtdO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUudHlwZS5zcGVjLmNvZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXNvbHZlZEZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xuICAgICAgICBjb25zdCByZXNvbHZlZFRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUuY29udGVudC5zaXplKTtcbiAgICAgICAgY29uc3QgdGV4dFRvTWF0Y2ggPSBub2RlLnRleHRCZXR3ZWVuKHJlc29sdmVkRnJvbSAtIHBvcywgcmVzb2x2ZWRUbyAtIHBvcywgdW5kZWZpbmVkLCAnXFx1ZmZmYycpO1xuICAgICAgICBjb25zdCBtYXRjaGVzID0gcGFzdGVSdWxlTWF0Y2hlckhhbmRsZXIodGV4dFRvTWF0Y2gsIHJ1bGUuZmluZCwgcGFzdGVFdmVudCk7XG4gICAgICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICAgICAgICBpZiAobWF0Y2guaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcmVzb2x2ZWRGcm9tICsgbWF0Y2guaW5kZXggKyAxO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChzdGFydCksXG4gICAgICAgICAgICAgICAgdG86IHN0YXRlLnRyLm1hcHBpbmcubWFwKGVuZCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHJ1bGUuaGFuZGxlcih7XG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgcmFuZ2UsXG4gICAgICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgY2FuLFxuICAgICAgICAgICAgICAgIHBhc3RlRXZlbnQsXG4gICAgICAgICAgICAgICAgZHJvcEV2ZW50LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzdWNjZXNzID0gaGFuZGxlcnMuZXZlcnkoaGFuZGxlciA9PiBoYW5kbGVyICE9PSBudWxsKTtcbiAgICByZXR1cm4gc3VjY2Vzcztcbn1cbi8vIFdoZW4gZHJhZ2dpbmcgYWNyb3NzIGVkaXRvcnMsIG11c3QgZ2V0IGFub3RoZXIgZWRpdG9yIGluc3RhbmNlIHRvIGRlbGV0ZSBzZWxlY3Rpb24gY29udGVudC5cbmxldCB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yID0gbnVsbDtcbmNvbnN0IGNyZWF0ZUNsaXBib2FyZFBhc3RlRXZlbnQgPSAodGV4dCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDbGlwYm9hcmRFdmVudCgncGFzdGUnLCB7XG4gICAgICAgIGNsaXBib2FyZERhdGE6IG5ldyBEYXRhVHJhbnNmZXIoKSxcbiAgICB9KTtcbiAgICAoX2EgPSBldmVudC5jbGlwYm9hcmREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGF0YSgndGV4dC9odG1sJywgdGV4dCk7XG4gICAgcmV0dXJuIGV2ZW50O1xufTtcbi8qKlxuICogQ3JlYXRlIGFuIHBhc3RlIHJ1bGVzIHBsdWdpbi4gV2hlbiBlbmFibGVkLCBpdCB3aWxsIGNhdXNlIHBhc3RlZFxuICogdGV4dCB0aGF0IG1hdGNoZXMgYW55IG9mIHRoZSBnaXZlbiBydWxlcyB0byB0cmlnZ2VyIHRoZSBydWxl4oCZc1xuICogYWN0aW9uLlxuICovXG5mdW5jdGlvbiBwYXN0ZVJ1bGVzUGx1Z2luKHByb3BzKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIHJ1bGVzIH0gPSBwcm9wcztcbiAgICBsZXQgZHJhZ1NvdXJjZUVsZW1lbnQgPSBudWxsO1xuICAgIGxldCBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9IGZhbHNlO1xuICAgIGxldCBpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJykgOiBudWxsO1xuICAgIGxldCBkcm9wRXZlbnQ7XG4gICAgdHJ5IHtcbiAgICAgICAgZHJvcEV2ZW50ID0gdHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRHJhZ0V2ZW50KCdkcm9wJykgOiBudWxsO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIGRyb3BFdmVudCA9IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHByb2Nlc3NFdmVudCA9ICh7IHN0YXRlLCBmcm9tLCB0bywgcnVsZSwgcGFzdGVFdnQsIH0pID0+IHtcbiAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgY29uc3QgY2hhaW5hYmxlU3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0cixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydW4oe1xuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgc3RhdGU6IGNoYWluYWJsZVN0YXRlLFxuICAgICAgICAgICAgZnJvbTogTWF0aC5tYXgoZnJvbSAtIDEsIDApLFxuICAgICAgICAgICAgdG86IHRvLmIgLSAxLFxuICAgICAgICAgICAgcnVsZSxcbiAgICAgICAgICAgIHBhc3RlRXZlbnQ6IHBhc3RlRXZ0LFxuICAgICAgICAgICAgZHJvcEV2ZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFoYW5kbGVyIHx8ICF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZHJvcEV2ZW50ID0gdHlwZW9mIERyYWdFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgRHJhZ0V2ZW50KCdkcm9wJykgOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIGRyb3BFdmVudCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcGFzdGVFdmVudCA9IHR5cGVvZiBDbGlwYm9hcmRFdmVudCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJykgOiBudWxsO1xuICAgICAgICByZXR1cm4gdHI7XG4gICAgfTtcbiAgICBjb25zdCBwbHVnaW5zID0gcnVsZXMubWFwKHJ1bGUgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAvLyB3ZSByZWdpc3RlciBhIGdsb2JhbCBkcmFnIGhhbmRsZXIgdG8gdHJhY2sgdGhlIGN1cnJlbnQgZHJhZyBzb3VyY2UgZWxlbWVudFxuICAgICAgICAgICAgdmlldyh2aWV3KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlRHJhZ3N0YXJ0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ1NvdXJjZUVsZW1lbnQgPSAoKF9hID0gdmlldy5kb20ucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZpZXcuZG9tLnBhcmVudEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdTb3VyY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVEcmFnZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnc3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbmQnLCBoYW5kbGVEcmFnZW5kKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRyb3A6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZHJhZ1NvdXJjZUVsZW1lbnQgPT09IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkcm9wRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZHJhZ0Zyb21PdGhlckVkaXRvciA9IHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdGcm9tT3RoZXJFZGl0b3IgPT09IG51bGwgfHwgZHJhZ0Zyb21PdGhlckVkaXRvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZHJhZ0Zyb21PdGhlckVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldFRpbWVvdXQgdG8gYXZvaWQgdGhlIHdyb25nIGNvbnRlbnQgYWZ0ZXIgZHJvcCwgdGltZW91dCBhcmcgY2FuJ3QgYmUgZW1wdHkgb3IgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IGRyYWdGcm9tT3RoZXJFZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdGcm9tT3RoZXJFZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tOiBzZWxlY3Rpb24uZnJvbSwgdG86IHNlbGVjdGlvbi50byB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFzdGU6IChfdmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAoX2EgPSBldmVudC5jbGlwYm9hcmREYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0RGF0YSgndGV4dC9odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvciA9ICEhKGh0bWwgPT09IG51bGwgfHwgaHRtbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaHRtbC5pbmNsdWRlcygnZGF0YS1wbS1zbGljZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGVuZFRyYW5zYWN0aW9uOiAodHJhbnNhY3Rpb25zLCBvbGRTdGF0ZSwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Bhc3RlID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAncGFzdGUnICYmICFpc1Bhc3RlZEZyb21Qcm9zZU1pcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0Ryb3AgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCd1aUV2ZW50JykgPT09ICdkcm9wJyAmJiAhaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yO1xuICAgICAgICAgICAgICAgIC8vIGlmIFBhc3RlUnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGVkUGFzdGVNZXRhID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYXBwbHlQYXN0ZVJ1bGVzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRQYXN0ZSA9ICEhc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgICAgICAgIGlmICghaXNQYXN0ZSAmJiAhaXNEcm9wICYmICFpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNpbXVsYXRlZCBwYXN0ZVxuICAgICAgICAgICAgICAgIGlmIChpc1NpbXVsYXRlZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gZ2V0SFRNTEZyb21GcmFnbWVudChGcmFnbWVudC5mcm9tKHRleHQpLCBzdGF0ZS5zY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkUGFzdGVNZXRhO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0byA9IGZyb20gKyB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFzdGVFdnQgPSBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50KHRleHQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogeyBiOiB0byB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVFdnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgYWN0dWFsIHBhc3RlL2Ryb3BcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZTdGFydChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSBvbGRTdGF0ZS5kb2MuY29udGVudC5maW5kRGlmZkVuZChzdGF0ZS5kb2MuY29udGVudCk7XG4gICAgICAgICAgICAgICAgLy8gc3RvcCBpZiB0aGVyZSBpcyBubyBjaGFuZ2VkIHJhbmdlXG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihmcm9tKSB8fCAhdG8gfHwgZnJvbSA9PT0gdG8uYikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9jZXNzRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlRXZ0OiBwYXN0ZUV2ZW50LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbnM7XG59XG5cbmZ1bmN0aW9uIGZpbmREdXBsaWNhdGVzKGl0ZW1zKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBpdGVtcy5maWx0ZXIoKGVsLCBpbmRleCkgPT4gaXRlbXMuaW5kZXhPZihlbCkgIT09IGluZGV4KTtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KGZpbHRlcmVkKSk7XG59XG5cbmNsYXNzIEV4dGVuc2lvbk1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGV4dGVuc2lvbnMsIGVkaXRvcikge1xuICAgICAgICB0aGlzLnNwbGl0dGFibGVNYXJrcyA9IFtdO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucywgZWRpdG9yKTtcbiAgICAgICAgdGhpcy5zZXR1cEV4dGVuc2lvbnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGZsYXR0ZW5lZCBhbmQgc29ydGVkIGV4dGVuc2lvbiBsaXN0IHdoaWxlXG4gICAgICogYWxzbyBjaGVja2luZyBmb3IgZHVwbGljYXRlZCBleHRlbnNpb25zIGFuZCB3YXJucyB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIEFuIGZsYXR0ZW5lZCBhbmQgc29ydGVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICovXG4gICAgc3RhdGljIHJlc29sdmUoZXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoRXh0ZW5zaW9uTWFuYWdlci5mbGF0dGVuKGV4dGVuc2lvbnMpKTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlZE5hbWVzID0gZmluZER1cGxpY2F0ZXMocmVzb2x2ZWRFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4gZXh0ZW5zaW9uLm5hbWUpKTtcbiAgICAgICAgaWYgKGR1cGxpY2F0ZWROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogRHVwbGljYXRlIGV4dGVuc2lvbiBuYW1lcyBmb3VuZDogWyR7ZHVwbGljYXRlZE5hbWVzXG4gICAgICAgICAgICAgICAgLm1hcChpdGVtID0+IGAnJHtpdGVtfSdgKVxuICAgICAgICAgICAgICAgIC5qb2luKCcsICcpfV0uIFRoaXMgY2FuIGxlYWQgdG8gaXNzdWVzLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZEV4dGVuc2lvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZsYXR0ZW5lZCBhcnJheSBvZiBleHRlbnNpb25zIGJ5IHRyYXZlcnNpbmcgdGhlIGBhZGRFeHRlbnNpb25zYCBmaWVsZC5cbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIEEgZmxhdHRlbmVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICovXG4gICAgc3RhdGljIGZsYXR0ZW4oZXh0ZW5zaW9ucykge1xuICAgICAgICByZXR1cm4gKGV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkRXh0ZW5zaW9ucyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEV4dGVuc2lvbnMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZGRFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtleHRlbnNpb24sIC4uLnRoaXMuZmxhdHRlbihhZGRFeHRlbnNpb25zKCkpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgICAgIH0pXG4gICAgICAgICAgICAvLyBgSW5maW5pdHlgIHdpbGwgYnJlYWsgVHlwZVNjcmlwdCBzbyB3ZSBzZXQgYSBudW1iZXIgdGhhdCBpcyBwcm9iYWJseSBoaWdoIGVub3VnaFxuICAgICAgICAgICAgLmZsYXQoMTApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU29ydCBleHRlbnNpb25zIGJ5IHByaW9yaXR5LlxuICAgICAqIEBwYXJhbSBleHRlbnNpb25zIEFuIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zXG4gICAgICogQHJldHVybnMgQSBzb3J0ZWQgYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnMgYnkgcHJpb3JpdHlcbiAgICAgKi9cbiAgICBzdGF0aWMgc29ydChleHRlbnNpb25zKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRQcmlvcml0eSA9IDEwMDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlBID0gZ2V0RXh0ZW5zaW9uRmllbGQoYSwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgICAgICAgICAgY29uc3QgcHJpb3JpdHlCID0gZ2V0RXh0ZW5zaW9uRmllbGQoYiwgJ3ByaW9yaXR5JykgfHwgZGVmYXVsdFByaW9yaXR5O1xuICAgICAgICAgICAgaWYgKHByaW9yaXR5QSA+IHByaW9yaXR5Qikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmlvcml0eUEgPCBwcmlvcml0eUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBjb21tYW5kcyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBjb21tYW5kcyB3aGVyZSB0aGUga2V5IGlzIHRoZSBjb21tYW5kIG5hbWUgYW5kIHRoZSB2YWx1ZSBpcyB0aGUgY29tbWFuZCBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBjb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5yZWR1Y2UoKGNvbW1hbmRzLCBleHRlbnNpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgYWRkQ29tbWFuZHMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRDb21tYW5kcycsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKCFhZGRDb21tYW5kcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgICAgICAgICAgLi4uYWRkQ29tbWFuZHMoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCByZWdpc3RlcmVkIFByb3NlbWlycm9yIHBsdWdpbnMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBQcm9zZW1pcnJvciBwbHVnaW5zXG4gICAgICovXG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICAvLyBXaXRoIFByb3NlTWlycm9yLCBmaXJzdCBwbHVnaW5zIHdpdGhpbiBhbiBhcnJheSBhcmUgZXhlY3V0ZWQgZmlyc3QuXG4gICAgICAgIC8vIEluIFRpcHRhcCwgd2UgcHJvdmlkZSB0aGUgYWJpbGl0eSB0byBvdmVycmlkZSBwbHVnaW5zLFxuICAgICAgICAvLyBzbyBpdCBmZWVscyBtb3JlIG5hdHVyYWwgdG8gcnVuIHBsdWdpbnMgYXQgdGhlIGVuZCBvZiBhbiBhcnJheSBmaXJzdC5cbiAgICAgICAgLy8gVGhhdOKAmXMgd2h5IHdlIGhhdmUgdG8gcmV2ZXJzZSB0aGUgYGV4dGVuc2lvbnNgIGFycmF5IGFuZCBzb3J0IGFnYWluXG4gICAgICAgIC8vIGJhc2VkIG9uIHRoZSBgcHJpb3JpdHlgIG9wdGlvbi5cbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIuc29ydChbLi4udGhpcy5leHRlbnNpb25zXS5yZXZlcnNlKCkpO1xuICAgICAgICBjb25zdCBpbnB1dFJ1bGVzID0gW107XG4gICAgICAgIGNvbnN0IHBhc3RlUnVsZXMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsUGx1Z2lucyA9IGV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHR5cGU6IGdldFNjaGVtYVR5cGVCeU5hbWUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBwbHVnaW5zID0gW107XG4gICAgICAgICAgICBjb25zdCBhZGRLZXlib2FyZFNob3J0Y3V0cyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZEtleWJvYXJkU2hvcnRjdXRzJywgY29udGV4dCk7XG4gICAgICAgICAgICBsZXQgZGVmYXVsdEJpbmRpbmdzID0ge307XG4gICAgICAgICAgICAvLyBiaW5kIGV4aXQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnICYmIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2V4aXRhYmxlJywgY29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0QmluZGluZ3MuQXJyb3dSaWdodCA9ICgpID0+IE1hcmsuaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyazogZXh0ZW5zaW9uIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFkZEtleWJvYXJkU2hvcnRjdXRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmluZGluZ3MgPSBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmVudHJpZXMoYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSkubWFwKChbc2hvcnRjdXQsIG1ldGhvZF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzaG9ydGN1dCwgKCkgPT4gbWV0aG9kKHsgZWRpdG9yIH0pXTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEJpbmRpbmdzID0geyAuLi5kZWZhdWx0QmluZGluZ3MsIC4uLmJpbmRpbmdzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBrZXlNYXBQbHVnaW4gPSBrZXltYXAoZGVmYXVsdEJpbmRpbmdzKTtcbiAgICAgICAgICAgIHBsdWdpbnMucHVzaChrZXlNYXBQbHVnaW4pO1xuICAgICAgICAgICAgY29uc3QgYWRkSW5wdXRSdWxlcyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZElucHV0UnVsZXMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChpc0V4dGVuc2lvblJ1bGVzRW5hYmxlZChleHRlbnNpb24sIGVkaXRvci5vcHRpb25zLmVuYWJsZUlucHV0UnVsZXMpICYmIGFkZElucHV0UnVsZXMpIHtcbiAgICAgICAgICAgICAgICBpbnB1dFJ1bGVzLnB1c2goLi4uYWRkSW5wdXRSdWxlcygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZFBhc3RlUnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRQYXN0ZVJ1bGVzJywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVQYXN0ZVJ1bGVzKSAmJiBhZGRQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgcGFzdGVSdWxlcy5wdXNoKC4uLmFkZFBhc3RlUnVsZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRQcm9zZU1pcnJvclBsdWdpbnMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRQcm9zZU1pcnJvclBsdWdpbnMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChhZGRQcm9zZU1pcnJvclBsdWdpbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9zZU1pcnJvclBsdWdpbnMgPSBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKTtcbiAgICAgICAgICAgICAgICBwbHVnaW5zLnB1c2goLi4ucHJvc2VNaXJyb3JQbHVnaW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwbHVnaW5zO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZsYXQoKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGlucHV0UnVsZXNQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBydWxlczogaW5wdXRSdWxlcyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLi4ucGFzdGVSdWxlc1BsdWdpbih7XG4gICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgIHJ1bGVzOiBwYXN0ZVJ1bGVzLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAuLi5hbGxQbHVnaW5zLFxuICAgICAgICBdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGF0dHJpYnV0ZXMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhdHRyaWJ1dGVzXG4gICAgICovXG4gICAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBub2RlIHZpZXdzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAgICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYWxsIG5vZGUgdmlld3Mgd2hlcmUgdGhlIGtleSBpcyB0aGUgbm9kZSBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG5vZGUgdmlldyBmdW5jdGlvblxuICAgICAqL1xuICAgIGdldCBub2RlVmlld3MoKSB7XG4gICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IG5vZGVFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnModGhpcy5leHRlbnNpb25zKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhub2RlRXh0ZW5zaW9uc1xuICAgICAgICAgICAgLmZpbHRlcihleHRlbnNpb24gPT4gISFnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGROb2RlVmlldycpKVxuICAgICAgICAgICAgLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcy5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXROb2RlVHlwZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFkZE5vZGVWaWV3ID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghYWRkTm9kZVZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RldmlldyA9IChub2RlLCB2aWV3LCBnZXRQb3MsIGRlY29yYXRpb25zLCBpbm5lckRlY29yYXRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXMobm9kZSwgZXh0ZW5zaW9uQXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZE5vZGVWaWV3KCkoe1xuICAgICAgICAgICAgICAgICAgICAvLyBwYXNzLXRocm91Z2hcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgICAgICAgICAgZ2V0UG9zOiBnZXRQb3MsXG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICBpbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aXB0YXAtc3BlY2lmaWNcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICBleHRlbnNpb24sXG4gICAgICAgICAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIG5vZGV2aWV3XTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHbyB0aHJvdWdoIGFsbCBleHRlbnNpb25zLCBjcmVhdGUgZXh0ZW5zaW9uIHN0b3JhZ2VzICYgc2V0dXAgbWFya3NcbiAgICAgKiAmIGJpbmQgZWRpdG9yIGV2ZW50IGxpc3RlbmVyLlxuICAgICAqL1xuICAgIHNldHVwRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgdGhpcy5leHRlbnNpb25zLmZvckVhY2goZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIHN0b3JlIGV4dGVuc2lvbiBzdG9yYWdlIGluIGVkaXRvclxuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZXh0ZW5zaW9uU3RvcmFnZVtleHRlbnNpb24ubmFtZV0gPSBleHRlbnNpb24uc3RvcmFnZTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4dGVuc2lvbi50eXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZWVwT25TcGxpdCA9IChfYSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdrZWVwT25TcGxpdCcsIGNvbnRleHQpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2VlcE9uU3BsaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdHRhYmxlTWFya3MucHVzaChleHRlbnNpb24ubmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb25CZWZvcmVDcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJlZm9yZUNyZWF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25DcmVhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkNyZWF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblVwZGF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25TZWxlY3Rpb25VcGRhdGUgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblNlbGVjdGlvblVwZGF0ZScsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25UcmFuc2FjdGlvbiA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uVHJhbnNhY3Rpb24nLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRm9jdXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkZvY3VzJywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvbkJsdXIgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkJsdXInLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRGVzdHJveSA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ29uRGVzdHJveScsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG9uQmVmb3JlQ3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JlZm9yZUNyZWF0ZScsIG9uQmVmb3JlQ3JlYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdjcmVhdGUnLCBvbkNyZWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25VcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbigndXBkYXRlJywgb25VcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uU2VsZWN0aW9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3NlbGVjdGlvblVwZGF0ZScsIG9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3RyYW5zYWN0aW9uJywgb25UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25Gb2N1cykge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIG9uRm9jdXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uQmx1cikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgb25CbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignZGVzdHJveScsIG9uRGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaGUgRXh0ZW5zaW9uIGNsYXNzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuY2xhc3MgRXh0ZW5zaW9uIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcgPSB7fSkge1xuICAgICAgICB0aGlzLnR5cGUgPSAnZXh0ZW5zaW9uJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ2V4dGVuc2lvbic7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pKSB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IEV4dGVuc2lvbihjb25maWcpO1xuICAgIH1cbiAgICBjb25maWd1cmUob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIHJldHVybiBhIG5ldyBpbnN0YW5jZSBzbyB3ZSBjYW4gdXNlIHRoZSBzYW1lIGV4dGVuc2lvblxuICAgICAgICAvLyB3aXRoIGRpZmZlcmVudCBjYWxscyBvZiBgY29uZmlndXJlYFxuICAgICAgICBjb25zdCBleHRlbnNpb24gPSB0aGlzLmV4dGVuZCh7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIGFkZE9wdGlvbnM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVyZ2VEZWVwKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWx3YXlzIHByZXNlcnZlIHRoZSBjdXJyZW50IG5hbWVcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIC8vIFNldCB0aGUgcGFyZW50IHRvIGJlIG91ciBwYXJlbnRcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXMucGFyZW50O1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBleHRlbmQoZXh0ZW5kZWRDb25maWcgPSB7fSkge1xuICAgICAgICBjb25zdCBleHRlbnNpb24gPSBuZXcgRXh0ZW5zaW9uKHsgLi4udGhpcy5jb25maWcsIC4uLmV4dGVuZGVkQ29uZmlnIH0pO1xuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICB9KSk7XG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgYmV0d2VlbiB0d28gcG9zaXRpb25zIGluIGEgUHJvc2VtaXJyb3Igbm9kZVxuICogYW5kIHNlcmlhbGl6ZXMgaXQgdXNpbmcgdGhlIGdpdmVuIHRleHQgc2VyaWFsaXplcnMgYW5kIGJsb2NrIHNlcGFyYXRvciAoc2VlIGdldFRleHQpXG4gKiBAcGFyYW0gc3RhcnROb2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHN0YXJ0IGZyb21cbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGhlIHRleHQgdG8gZ2V0XG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGV4dCBzZXJpYWxpemVyICYgYmxvY2sgc2VwYXJhdG9yXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBiZXR3ZWVuIHRoZSB0d28gcG9zaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRCZXR3ZWVuKHN0YXJ0Tm9kZSwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgc3RhcnROb2RlLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcywgcGFyZW50LCBpbmRleCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgcG9zID4gZnJvbSkge1xuICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplciA9IHRleHRTZXJpYWxpemVycyA9PT0gbnVsbCB8fCB0ZXh0U2VyaWFsaXplcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRleHRTZXJpYWxpemVyc1tub2RlLnR5cGUubmFtZV07XG4gICAgICAgIGlmICh0ZXh0U2VyaWFsaXplcikge1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gdGV4dFNlcmlhbGl6ZXIoe1xuICAgICAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZG8gbm90IGRlc2NlbmQgaW50byBjaGlsZCBub2RlcyB3aGVuIHRoZXJlIGV4aXN0cyBhIHNlcmlhbGl6ZXJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIHRleHQgKz0gKF9hID0gbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbGljZShNYXRoLm1heChmcm9tLCBwb3MpIC0gcG9zLCB0byAtIHBvcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0O1xufVxuXG4vKipcbiAqIEZpbmQgdGV4dCBzZXJpYWxpemVycyBgdG9UZXh0YCBpbiBhIFByb3NlbWlycm9yIHNjaGVtYVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHNlYXJjaCBpblxuICogQHJldHVybnMgQSByZWNvcmQgb2YgdGV4dCBzZXJpYWxpemVycyBieSBub2RlIG5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpIHtcbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHNjaGVtYS5ub2RlcylcbiAgICAgICAgLmZpbHRlcigoWywgbm9kZV0pID0+IG5vZGUuc3BlYy50b1RleHQpXG4gICAgICAgIC5tYXAoKFtuYW1lLCBub2RlXSkgPT4gW25hbWUsIG5vZGUuc3BlYy50b1RleHRdKSk7XG59XG5cbmNvbnN0IENsaXBib2FyZFRleHRTZXJpYWxpemVyID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmxvY2tTZXBhcmF0b3I6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXInKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBjbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBzY2hlbWEgfSA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTZXJpYWxpemVycyA9IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tLCB0byB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFRleHRCZXR3ZWVuKGRvYywgcmFuZ2UsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4odGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGJsb2NrU2VwYXJhdG9yOiB0aGlzLm9wdGlvbnMuYmxvY2tTZXBhcmF0b3IgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0U2VyaWFsaXplcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBibHVyID0gKCkgPT4gKHsgZWRpdG9yLCB2aWV3IH0pID0+IHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICAvLyBCcm93c2VycyBzaG91bGQgcmVtb3ZlIHRoZSBjYXJldCBvbiBibHVyIGJ1dCBzYWZhcmkgZG9lcyBub3QuXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMjQwNVxuICAgICAgICAgICAgKF9hID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LmdldFNlbGVjdGlvbigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGNsZWFyQ29udGVudCA9IChlbWl0VXBkYXRlID0gZmFsc2UpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICByZXR1cm4gY29tbWFuZHMuc2V0Q29udGVudCgnJywgZW1pdFVwZGF0ZSk7XG59O1xuXG5jb25zdCBjbGVhck5vZGVzID0gKCkgPT4gKHsgc3RhdGUsIHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKCFkaXNwYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZG9jLCBtYXBwaW5nIH0gPSB0cjtcbiAgICAgICAgICAgIGNvbnN0ICRtYXBwZWRGcm9tID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zKSk7XG4gICAgICAgICAgICBjb25zdCAkbWFwcGVkVG8gPSBkb2MucmVzb2x2ZShtYXBwaW5nLm1hcChwb3MgKyBub2RlLm5vZGVTaXplKSk7XG4gICAgICAgICAgICBjb25zdCBub2RlUmFuZ2UgPSAkbWFwcGVkRnJvbS5ibG9ja1JhbmdlKCRtYXBwZWRUbyk7XG4gICAgICAgICAgICBpZiAoIW5vZGVSYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExpZnREZXB0aCA9IGxpZnRUYXJnZXQobm9kZVJhbmdlKTtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRlZmF1bHRUeXBlIH0gPSAkbWFwcGVkRnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJG1hcHBlZEZyb20uaW5kZXgoKSk7XG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChub2RlUmFuZ2Uuc3RhcnQsIGRlZmF1bHRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXJnZXRMaWZ0RGVwdGggfHwgdGFyZ2V0TGlmdERlcHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdHIubGlmdChub2RlUmFuZ2UsIHRhcmdldExpZnREZXB0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgY29tbWFuZCA9IGZuID0+IHByb3BzID0+IHtcbiAgICByZXR1cm4gZm4ocHJvcHMpO1xufTtcblxuY29uc3QgY3JlYXRlUGFyYWdyYXBoTmVhciA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcmFncmFwaE5lYXIkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgY3V0ID0gKG9yaWdpblJhbmdlLCB0YXJnZXRQb3MpID0+ICh7IGVkaXRvciwgdHIgfSkgPT4ge1xuICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICBjb25zdCBjb250ZW50U2xpY2UgPSBzdGF0ZS5kb2Muc2xpY2Uob3JpZ2luUmFuZ2UuZnJvbSwgb3JpZ2luUmFuZ2UudG8pO1xuICAgIHRyLmRlbGV0ZVJhbmdlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcbiAgICBjb25zdCBuZXdQb3MgPSB0ci5tYXBwaW5nLm1hcCh0YXJnZXRQb3MpO1xuICAgIHRyLmluc2VydChuZXdQb3MsIGNvbnRlbnRTbGljZS5jb250ZW50KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24obmV3IFRleHRTZWxlY3Rpb24odHIuZG9jLnJlc29sdmUoTWF0aC5tYXgobmV3UG9zIC0gMSwgMCkpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBkZWxldGVDdXJyZW50Tm9kZSA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICAgIGNvbnN0IGN1cnJlbnROb2RlID0gc2VsZWN0aW9uLiRhbmNob3Iubm9kZSgpO1xuICAgIC8vIGlmIHRoZXJlIGlzIGNvbnRlbnQgaW5zaWRlIHRoZSBjdXJyZW50IG5vZGUsIGJyZWFrIG91dCBvZiB0aGlzIGNvbW1hbmRcbiAgICBpZiAoY3VycmVudE5vZGUuY29udGVudC5zaXplID4gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gY3VycmVudE5vZGUudHlwZSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpO1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGRlbGV0ZU5vZGUgPSB0eXBlT3JOYW1lID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0ICRwb3MgPSB0ci5zZWxlY3Rpb24uJGFuY2hvcjtcbiAgICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGggLT0gMSkge1xuICAgICAgICBjb25zdCBub2RlID0gJHBvcy5ub2RlKGRlcHRoKTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gdHlwZSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9ICRwb3MuYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0byA9ICRwb3MuYWZ0ZXIoZGVwdGgpO1xuICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0bykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGRlbGV0ZVJhbmdlID0gcmFuZ2UgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSByYW5nZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBkZWxldGVTZWxlY3Rpb24gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBkZWxldGVTZWxlY3Rpb24kMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgZW50ZXIgPSAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLmtleWJvYXJkU2hvcnRjdXQoJ0VudGVyJyk7XG59O1xuXG5jb25zdCBleGl0Q29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGV4aXRDb2RlJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgb2JqZWN0MSBpbmNsdWRlcyBvYmplY3QyXG4gKiBAcGFyYW0gb2JqZWN0MSBPYmplY3RcbiAqIEBwYXJhbSBvYmplY3QyIE9iamVjdFxuICovXG5mdW5jdGlvbiBvYmplY3RJbmNsdWRlcyhvYmplY3QxLCBvYmplY3QyLCBvcHRpb25zID0geyBzdHJpY3Q6IHRydWUgfSkge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcbiAgICBpZiAoIWtleXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cy5ldmVyeShrZXkgPT4ge1xuICAgICAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWdFeHAob2JqZWN0MltrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDJba2V5XS50ZXN0KG9iamVjdDFba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDJba2V5XSA9PT0gb2JqZWN0MVtrZXldO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICByZXR1cm4gbWFya3MuZmluZChpdGVtID0+IHtcbiAgICAgICAgcmV0dXJuIChpdGVtLnR5cGUgPT09IHR5cGVcbiAgICAgICAgICAgICYmIG9iamVjdEluY2x1ZGVzKFxuICAgICAgICAgICAgLy8gT25seSBjaGVjayBlcXVhbGl0eSBmb3IgdGhlIGF0dHJpYnV0ZXMgdGhhdCBhcmUgcHJvdmlkZWRcbiAgICAgICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5tYXAoayA9PiBbaywgaXRlbS5hdHRyc1trXV0pKSwgYXR0cmlidXRlcykpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIHJldHVybiAhIWZpbmRNYXJrSW5TZXQobWFya3MsIHR5cGUsIGF0dHJpYnV0ZXMpO1xufVxuLyoqXG4gKiBHZXQgdGhlIHJhbmdlIG9mIGEgbWFyayBhdCBhIHJlc29sdmVkIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrUmFuZ2UoXG4vKipcbiAqIFRoZSBwb3NpdGlvbiB0byBnZXQgdGhlIG1hcmsgcmFuZ2UgZm9yLlxuICovXG4kcG9zLCBcbi8qKlxuICogVGhlIG1hcmsgdHlwZSB0byBnZXQgdGhlIHJhbmdlIGZvci5cbiAqL1xudHlwZSwgXG4vKipcbiAqIFRoZSBhdHRyaWJ1dGVzIHRvIG1hdGNoIGFnYWluc3QuXG4gKiBJZiBub3QgcHJvdmlkZWQsIG9ubHkgdGhlIGZpcnN0IG1hcmsgYXQgdGhlIHBvc2l0aW9uIHdpbGwgYmUgbWF0Y2hlZC5cbiAqL1xuYXR0cmlidXRlcykge1xuICAgIHZhciBfYTtcbiAgICBpZiAoISRwb3MgfHwgIXR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEFmdGVyKCRwb3MucGFyZW50T2Zmc2V0KTtcbiAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBzdGFydCBvZiBhIHRleHQgbm9kZSB0aGF0IGRvZXMgbm90IGhhdmUgdGhlIG1hcmssIGxvb2sgYmFja3dhcmRcbiAgICBpZiAoIXN0YXJ0Lm5vZGUgfHwgIXN0YXJ0Lm5vZGUubWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgc3RhcnQgPSAkcG9zLnBhcmVudC5jaGlsZEJlZm9yZSgkcG9zLnBhcmVudE9mZnNldCk7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlIGlzIG5vIHRleHQgbm9kZSB3aXRoIHRoZSBtYXJrIGV2ZW4gYmFja3dhcmQsIHJldHVybiB1bmRlZmluZWRcbiAgICBpZiAoIXN0YXJ0Lm5vZGUgfHwgIXN0YXJ0Lm5vZGUubWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0IHRvIG9ubHkgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgZmlyc3QgbWFyaydzIGF0dHJpYnV0ZXNcbiAgICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCAoKF9hID0gc3RhcnQubm9kZS5tYXJrc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKTtcbiAgICAvLyBXZSBub3cga25vdyB0aGF0IHRoZSBjdXJzb3IgaXMgZWl0aGVyIGF0IHRoZSBzdGFydCwgbWlkZGxlIG9yIGVuZCBvZiBhIHRleHQgbm9kZSB3aXRoIHRoZSBzcGVjaWZpZWQgbWFya1xuICAgIC8vIHNvIHdlIGNhbiBsb29rIGl0IHVwIG9uIHRoZSB0YXJnZXRlZCBtYXJrXG4gICAgY29uc3QgbWFyayA9IGZpbmRNYXJrSW5TZXQoWy4uLnN0YXJ0Lm5vZGUubWFya3NdLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAoIW1hcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3RhcnRJbmRleCA9IHN0YXJ0LmluZGV4O1xuICAgIGxldCBzdGFydFBvcyA9ICRwb3Muc3RhcnQoKSArIHN0YXJ0Lm9mZnNldDtcbiAgICBsZXQgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgMTtcbiAgICBsZXQgZW5kUG9zID0gc3RhcnRQb3MgKyBzdGFydC5ub2RlLm5vZGVTaXplO1xuICAgIHdoaWxlIChzdGFydEluZGV4ID4gMFxuICAgICAgICAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICAgICAgc3RhcnRJbmRleCAtPSAxO1xuICAgICAgICBzdGFydFBvcyAtPSAkcG9zLnBhcmVudC5jaGlsZChzdGFydEluZGV4KS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgd2hpbGUgKGVuZEluZGV4IDwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudFxuICAgICAgICAmJiBpc01hcmtJblNldChbLi4uJHBvcy5wYXJlbnQuY2hpbGQoZW5kSW5kZXgpLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcykpIHtcbiAgICAgICAgZW5kUG9zICs9ICRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5ub2RlU2l6ZTtcbiAgICAgICAgZW5kSW5kZXggKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogc3RhcnRQb3MsXG4gICAgICAgIHRvOiBlbmRQb3MsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya1R5cGUobmFtZU9yVHlwZSwgc2NoZW1hKSB7XG4gICAgaWYgKHR5cGVvZiBuYW1lT3JUeXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoIXNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFRoZXJlIGlzIG5vIG1hcmsgdHlwZSBuYW1lZCAnJHtuYW1lT3JUeXBlfScuIE1heWJlIHlvdSBmb3Jnb3QgdG8gYWRkIHRoZSBleHRlbnNpb24/YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjaGVtYS5tYXJrc1tuYW1lT3JUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVPclR5cGU7XG59XG5cbmNvbnN0IGV4dGVuZE1hcmtSYW5nZSA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IHsgZG9jLCBzZWxlY3Rpb24gfSA9IHRyO1xuICAgIGNvbnN0IHsgJGZyb20sIGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRmcm9tLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKHJhbmdlICYmIHJhbmdlLmZyb20gPD0gZnJvbSAmJiByYW5nZS50byA+PSB0bykge1xuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCByYW5nZS5mcm9tLCByYW5nZS50byk7XG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGZpcnN0ID0gY29tbWFuZHMgPT4gcHJvcHMgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gdHlwZW9mIGNvbW1hbmRzID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gY29tbWFuZHMocHJvcHMpXG4gICAgICAgIDogY29tbWFuZHM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlbXNbaV0ocHJvcHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBpc1RleHRTZWxlY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uO1xufVxuXG5mdW5jdGlvbiBtaW5NYXgodmFsdWUgPSAwLCBtaW4gPSAwLCBtYXggPSAwKSB7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCBtaW4pLCBtYXgpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlRm9jdXNQb3NpdGlvbihkb2MsIHBvc2l0aW9uID0gbnVsbCkge1xuICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbkF0U3RhcnQgPSBTZWxlY3Rpb24uYXRTdGFydChkb2MpO1xuICAgIGNvbnN0IHNlbGVjdGlvbkF0RW5kID0gU2VsZWN0aW9uLmF0RW5kKGRvYyk7XG4gICAgaWYgKHBvc2l0aW9uID09PSAnc3RhcnQnIHx8IHBvc2l0aW9uID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25BdFN0YXJ0O1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPT09ICdlbmQnKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb25BdEVuZDtcbiAgICB9XG4gICAgY29uc3QgbWluUG9zID0gc2VsZWN0aW9uQXRTdGFydC5mcm9tO1xuICAgIGNvbnN0IG1heFBvcyA9IHNlbGVjdGlvbkF0RW5kLnRvO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2FsbCcpIHtcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbWluTWF4KDAsIG1pblBvcywgbWF4UG9zKSwgbWluTWF4KGRvYy5jb250ZW50LnNpemUsIG1pblBvcywgbWF4UG9zKSk7XG4gICAgfVxuICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG1pbk1heChwb3NpdGlvbiwgbWluUG9zLCBtYXhQb3MpLCBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSk7XG59XG5cbmZ1bmN0aW9uIGlzQW5kcm9pZCgpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnBsYXRmb3JtID09PSAnQW5kcm9pZCcgfHwgL2FuZHJvaWQvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG5mdW5jdGlvbiBpc2lPUygpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnaVBhZCBTaW11bGF0b3InLFxuICAgICAgICAnaVBob25lIFNpbXVsYXRvcicsXG4gICAgICAgICdpUG9kIFNpbXVsYXRvcicsXG4gICAgICAgICdpUGFkJyxcbiAgICAgICAgJ2lQaG9uZScsXG4gICAgICAgICdpUG9kJyxcbiAgICBdLmluY2x1ZGVzKG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAgICAgLy8gaVBhZCBvbiBpT1MgMTMgZGV0ZWN0aW9uXG4gICAgICAgIHx8IChuYXZpZ2F0b3IudXNlckFnZW50LmluY2x1ZGVzKCdNYWMnKSAmJiAnb250b3VjaGVuZCcgaW4gZG9jdW1lbnQpO1xufVxuXG5jb25zdCBmb2N1cyA9IChwb3NpdGlvbiA9IG51bGwsIG9wdGlvbnMgPSB7fSkgPT4gKHsgZWRpdG9yLCB2aWV3LCB0ciwgZGlzcGF0Y2gsIH0pID0+IHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgICBzY3JvbGxJbnRvVmlldzogdHJ1ZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IGRlbGF5ZWRGb2N1cyA9ICgpID0+IHtcbiAgICAgICAgLy8gZm9jdXMgd2l0aGluIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGJyZWFrcyBmb2N1cyBvbiBpT1MgYW5kIEFuZHJvaWRcbiAgICAgICAgLy8gc28gd2UgaGF2ZSB0byBjYWxsIHRoaXNcbiAgICAgICAgaWYgKGlzaU9TKCkgfHwgaXNBbmRyb2lkKCkpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yIFJlYWN0IHdlIGhhdmUgdG8gZm9jdXMgYXN5bmNocm9ub3VzbHkuIE90aGVyd2lzZSB3aWxkIHRoaW5ncyBoYXBwZW4uXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xNTIwXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHZpZXcuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcm9sbEludG9WaWV3KSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5jb21tYW5kcy5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoKHZpZXcuaGFzRm9jdXMoKSAmJiBwb3NpdGlvbiA9PT0gbnVsbCkgfHwgcG9zaXRpb24gPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyB3ZSBkb27igJl0IHRyeSB0byByZXNvbHZlIGEgTm9kZVNlbGVjdGlvbiBvciBDZWxsU2VsZWN0aW9uXG4gICAgaWYgKGRpc3BhdGNoICYmIHBvc2l0aW9uID09PSBudWxsICYmICFpc1RleHRTZWxlY3Rpb24oZWRpdG9yLnN0YXRlLnNlbGVjdGlvbikpIHtcbiAgICAgICAgZGVsYXllZEZvY3VzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBwYXNzIHRocm91Z2ggdHIuZG9jIGluc3RlYWQgb2YgZWRpdG9yLnN0YXRlLmRvY1xuICAgIC8vIHNpbmNlIHRyYW5zYWN0aW9ucyBjb3VsZCBjaGFuZ2UgdGhlIGVkaXRvcnMgc3RhdGUgYmVmb3JlIHRoaXMgY29tbWFuZCBoYXMgYmVlbiBydW5cbiAgICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbih0ci5kb2MsIHBvc2l0aW9uKSB8fCBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0IGlzU2FtZVNlbGVjdGlvbiA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgaWYgKCFpc1NhbWVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGB0ci5zZXRTZWxlY3Rpb25gIHJlc2V0cyB0aGUgc3RvcmVkIG1hcmtzXG4gICAgICAgIC8vIHNvIHdl4oCZbGwgcmVzdG9yZSB0aGVtIGlmIHRoZSBzZWxlY3Rpb24gaXMgdGhlIHNhbWUgYXMgYmVmb3JlXG4gICAgICAgIGlmIChpc1NhbWVTZWxlY3Rpb24gJiYgdHIuc3RvcmVkTWFya3MpIHtcbiAgICAgICAgICAgIHRyLnNldFN0b3JlZE1hcmtzKHRyLnN0b3JlZE1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxheWVkRm9jdXMoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBmb3JFYWNoID0gKGl0ZW1zLCBmbikgPT4gcHJvcHMgPT4ge1xuICAgIHJldHVybiBpdGVtcy5ldmVyeSgoaXRlbSwgaW5kZXgpID0+IGZuKGl0ZW0sIHsgLi4ucHJvcHMsIGluZGV4IH0pKTtcbn07XG5cbmNvbnN0IGluc2VydENvbnRlbnQgPSAodmFsdWUsIG9wdGlvbnMpID0+ICh7IHRyLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLmluc2VydENvbnRlbnRBdCh7IGZyb206IHRyLnNlbGVjdGlvbi5mcm9tLCB0bzogdHIuc2VsZWN0aW9uLnRvIH0sIHZhbHVlLCBvcHRpb25zKTtcbn07XG5cbmNvbnN0IHJlbW92ZVdoaXRlc3BhY2VzID0gKG5vZGUpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAzICYmIGNoaWxkLm5vZGVWYWx1ZSAmJiAvXihcXG5cXHNcXHN8XFxuKSQvLnRlc3QoY2hpbGQubm9kZVZhbHVlKSkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICAgIHJlbW92ZVdoaXRlc3BhY2VzKGNoaWxkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn07XG5mdW5jdGlvbiBlbGVtZW50RnJvbVN0cmluZyh2YWx1ZSkge1xuICAgIC8vIGFkZCBhIHdyYXBwZXIgdG8gcHJlc2VydmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgIGNvbnN0IHdyYXBwZWRWYWx1ZSA9IGA8Ym9keT4ke3ZhbHVlfTwvYm9keT5gO1xuICAgIGNvbnN0IGh0bWwgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh3cmFwcGVkVmFsdWUsICd0ZXh0L2h0bWwnKS5ib2R5O1xuICAgIHJldHVybiByZW1vdmVXaGl0ZXNwYWNlcyhodG1sKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIEpTT04gb3IgSFRNTCBjb250ZW50IGFuZCBjcmVhdGVzIGEgUHJvc2VtaXJyb3Igbm9kZSBvciBmcmFnbWVudCBmcm9tIGl0LlxuICogQHBhcmFtIGNvbnRlbnQgVGhlIEpTT04gb3IgSFRNTCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgbm9kZSBmcm9tXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcnJvciBzY2hlbWEgdG8gdXNlIGZvciB0aGUgbm9kZVxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHBhcnNlclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgUHJvc2VtaXJyb3Igbm9kZSBvciBmcmFnbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoY29udGVudCwgc2NoZW1hLCBvcHRpb25zKSB7XG4gICAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBOb2RlJDEgfHwgY29udGVudCBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cbiAgICBvcHRpb25zID0ge1xuICAgICAgICBzbGljZTogdHJ1ZSxcbiAgICAgICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IGlzSlNPTkNvbnRlbnQgPSB0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgY29udGVudCAhPT0gbnVsbDtcbiAgICBjb25zdCBpc1RleHRDb250ZW50ID0gdHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnO1xuICAgIGlmIChpc0pTT05Db250ZW50KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBpc0FycmF5Q29udGVudCA9IEFycmF5LmlzQXJyYXkoY29udGVudCkgJiYgY29udGVudC5sZW5ndGggPiAwO1xuICAgICAgICAgICAgLy8gaWYgdGhlIEpTT04gQ29udGVudCBpcyBhbiBhcnJheSBvZiBub2RlcywgY3JlYXRlIGEgZnJhZ21lbnQgZm9yIGVhY2ggbm9kZVxuICAgICAgICAgICAgaWYgKGlzQXJyYXlDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShjb250ZW50Lm1hcChpdGVtID0+IHNjaGVtYS5ub2RlRnJvbUpTT04oaXRlbSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzY2hlbWEubm9kZUZyb21KU09OKGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1t0aXB0YXAgZXJyb3JdOiBJbnZhbGlkIEpTT04gY29udGVudCcsIHsgY2F1c2U6IGVycm9yIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBJbnZhbGlkIGNvbnRlbnQuJywgJ1Bhc3NlZCB2YWx1ZTonLCBjb250ZW50LCAnRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudCgnJywgc2NoZW1hLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNUZXh0Q29udGVudCkge1xuICAgICAgICAvLyBDaGVjayBmb3IgaW52YWxpZCBjb250ZW50XG4gICAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGhhc0ludmFsaWRDb250ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgaW52YWxpZENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIC8vIEEgY29weSBvZiB0aGUgY3VycmVudCBzY2hlbWEgd2l0aCBhIGNhdGNoLWFsbCBub2RlIGF0IHRoZSBlbmRcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRDaGVja1NjaGVtYSA9IG5ldyBTY2hlbWEoe1xuICAgICAgICAgICAgICAgIHRvcE5vZGU6IHNjaGVtYS5zcGVjLnRvcE5vZGUsXG4gICAgICAgICAgICAgICAgbWFya3M6IHNjaGVtYS5zcGVjLm1hcmtzLFxuICAgICAgICAgICAgICAgIC8vIFByb3NlbWlycm9yJ3Mgc2NoZW1hcyBhcmUgZXhlY3V0ZWQgc3VjaCB0aGF0OiB0aGUgbGFzdCB0byBleGVjdXRlLCBtYXRjaGVzIGxhc3RcbiAgICAgICAgICAgICAgICAvLyBUaGlzIG1lYW5zIHRoYXQgd2UgY2FuIGFkZCBhIGNhdGNoLWFsbCBub2RlIGF0IHRoZSBlbmQgb2YgdGhlIHNjaGVtYSB0byBjYXRjaCBhbnkgY29udGVudCB0aGF0IHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZVxuICAgICAgICAgICAgICAgIG5vZGVzOiBzY2hlbWEuc3BlYy5ub2Rlcy5hcHBlbmQoe1xuICAgICAgICAgICAgICAgICAgICBfX3RpcHRhcF9fcHJpdmF0ZV9fdW5rbm93bl9fY2F0Y2hfX2FsbF9fbm9kZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogJ2lubGluZSonLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXA6ICdibG9jaycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZURPTTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFnOiAnKicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEF0dHJzOiBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgZXZlciBjYWxsZWQsIHdlIGtub3cgdGhhdCB0aGUgY29udGVudCBoYXMgc29tZXRoaW5nIHRoYXQgd2UgZG9uJ3Qga25vdyBob3cgdG8gaGFuZGxlIGluIHRoZSBzY2hlbWFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0ludmFsaWRDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzdHJpbmdpZnkgdGhlIGVsZW1lbnQgZm9yIGEgbW9yZSBoZWxwZnVsIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWRDb250ZW50ID0gdHlwZW9mIGUgPT09ICdzdHJpbmcnID8gZSA6IGUub3V0ZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNsaWNlKSB7XG4gICAgICAgICAgICAgICAgRE9NUGFyc2VyLmZyb21TY2hlbWEoY29udGVudENoZWNrU2NoZW1hKS5wYXJzZVNsaWNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBET01QYXJzZXIuZnJvbVNjaGVtYShjb250ZW50Q2hlY2tTY2hlbWEpLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQgJiYgaGFzSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1t0aXB0YXAgZXJyb3JdOiBJbnZhbGlkIEhUTUwgY29udGVudCcsIHsgY2F1c2U6IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IGZvdW5kOiAke2ludmFsaWRDb250ZW50fWApIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IERPTVBhcnNlci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgIGlmIChvcHRpb25zLnNsaWNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlU2xpY2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZXIucGFyc2UoZWxlbWVudEZyb21TdHJpbmcoY29udGVudCksIG9wdGlvbnMucGFyc2VPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudCgnJywgc2NoZW1hLCBvcHRpb25zKTtcbn1cblxuLy8gc291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itc3RhdGUvYmxvYi9tYXN0ZXIvc3JjL3NlbGVjdGlvbi5qcyNMNDY2XG5mdW5jdGlvbiBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgc3RhcnRMZW4sIGJpYXMpIHtcbiAgICBjb25zdCBsYXN0ID0gdHIuc3RlcHMubGVuZ3RoIC0gMTtcbiAgICBpZiAobGFzdCA8IHN0YXJ0TGVuKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RlcCA9IHRyLnN0ZXBzW2xhc3RdO1xuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gdHIubWFwcGluZy5tYXBzW2xhc3RdO1xuICAgIGxldCBlbmQgPSAwO1xuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHtcbiAgICAgICAgaWYgKGVuZCA9PT0gMCkge1xuICAgICAgICAgICAgZW5kID0gbmV3VG87XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoZW5kKSwgYmlhcykpO1xufVxuXG5jb25zdCBpc0ZyYWdtZW50ID0gKG5vZGVPckZyYWdtZW50KSA9PiB7XG4gICAgcmV0dXJuICEoJ3R5cGUnIGluIG5vZGVPckZyYWdtZW50KTtcbn07XG5jb25zdCBpbnNlcnRDb250ZW50QXQgPSAocG9zaXRpb24sIHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgZGlzcGF0Y2gsIGVkaXRvciB9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgcGFyc2VPcHRpb25zOiBlZGl0b3Iub3B0aW9ucy5wYXJzZU9wdGlvbnMsXG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb246IHRydWUsXG4gICAgICAgICAgICBhcHBseUlucHV0UnVsZXM6IGZhbHNlLFxuICAgICAgICAgICAgYXBwbHlQYXN0ZVJ1bGVzOiBmYWxzZSxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBjb250ZW50O1xuICAgICAgICBjb25zdCBlbWl0Q29udGVudEVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuZW1pdCgnY29udGVudEVycm9yJywge1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ29sbGFib3JhdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLnN0b3JhZ2UuY29sbGFib3JhdGlvbi5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGFyc2VPcHRpb25zID0ge1xuICAgICAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAnZnVsbCcsXG4gICAgICAgICAgICAuLi5vcHRpb25zLnBhcnNlT3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgYGVtaXRDb250ZW50RXJyb3JgIGlzIGVuYWJsZWQsIHdlIHdhbnQgdG8gY2hlY2sgdGhlIGNvbnRlbnQgZm9yIGVycm9yc1xuICAgICAgICAvLyBidXQgaWdub3JlIHRoZW0gKGRvIG5vdCByZW1vdmUgdGhlIGludmFsaWQgY29udGVudCBmcm9tIHRoZSBkb2N1bWVudClcbiAgICAgICAgaWYgKCFvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCAmJiAhZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrICYmIGVkaXRvci5vcHRpb25zLmVtaXRDb250ZW50RXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlbWl0Q29udGVudEVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb250ZW50ID0gY3JlYXRlTm9kZUZyb21Db250ZW50KHZhbHVlLCBlZGl0b3Iuc2NoZW1hLCB7XG4gICAgICAgICAgICAgICAgcGFyc2VPcHRpb25zLFxuICAgICAgICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9hID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBlbWl0Q29udGVudEVycm9yKGUpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiB7IGZyb206IHBvc2l0aW9uLmZyb20sIHRvOiBwb3NpdGlvbi50byB9O1xuICAgICAgICBsZXQgaXNPbmx5VGV4dENvbnRlbnQgPSB0cnVlO1xuICAgICAgICBsZXQgaXNPbmx5QmxvY2tDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBpc0ZyYWdtZW50KGNvbnRlbnQpID8gY29udGVudCA6IFtjb250ZW50XTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIGFkZGVkIG5vZGUgaXMgdmFsaWRcbiAgICAgICAgICAgIG5vZGUuY2hlY2soKTtcbiAgICAgICAgICAgIGlzT25seVRleHRDb250ZW50ID0gaXNPbmx5VGV4dENvbnRlbnQgPyBub2RlLmlzVGV4dCAmJiBub2RlLm1hcmtzLmxlbmd0aCA9PT0gMCA6IGZhbHNlO1xuICAgICAgICAgICAgaXNPbmx5QmxvY2tDb250ZW50ID0gaXNPbmx5QmxvY2tDb250ZW50ID8gbm9kZS5pc0Jsb2NrIDogZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjaGVjayBpZiB3ZSBjYW4gcmVwbGFjZSB0aGUgd3JhcHBpbmcgbm9kZSBieVxuICAgICAgICAvLyB0aGUgbmV3bHkgaW5zZXJ0ZWQgY29udGVudFxuICAgICAgICAvLyBleGFtcGxlOlxuICAgICAgICAvLyByZXBsYWNlIGFuIGVtcHR5IHBhcmFncmFwaCBieSBhbiBpbnNlcnRlZCBpbWFnZVxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGluc2VydGluZyB0aGUgaW1hZ2UgYmVsb3cgdGhlIHBhcmFncmFwaFxuICAgICAgICBpZiAoZnJvbSA9PT0gdG8gJiYgaXNPbmx5QmxvY2tDb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHBhcmVudCB9ID0gdHIuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgICAgICAgICBjb25zdCBpc0VtcHR5VGV4dEJsb2NrID0gcGFyZW50LmlzVGV4dGJsb2NrICYmICFwYXJlbnQudHlwZS5zcGVjLmNvZGUgJiYgIXBhcmVudC5jaGlsZENvdW50O1xuICAgICAgICAgICAgaWYgKGlzRW1wdHlUZXh0QmxvY2spIHtcbiAgICAgICAgICAgICAgICBmcm9tIC09IDE7XG4gICAgICAgICAgICAgICAgdG8gKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbmV3Q29udGVudDtcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgb25seSBwbGFpbiB0ZXh0IHdlIGhhdmUgdG8gdXNlIGBpbnNlcnRUZXh0YFxuICAgICAgICAvLyBiZWNhdXNlIHRoaXMgd2lsbCBrZWVwIHRoZSBjdXJyZW50IG1hcmtzXG4gICAgICAgIGlmIChpc09ubHlUZXh0Q29udGVudCkge1xuICAgICAgICAgICAgLy8gaWYgdmFsdWUgaXMgc3RyaW5nLCB3ZSBjYW4gdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaWYgaXQgaXMgYW4gYXJyYXksIHdlIGhhdmUgdG8gam9pbiBpdFxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlLm1hcCh2ID0+IHYudGV4dCB8fCAnJykuam9pbignJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEZyYWdtZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IG5vZGUudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAhIXZhbHVlICYmICEhdmFsdWUudGV4dCkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS50ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3Q29udGVudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuaW5zZXJ0VGV4dChuZXdDb250ZW50LCBmcm9tLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKGZyb20sIHRvLCBuZXdDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXQgY3Vyc29yIGF0IGVuZCBvZiBpbnNlcnRlZCBjb250ZW50XG4gICAgICAgIGlmIChvcHRpb25zLnVwZGF0ZVNlbGVjdGlvbikge1xuICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHRyLnN0ZXBzLmxlbmd0aCAtIDEsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hcHBseUlucHV0UnVsZXMpIHtcbiAgICAgICAgICAgIHRyLnNldE1ldGEoJ2FwcGx5SW5wdXRSdWxlcycsIHsgZnJvbSwgdGV4dDogbmV3Q29udGVudCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5hcHBseVBhc3RlUnVsZXMpIHtcbiAgICAgICAgICAgIHRyLnNldE1ldGEoJ2FwcGx5UGFzdGVSdWxlcycsIHsgZnJvbSwgdGV4dDogbmV3Q29udGVudCB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGpvaW5VcCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGpvaW5VcCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuY29uc3Qgam9pbkRvd24gPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luRG93biQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuY29uc3Qgam9pbkJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pbkJhY2t3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5jb25zdCBqb2luRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGpvaW5Gb3J3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGpvaW5JdGVtQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIHRyLCB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHIuam9pbihwb2ludCwgMik7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5jb25zdCBqb2luSXRlbUZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIHRyLCB9KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ucG9zLCArMSk7XG4gICAgICAgIGlmIChwb2ludCA9PT0gbnVsbCB8fCBwb2ludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdHIuam9pbihwb2ludCwgMik7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG5jb25zdCBqb2luVGV4dGJsb2NrQmFja3dhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luVGV4dGJsb2NrQmFja3dhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luVGV4dGJsb2NrRm9yd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5mdW5jdGlvbiBpc01hY09TKCkge1xuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IC9NYWMvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKVxuICAgICAgICA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgICBjb25zdCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pO1xuICAgIGxldCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09PSAnU3BhY2UnKSB7XG4gICAgICAgIHJlc3VsdCA9ICcgJztcbiAgICB9XG4gICAgbGV0IGFsdDtcbiAgICBsZXQgY3RybDtcbiAgICBsZXQgc2hpZnQ7XG4gICAgbGV0IG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgbW9kID0gcGFydHNbaV07XG4gICAgICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgYWx0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXihjfGN0cmx8Y29udHJvbCkkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXnMoaGlmdCk/JC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgc2hpZnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6ICR7bW9kfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbHQpIHtcbiAgICAgICAgcmVzdWx0ID0gYEFsdC0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBpZiAoY3RybCkge1xuICAgICAgICByZXN1bHQgPSBgQ3RybC0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBpZiAobWV0YSkge1xuICAgICAgICByZXN1bHQgPSBgTWV0YS0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICBpZiAoc2hpZnQpIHtcbiAgICAgICAgcmVzdWx0ID0gYFNoaWZ0LSR7cmVzdWx0fWA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBrZXlib2FyZFNob3J0Y3V0ID0gbmFtZSA9PiAoeyBlZGl0b3IsIHZpZXcsIHRyLCBkaXNwYXRjaCwgfSkgPT4ge1xuICAgIGNvbnN0IGtleXMgPSBub3JtYWxpemVLZXlOYW1lKG5hbWUpLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBjb25zdCBrZXkgPSBrZXlzLmZpbmQoaXRlbSA9PiAhWydBbHQnLCAnQ3RybCcsICdNZXRhJywgJ1NoaWZ0J10uaW5jbHVkZXMoaXRlbSkpO1xuICAgIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleWRvd24nLCB7XG4gICAgICAgIGtleToga2V5ID09PSAnU3BhY2UnXG4gICAgICAgICAgICA/ICcgJ1xuICAgICAgICAgICAgOiBrZXksXG4gICAgICAgIGFsdEtleToga2V5cy5pbmNsdWRlcygnQWx0JyksXG4gICAgICAgIGN0cmxLZXk6IGtleXMuaW5jbHVkZXMoJ0N0cmwnKSxcbiAgICAgICAgbWV0YUtleToga2V5cy5pbmNsdWRlcygnTWV0YScpLFxuICAgICAgICBzaGlmdEtleToga2V5cy5pbmNsdWRlcygnU2hpZnQnKSxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBjb25zdCBjYXB0dXJlZFRyYW5zYWN0aW9uID0gZWRpdG9yLmNhcHR1cmVUcmFuc2FjdGlvbigoKSA9PiB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoJ2hhbmRsZUtleURvd24nLCBmID0+IGYodmlldywgZXZlbnQpKTtcbiAgICB9KTtcbiAgICBjYXB0dXJlZFRyYW5zYWN0aW9uID09PSBudWxsIHx8IGNhcHR1cmVkVHJhbnNhY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhcHR1cmVkVHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgICAgY29uc3QgbmV3U3RlcCA9IHN0ZXAubWFwKHRyLm1hcHBpbmcpO1xuICAgICAgICBpZiAobmV3U3RlcCAmJiBkaXNwYXRjaCkge1xuICAgICAgICAgICAgdHIubWF5YmVTdGVwKG5ld1N0ZXApO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIGNvbnN0IHsgZnJvbSwgdG8sIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3QgdHlwZSA9IHR5cGVPck5hbWUgPyBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpIDogbnVsbDtcbiAgICBjb25zdCBub2RlUmFuZ2VzID0gW107XG4gICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xuICAgICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICBub2RlUmFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgICAgICAgIHRvOiByZWxhdGl2ZVRvLFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCBzZWxlY3Rpb25SYW5nZSA9IHRvIC0gZnJvbTtcbiAgICBjb25zdCBtYXRjaGVkTm9kZVJhbmdlcyA9IG5vZGVSYW5nZXNcbiAgICAgICAgLmZpbHRlcihub2RlUmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG5vZGVSYW5nZS5ub2RlLnR5cGUubmFtZTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKG5vZGVSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhub2RlUmFuZ2Uubm9kZS5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuICEhbWF0Y2hlZE5vZGVSYW5nZXMubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IG1hdGNoZWROb2RlUmFuZ2VzLnJlZHVjZSgoc3VtLCBub2RlUmFuZ2UpID0+IHN1bSArIG5vZGVSYW5nZS50byAtIG5vZGVSYW5nZS5mcm9tLCAwKTtcbiAgICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XG59XG5cbmNvbnN0IGxpZnQgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAoIWlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGxpZnQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBsaWZ0RW1wdHlCbG9jayQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBsaWZ0TGlzdEl0ZW0gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIGxpZnRMaXN0SXRlbSQxKHR5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gbmV3bGluZUluQ29kZSQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vKipcbiAqIEdldCB0aGUgdHlwZSBvZiBhIHNjaGVtYSBpdGVtIGJ5IGl0cyBuYW1lLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHNjaGVtYSBpdGVtXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcm9yIHNjaGVtYSB0byBzZWFyY2ggaW5cbiAqIEByZXR1cm5zIFRoZSB0eXBlIG9mIHRoZSBzY2hlbWEgaXRlbSAoYG5vZGVgIG9yIGBtYXJrYCksIG9yIG51bGwgaWYgaXQgZG9lc24ndCBleGlzdFxuICovXG5mdW5jdGlvbiBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hLm5vZGVzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiAnbm9kZSc7XG4gICAgfVxuICAgIGlmIChzY2hlbWEubWFya3NbbmFtZV0pIHtcbiAgICAgICAgcmV0dXJuICdtYXJrJztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgcHJvcGVydHkgb3IgYW4gYXJyYXkgb2YgcHJvcGVydGllcyBmcm9tIGFuIG9iamVjdFxuICogQHBhcmFtIG9iaiBPYmplY3RcbiAqIEBwYXJhbSBrZXkgS2V5IHRvIHJlbW92ZVxuICovXG5mdW5jdGlvbiBkZWxldGVQcm9wcyhvYmosIHByb3BPclByb3BzKSB7XG4gICAgY29uc3QgcHJvcHMgPSB0eXBlb2YgcHJvcE9yUHJvcHMgPT09ICdzdHJpbmcnXG4gICAgICAgID8gW3Byb3BPclByb3BzXVxuICAgICAgICA6IHByb3BPclByb3BzO1xuICAgIHJldHVybiBPYmplY3RcbiAgICAgICAgLmtleXMob2JqKVxuICAgICAgICAucmVkdWNlKChuZXdPYmosIHByb3ApID0+IHtcbiAgICAgICAgaWYgKCFwcm9wcy5pbmNsdWRlcyhwcm9wKSkge1xuICAgICAgICAgICAgbmV3T2JqW3Byb3BdID0gb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdPYmo7XG4gICAgfSwge30pO1xufVxuXG5jb25zdCByZXNldEF0dHJpYnV0ZXMgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcykgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IG5vZGVUeXBlID0gbnVsbDtcbiAgICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSh0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocG9zLCB1bmRlZmluZWQsIGRlbGV0ZVByb3BzKG5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayhwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG1hcmtUeXBlLmNyZWF0ZShkZWxldGVQcm9wcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2Nyb2xsSW50b1ZpZXcgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlbGVjdEFsbCA9ICgpID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IG5ldyBBbGxTZWxlY3Rpb24odHIuZG9jKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgc2VsZWN0Tm9kZUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gc2VsZWN0Tm9kZUJhY2t3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IHNlbGVjdE5vZGVGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gc2VsZWN0Tm9kZUZvcndhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdFBhcmVudE5vZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLy8gQHRzLWlnbm9yZVxuLy8gVE9ETzogYWRkIHR5cGVzIHRvIEB0eXBlcy9wcm9zZW1pcnJvci1jb21tYW5kc1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrRW5kID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gc2VsZWN0VGV4dGJsb2NrRW5kJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmNvbnN0IHNlbGVjdFRleHRibG9ja1N0YXJ0ID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gc2VsZWN0VGV4dGJsb2NrU3RhcnQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgUHJvc2VtaXJyb3IgZG9jdW1lbnQgbm9kZSBmcm9tIGNvbnRlbnQuXG4gKiBAcGFyYW0gY29udGVudCBUaGUgSlNPTiBvciBIVE1MIGNvbnRlbnQgdG8gY3JlYXRlIHRoZSBkb2N1bWVudCBmcm9tXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcnJvciBzY2hlbWEgdG8gdXNlIGZvciB0aGUgZG9jdW1lbnRcbiAqIEBwYXJhbSBwYXJzZU9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHBhcnNlclxuICogQHJldHVybnMgVGhlIGNyZWF0ZWQgUHJvc2VtaXJyb3IgZG9jdW1lbnQgbm9kZVxuICovXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudChjb250ZW50LCBzY2hlbWEsIHBhcnNlT3B0aW9ucyA9IHt9LCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwge1xuICAgICAgICBzbGljZTogZmFsc2UsXG4gICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiBvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCxcbiAgICB9KTtcbn1cblxuY29uc3Qgc2V0Q29udGVudCA9IChjb250ZW50LCBlbWl0VXBkYXRlID0gZmFsc2UsIHBhcnNlT3B0aW9ucyA9IHt9LCBvcHRpb25zID0ge30pID0+ICh7IGVkaXRvciwgdHIsIGRpc3BhdGNoLCBjb21tYW5kcywgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyBkb2MgfSA9IHRyO1xuICAgIC8vIFRoaXMgaXMgdG8ga2VlcCBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IHdpdGggdGhlIHByZXZpb3VzIGJlaGF2aW9yXG4gICAgLy8gVE9ETyByZW1vdmUgdGhpcyBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgaWYgKHBhcnNlT3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UgIT09ICdmdWxsJykge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGNyZWF0ZURvY3VtZW50KGNvbnRlbnQsIGVkaXRvci5zY2hlbWEsIHBhcnNlT3B0aW9ucywge1xuICAgICAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiAoX2EgPSBvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aCgwLCBkb2MuY29udGVudC5zaXplLCBkb2N1bWVudCkuc2V0TWV0YSgncHJldmVudFVwZGF0ZScsICFlbWl0VXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHRyLnNldE1ldGEoJ3ByZXZlbnRVcGRhdGUnLCAhZW1pdFVwZGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tOiAwLCB0bzogZG9jLmNvbnRlbnQuc2l6ZSB9LCBjb250ZW50LCB7XG4gICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgZXJyb3JPbkludmFsaWRDb250ZW50OiAoX2IgPSBvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrLFxuICAgIH0pO1xufTtcblxuZnVuY3Rpb24gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0IG1hcmtzID0gW107XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdG9yZWRNYXJrcykge1xuICAgICAgICAgICAgbWFya3MucHVzaCguLi5zdGF0ZS5zdG9yZWRNYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgbWFya3MucHVzaCguLi5zdGF0ZS5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goLi4ubm9kZS5tYXJrcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtYXJrID0gbWFya3MuZmluZChtYXJrSXRlbSA9PiBtYXJrSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSk7XG4gICAgaWYgKCFtYXJrKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4ubWFyay5hdHRycyB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgYFRyYW5zZm9ybWAgYmFzZWQgb24gYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zLlxuICogQHBhcmFtIG9sZERvYyBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRoZSB0cmFuc2FjdGlvbnMgdG8gY29tYmluZVxuICogQHJldHVybnMgQSBuZXcgYFRyYW5zZm9ybWAgd2l0aCBhbGwgc3RlcHMgb2YgdGhlIHBhc3NlZCB0cmFuc2FjdGlvbnNcbiAqL1xuZnVuY3Rpb24gY29tYmluZVRyYW5zYWN0aW9uU3RlcHMob2xkRG9jLCB0cmFuc2FjdGlvbnMpIHtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtKG9sZERvYyk7XG4gICAgdHJhbnNhY3Rpb25zLmZvckVhY2godHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4ge1xuICAgICAgICAgICAgdHJhbnNmb3JtLnN0ZXAoc3RlcCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB0cmFuc2Zvcm07XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGVmYXVsdCBibG9jayB0eXBlIGF0IGEgZ2l2ZW4gbWF0Y2hcbiAqIEBwYXJhbSBtYXRjaCBUaGUgY29udGVudCBtYXRjaCB0byBnZXQgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBmcm9tXG4gKiBAcmV0dXJucyBUaGUgZGVmYXVsdCBibG9jayB0eXBlIG9yIG51bGxcbiAqL1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgaWYgKHR5cGUuaXNUZXh0YmxvY2sgJiYgIXR5cGUuaGFzUmVxdWlyZWRBdHRycygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGNoaWxkcmVuIGluc2lkZSBhIFByb3NlbWlycm9yIG5vZGUgdGhhdCBtYXRjaCBhIHByZWRpY2F0ZS5cbiAqIEBwYXJhbSBub2RlIFRoZSBQcm9zZW1pcnJvciBub2RlIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW4obm9kZSwgcHJlZGljYXRlKSB7XG4gICAgY29uc3Qgbm9kZXNXaXRoUG9zID0gW107XG4gICAgbm9kZS5kZXNjZW5kYW50cygoY2hpbGQsIHBvcykgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzV2l0aFBvcztcbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBmaW5kQ2hpbGRyZW5gIGJ1dCBzZWFyY2hlcyBvbmx5IHdpdGhpbiBhIGByYW5nZWAuXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2UgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbWF0Y2hcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzIHdpdGggdGhlaXIgcG9zaXRpb25zXG4gKi9cbmZ1bmN0aW9uIGZpbmRDaGlsZHJlbkluUmFuZ2Uobm9kZSwgcmFuZ2UsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICAgIC8vIGlmIChyYW5nZS5mcm9tID09PSByYW5nZS50bykge1xuICAgIC8vICAgY29uc3Qgbm9kZUF0ID0gbm9kZS5ub2RlQXQocmFuZ2UuZnJvbSlcbiAgICAvLyAgIGlmIChub2RlQXQpIHtcbiAgICAvLyAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgIC8vICAgICAgIG5vZGU6IG5vZGVBdCxcbiAgICAvLyAgICAgICBwb3M6IHJhbmdlLmZyb20sXG4gICAgLy8gICAgIH0pXG4gICAgLy8gICB9XG4gICAgLy8gfVxuICAgIG5vZGUubm9kZXNCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCAoY2hpbGQsIHBvcykgPT4ge1xuICAgICAgICBpZiAocHJlZGljYXRlKGNoaWxkKSkge1xuICAgICAgICAgICAgbm9kZXNXaXRoUG9zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzV2l0aFBvcztcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byBhIHJlc29sdmVkIHBvc2l0aW9uIHRoYXQgbWF0Y2hlcyBhIHByZWRpY2F0ZS5cbiAqIEBwYXJhbSAkcG9zIFRoZSByZXNvbHZlZCBwb3NpdGlvbiB0byBzZWFyY2ggZnJvbVxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBUaGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgcmVzb2x2ZWQgcG9zaXRpb24gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcygkZnJvbSwgbm9kZSA9PiBub2RlLnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCcpXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJHBvcywgcHJlZGljYXRlKSB7XG4gICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGg7IGkgPiAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShpKTtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwb3M6IGkgPiAwID8gJHBvcy5iZWZvcmUoaSkgOiAwLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAkcG9zLnN0YXJ0KGkpLFxuICAgICAgICAgICAgICAgIGRlcHRoOiBpLFxuICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbWF0Y2hcbiAqIEByZXR1cm5zIEEgY29tbWFuZCB0aGF0IGZpbmRzIHRoZSBjbG9zZXN0IHBhcmVudCBub2RlIHRvIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB0aGF0IG1hdGNoZXMgdGhlIHByZWRpY2F0ZVxuICogQGV4YW1wbGUgYGBganNcbiAqIGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiAoc2VsZWN0aW9uKSA9PiBmaW5kUGFyZW50Tm9kZUNsb3Nlc3RUb1BvcyhzZWxlY3Rpb24uJGZyb20sIHByZWRpY2F0ZSk7XG59XG5cbmZ1bmN0aW9uIGdldFNjaGVtYShleHRlbnNpb25zLCBlZGl0b3IpIHtcbiAgICBjb25zdCByZXNvbHZlZEV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnJlc29sdmUoZXh0ZW5zaW9ucyk7XG4gICAgcmV0dXJuIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zKHJlc29sdmVkRXh0ZW5zaW9ucywgZWRpdG9yKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBIVE1MIGZyb20gYSBKU09OQ29udGVudFxuICogQHBhcmFtIGRvYyBUaGUgSlNPTkNvbnRlbnQgdG8gZ2VuZXJhdGUgSFRNTCBmcm9tXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9ucyB0byB1c2UgZm9yIHRoZSBzY2hlbWFcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgSFRNTFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUhUTUwoZG9jLCBleHRlbnNpb25zKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xuICAgIGNvbnN0IGNvbnRlbnROb2RlID0gTm9kZSQxLmZyb21KU09OKHNjaGVtYSwgZG9jKTtcbiAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudChjb250ZW50Tm9kZS5jb250ZW50LCBzY2hlbWEpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIEpTT05Db250ZW50IGZyb20gSFRNTFxuICogQHBhcmFtIGh0bWwgVGhlIEhUTUwgdG8gZ2VuZXJhdGUgSlNPTkNvbnRlbnQgZnJvbVxuICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbnMgdG8gdXNlIGZvciB0aGUgc2NoZW1hXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEpTT05Db250ZW50XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSlNPTihodG1sLCBleHRlbnNpb25zKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gZ2V0U2NoZW1hKGV4dGVuc2lvbnMpO1xuICAgIGNvbnN0IGRvbSA9IGVsZW1lbnRGcm9tU3RyaW5nKGh0bWwpO1xuICAgIHJldHVybiBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpLnBhcnNlKGRvbSkudG9KU09OKCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdGV4dCBvZiBhIFByb3NlbWlycm9yIG5vZGVcbiAqIEBwYXJhbSBub2RlIFRoZSBQcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25zIGZvciB0aGUgdGV4dCBzZXJpYWxpemVyICYgYmxvY2sgc2VwYXJhdG9yXG4gKiBAcmV0dXJucyBUaGUgdGV4dCBvZiB0aGUgbm9kZVxuICogQGV4YW1wbGUgYGBganNcbiAqIGNvbnN0IHRleHQgPSBnZXRUZXh0KG5vZGUsIHsgYmxvY2tTZXBhcmF0b3I6ICdcXG4nIH0pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dChub2RlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgIGZyb206IDAsXG4gICAgICAgIHRvOiBub2RlLmNvbnRlbnQuc2l6ZSxcbiAgICB9O1xuICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihub2RlLCByYW5nZSwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgcmF3IHRleHQgZnJvbSBhIEpTT05Db250ZW50XG4gKiBAcGFyYW0gZG9jIFRoZSBKU09OQ29udGVudCB0byBnZW5lcmF0ZSB0ZXh0IGZyb21cbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgZ2VuZXJhdGlvbiBmLmUuIGJsb2NrU2VwYXJhdG9yIG9yIHRleHRTZXJpYWxpemVyc1xuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCB0ZXh0XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlVGV4dChkb2MsIGV4dGVuc2lvbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGJsb2NrU2VwYXJhdG9yID0gJ1xcblxcbicsIHRleHRTZXJpYWxpemVycyA9IHt9IH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUkMS5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gICAgcmV0dXJuIGdldFRleHQoY29udGVudE5vZGUsIHtcbiAgICAgICAgYmxvY2tTZXBhcmF0b3IsXG4gICAgICAgIHRleHRTZXJpYWxpemVyczoge1xuICAgICAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYShzY2hlbWEpLFxuICAgICAgICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgIH0pO1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlcy5yZXZlcnNlKCkuZmluZChub2RlSXRlbSA9PiBub2RlSXRlbS50eXBlLm5hbWUgPT09IHR5cGUubmFtZSk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4ubm9kZS5hdHRycyB9O1xufVxuXG4vKipcbiAqIEdldCBub2RlIG9yIG1hcmsgYXR0cmlidXRlcyBieSB0eXBlIG9yIG5hbWUgb24gdGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlXG4gKiBAcGFyYW0gc3RhdGUgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlXG4gKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbm9kZSBvciBtYXJrIHR5cGUgb3IgbmFtZVxuICogQHJldHVybnMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIG5vZGUgb3IgbWFyayBvciBhbiBlbXB0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0QXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSkge1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSh0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIGdldE5vZGVBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgICAgICByZXR1cm4gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge307XG59XG5cbi8qKlxuICogUmVtb3ZlcyBkdXBsaWNhdGVkIHZhbHVlcyB3aXRoaW4gYW4gYXJyYXkuXG4gKiBTdXBwb3J0cyBudW1iZXJzLCBzdHJpbmdzIGFuZCBvYmplY3RzLlxuICovXG5mdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVzKGFycmF5LCBieSA9IEpTT04uc3RyaW5naWZ5KSB7XG4gICAgY29uc3Qgc2VlbiA9IHt9O1xuICAgIHJldHVybiBhcnJheS5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ5KGl0ZW0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNlZW4sIGtleSlcbiAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgIDogKHNlZW5ba2V5XSA9IHRydWUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCByYW5nZXMgYW5kIHJhbmdlcyB0aGF0IGFyZVxuICogZnVsbHkgY2FwdHVyZWQgYnkgb3RoZXIgcmFuZ2VzLlxuICovXG5mdW5jdGlvbiBzaW1wbGlmeUNoYW5nZWRSYW5nZXMoY2hhbmdlcykge1xuICAgIGNvbnN0IHVuaXF1ZUNoYW5nZXMgPSByZW1vdmVEdXBsaWNhdGVzKGNoYW5nZXMpO1xuICAgIHJldHVybiB1bmlxdWVDaGFuZ2VzLmxlbmd0aCA9PT0gMVxuICAgICAgICA/IHVuaXF1ZUNoYW5nZXNcbiAgICAgICAgOiB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoY2hhbmdlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdCA9IHVuaXF1ZUNoYW5nZXMuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCk7XG4gICAgICAgICAgICByZXR1cm4gIXJlc3Quc29tZShvdGhlckNoYW5nZSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYW5nZS5vbGRSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm9sZFJhbmdlLmZyb21cbiAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlLm9sZFJhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm9sZFJhbmdlLnRvXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS5mcm9tID49IG90aGVyQ2hhbmdlLm5ld1JhbmdlLmZyb21cbiAgICAgICAgICAgICAgICAgICAgJiYgY2hhbmdlLm5ld1JhbmdlLnRvIDw9IG90aGVyQ2hhbmdlLm5ld1JhbmdlLnRvO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xufVxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBjaGFuZ2VkIHJhbmdlc1xuICogYmFzZWQgb24gdGhlIGZpcnN0IGFuZCBsYXN0IHN0YXRlIG9mIGFsbCBzdGVwcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhbmdlZFJhbmdlcyh0cmFuc2Zvcm0pIHtcbiAgICBjb25zdCB7IG1hcHBpbmcsIHN0ZXBzIH0gPSB0cmFuc2Zvcm07XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIG1hcHBpbmcubWFwcy5mb3JFYWNoKChzdGVwTWFwLCBpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCByYW5nZXMgPSBbXTtcbiAgICAgICAgLy8gVGhpcyBhY2NvdW50cyBmb3Igc3RlcCBjaGFuZ2VzIHdoZXJlIG5vIHJhbmdlIHdhcyBhY3R1YWxseSBhbHRlcmVkXG4gICAgICAgIC8vIGUuZy4gd2hlbiBzZXR0aW5nIGEgbWFyaywgbm9kZSBhdHRyaWJ1dGUsIGV0Yy5cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIXN0ZXBNYXAucmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc3RlcHNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGZyb20gPT09IHVuZGVmaW5lZCB8fCB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0ZXBNYXAuZm9yRWFjaCgoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgICAgICAgICByYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2VzLmZvckVhY2goKHsgZnJvbSwgdG8gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3U3RhcnQgPSBtYXBwaW5nLnNsaWNlKGluZGV4KS5tYXAoZnJvbSwgLTEpO1xuICAgICAgICAgICAgY29uc3QgbmV3RW5kID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKHRvKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFN0YXJ0ID0gbWFwcGluZy5pbnZlcnQoKS5tYXAobmV3U3RhcnQsIC0xKTtcbiAgICAgICAgICAgIGNvbnN0IG9sZEVuZCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld0VuZCk7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9sZFJhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IG9sZFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB0bzogb2xkRW5kLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmV3UmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogbmV3U3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIHRvOiBuZXdFbmQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpO1xufVxuXG5mdW5jdGlvbiBnZXREZWJ1Z0pTT04obm9kZSwgc3RhcnRPZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgaXNUb3BOb2RlID0gbm9kZS50eXBlID09PSBub2RlLnR5cGUuc2NoZW1hLnRvcE5vZGVUeXBlO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IGlzVG9wTm9kZSA/IDAgOiAxO1xuICAgIGNvbnN0IGZyb20gPSBzdGFydE9mZnNldDtcbiAgICBjb25zdCB0byA9IGZyb20gKyBub2RlLm5vZGVTaXplO1xuICAgIGNvbnN0IG1hcmtzID0gbm9kZS5tYXJrcy5tYXAobWFyayA9PiB7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgICAgIHR5cGU6IG1hcmsudHlwZS5uYW1lLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMobWFyay5hdHRycykubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXRwdXQuYXR0cnMgPSB7IC4uLm1hcmsuYXR0cnMgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICAgIGNvbnN0IGF0dHJzID0geyAuLi5ub2RlLmF0dHJzIH07XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICB0eXBlOiBub2RlLnR5cGUubmFtZSxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG8sXG4gICAgfTtcbiAgICBpZiAoT2JqZWN0LmtleXMoYXR0cnMpLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgaWYgKG1hcmtzLmxlbmd0aCkge1xuICAgICAgICBvdXRwdXQubWFya3MgPSBtYXJrcztcbiAgICB9XG4gICAgaWYgKG5vZGUuY29udGVudC5jaGlsZENvdW50KSB7XG4gICAgICAgIG91dHB1dC5jb250ZW50ID0gW107XG4gICAgICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gb3V0cHV0LmNvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdXNoKGdldERlYnVnSlNPTihjaGlsZCwgc3RhcnRPZmZzZXQgKyBvZmZzZXQgKyBpbmNyZW1lbnQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChub2RlLnRleHQpIHtcbiAgICAgICAgb3V0cHV0LnRleHQgPSBub2RlLnRleHQ7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtzQmV0d2Vlbihmcm9tLCB0bywgZG9jKSB7XG4gICAgY29uc3QgbWFya3MgPSBbXTtcbiAgICAvLyBnZXQgYWxsIGluY2x1c2l2ZSBtYXJrcyBvbiBlbXB0eSBzZWxlY3Rpb25cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgICAgZG9jXG4gICAgICAgICAgICAucmVzb2x2ZShmcm9tKVxuICAgICAgICAgICAgLm1hcmtzKClcbiAgICAgICAgICAgIC5mb3JFYWNoKG1hcmsgPT4ge1xuICAgICAgICAgICAgY29uc3QgJHBvcyA9IGRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBnZXRNYXJrUmFuZ2UoJHBvcywgbWFyay50eXBlKTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtYXJrLFxuICAgICAgICAgICAgICAgIC4uLnJhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUubm9kZVNpemUpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICAgICAgICBmcm9tOiBwb3MsXG4gICAgICAgICAgICAgICAgdG86IHBvcyArIG5vZGUubm9kZVNpemUsXG4gICAgICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbWFya3M7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IG5vZGUgb2YgYSBnaXZlbiB0eXBlIG9yIG5hbWUgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHN0YXRlIFRoZSBlZGl0b3Igc3RhdGUuXG4gKiBAcGFyYW0gdHlwZU9yTmFtZSBUaGUgbm9kZSB0eXBlIG9yIG5hbWUuXG4gKiBAcGFyYW0gcG9zIFRoZSBwb3NpdGlvbiB0byBzdGFydCBzZWFyY2hpbmcgZnJvbS5cbiAqIEBwYXJhbSBtYXhEZXB0aCBUaGUgbWF4aW11bSBkZXB0aCB0byBzZWFyY2guXG4gKiBAcmV0dXJucyBUaGUgbm9kZSBhbmQgdGhlIGRlcHRoIGFzIGFuIGFycmF5LlxuICovXG5jb25zdCBnZXROb2RlQXRQb3NpdGlvbiA9IChzdGF0ZSwgdHlwZU9yTmFtZSwgcG9zLCBtYXhEZXB0aCA9IDIwKSA9PiB7XG4gICAgY29uc3QgJHBvcyA9IHN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgbGV0IGN1cnJlbnREZXB0aCA9IG1heERlcHRoO1xuICAgIGxldCBub2RlID0gbnVsbDtcbiAgICB3aGlsZSAoY3VycmVudERlcHRoID4gMCAmJiBub2RlID09PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnROb2RlID0gJHBvcy5ub2RlKGN1cnJlbnREZXB0aCk7XG4gICAgICAgIGlmICgoY3VycmVudE5vZGUgPT09IG51bGwgfHwgY3VycmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnROb2RlLnR5cGUubmFtZSkgPT09IHR5cGVPck5hbWUpIHtcbiAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1cnJlbnREZXB0aCAtPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbm9kZSwgY3VycmVudERlcHRoXTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGF0dHJpYnV0ZXMgb2YgYW4gZXh0ZW5zaW9uIHRoYXQgc2hvdWxkIGJlIHNwbGl0dGVkIGJ5IGtlZXBPblNwbGl0IGZsYWdcbiAqIEBwYXJhbSBleHRlbnNpb25BdHRyaWJ1dGVzIEFycmF5IG9mIGV4dGVuc2lvbiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0gdHlwZU5hbWUgVGhlIHR5cGUgb2YgdGhlIGV4dGVuc2lvblxuICogQHBhcmFtIGF0dHJpYnV0ZXMgVGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGV4dGVuc2lvblxuICogQHJldHVybnMgVGhlIHNwbGl0dGVkIGF0dHJpYnV0ZXNcbiAqL1xuZnVuY3Rpb24gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsIHR5cGVOYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3RcbiAgICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAgICAgLmZpbHRlcigoW25hbWVdKSA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZSA9IGV4dGVuc2lvbkF0dHJpYnV0ZXMuZmluZChpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnR5cGUgPT09IHR5cGVOYW1lICYmIGl0ZW0ubmFtZSA9PT0gbmFtZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZXh0ZW5zaW9uQXR0cmlidXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUua2VlcE9uU3BsaXQ7XG4gICAgfSkpO1xufVxuXG5mdW5jdGlvbiBpc01hcmtBY3RpdmUoc3RhdGUsIHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIGNvbnN0IHsgZW1wdHksIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGw7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiAhIShzdGF0ZS5zdG9yZWRNYXJrcyB8fCBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSlcbiAgICAgICAgICAgIC5maWx0ZXIobWFyayA9PiB7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmsudHlwZS5uYW1lO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbmQobWFyayA9PiBvYmplY3RJbmNsdWRlcyhtYXJrLmF0dHJzLCBhdHRyaWJ1dGVzLCB7IHN0cmljdDogZmFsc2UgfSkpO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0aW9uUmFuZ2UgPSAwO1xuICAgIGNvbnN0IG1hcmtSYW5nZXMgPSBbXTtcbiAgICByYW5nZXMuZm9yRWFjaCgoeyAkZnJvbSwgJHRvIH0pID0+IHtcbiAgICAgICAgY29uc3QgZnJvbSA9ICRmcm9tLnBvcztcbiAgICAgICAgY29uc3QgdG8gPSAkdG8ucG9zO1xuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW5vZGUuaXNUZXh0ICYmICFub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlRnJvbSA9IE1hdGgubWF4KGZyb20sIHBvcyk7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVRvID0gTWF0aC5taW4odG8sIHBvcyArIG5vZGUubm9kZVNpemUpO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSByZWxhdGl2ZVRvIC0gcmVsYXRpdmVGcm9tO1xuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2UgKz0gcmFuZ2U7XG4gICAgICAgICAgICBtYXJrUmFuZ2VzLnB1c2goLi4ubm9kZS5tYXJrcy5tYXAobWFyayA9PiAoe1xuICAgICAgICAgICAgICAgIG1hcmssXG4gICAgICAgICAgICAgICAgZnJvbTogcmVsYXRpdmVGcm9tLFxuICAgICAgICAgICAgICAgIHRvOiByZWxhdGl2ZVRvLFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHNlbGVjdGlvblJhbmdlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gY2FsY3VsYXRlIHJhbmdlIG9mIG1hdGNoZWQgbWFya1xuICAgIGNvbnN0IG1hdGNoZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWUgPT09IG1hcmtSYW5nZS5tYXJrLnR5cGUubmFtZTtcbiAgICB9KVxuICAgICAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiBvYmplY3RJbmNsdWRlcyhtYXJrUmFuZ2UubWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKVxuICAgICAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApO1xuICAgIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXJrcyB0aGF0IGV4Y2x1ZGVzIHRoZSBzZWFyY2hlZCBtYXJrXG4gICAgLy8gZm9yIGV4YW1wbGUgYGNvZGVgIGRvZXNu4oCZdCBhbGxvdyBhbnkgb3RoZXIgbWFya3NcbiAgICBjb25zdCBleGNsdWRlZFJhbmdlID0gbWFya1Jhbmdlc1xuICAgICAgICAuZmlsdGVyKG1hcmtSYW5nZSA9PiB7XG4gICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcmtSYW5nZS5tYXJrLnR5cGUgIT09IHR5cGUgJiYgbWFya1JhbmdlLm1hcmsudHlwZS5leGNsdWRlcyh0eXBlKTtcbiAgICB9KVxuICAgICAgICAucmVkdWNlKChzdW0sIG1hcmtSYW5nZSkgPT4gc3VtICsgbWFya1JhbmdlLnRvIC0gbWFya1JhbmdlLmZyb20sIDApO1xuICAgIC8vIHdlIG9ubHkgaW5jbHVkZSB0aGUgcmVzdWx0IG9mIGBleGNsdWRlZFJhbmdlYFxuICAgIC8vIGlmIHRoZXJlIGlzIGEgbWF0Y2ggYXQgYWxsXG4gICAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkUmFuZ2UgPiAwID8gbWF0Y2hlZFJhbmdlICsgZXhjbHVkZWRSYW5nZSA6IG1hdGNoZWRSYW5nZTtcbiAgICByZXR1cm4gcmFuZ2UgPj0gc2VsZWN0aW9uUmFuZ2U7XG59XG5cbmZ1bmN0aW9uIGlzQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcykgfHwgaXNNYXJrQWN0aXZlKHN0YXRlLCBudWxsLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKG5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgICAgICByZXR1cm4gaXNOb2RlQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgICAgICByZXR1cm4gaXNNYXJrQWN0aXZlKHN0YXRlLCBuYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBpc0F0RW5kT2ZOb2RlID0gKHN0YXRlLCBub2RlVHlwZSkgPT4ge1xuICAgIGNvbnN0IHsgJGZyb20sICR0bywgJGFuY2hvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChub2RlVHlwZSkge1xuICAgICAgICBjb25zdCBwYXJlbnROb2RlID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUubmFtZSA9PT0gbm9kZVR5cGUpKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0ICRwYXJlbnRQb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwYXJlbnROb2RlLnBvcyArIDEpO1xuICAgICAgICBpZiAoJGFuY2hvci5wb3MgKyAxID09PSAkcGFyZW50UG9zLmVuZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkdG8ucGFyZW50T2Zmc2V0IDwgJHRvLnBhcmVudC5ub2RlU2l6ZSAtIDIgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc0F0U3RhcnRPZk5vZGUgPSAoc3RhdGUpID0+IHtcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoJGZyb20ucGFyZW50T2Zmc2V0ID4gMCB8fCAkZnJvbS5wb3MgIT09ICR0by5wb3MpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIGlzTGlzdChuYW1lLCBleHRlbnNpb25zKSB7XG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKGV4dGVuc2lvbnMpO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5vZGVFeHRlbnNpb25zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09IG5hbWUpO1xuICAgIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICB9O1xuICAgIGNvbnN0IGdyb3VwID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpO1xuICAgIGlmICh0eXBlb2YgZ3JvdXAgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGdyb3VwLnNwbGl0KCcgJykuaW5jbHVkZXMoJ2xpc3QnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHByb3NlbWlycm9yIG5vZGUgaXMgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZUVtcHR5KG5vZGUsIHsgY2hlY2tDaGlsZHJlbiA9IHRydWUsIGlnbm9yZVdoaXRlc3BhY2UgPSBmYWxzZSwgfSA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChpZ25vcmVXaGl0ZXNwYWNlKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUubmFtZSA9PT0gJ2hhcmRCcmVhaycpIHtcbiAgICAgICAgICAgIC8vIEhhcmQgYnJlYWtzIGFyZSBjb25zaWRlcmVkIGVtcHR5XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgICAgIHJldHVybiAvXlxccyokL20udGVzdCgoX2EgPSBub2RlLnRleHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5pc1RleHQpIHtcbiAgICAgICAgcmV0dXJuICFub2RlLnRleHQ7XG4gICAgfVxuICAgIGlmIChub2RlLmlzQXRvbSB8fCBub2RlLmlzTGVhZikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNoZWNrQ2hpbGRyZW4pIHtcbiAgICAgICAgbGV0IGlzQ29udGVudEVtcHR5ID0gdHJ1ZTtcbiAgICAgICAgbm9kZS5jb250ZW50LmZvckVhY2goY2hpbGROb2RlID0+IHtcbiAgICAgICAgICAgIGlmIChpc0NvbnRlbnRFbXB0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGZvciBwZXJmXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc05vZGVFbXB0eShjaGlsZE5vZGUsIHsgaWdub3JlV2hpdGVzcGFjZSwgY2hlY2tDaGlsZHJlbiB9KSkge1xuICAgICAgICAgICAgICAgIGlzQ29udGVudEVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXNDb250ZW50RW1wdHk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlU2VsZWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKSB7XG4gICAgY29uc3QgbWluUG9zID0gMDtcbiAgICBjb25zdCBtYXhQb3MgPSB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemU7XG4gICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gbWluTWF4KGZyb20sIG1pblBvcywgbWF4UG9zKTtcbiAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xuICAgIGNvbnN0IHN0YXJ0ID0gdmlldy5jb29yZHNBdFBvcyhyZXNvbHZlZEZyb20pO1xuICAgIGNvbnN0IGVuZCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRFbmQsIC0xKTtcbiAgICBjb25zdCB0b3AgPSBNYXRoLm1pbihzdGFydC50b3AsIGVuZC50b3ApO1xuICAgIGNvbnN0IGJvdHRvbSA9IE1hdGgubWF4KHN0YXJ0LmJvdHRvbSwgZW5kLmJvdHRvbSk7XG4gICAgY29uc3QgbGVmdCA9IE1hdGgubWluKHN0YXJ0LmxlZnQsIGVuZC5sZWZ0KTtcbiAgICBjb25zdCByaWdodCA9IE1hdGgubWF4KHN0YXJ0LnJpZ2h0LCBlbmQucmlnaHQpO1xuICAgIGNvbnN0IHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgIGNvbnN0IGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcbiAgICBjb25zdCB4ID0gbGVmdDtcbiAgICBjb25zdCB5ID0gdG9wO1xuICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIHRvcCxcbiAgICAgICAgYm90dG9tLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIHRvSlNPTjogKCkgPT4gZGF0YSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFRoZSBhY3R1YWwgaW1wbGVtZW50YXRpb24gb2YgdGhlIHJld3JpdGVVbmtub3duQ29udGVudCBmdW5jdGlvblxuICovXG5mdW5jdGlvbiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7IGpzb24sIHZhbGlkTWFya3MsIHZhbGlkTm9kZXMsIG9wdGlvbnMsIHJld3JpdHRlbkNvbnRlbnQgPSBbXSwgfSkge1xuICAgIGlmIChqc29uLm1hcmtzICYmIEFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpIHtcbiAgICAgICAganNvbi5tYXJrcyA9IGpzb24ubWFya3MuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBtYXJrID09PSAnc3RyaW5nJyA/IG1hcmsgOiBtYXJrLnR5cGU7XG4gICAgICAgICAgICBpZiAodmFsaWRNYXJrcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWw6IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWFyaykpLFxuICAgICAgICAgICAgICAgIHVuc3VwcG9ydGVkOiBuYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBKdXN0IGlnbm9yZSBhbnkgdW5rbm93biBtYXJrc1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGpzb24uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGpzb24uY29udGVudCkpIHtcbiAgICAgICAganNvbi5jb250ZW50ID0ganNvbi5jb250ZW50XG4gICAgICAgICAgICAubWFwKHZhbHVlID0+IHJld3JpdGVVbmtub3duQ29udGVudElubmVyKHtcbiAgICAgICAgICAgIGpzb246IHZhbHVlLFxuICAgICAgICAgICAgdmFsaWRNYXJrcyxcbiAgICAgICAgICAgIHZhbGlkTm9kZXMsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICAgICAgfSkuanNvbilcbiAgICAgICAgICAgIC5maWx0ZXIoYSA9PiBhICE9PSBudWxsICYmIGEgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGlmIChqc29uLnR5cGUgJiYgIXZhbGlkTm9kZXMuaGFzKGpzb24udHlwZSkpIHtcbiAgICAgICAgcmV3cml0dGVuQ29udGVudC5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbmFsOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGpzb24pKSxcbiAgICAgICAgICAgIHVuc3VwcG9ydGVkOiBqc29uLnR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoanNvbi5jb250ZW50ICYmIEFycmF5LmlzQXJyYXkoanNvbi5jb250ZW50KSAmJiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWxsYmFja1RvUGFyYWdyYXBoKSAhPT0gZmFsc2UpKSB7XG4gICAgICAgICAgICAvLyBKdXN0IHRyZWF0IGl0IGxpa2UgYSBwYXJhZ3JhcGggYW5kIGhvcGUgZm9yIHRoZSBiZXN0XG4gICAgICAgICAgICBqc29uLnR5cGUgPSAncGFyYWdyYXBoJztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgICAgICByZXdyaXR0ZW5Db250ZW50LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvciBqdXN0IG9taXQgaXQgZW50aXJlbHlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGpzb246IG51bGwsXG4gICAgICAgICAgICByZXdyaXR0ZW5Db250ZW50LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBqc29uLCByZXdyaXR0ZW5Db250ZW50IH07XG59XG4vKipcbiAqIFJld3JpdGUgdW5rbm93biBub2RlcyBhbmQgbWFya3Mgd2l0aGluIEpTT04gY29udGVudFxuICogQWxsb3dpbmcgZm9yIHVzZXIgd2l0aGluIHRoZSBlZGl0b3JcbiAqL1xuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50KFxuLyoqXG4gKiBUaGUgSlNPTiBjb250ZW50IHRvIGNsZWFuIG9mIHVua25vd24gbm9kZXMgYW5kIG1hcmtzXG4gKi9cbmpzb24sIFxuLyoqXG4gKiBUaGUgc2NoZW1hIHRvIHVzZSBmb3IgdmFsaWRhdGlvblxuICovXG5zY2hlbWEsIFxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgY2xlYW5pbmcgcHJvY2Vzc1xuICovXG5vcHRpb25zKSB7XG4gICAgcmV0dXJuIHJld3JpdGVVbmtub3duQ29udGVudElubmVyKHtcbiAgICAgICAganNvbixcbiAgICAgICAgdmFsaWROb2RlczogbmV3IFNldChPYmplY3Qua2V5cyhzY2hlbWEubm9kZXMpKSxcbiAgICAgICAgdmFsaWRNYXJrczogbmV3IFNldChPYmplY3Qua2V5cyhzY2hlbWEubWFya3MpKSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2FuU2V0TWFyayhzdGF0ZSwgdHIsIG5ld01hcmtUeXBlKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBsZXQgY3Vyc29yID0gbnVsbDtcbiAgICBpZiAoaXNUZXh0U2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgY3Vyc29yID0gc2VsZWN0aW9uLiRjdXJzb3I7XG4gICAgfVxuICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgY29uc3QgY3VycmVudE1hcmtzID0gKF9hID0gc3RhdGUuc3RvcmVkTWFya3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN1cnNvci5tYXJrcygpO1xuICAgICAgICAvLyBUaGVyZSBjYW4gYmUgbm8gY3VycmVudCBtYXJrcyB0aGF0IGV4Y2x1ZGUgdGhlIG5ldyBtYXJrXG4gICAgICAgIHJldHVybiAoISFuZXdNYXJrVHlwZS5pc0luU2V0KGN1cnJlbnRNYXJrcylcbiAgICAgICAgICAgIHx8ICFjdXJyZW50TWFya3Muc29tZShtYXJrID0+IG1hcmsudHlwZS5leGNsdWRlcyhuZXdNYXJrVHlwZSkpKTtcbiAgICB9XG4gICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICByZXR1cm4gcmFuZ2VzLnNvbWUoKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICAgIGxldCBzb21lTm9kZVN1cHBvcnRzTWFyayA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICAgICAgICA/IHN0YXRlLmRvYy5pbmxpbmVDb250ZW50ICYmIHN0YXRlLmRvYy50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKVxuICAgICAgICAgICAgOiBmYWxzZTtcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBfcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFscmVhZHkgZm91bmQgYSBtYXJrIHRoYXQgd2UgY2FuIGVuYWJsZSwgcmV0dXJuIGZhbHNlIHRvIGJ5cGFzcyB0aGUgcmVtYWluaW5nIHNlYXJjaFxuICAgICAgICAgICAgaWYgKHNvbWVOb2RlU3VwcG9ydHNNYXJrKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRBbGxvd3NNYXJrVHlwZSA9ICFwYXJlbnQgfHwgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobmV3TWFya1R5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGUgPSAhIW5ld01hcmtUeXBlLmlzSW5TZXQobm9kZS5tYXJrcylcbiAgICAgICAgICAgICAgICAgICAgfHwgIW5vZGUubWFya3Muc29tZShvdGhlck1hcmsgPT4gb3RoZXJNYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKTtcbiAgICAgICAgICAgICAgICBzb21lTm9kZVN1cHBvcnRzTWFyayA9IHBhcmVudEFsbG93c01hcmtUeXBlICYmIGN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIXNvbWVOb2RlU3VwcG9ydHNNYXJrO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvbWVOb2RlU3VwcG9ydHNNYXJrO1xuICAgIH0pO1xufVxuY29uc3Qgc2V0TWFyayA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgaWYgKGVtcHR5KSB7XG4gICAgICAgICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gZ2V0TWFya0F0dHJpYnV0ZXMoc3RhdGUsIHR5cGUpO1xuICAgICAgICAgICAgdHIuYWRkU3RvcmVkTWFyayh0eXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgLi4ub2xkQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3M7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSByYW5nZS4kdG8ucG9zO1xuICAgICAgICAgICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvbWVIYXNNYXJrID0gbm9kZS5tYXJrcy5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYWxyZWFkeSBhIG1hcmsgb2YgdGhpcyB0eXBlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBoYXZlIHRvIG1lcmdlIGl0cyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB3ZSBhZGQgYSBmcmVzaCBuZXcgbWFya1xuICAgICAgICAgICAgICAgICAgICBpZiAoc29tZUhhc01hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWFya3MuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20sIHRyaW1tZWRUbywgdHlwZS5jcmVhdGUoYXR0cmlidXRlcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuU2V0TWFyayhzdGF0ZSwgdHIsIHR5cGUpO1xufTtcblxuY29uc3Qgc2V0TWV0YSA9IChrZXksIHZhbHVlKSA9PiAoeyB0ciB9KSA9PiB7XG4gICAgdHIuc2V0TWV0YShrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNldE5vZGUgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBsZXQgYXR0cmlidXRlc1RvQ29weTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLiRhbmNob3Iuc2FtZVBhcmVudChzdGF0ZS5zZWxlY3Rpb24uJGhlYWQpKSB7XG4gICAgICAgIC8vIG9ubHkgY29weSBhdHRyaWJ1dGVzIGlmIHRoZSBzZWxlY3Rpb24gaXMgcG9pbnRpbmcgdG8gYSBub2RlIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgYXR0cmlidXRlc1RvQ29weSA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudC5hdHRycztcbiAgICB9XG4gICAgLy8gVE9ETzogdXNlIGEgZmFsbGJhY2sgbGlrZSBpbnNlcnRDb250ZW50P1xuICAgIGlmICghdHlwZS5pc1RleHRibG9jaykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IEN1cnJlbnRseSBcInNldE5vZGUoKVwiIG9ubHkgc3VwcG9ydHMgdGV4dCBibG9jayBub2Rlcy4nKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gKGNoYWluKClcbiAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAgIC5jb21tYW5kKCh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgY29uc3QgY2FuU2V0QmxvY2sgPSBzZXRCbG9ja1R5cGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pKHN0YXRlKTtcbiAgICAgICAgaWYgKGNhblNldEJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgIH0pXG4gICAgICAgIC5jb21tYW5kKCh7IHN0YXRlOiB1cGRhdGVkU3RhdGUgfSkgPT4ge1xuICAgICAgICByZXR1cm4gc2V0QmxvY2tUeXBlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KSh1cGRhdGVkU3RhdGUsIGRpc3BhdGNoKTtcbiAgICB9KVxuICAgICAgICAucnVuKCkpO1xufTtcblxuY29uc3Qgc2V0Tm9kZVNlbGVjdGlvbiA9IHBvc2l0aW9uID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcbiAgICAgICAgY29uc3QgZnJvbSA9IG1pbk1heChwb3NpdGlvbiwgMCwgZG9jLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgZnJvbSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNldFRleHRTZWxlY3Rpb24gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHR5cGVvZiBwb3NpdGlvbiA9PT0gJ251bWJlcicgPyB7IGZyb206IHBvc2l0aW9uLCB0bzogcG9zaXRpb24gfSA6IHBvc2l0aW9uO1xuICAgICAgICBjb25zdCBtaW5Qb3MgPSBUZXh0U2VsZWN0aW9uLmF0U3RhcnQoZG9jKS5mcm9tO1xuICAgICAgICBjb25zdCBtYXhQb3MgPSBUZXh0U2VsZWN0aW9uLmF0RW5kKGRvYykudG87XG4gICAgICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkRW5kID0gbWluTWF4KHRvLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmVzb2x2ZWRGcm9tLCByZXNvbHZlZEVuZCk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNpbmtMaXN0SXRlbSA9IHR5cGVPck5hbWUgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICByZXR1cm4gc2lua0xpc3RJdGVtJDEodHlwZSkoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmZ1bmN0aW9uIGVuc3VyZU1hcmtzKHN0YXRlLCBzcGxpdHRhYmxlTWFya3MpIHtcbiAgICBjb25zdCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgaWYgKG1hcmtzKSB7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MgPT09IG51bGwgfHwgc3BsaXR0YWJsZU1hcmtzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgc3RhdGUudHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgfVxufVxuY29uc3Qgc3BsaXRCbG9jayA9ICh7IGtlZXBNYXJrcyA9IHRydWUgfSA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0cjtcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHNlbGVjdGlvbjtcbiAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycyk7XG4gICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsZWN0aW9uLm5vZGUuaXNCbG9jaykge1xuICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoZG9jLCAkZnJvbS5wb3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICAgICAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghJGZyb20ucGFyZW50LmlzQmxvY2spIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhdEVuZCA9ICR0by5wYXJlbnRPZmZzZXQgPT09ICR0by5wYXJlbnQuY29udGVudC5zaXplO1xuICAgIGNvbnN0IGRlZmx0ID0gJGZyb20uZGVwdGggPT09IDBcbiAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgOiBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKC0xKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKC0xKSkpO1xuICAgIGxldCB0eXBlcyA9IGF0RW5kICYmIGRlZmx0XG4gICAgICAgID8gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IGRlZmx0LFxuICAgICAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgaWYgKCF0eXBlc1xuICAgICAgICAmJiAhY2FuXG4gICAgICAgICYmIGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgZGVmbHQgPyBbeyB0eXBlOiBkZWZsdCB9XSA6IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgY2FuID0gdHJ1ZTtcbiAgICAgICAgdHlwZXMgPSBkZWZsdFxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IG5ld0F0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgaWYgKGNhbikge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLnNwbGl0KHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIHR5cGVzKTtcbiAgICAgICAgICAgIGlmIChkZWZsdCAmJiAhYXRFbmQgJiYgISRmcm9tLnBhcmVudE9mZnNldCAmJiAkZnJvbS5wYXJlbnQudHlwZSAhPT0gZGVmbHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCAkZmlyc3QgPSB0ci5kb2MucmVzb2x2ZShmaXJzdCk7XG4gICAgICAgICAgICAgICAgaWYgKCRmcm9tLm5vZGUoLTEpLmNhblJlcGxhY2VXaXRoKCRmaXJzdC5pbmRleCgpLCAkZmlyc3QuaW5kZXgoKSArIDEsIGRlZmx0KSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZSgpKSwgZGVmbHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2VlcE1hcmtzKSB7XG4gICAgICAgICAgICBlbnN1cmVNYXJrcyhzdGF0ZSwgZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuc3BsaXR0YWJsZU1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuO1xufTtcblxuY29uc3Qgc3BsaXRMaXN0SXRlbSA9ICh0eXBlT3JOYW1lLCBvdmVycmlkZUF0dHJzID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGVkaXRvciwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgY29uc3Qgbm9kZSA9IHN0YXRlLnNlbGVjdGlvbi5ub2RlO1xuICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICBpZiAoZ3JhbmRQYXJlbnQudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5hdHRyaWJ1dGVzO1xuICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09PSAwICYmICRmcm9tLm5vZGUoLTEpLmNoaWxkQ291bnQgPT09ICRmcm9tLmluZGV4QWZ0ZXIoLTEpKSB7XG4gICAgICAgIC8vIEluIGFuIGVtcHR5IGJsb2NrLiBJZiB0aGlzIGlzIGEgbmVzdGVkIGxpc3QsIHRoZSB3cmFwcGluZ1xuICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAvLyBjb21tYW5kIGhhbmRsZSBsaWZ0aW5nLlxuICAgICAgICBpZiAoJGZyb20uZGVwdGggPT09IDJcbiAgICAgICAgICAgIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT09IHR5cGVcbiAgICAgICAgICAgIHx8ICRmcm9tLmluZGV4KC0yKSAhPT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgICAgIGNvbnN0IGRlcHRoQmVmb3JlID0gJGZyb20uaW5kZXgoLTEpID8gMSA6ICRmcm9tLmluZGV4KC0yKSA/IDIgOiAzO1xuICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG91dGVyIGxpc3QgaXRlbSB0byB0aGUgcGFyZW50IG5vZGUgb2YgdGhlIGN1cnNvclxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoIC0gZGVwdGhCZWZvcmU7IGQgPj0gJGZyb20uZGVwdGggLSAzOyBkIC09IDEpIHtcbiAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkod3JhcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBjb25zdCBkZXB0aEFmdGVyID0gJGZyb20uaW5kZXhBZnRlcigtMSkgPCAkZnJvbS5ub2RlKC0yKS5jaGlsZENvdW50ID8gMSA6ICRmcm9tLmluZGV4QWZ0ZXIoLTIpIDwgJGZyb20ubm9kZSgtMykuY2hpbGRDb3VudCA/IDIgOiAzO1xuICAgICAgICAgICAgLy8gQWRkIGEgc2Vjb25kIGxpc3QgaXRlbSB3aXRoIGFuIGVtcHR5IGRlZmF1bHQgc3RhcnQgbm9kZVxuICAgICAgICAgICAgY29uc3QgbmV3TmV4dFR5cGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICAgICAgICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgICAgICAgICAgICAgIC4uLm92ZXJyaWRlQXR0cnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbmV4dFR5cGUgPSAoKF9hID0gdHlwZS5jb250ZW50TWF0Y2guZGVmYXVsdFR5cGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jcmVhdGVBbmRGaWxsKG5ld05leHRUeXBlQXR0cmlidXRlcykpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdyYXAgPSB3cmFwLmFwcGVuZChGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlQW5kRmlsbChudWxsLCBuZXh0VHlwZSkgfHwgdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9ICRmcm9tLmJlZm9yZSgkZnJvbS5kZXB0aCAtIChkZXB0aEJlZm9yZSAtIDEpKTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgbGV0IHNlbCA9IC0xO1xuICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihzdGFydCwgdHIuZG9jLmNvbnRlbnQuc2l6ZSwgKG4sIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuLmlzVGV4dGJsb2NrICYmIG4uY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKHNlbCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG5leHRUeXBlID0gJHRvLnBvcyA9PT0gJGZyb20uZW5kKCkgPyBncmFuZFBhcmVudC5jb250ZW50TWF0Y2hBdCgwKS5kZWZhdWx0VHlwZSA6IG51bGw7XG4gICAgY29uc3QgbmV3VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCBncmFuZFBhcmVudC50eXBlLm5hbWUsIGdyYW5kUGFyZW50LmF0dHJzKSxcbiAgICAgICAgLi4ub3ZlcnJpZGVBdHRycyxcbiAgICB9O1xuICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IHtcbiAgICAgICAgLi4uZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMsICRmcm9tLm5vZGUoKS50eXBlLm5hbWUsICRmcm9tLm5vZGUoKS5hdHRycyksXG4gICAgICAgIC4uLm92ZXJyaWRlQXR0cnMsXG4gICAgfTtcbiAgICB0ci5kZWxldGUoJGZyb20ucG9zLCAkdG8ucG9zKTtcbiAgICBjb25zdCB0eXBlcyA9IG5leHRUeXBlXG4gICAgICAgID8gW1xuICAgICAgICAgICAgeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICAgICAgICAgIHsgdHlwZTogbmV4dFR5cGUsIGF0dHJzOiBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgfSxcbiAgICAgICAgXVxuICAgICAgICA6IFt7IHR5cGUsIGF0dHJzOiBuZXdUeXBlQXR0cmlidXRlcyB9XTtcbiAgICBpZiAoIWNhblNwbGl0KHRyLmRvYywgJGZyb20ucG9zLCAyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgdHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgaWYgKCFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3Qgam9pbkxpc3RCYWNrd2FyZHMgPSAodHIsIGxpc3RUeXBlKSA9PiB7XG4gICAgY29uc3QgbGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlID09PSBsaXN0VHlwZSkodHIuc2VsZWN0aW9uKTtcbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIGxpc3QucG9zIC0gMSkpLmJlZm9yZShsaXN0LmRlcHRoKTtcbiAgICBpZiAoYmVmb3JlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG5vZGVCZWZvcmUgPSB0ci5kb2Mubm9kZUF0KGJlZm9yZSk7XG4gICAgY29uc3QgY2FuSm9pbkJhY2t3YXJkcyA9IGxpc3Qubm9kZS50eXBlID09PSAobm9kZUJlZm9yZSA9PT0gbnVsbCB8fCBub2RlQmVmb3JlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlQmVmb3JlLnR5cGUpICYmIGNhbkpvaW4odHIuZG9jLCBsaXN0LnBvcyk7XG4gICAgaWYgKCFjYW5Kb2luQmFja3dhcmRzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0ci5qb2luKGxpc3QucG9zKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBqb2luTGlzdEZvcndhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBhZnRlciA9IHRyLmRvYy5yZXNvbHZlKGxpc3Quc3RhcnQpLmFmdGVyKGxpc3QuZGVwdGgpO1xuICAgIGlmIChhZnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBub2RlQWZ0ZXIgPSB0ci5kb2Mubm9kZUF0KGFmdGVyKTtcbiAgICBjb25zdCBjYW5Kb2luRm9yd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVBZnRlciA9PT0gbnVsbCB8fCBub2RlQWZ0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVBZnRlci50eXBlKSAmJiBjYW5Kb2luKHRyLmRvYywgYWZ0ZXIpO1xuICAgIGlmICghY2FuSm9pbkZvcndhcmRzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0ci5qb2luKGFmdGVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCB0b2dnbGVMaXN0ID0gKGxpc3RUeXBlT3JOYW1lLCBpdGVtVHlwZU9yTmFtZSwga2VlcE1hcmtzLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IGVkaXRvciwgdHIsIHN0YXRlLCBkaXNwYXRjaCwgY2hhaW4sIGNvbW1hbmRzLCBjYW4sIH0pID0+IHtcbiAgICBjb25zdCB7IGV4dGVuc2lvbnMsIHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gICAgY29uc3QgbGlzdFR5cGUgPSBnZXROb2RlVHlwZShsaXN0VHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpdGVtVHlwZSA9IGdldE5vZGVUeXBlKGl0ZW1UeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgY29uc3QgbWFya3MgPSBzdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgIGlmICghcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnRMaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBpc0xpc3Qobm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpKShzZWxlY3Rpb24pO1xuICAgIGlmIChyYW5nZS5kZXB0aCA+PSAxICYmIHBhcmVudExpc3QgJiYgcmFuZ2UuZGVwdGggLSBwYXJlbnRMaXN0LmRlcHRoIDw9IDEpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGxpc3RcbiAgICAgICAgaWYgKHBhcmVudExpc3Qubm9kZS50eXBlID09PSBsaXN0VHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnRMaXN0SXRlbShpdGVtVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2hhbmdlIGxpc3QgdHlwZVxuICAgICAgICBpZiAoaXNMaXN0KHBhcmVudExpc3Qubm9kZS50eXBlLm5hbWUsIGV4dGVuc2lvbnMpXG4gICAgICAgICAgICAmJiBsaXN0VHlwZS52YWxpZENvbnRlbnQocGFyZW50TGlzdC5ub2RlLmNvbnRlbnQpXG4gICAgICAgICAgICAmJiBkaXNwYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwYXJlbnRMaXN0LnBvcywgbGlzdFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAgICAgICAucnVuKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFrZWVwTWFya3MgfHwgIW1hcmtzIHx8ICFkaXNwYXRjaCkge1xuICAgICAgICByZXR1cm4gY2hhaW4oKVxuICAgICAgICAgICAgLy8gdHJ5IHRvIGNvbnZlcnQgbm9kZSB0byBkZWZhdWx0IG5vZGUgaWYgbmVlZGVkXG4gICAgICAgICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBpZiAoY2FuV3JhcEluTGlzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAgIC5ydW4oKTtcbiAgICB9XG4gICAgcmV0dXJuIChjaGFpbigpXG4gICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNhbldyYXBJbkxpc3QgPSBjYW4oKS53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgfSlcbiAgICAgICAgLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0Rm9yd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgLnJ1bigpKTtcbn07XG5cbmNvbnN0IHRvZ2dsZU1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9LCBvcHRpb25zID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0eXBlLCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0eXBlLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IHRvZ2dsZU5vZGUgPSAodHlwZU9yTmFtZSwgdG9nZ2xlVHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IHRvZ2dsZVR5cGUgPSBnZXROb2RlVHlwZSh0b2dnbGVUeXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBsZXQgYXR0cmlidXRlc1RvQ29weTtcbiAgICBpZiAoc3RhdGUuc2VsZWN0aW9uLiRhbmNob3Iuc2FtZVBhcmVudChzdGF0ZS5zZWxlY3Rpb24uJGhlYWQpKSB7XG4gICAgICAgIC8vIG9ubHkgY29weSBhdHRyaWJ1dGVzIGlmIHRoZSBzZWxlY3Rpb24gaXMgcG9pbnRpbmcgdG8gYSBub2RlIG9mIHRoZSBzYW1lIHR5cGVcbiAgICAgICAgYXR0cmlidXRlc1RvQ29weSA9IHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnBhcmVudC5hdHRycztcbiAgICB9XG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRvZ2dsZVR5cGUsIGF0dHJpYnV0ZXNUb0NvcHkpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgbm9kZSBpcyBub3QgYWN0aXZlLCB3ZSB3YW50IHRvIHNldCB0aGUgbmV3IG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzXG4gICAgLy8gQ29weWluZyBvdmVyIHRoZSBhdHRyaWJ1dGVzIGZyb20gdGhlIGN1cnJlbnQgbm9kZSBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE5vZGUodHlwZSwgeyAuLi5hdHRyaWJ1dGVzVG9Db3B5LCAuLi5hdHRyaWJ1dGVzIH0pO1xufTtcblxuY29uc3QgdG9nZ2xlV3JhcCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBjb21tYW5kcyB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSBpc05vZGVBY3RpdmUoc3RhdGUsIHR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0eXBlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLndyYXBJbih0eXBlLCBhdHRyaWJ1dGVzKTtcbn07XG5cbmNvbnN0IHVuZG9JbnB1dFJ1bGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHBsdWdpbnMgPSBzdGF0ZS5wbHVnaW5zO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgICAgICBsZXQgdW5kb2FibGU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIGlmIChwbHVnaW4uc3BlYy5pc0lucHV0UnVsZXMgJiYgKHVuZG9hYmxlID0gcGx1Z2luLmdldFN0YXRlKHN0YXRlKSkpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9VbmRvID0gdW5kb2FibGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0b1VuZG8uc3RlcHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqIC09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuc3RlcCh0b1VuZG8uc3RlcHNbal0uaW52ZXJ0KHRvVW5kby5kb2NzW2pdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh1bmRvYWJsZS50ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gdHIuZG9jLnJlc29sdmUodW5kb2FibGUuZnJvbSkubWFya3MoKTtcbiAgICAgICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8sIHN0YXRlLnNjaGVtYS50ZXh0KHVuZG9hYmxlLnRleHQsIG1hcmtzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUodW5kb2FibGUuZnJvbSwgdW5kb2FibGUudG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IHVuc2V0QWxsTWFya3MgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoZW1wdHkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICByYW5nZXMuZm9yRWFjaChyYW5nZSA9PiB7XG4gICAgICAgICAgICB0ci5yZW1vdmVNYXJrKHJhbmdlLiRmcm9tLnBvcywgcmFuZ2UuJHRvLnBvcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHVuc2V0TWFyayA9ICh0eXBlT3JOYW1lLCBvcHRpb25zID0ge30pID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IGV4dGVuZEVtcHR5TWFya1JhbmdlID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHRyO1xuICAgIGNvbnN0IHR5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IHsgJGZyb20sIGVtcHR5LCByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZW1wdHkgJiYgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UpIHtcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgYXR0cnMgPSAoX2EgPSAkZnJvbS5tYXJrcygpLmZpbmQobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnM7XG4gICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRmcm9tLCB0eXBlLCBhdHRycyk7XG4gICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgZnJvbSA9IHJhbmdlLmZyb207XG4gICAgICAgICAgICB0byA9IHJhbmdlLnRvO1xuICAgICAgICB9XG4gICAgICAgIHRyLnJlbW92ZU1hcmsoZnJvbSwgdG8sIHR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIHR5cGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdHIucmVtb3ZlU3RvcmVkTWFyayh0eXBlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHVwZGF0ZUF0dHJpYnV0ZXMgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBsZXQgbm9kZVR5cGUgPSBudWxsO1xuICAgIGxldCBtYXJrVHlwZSA9IG51bGw7XG4gICAgY29uc3Qgc2NoZW1hVHlwZSA9IGdldFNjaGVtYVR5cGVOYW1lQnlOYW1lKHR5cGVvZiB0eXBlT3JOYW1lID09PSAnc3RyaW5nJyA/IHR5cGVPck5hbWUgOiB0eXBlT3JOYW1lLm5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgaWYgKCFzY2hlbWFUeXBlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdub2RlJykge1xuICAgICAgICBub2RlVHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgbWFya1R5cGUgPSBnZXRNYXJrVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdHIuc2VsZWN0aW9uLnJhbmdlcy5mb3JFYWNoKChyYW5nZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHJhbmdlLiRmcm9tLnBvcztcbiAgICAgICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvcztcbiAgICAgICAgICAgIGxldCBsYXN0UG9zO1xuICAgICAgICAgICAgbGV0IGxhc3ROb2RlO1xuICAgICAgICAgICAgbGV0IHRyaW1tZWRGcm9tO1xuICAgICAgICAgICAgbGV0IHRyaW1tZWRUbztcbiAgICAgICAgICAgIGlmICh0ci5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tICYmIG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaW1tZWRUbyA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA+PSBmcm9tICYmIHBvcyA8PSB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlICYmIG5vZGVUeXBlID09PSBub2RlLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgJiYgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tMiA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkVG8yID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbTIsIHRyaW1tZWRUbzIsIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ubWFyay5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsYXN0Tm9kZSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0UG9zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChsYXN0UG9zLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmxhc3ROb2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBsYXN0Tm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGUubWFya3MuZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlID09PSBtYXJrLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIG1hcmtUeXBlLmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHdyYXBJbiA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIHdyYXBJbiQxKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCB3cmFwSW5MaXN0ID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICByZXR1cm4gd3JhcEluTGlzdCQxKHR5cGUsIGF0dHJpYnV0ZXMpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG52YXIgY29tbWFuZHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYmx1cjogYmx1cixcbiAgY2xlYXJDb250ZW50OiBjbGVhckNvbnRlbnQsXG4gIGNsZWFyTm9kZXM6IGNsZWFyTm9kZXMsXG4gIGNvbW1hbmQ6IGNvbW1hbmQsXG4gIGNyZWF0ZVBhcmFncmFwaE5lYXI6IGNyZWF0ZVBhcmFncmFwaE5lYXIsXG4gIGN1dDogY3V0LFxuICBkZWxldGVDdXJyZW50Tm9kZTogZGVsZXRlQ3VycmVudE5vZGUsXG4gIGRlbGV0ZU5vZGU6IGRlbGV0ZU5vZGUsXG4gIGRlbGV0ZVJhbmdlOiBkZWxldGVSYW5nZSxcbiAgZGVsZXRlU2VsZWN0aW9uOiBkZWxldGVTZWxlY3Rpb24sXG4gIGVudGVyOiBlbnRlcixcbiAgZXhpdENvZGU6IGV4aXRDb2RlLFxuICBleHRlbmRNYXJrUmFuZ2U6IGV4dGVuZE1hcmtSYW5nZSxcbiAgZmlyc3Q6IGZpcnN0LFxuICBmb2N1czogZm9jdXMsXG4gIGZvckVhY2g6IGZvckVhY2gsXG4gIGluc2VydENvbnRlbnQ6IGluc2VydENvbnRlbnQsXG4gIGluc2VydENvbnRlbnRBdDogaW5zZXJ0Q29udGVudEF0LFxuICBqb2luQmFja3dhcmQ6IGpvaW5CYWNrd2FyZCxcbiAgam9pbkRvd246IGpvaW5Eb3duLFxuICBqb2luRm9yd2FyZDogam9pbkZvcndhcmQsXG4gIGpvaW5JdGVtQmFja3dhcmQ6IGpvaW5JdGVtQmFja3dhcmQsXG4gIGpvaW5JdGVtRm9yd2FyZDogam9pbkl0ZW1Gb3J3YXJkLFxuICBqb2luVGV4dGJsb2NrQmFja3dhcmQ6IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCxcbiAgam9pblRleHRibG9ja0ZvcndhcmQ6IGpvaW5UZXh0YmxvY2tGb3J3YXJkLFxuICBqb2luVXA6IGpvaW5VcCxcbiAga2V5Ym9hcmRTaG9ydGN1dDoga2V5Ym9hcmRTaG9ydGN1dCxcbiAgbGlmdDogbGlmdCxcbiAgbGlmdEVtcHR5QmxvY2s6IGxpZnRFbXB0eUJsb2NrLFxuICBsaWZ0TGlzdEl0ZW06IGxpZnRMaXN0SXRlbSxcbiAgbmV3bGluZUluQ29kZTogbmV3bGluZUluQ29kZSxcbiAgcmVzZXRBdHRyaWJ1dGVzOiByZXNldEF0dHJpYnV0ZXMsXG4gIHNjcm9sbEludG9WaWV3OiBzY3JvbGxJbnRvVmlldyxcbiAgc2VsZWN0QWxsOiBzZWxlY3RBbGwsXG4gIHNlbGVjdE5vZGVCYWNrd2FyZDogc2VsZWN0Tm9kZUJhY2t3YXJkLFxuICBzZWxlY3ROb2RlRm9yd2FyZDogc2VsZWN0Tm9kZUZvcndhcmQsXG4gIHNlbGVjdFBhcmVudE5vZGU6IHNlbGVjdFBhcmVudE5vZGUsXG4gIHNlbGVjdFRleHRibG9ja0VuZDogc2VsZWN0VGV4dGJsb2NrRW5kLFxuICBzZWxlY3RUZXh0YmxvY2tTdGFydDogc2VsZWN0VGV4dGJsb2NrU3RhcnQsXG4gIHNldENvbnRlbnQ6IHNldENvbnRlbnQsXG4gIHNldE1hcms6IHNldE1hcmssXG4gIHNldE1ldGE6IHNldE1ldGEsXG4gIHNldE5vZGU6IHNldE5vZGUsXG4gIHNldE5vZGVTZWxlY3Rpb246IHNldE5vZGVTZWxlY3Rpb24sXG4gIHNldFRleHRTZWxlY3Rpb246IHNldFRleHRTZWxlY3Rpb24sXG4gIHNpbmtMaXN0SXRlbTogc2lua0xpc3RJdGVtLFxuICBzcGxpdEJsb2NrOiBzcGxpdEJsb2NrLFxuICBzcGxpdExpc3RJdGVtOiBzcGxpdExpc3RJdGVtLFxuICB0b2dnbGVMaXN0OiB0b2dnbGVMaXN0LFxuICB0b2dnbGVNYXJrOiB0b2dnbGVNYXJrLFxuICB0b2dnbGVOb2RlOiB0b2dnbGVOb2RlLFxuICB0b2dnbGVXcmFwOiB0b2dnbGVXcmFwLFxuICB1bmRvSW5wdXRSdWxlOiB1bmRvSW5wdXRSdWxlLFxuICB1bnNldEFsbE1hcmtzOiB1bnNldEFsbE1hcmtzLFxuICB1bnNldE1hcms6IHVuc2V0TWFyayxcbiAgdXBkYXRlQXR0cmlidXRlczogdXBkYXRlQXR0cmlidXRlcyxcbiAgd3JhcEluOiB3cmFwSW4sXG4gIHdyYXBJbkxpc3Q6IHdyYXBJbkxpc3Rcbn0pO1xuXG5jb25zdCBDb21tYW5kcyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdjb21tYW5kcycsXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tYW5kcyxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IERyb3AgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZHJvcCcsXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCd0aXB0YXBEcm9wJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRHJvcDogKF8sIGUsIHNsaWNlLCBtb3ZlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdCgnZHJvcCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vdmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgRWRpdGFibGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZWRpdGFibGUnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgnZWRpdGFibGUnKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBlZGl0YWJsZTogKCkgPT4gdGhpcy5lZGl0b3Iub3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBmb2N1c0V2ZW50c1BsdWdpbktleSA9IG5ldyBQbHVnaW5LZXkoJ2ZvY3VzRXZlbnRzJyk7XG5jb25zdCBGb2N1c0V2ZW50cyA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdmb2N1c0V2ZW50cycsXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogZm9jdXNFdmVudHNQbHVnaW5LZXksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1czogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ2ZvY3VzJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBibHVyOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3IuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBlZGl0b3Iuc3RhdGUudHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ2JsdXInLCB7IGV2ZW50IH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdhZGRUb0hpc3RvcnknLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBLZXltYXAgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAna2V5bWFwJyxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQmFja3NwYWNlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMudW5kb0lucHV0UnVsZSgpLFxuICAgICAgICAgICAgLy8gbWF5YmUgY29udmVydCBmaXJzdCB0ZXh0IGJsb2NrIG5vZGUgdG8gZGVmYXVsdCBub2RlXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSB0cjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVtcHR5LCAkYW5jaG9yIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwb3MsIHBhcmVudCB9ID0gJGFuY2hvcjtcbiAgICAgICAgICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gJGFuY2hvci5wYXJlbnQuaXNUZXh0YmxvY2sgJiYgcG9zID4gMCA/IHRyLmRvYy5yZXNvbHZlKHBvcyAtIDEpIDogJGFuY2hvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRJc0lzb2xhdGluZyA9ICRwYXJlbnRQb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmc7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50UG9zID0gJGFuY2hvci5wb3MgLSAkYW5jaG9yLnBhcmVudE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAocGFyZW50SXNJc29sYXRpbmcgJiYgJHBhcmVudFBvcy5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJlbnRQb3MgPT09ICRhbmNob3IucG9zXG4gICAgICAgICAgICAgICAgICAgIDogU2VsZWN0aW9uLmF0U3RhcnQoZG9jKS5mcm9tID09PSBwb3M7XG4gICAgICAgICAgICAgICAgaWYgKCFlbXB0eVxuICAgICAgICAgICAgICAgICAgICB8fCAhcGFyZW50LnR5cGUuaXNUZXh0YmxvY2tcbiAgICAgICAgICAgICAgICAgICAgfHwgcGFyZW50LnRleHRDb250ZW50Lmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB8fCAhaXNBdFN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHx8IChpc0F0U3RhcnQgJiYgJGFuY2hvci5wYXJlbnQudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJykgLy8gcHJldmVudCBjbGVhck5vZGVzIHdoZW4gbm8gbm9kZXMgdG8gY2xlYXIsIG90aGVyd2lzZSBoaXN0b3J5IHN0YWNrIGlzIGFwcGVuZGVkXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5qb2luQmFja3dhcmQoKSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVCYWNrd2FyZCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRGVsZXRlID0gKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuZmlyc3QoKHsgY29tbWFuZHMgfSkgPT4gW1xuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlU2VsZWN0aW9uKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5kZWxldGVDdXJyZW50Tm9kZSgpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkZvcndhcmQoKSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnNlbGVjdE5vZGVGb3J3YXJkKCksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBoYW5kbGVFbnRlciA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLm5ld2xpbmVJbkNvZGUoKSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmNyZWF0ZVBhcmFncmFwaE5lYXIoKSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmxpZnRFbXB0eUJsb2NrKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zcGxpdEJsb2NrKCksXG4gICAgICAgIF0pO1xuICAgICAgICBjb25zdCBiYXNlS2V5bWFwID0ge1xuICAgICAgICAgICAgRW50ZXI6IGhhbmRsZUVudGVyLFxuICAgICAgICAgICAgJ01vZC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCksXG4gICAgICAgICAgICBCYWNrc3BhY2U6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdNb2QtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgICAgICAgJ1NoaWZ0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgIERlbGV0ZTogaGFuZGxlRGVsZXRlLFxuICAgICAgICAgICAgJ01vZC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnTW9kLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RBbGwoKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGNLZXltYXAgPSB7XG4gICAgICAgICAgICAuLi5iYXNlS2V5bWFwLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYWNLZXltYXAgPSB7XG4gICAgICAgICAgICAuLi5iYXNlS2V5bWFwLFxuICAgICAgICAgICAgJ0N0cmwtaCc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdBbHQtQmFja3NwYWNlJzogaGFuZGxlQmFja3NwYWNlLFxuICAgICAgICAgICAgJ0N0cmwtZCc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICAgICAgICdDdHJsLUFsdC1CYWNrc3BhY2UnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQWx0LURlbGV0ZSc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICAgICAgICdBbHQtZCc6IGhhbmRsZURlbGV0ZSxcbiAgICAgICAgICAgICdDdHJsLWEnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tTdGFydCgpLFxuICAgICAgICAgICAgJ0N0cmwtZSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNlbGVjdFRleHRibG9ja0VuZCgpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNpT1MoKSB8fCBpc01hY09TKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWNLZXltYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBjS2V5bWFwO1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gV2l0aCB0aGlzIHBsdWdpbiB3ZSBjaGVjayBpZiB0aGUgd2hvbGUgZG9jdW1lbnQgd2FzIHNlbGVjdGVkIGFuZCBkZWxldGVkLlxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIHdlIHdpbGwgYWRkaXRpb25hbGx5IGNhbGwgYGNsZWFyTm9kZXMoKWAgdG8gY29udmVydCBlLmcuIGEgaGVhZGluZ1xuICAgICAgICAgICAgLy8gdG8gYSBwYXJhZ3JhcGggaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBhbHRlcm5hdGl2ZSB0byBQcm9zZU1pcnJvcidzIGBBbGxTZWxlY3Rpb25gLCB3aGljaCBkb2VzbuKAmXQgd29yayB3ZWxsXG4gICAgICAgICAgICAvLyB3aXRoIG1hbnkgb3RoZXIgY29tbWFuZHMuXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsZWFyRG9jdW1lbnQnKSxcbiAgICAgICAgICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIG5ld1N0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbnMuc29tZSh0ciA9PiB0ci5nZXRNZXRhKCdjb21wb3NpdGlvbicpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZXMgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgIW9sZFN0YXRlLmRvYy5lcShuZXdTdGF0ZS5kb2MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZ25vcmVUciA9IHRyYW5zYWN0aW9ucy5zb21lKHRyYW5zYWN0aW9uID0+IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRDbGVhckRvY3VtZW50JykpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRvY0NoYW5nZXMgfHwgaWdub3JlVHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVtcHR5LCBmcm9tLCB0byB9ID0gb2xkU3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxGcm9tID0gU2VsZWN0aW9uLmF0U3RhcnQob2xkU3RhdGUuZG9jKS5mcm9tO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxFbmQgPSBTZWxlY3Rpb24uYXRFbmQob2xkU3RhdGUuZG9jKS50bztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsV2FzU2VsZWN0ZWQgPSBmcm9tID09PSBhbGxGcm9tICYmIHRvID09PSBhbGxFbmQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbXB0eSB8fCAhYWxsV2FzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gaXNOb2RlRW1wdHkobmV3U3RhdGUuZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHIgPSBuZXdTdGF0ZS50cjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNvbW1hbmRzIH0gPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBQYXN0ZSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdwYXN0ZScsXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCd0aXB0YXBQYXN0ZScpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVBhc3RlOiAoX3ZpZXcsIGUsIHNsaWNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5lbWl0KCdwYXN0ZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgVGFiaW5kZXggPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAndGFiaW5kZXgnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGFiaW5kZXgnKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiAoKSA9PiAodGhpcy5lZGl0b3IuaXNFZGl0YWJsZSA/IHsgdGFiaW5kZXg6ICcwJyB9IDoge30pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbnZhciBpbmRleCA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBDbGlwYm9hcmRUZXh0U2VyaWFsaXplcjogQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIsXG4gIENvbW1hbmRzOiBDb21tYW5kcyxcbiAgRHJvcDogRHJvcCxcbiAgRWRpdGFibGU6IEVkaXRhYmxlLFxuICBGb2N1c0V2ZW50czogRm9jdXNFdmVudHMsXG4gIEtleW1hcDogS2V5bWFwLFxuICBQYXN0ZTogUGFzdGUsXG4gIFRhYmluZGV4OiBUYWJpbmRleCxcbiAgZm9jdXNFdmVudHNQbHVnaW5LZXk6IGZvY3VzRXZlbnRzUGx1Z2luS2V5XG59KTtcblxuY2xhc3MgTm9kZVBvcyB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudHlwZS5uYW1lO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGVkaXRvciwgaXNCbG9jayA9IGZhbHNlLCBub2RlID0gbnVsbCkge1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5hY3R1YWxEZXB0aCA9IG51bGw7XG4gICAgICAgIHRoaXMuaXNCbG9jayA9IGlzQmxvY2s7XG4gICAgICAgIHRoaXMucmVzb2x2ZWRQb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcbiAgICB9XG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnROb2RlIHx8IHRoaXMucmVzb2x2ZWRQb3Mubm9kZSgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tQXRQb3ModGhpcy5wb3MpLm5vZGU7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5hY3R1YWxEZXB0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5yZXNvbHZlZFBvcy5kZXB0aDtcbiAgICB9XG4gICAgZ2V0IHBvcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MucG9zO1xuICAgIH1cbiAgICBnZXQgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS5jb250ZW50O1xuICAgIH1cbiAgICBzZXQgY29udGVudChjb250ZW50KSB7XG4gICAgICAgIGxldCBmcm9tID0gdGhpcy5mcm9tO1xuICAgICAgICBsZXQgdG8gPSB0aGlzLnRvO1xuICAgICAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50LnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBZb3UgY2Fu4oCZdCBzZXQgY29udGVudCBvbiBhIGJsb2NrIG5vZGUuIFRyaWVkIHRvIHNldCBjb250ZW50IG9uICR7dGhpcy5uYW1lfSBhdCAke3RoaXMucG9zfWApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZyb20gPSB0aGlzLmZyb20gKyAxO1xuICAgICAgICAgICAgdG8gPSB0aGlzLnRvIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tLCB0byB9LCBjb250ZW50KTtcbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuYXR0cnM7XG4gICAgfVxuICAgIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZS50ZXh0Q29udGVudDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUubm9kZVNpemU7XG4gICAgfVxuICAgIGdldCBmcm9tKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3Muc3RhcnQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCk7XG4gICAgfVxuICAgIGdldCByYW5nZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXQgdG8oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvcyArIHRoaXMuc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZFBvcy5lbmQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCkgKyAodGhpcy5ub2RlLmlzVGV4dCA/IDAgOiAxKTtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVwdGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudFBvcyA9IHRoaXMucmVzb2x2ZWRQb3Muc3RhcnQodGhpcy5yZXNvbHZlZFBvcy5kZXB0aCAtIDEpO1xuICAgICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZShwYXJlbnRQb3MpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpO1xuICAgIH1cbiAgICBnZXQgYmVmb3JlKCkge1xuICAgICAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gKHRoaXMuaXNCbG9jayA/IDEgOiAyKSk7XG4gICAgICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLmZyb20gLSAzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IpO1xuICAgIH1cbiAgICBnZXQgYWZ0ZXIoKSB7XG4gICAgICAgIGxldCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgKHRoaXMuaXNCbG9jayA/IDIgOiAxKSk7XG4gICAgICAgIGlmICgkcG9zLmRlcHRoICE9PSB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0aGlzLnRvICsgMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB0aGlzLm5vZGUuY29udGVudC5mb3JFYWNoKChub2RlLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQmxvY2sgPSBub2RlLmlzQmxvY2sgJiYgIW5vZGUuaXNUZXh0YmxvY2s7XG4gICAgICAgICAgICBjb25zdCBpc05vblRleHRBdG9tID0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0UG9zID0gdGhpcy5wb3MgKyBvZmZzZXQgKyAoaXNOb25UZXh0QXRvbSA/IDAgOiAxKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRhcmdldFBvcyBpcyB3aXRoaW4gdmFsaWQgZG9jdW1lbnQgcmFuZ2VcbiAgICAgICAgICAgIGlmICh0YXJnZXRQb3MgPCAwIHx8IHRhcmdldFBvcyA+IHRoaXMucmVzb2x2ZWRQb3MuZG9jLm5vZGVTaXplIC0gMikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRhcmdldFBvcyk7XG4gICAgICAgICAgICBpZiAoIWlzQmxvY2sgJiYgJHBvcy5kZXB0aCA8PSB0aGlzLmRlcHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlUG9zID0gbmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCk7XG4gICAgICAgICAgICBpZiAoaXNCbG9jaykge1xuICAgICAgICAgICAgICAgIGNoaWxkTm9kZVBvcy5hY3R1YWxEZXB0aCA9IHRoaXMuZGVwdGggKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvciwgaXNCbG9jaywgaXNCbG9jayA/IG5vZGUgOiBudWxsKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW47XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlblswXSB8fCBudWxsO1xuICAgIH1cbiAgICBnZXQgbGFzdENoaWxkKCkge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICAgIHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cbiAgICBjbG9zZXN0KHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBudWxsO1xuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlICYmICFub2RlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUF0dHJpYnV0ZXMgPSBjdXJyZW50Tm9kZS5ub2RlLmF0dHJzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyS2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYXR0cktleXMubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhdHRyS2V5c1tpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZUF0dHJpYnV0ZXNba2V5XSAhPT0gYXR0cmlidXRlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgcXVlcnlTZWxlY3RvcihzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMsIHRydWUpWzBdIHx8IG51bGw7XG4gICAgfVxuICAgIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSwgZmlyc3RJdGVtT25seSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoIXRoaXMuY2hpbGRyZW4gfHwgdGhpcy5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdHRyS2V5cyA9IE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgYWxsIGNoaWxkcmVuIHJlY3Vyc2l2ZWx5IHRoYXQgbWF0Y2ggdGhlIHNlbGVjdG9yIGFuZCBhdHRyaWJ1dGVzXG4gICAgICAgICAqIElmIGZpcnN0SXRlbU9ubHkgaXMgdHJ1ZSwgaXQgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGl0ZW0gZm91bmRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChjaGlsZFBvcyA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbm9kZSBhbmQgd2Ugb25seSB3YW50IHRoZSBmaXJzdCBpdGVtLCB3ZSBkb250IG5lZWQgdG8ga2VlcCBnb2luZ1xuICAgICAgICAgICAgaWYgKGZpcnN0SXRlbU9ubHkgJiYgbm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZFBvcy5ub2RlLnR5cGUubmFtZSA9PT0gc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2VzQWxsQXR0cmlidXRlc01hdGNoID0gYXR0cktleXMuZXZlcnkoa2V5ID0+IGF0dHJpYnV0ZXNba2V5XSA9PT0gY2hpbGRQb3Mubm9kZS5hdHRyc1trZXldKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5wdXNoKGNoaWxkUG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbm9kZSBhbmQgd2Ugb25seSB3YW50IHRoZSBmaXJzdCBpdGVtLCB3ZSBjYW4gc3RvcCBoZXJlIGFuZCBza2lwIHRoZSByZWN1cnNpb25cbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlcyA9IG5vZGVzLmNvbmNhdChjaGlsZFBvcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCBmaXJzdEl0ZW1Pbmx5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgfVxuICAgIHNldEF0dHJpYnV0ZShhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvbnN0IHsgdHIgfSA9IHRoaXMuZWRpdG9yLnN0YXRlO1xuICAgICAgICB0ci5zZXROb2RlTWFya3VwKHRoaXMuZnJvbSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAuLi50aGlzLm5vZGUuYXR0cnMsXG4gICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3Iudmlldy5kaXNwYXRjaCh0cik7XG4gICAgfVxufVxuXG5jb25zdCBzdHlsZSA9IGAuUHJvc2VNaXJyb3Ige1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG5cbi5Qcm9zZU1pcnJvciB7XG4gIHdvcmQtd3JhcDogYnJlYWstd29yZDtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xuICB3aGl0ZS1zcGFjZTogYnJlYWstc3BhY2VzO1xuICAtd2Via2l0LWZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtdmFyaWFudC1saWdhdHVyZXM6IG5vbmU7XG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogXCJsaWdhXCIgMDsgLyogdGhlIGFib3ZlIGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIEVkZ2UgKi9cbn1cblxuLlByb3NlTWlycm9yIFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSB7XG4gIHdoaXRlLXNwYWNlOiBub3JtYWw7XG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0gW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0ge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbi5Qcm9zZU1pcnJvciBwcmUge1xuICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7XG59XG5cbmltZy5Qcm9zZU1pcnJvci1zZXBhcmF0b3Ige1xuICBkaXNwbGF5OiBpbmxpbmUgIWltcG9ydGFudDtcbiAgYm9yZGVyOiBub25lICFpbXBvcnRhbnQ7XG4gIG1hcmdpbjogMCAhaW1wb3J0YW50O1xuICB3aWR0aDogMCAhaW1wb3J0YW50O1xuICBoZWlnaHQ6IDAgIWltcG9ydGFudDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IG5vbmU7XG4gIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIG1hcmdpbjogMDtcbn1cblxuLlByb3NlTWlycm9yLWdhcGN1cnNvcjphZnRlciB7XG4gIGNvbnRlbnQ6IFwiXCI7XG4gIGRpc3BsYXk6IGJsb2NrO1xuICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gIHRvcDogLTJweDtcbiAgd2lkdGg6IDIwcHg7XG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCBibGFjaztcbiAgYW5pbWF0aW9uOiBQcm9zZU1pcnJvci1jdXJzb3ItYmxpbmsgMS4xcyBzdGVwcygyLCBzdGFydCkgaW5maW5pdGU7XG59XG5cbkBrZXlmcmFtZXMgUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIHtcbiAgdG8ge1xuICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgfVxufVxuXG4uUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvbiAqOjpzZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6LW1vei1zZWxlY3Rpb24ge1xuICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKiB7XG4gIGNhcmV0LWNvbG9yOiB0cmFuc3BhcmVudDtcbn1cblxuLlByb3NlTWlycm9yLWZvY3VzZWQgLlByb3NlTWlycm9yLWdhcGN1cnNvciB7XG4gIGRpc3BsYXk6IGJsb2NrO1xufVxuXG4udGlwcHktYm94W2RhdGEtYW5pbWF0aW9uPWZhZGVdW2RhdGEtc3RhdGU9aGlkZGVuXSB7XG4gIG9wYWNpdHk6IDBcbn1gO1xuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZVRhZyhzdHlsZSwgbm9uY2UsIHN1ZmZpeCkge1xuICAgIGNvbnN0IHRpcHRhcFN0eWxlVGFnID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihgc3R5bGVbZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfV1gKTtcbiAgICBpZiAodGlwdGFwU3R5bGVUYWcgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRpcHRhcFN0eWxlVGFnO1xuICAgIH1cbiAgICBjb25zdCBzdHlsZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIGlmIChub25jZSkge1xuICAgICAgICBzdHlsZU5vZGUuc2V0QXR0cmlidXRlKCdub25jZScsIG5vbmNlKTtcbiAgICB9XG4gICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZShgZGF0YS10aXB0YXAtc3R5bGUke3N1ZmZpeCA/IGAtJHtzdWZmaXh9YCA6ICcnfWAsICcnKTtcbiAgICBzdHlsZU5vZGUuaW5uZXJIVE1MID0gc3R5bGU7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXS5hcHBlbmRDaGlsZChzdHlsZU5vZGUpO1xuICAgIHJldHVybiBzdHlsZU5vZGU7XG59XG5cbmNsYXNzIEVkaXRvciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNGb2N1c2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgZWRpdG9yIGlzIGNvbnNpZGVyZWQgaW5pdGlhbGl6ZWQgYWZ0ZXIgdGhlIGBjcmVhdGVgIGV2ZW50IGhhcyBiZWVuIGVtaXR0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25TdG9yYWdlID0ge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgY29udGVudDogJycsXG4gICAgICAgICAgICBpbmplY3RDU1M6IHRydWUsXG4gICAgICAgICAgICBpbmplY3ROb25jZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZXh0ZW5zaW9uczogW10sXG4gICAgICAgICAgICBhdXRvZm9jdXM6IGZhbHNlLFxuICAgICAgICAgICAgZWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBlZGl0b3JQcm9wczoge30sXG4gICAgICAgICAgICBwYXJzZU9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgY29yZUV4dGVuc2lvbk9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgZW5hYmxlSW5wdXRSdWxlczogdHJ1ZSxcbiAgICAgICAgICAgIGVuYWJsZVBhc3RlUnVsZXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDb3JlRXh0ZW5zaW9uczogdHJ1ZSxcbiAgICAgICAgICAgIGVuYWJsZUNvbnRlbnRDaGVjazogZmFsc2UsXG4gICAgICAgICAgICBlbWl0Q29udGVudEVycm9yOiBmYWxzZSxcbiAgICAgICAgICAgIG9uQmVmb3JlQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25DcmVhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblVwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uU2VsZWN0aW9uVXBkYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25UcmFuc2FjdGlvbjogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uRm9jdXM6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkJsdXI6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkRlc3Ryb3k6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkNvbnRlbnRFcnJvcjogKHsgZXJyb3IgfSkgPT4geyB0aHJvdyBlcnJvcjsgfSxcbiAgICAgICAgICAgIG9uUGFzdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkRyb3A6ICgpID0+IG51bGwsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSBudWxsO1xuICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlU2NoZW1hKCk7XG4gICAgICAgIHRoaXMub24oJ2JlZm9yZUNyZWF0ZScsIHRoaXMub3B0aW9ucy5vbkJlZm9yZUNyZWF0ZSk7XG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlQ3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgICAgIHRoaXMub24oJ2NvbnRlbnRFcnJvcicsIHRoaXMub3B0aW9ucy5vbkNvbnRlbnRFcnJvcik7XG4gICAgICAgIHRoaXMuY3JlYXRlVmlldygpO1xuICAgICAgICB0aGlzLmluamVjdENTUygpO1xuICAgICAgICB0aGlzLm9uKCdjcmVhdGUnLCB0aGlzLm9wdGlvbnMub25DcmVhdGUpO1xuICAgICAgICB0aGlzLm9uKCd1cGRhdGUnLCB0aGlzLm9wdGlvbnMub25VcGRhdGUpO1xuICAgICAgICB0aGlzLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLm9wdGlvbnMub25TZWxlY3Rpb25VcGRhdGUpO1xuICAgICAgICB0aGlzLm9uKCd0cmFuc2FjdGlvbicsIHRoaXMub3B0aW9ucy5vblRyYW5zYWN0aW9uKTtcbiAgICAgICAgdGhpcy5vbignZm9jdXMnLCB0aGlzLm9wdGlvbnMub25Gb2N1cyk7XG4gICAgICAgIHRoaXMub24oJ2JsdXInLCB0aGlzLm9wdGlvbnMub25CbHVyKTtcbiAgICAgICAgdGhpcy5vbignZGVzdHJveScsIHRoaXMub3B0aW9ucy5vbkRlc3Ryb3kpO1xuICAgICAgICB0aGlzLm9uKCdkcm9wJywgKHsgZXZlbnQsIHNsaWNlLCBtb3ZlZCB9KSA9PiB0aGlzLm9wdGlvbnMub25Ecm9wKGV2ZW50LCBzbGljZSwgbW92ZWQpKTtcbiAgICAgICAgdGhpcy5vbigncGFzdGUnLCAoeyBldmVudCwgc2xpY2UgfSkgPT4gdGhpcy5vcHRpb25zLm9uUGFzdGUoZXZlbnQsIHNsaWNlKSk7XG4gICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5mb2N1cyh0aGlzLm9wdGlvbnMuYXV0b2ZvY3VzKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnY3JlYXRlJywgeyBlZGl0b3I6IHRoaXMgfSk7XG4gICAgICAgICAgICB0aGlzLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0b3JhZ2UuXG4gICAgICovXG4gICAgZ2V0IHN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvblN0b3JhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBvZiBhbGwgcmVnaXN0ZXJlZCBjb21tYW5kcy5cbiAgICAgKi9cbiAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNvbW1hbmRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb21tYW5kIGNoYWluIHRvIGNhbGwgbXVsdGlwbGUgY29tbWFuZHMgYXQgb25jZS5cbiAgICAgKi9cbiAgICBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2hhaW4oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBjb21tYW5kIG9yIGEgY29tbWFuZCBjaGFpbiBjYW4gYmUgZXhlY3V0ZWQuIFdpdGhvdXQgZXhlY3V0aW5nIGl0LlxuICAgICAqL1xuICAgIGNhbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZE1hbmFnZXIuY2FuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluamVjdCBDU1Mgc3R5bGVzLlxuICAgICAqL1xuICAgIGluamVjdENTUygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pbmplY3RDU1MgJiYgZG9jdW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuY3NzID0gY3JlYXRlU3R5bGVUYWcoc3R5bGUsIHRoaXMub3B0aW9ucy5pbmplY3ROb25jZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGVkaXRvciBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgQSBsaXN0IG9mIG9wdGlvbnNcbiAgICAgKi9cbiAgICBzZXRPcHRpb25zKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMudmlldyB8fCAhdGhpcy5zdGF0ZSB8fCB0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykge1xuICAgICAgICAgICAgdGhpcy52aWV3LnNldFByb3BzKHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgZWRpdGFibGUgc3RhdGUgb2YgdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBzZXRFZGl0YWJsZShlZGl0YWJsZSwgZW1pdFVwZGF0ZSA9IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKHsgZWRpdGFibGUgfSk7XG4gICAgICAgIGlmIChlbWl0VXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHsgZWRpdG9yOiB0aGlzLCB0cmFuc2FjdGlvbjogdGhpcy5zdGF0ZS50ciB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGVkaXRvciBpcyBlZGl0YWJsZS5cbiAgICAgKi9cbiAgICBnZXQgaXNFZGl0YWJsZSgpIHtcbiAgICAgICAgLy8gc2luY2UgcGx1Z2lucyBhcmUgYXBwbGllZCBhZnRlciBjcmVhdGluZyB0aGUgdmlld1xuICAgICAgICAvLyBgZWRpdGFibGVgIGlzIGFsd2F5cyBgdHJ1ZWAgZm9yIG9uZSB0aWNrLlxuICAgICAgICAvLyB0aGF04oCZcyB3aHkgd2UgYWxzbyBoYXZlIHRvIGNoZWNrIGZvciBgb3B0aW9ucy5lZGl0YWJsZWBcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0YWJsZSAmJiB0aGlzLnZpZXcgJiYgdGhpcy52aWV3LmVkaXRhYmxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBlZGl0b3Igc3RhdGUuXG4gICAgICovXG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3LnN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIFByb3NlTWlycm9yIHBsdWdpbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbHVnaW4gQSBQcm9zZU1pcnJvciBwbHVnaW5cbiAgICAgKiBAcGFyYW0gaGFuZGxlUGx1Z2lucyBDb250cm9sIGhvdyB0byBtZXJnZSB0aGUgcGx1Z2luIGludG8gdGhlIGV4aXN0aW5nIHBsdWdpbnMuXG4gICAgICogQHJldHVybnMgVGhlIG5ldyBlZGl0b3Igc3RhdGVcbiAgICAgKi9cbiAgICByZWdpc3RlclBsdWdpbihwbHVnaW4sIGhhbmRsZVBsdWdpbnMpIHtcbiAgICAgICAgY29uc3QgcGx1Z2lucyA9IGlzRnVuY3Rpb24oaGFuZGxlUGx1Z2lucylcbiAgICAgICAgICAgID8gaGFuZGxlUGx1Z2lucyhwbHVnaW4sIFsuLi50aGlzLnN0YXRlLnBsdWdpbnNdKVxuICAgICAgICAgICAgOiBbLi4udGhpcy5zdGF0ZS5wbHVnaW5zLCBwbHVnaW5dO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoeyBwbHVnaW5zIH0pO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVucmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZU9yUGx1Z2luS2V5VG9SZW1vdmUgVGhlIHBsdWdpbnMgbmFtZVxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgZWRpdG9yIHN0YXRlIG9yIHVuZGVmaW5lZCBpZiB0aGUgZWRpdG9yIGlzIGRlc3Ryb3llZFxuICAgICAqL1xuICAgIHVucmVnaXN0ZXJQbHVnaW4obmFtZU9yUGx1Z2luS2V5VG9SZW1vdmUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlBsdWdpbnMgPSB0aGlzLnN0YXRlLnBsdWdpbnM7XG4gICAgICAgIGxldCBwbHVnaW5zID0gcHJldlBsdWdpbnM7XG4gICAgICAgIFtdLmNvbmNhdChuYW1lT3JQbHVnaW5LZXlUb1JlbW92ZSkuZm9yRWFjaChuYW1lT3JQbHVnaW5LZXkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JQbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gYCR7bmFtZU9yUGx1Z2luS2V5fSRgIDogbmFtZU9yUGx1Z2luS2V5LmtleTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHBsdWdpbnMgPSBwbHVnaW5zLmZpbHRlcihwbHVnaW4gPT4gIXBsdWdpbi5rZXkuc3RhcnRzV2l0aChuYW1lKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJldlBsdWdpbnMubGVuZ3RoID09PSBwbHVnaW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gTm8gcGx1Z2luIHdhcyByZW1vdmVkLCBzbyB3ZSBkb27igJl0IG5lZWQgdG8gdXBkYXRlIHRoZSBzdGF0ZVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUucmVjb25maWd1cmUoe1xuICAgICAgICAgICAgcGx1Z2lucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBleHRlbnNpb24gbWFuYWdlci5cbiAgICAgKi9cbiAgICBjcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBjb3JlRXh0ZW5zaW9ucyA9IHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9ucyA/IFtcbiAgICAgICAgICAgIEVkaXRhYmxlLFxuICAgICAgICAgICAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIuY29uZmlndXJlKHtcbiAgICAgICAgICAgICAgICBibG9ja1NlcGFyYXRvcjogKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmNvcmVFeHRlbnNpb25PcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ibG9ja1NlcGFyYXRvcixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgQ29tbWFuZHMsXG4gICAgICAgICAgICBGb2N1c0V2ZW50cyxcbiAgICAgICAgICAgIEtleW1hcCxcbiAgICAgICAgICAgIFRhYmluZGV4LFxuICAgICAgICAgICAgRHJvcCxcbiAgICAgICAgICAgIFBhc3RlLFxuICAgICAgICBdLmZpbHRlcihleHQgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lbmFibGVDb3JlRXh0ZW5zaW9uc1tleHQubmFtZV0gIT09IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pIDogW107XG4gICAgICAgIGNvbnN0IGFsbEV4dGVuc2lvbnMgPSBbLi4uY29yZUV4dGVuc2lvbnMsIC4uLnRoaXMub3B0aW9ucy5leHRlbnNpb25zXS5maWx0ZXIoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbJ2V4dGVuc2lvbicsICdub2RlJywgJ21hcmsnXS5pbmNsdWRlcyhleHRlbnNpb24gPT09IG51bGwgfHwgZXh0ZW5zaW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleHRlbnNpb24udHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmV4dGVuc2lvbk1hbmFnZXIgPSBuZXcgRXh0ZW5zaW9uTWFuYWdlcihhbGxFeHRlbnNpb25zLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBjb21tYW5kIG1hbmFnZXIuXG4gICAgICovXG4gICAgY3JlYXRlQ29tbWFuZE1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoe1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHNjaGVtYS5cbiAgICAgKi9cbiAgICBjcmVhdGVTY2hlbWEoKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gdGhpcy5leHRlbnNpb25NYW5hZ2VyLnNjaGVtYTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIFByb3NlTWlycm9yIHZpZXcuXG4gICAgICovXG4gICAgY3JlYXRlVmlldygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZG9jO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZG9jID0gY3JlYXRlRG9jdW1lbnQodGhpcy5vcHRpb25zLmNvbnRlbnQsIHRoaXMuc2NoZW1hLCB0aGlzLm9wdGlvbnMucGFyc2VPcHRpb25zLCB7IGVycm9yT25JbnZhbGlkQ29udGVudDogdGhpcy5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIEVycm9yKSB8fCAhWydbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnQnLCAnW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSFRNTCBjb250ZW50J10uaW5jbHVkZXMoZS5tZXNzYWdlKSkge1xuICAgICAgICAgICAgICAgIC8vIE5vdCB0aGUgY29udGVudCBlcnJvciB3ZSB3ZXJlIGV4cGVjdGluZ1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NvbnRlbnRFcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5jb2xsYWJvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbi5pc0Rpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUbyBhdm9pZCBzeW5jaW5nIGJhY2sgaW52YWxpZCBjb250ZW50LCByZWluaXRpYWxpemUgdGhlIGV4dGVuc2lvbnMgd2l0aG91dCB0aGUgY29sbGFib3JhdGlvbiBleHRlbnNpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lICE9PSAnY29sbGFib3JhdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXN0YXJ0IHRoZSBpbml0aWFsaXphdGlvbiBwcm9jZXNzIGJ5IHJlY3JlYXRpbmcgdGhlIGV4dGVuc2lvbiBtYW5hZ2VyIHdpdGggdGhlIG5ldyBzZXQgb2YgZXh0ZW5zaW9uc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDb250ZW50IGlzIGludmFsaWQsIGJ1dCBhdHRlbXB0IHRvIGNyZWF0ZSBpdCBhbnl3YXksIHN0cmlwcGluZyBvdXQgdGhlIGludmFsaWQgcGFydHNcbiAgICAgICAgICAgIGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucywgeyBlcnJvck9uSW52YWxpZENvbnRlbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHJlc29sdmVGb2N1c1Bvc2l0aW9uKGRvYywgdGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgICAgIHRoaXMudmlldyA9IG5ldyBFZGl0b3JWaWV3KHRoaXMub3B0aW9ucy5lbGVtZW50LCB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGByb2xlPVwidGV4dGJveFwiYCB0byB0aGUgZWRpdG9yIGVsZW1lbnRcbiAgICAgICAgICAgICAgICByb2xlOiAndGV4dGJveCcsXG4gICAgICAgICAgICAgICAgLi4uKF9hID0gdGhpcy5vcHRpb25zLmVkaXRvclByb3BzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwYXRjaFRyYW5zYWN0aW9uOiB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHN0YXRlOiBFZGl0b3JTdGF0ZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHNlbGVjdGlvbiB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGBlZGl0b3Iudmlld2AgaXMgbm90IHlldCBhdmFpbGFibGUgYXQgdGhpcyB0aW1lLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2Ugd2lsbCBhZGQgYWxsIHBsdWdpbnMgYW5kIG5vZGUgdmlld3MgZGlyZWN0bHkgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgY29uc3QgbmV3U3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgICAgICAgIHBsdWdpbnM6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5wbHVnaW5zLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgdGhpcy5jcmVhdGVOb2RlVmlld3MoKTtcbiAgICAgICAgdGhpcy5wcmVwZW5kQ2xhc3MoKTtcbiAgICAgICAgLy8gTGV04oCZcyBzdG9yZSB0aGUgZWRpdG9yIGluc3RhbmNlIGluIHRoZSBET00gZWxlbWVudC5cbiAgICAgICAgLy8gU28gd2XigJlsbCBoYXZlIGFjY2VzcyB0byBpdCBmb3IgdGVzdHMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgZG9tLmVkaXRvciA9IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYWxsIG5vZGUgdmlld3MuXG4gICAgICovXG4gICAgY3JlYXRlTm9kZVZpZXdzKCkge1xuICAgICAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52aWV3LnNldFByb3BzKHtcbiAgICAgICAgICAgIG5vZGVWaWV3czogdGhpcy5leHRlbnNpb25NYW5hZ2VyLm5vZGVWaWV3cyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBlbmQgY2xhc3MgbmFtZSB0byBlbGVtZW50LlxuICAgICAqL1xuICAgIHByZXBlbmRDbGFzcygpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5jbGFzc05hbWUgPSBgdGlwdGFwICR7dGhpcy52aWV3LmRvbS5jbGFzc05hbWV9YDtcbiAgICB9XG4gICAgY2FwdHVyZVRyYW5zYWN0aW9uKGZuKSB7XG4gICAgICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbiA9IGZhbHNlO1xuICAgICAgICBjb25zdCB0ciA9IHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2FsbGJhY2sgb3ZlciB3aGljaCB0byBzZW5kIHRyYW5zYWN0aW9ucyAoc3RhdGUgdXBkYXRlcykgcHJvZHVjZWQgYnkgdGhlIHZpZXcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb24gQW4gZWRpdG9yIHN0YXRlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgZGlzcGF0Y2hUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIC8gdGhlIHZpZXcgb2YgdGhlIGVkaXRvciB3YXMgZGVzdHJveWVkXG4gICAgICAgIC8vIHRoZSB0cmFuc2FjdGlvbiBzaG91bGQgbm90IGJlIGRpc3BhdGNoZWQgYXMgdGhlcmUgaXMgbm8gdmlldyBhbnltb3JlLlxuICAgICAgICBpZiAodGhpcy52aWV3LmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDYXB0dXJpbmdUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5zdGVwcy5mb3JFYWNoKHN0ZXAgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGVwKHN0ZXApOyB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuc3RhdGUuYXBwbHkodHJhbnNhY3Rpb24pO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25IYXNDaGFuZ2VkID0gIXRoaXMuc3RhdGUuc2VsZWN0aW9uLmVxKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZW1pdCgnYmVmb3JlVHJhbnNhY3Rpb24nLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIG5leHRTdGF0ZTogc3RhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zYWN0aW9uJywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc2VsZWN0aW9uSGFzQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdzZWxlY3Rpb25VcGRhdGUnLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9jdXMgPSB0cmFuc2FjdGlvbi5nZXRNZXRhKCdmb2N1cycpO1xuICAgICAgICBjb25zdCBibHVyID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnYmx1cicpO1xuICAgICAgICBpZiAoZm9jdXMpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZm9jdXMnLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBmb2N1cy5ldmVudCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChibHVyKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2JsdXInLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIGV2ZW50OiBibHVyLmV2ZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5kb2NDaGFuZ2VkIHx8IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3ByZXZlbnRVcGRhdGUnKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXR0cmlidXRlcyBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5vZGUgb3IgbWFyay5cbiAgICAgKi9cbiAgICBnZXRBdHRyaWJ1dGVzKG5hbWVPclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEF0dHJpYnV0ZXModGhpcy5zdGF0ZSwgbmFtZU9yVHlwZSk7XG4gICAgfVxuICAgIGlzQWN0aXZlKG5hbWVPckF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNPclVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gbmFtZU9yQXR0cmlidXRlcyA6IG51bGw7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB0eXBlb2YgbmFtZU9yQXR0cmlidXRlcyA9PT0gJ3N0cmluZycgPyBhdHRyaWJ1dGVzT3JVbmRlZmluZWQgOiBuYW1lT3JBdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gaXNBY3RpdmUodGhpcy5zdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSlNPTi5cbiAgICAgKi9cbiAgICBnZXRKU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MudG9KU09OKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgSFRNTC5cbiAgICAgKi9cbiAgICBnZXRIVE1MKCkge1xuICAgICAgICByZXR1cm4gZ2V0SFRNTEZyb21GcmFnbWVudCh0aGlzLnN0YXRlLmRvYy5jb250ZW50LCB0aGlzLnNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZG9jdW1lbnQgYXMgdGV4dC5cbiAgICAgKi9cbiAgICBnZXRUZXh0KG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgcmV0dXJuIGdldFRleHQodGhpcy5zdGF0ZS5kb2MsIHtcbiAgICAgICAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzOiB7XG4gICAgICAgICAgICAgICAgLi4uZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSh0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICAgICAgLi4udGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlIGlzIG5vIGNvbnRlbnQuXG4gICAgICovXG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiBpc05vZGVFbXB0eSh0aGlzLnN0YXRlLmRvYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbnVtYmVyIG9mIGNoYXJhY3RlcnMgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBnZXRDaGFyYWN0ZXJDb3VudCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBcImVkaXRvci5nZXRDaGFyYWN0ZXJDb3VudCgpXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImVkaXRvci5zdG9yYWdlLmNoYXJhY3RlckNvdW50LmNoYXJhY3RlcnMoKVwiIGluc3RlYWQuJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSAyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkZXN0cm95Jyk7XG4gICAgICAgIGlmICh0aGlzLnZpZXcpIHtcbiAgICAgICAgICAgIC8vIENsZWFudXAgb3VyIHJlZmVyZW5jZSB0byBwcmV2ZW50IGNpcmN1bGFyIHJlZmVyZW5jZXMgd2hpY2ggY2F1c2VkIG1lbW9yeSBsZWFrc1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgZG9tID0gdGhpcy52aWV3LmRvbTtcbiAgICAgICAgICAgIGlmIChkb20gJiYgZG9tLmVkaXRvcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBkb20uZWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy52aWV3LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgZGVzdHJveWVkLlxuICAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiAhKChfYSA9IHRoaXMudmlldykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRvY1ZpZXcpO1xuICAgIH1cbiAgICAkbm9kZShzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvcihzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gICAgfVxuICAgICRub2RlcyhzZWxlY3RvciwgYXR0cmlidXRlcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy4kZG9jKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcykpIHx8IG51bGw7XG4gICAgfVxuICAgICRwb3MocG9zKSB7XG4gICAgICAgIGNvbnN0ICRwb3MgPSB0aGlzLnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0ICRkb2MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwb3MoMCk7XG4gICAgfVxufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbWFyayB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNpbnB1dC1ydWxlc1xuICovXG5mdW5jdGlvbiBtYXJrSW5wdXRSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmVHcm91cCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0U3BhY2VzID0gZnVsbE1hdGNoLnNlYXJjaCgvXFxTLyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dFN0YXJ0ID0gcmFuZ2UuZnJvbSArIGZ1bGxNYXRjaC5pbmRleE9mKGNhcHR1cmVHcm91cCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dEVuZCA9IHRleHRTdGFydCArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWRNYXJrcyA9IGdldE1hcmtzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgc3RhdGUuZG9jKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkID0gaXRlbS5tYXJrLnR5cGUuZXhjbHVkZWQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGNsdWRlZC5maW5kKHR5cGUgPT4gdHlwZSA9PT0gY29uZmlnLnR5cGUgJiYgdHlwZSAhPT0gaXRlbS5tYXJrLnR5cGUpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnRvID4gdGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICBpZiAoZXhjbHVkZWRNYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0RW5kIDwgcmFuZ2UudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHRleHRFbmQsIHJhbmdlLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRTdGFydCA+IHJhbmdlLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgdGV4dFN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbWFya0VuZCA9IHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcyArIGNhcHR1cmVHcm91cC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdHIuYWRkTWFyayhyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIG1hcmtFbmQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzIHx8IHt9KSk7XG4gICAgICAgICAgICAgICAgdHIucmVtb3ZlU3RvcmVkTWFyayhjb25maWcudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGFkZHMgYSBub2RlIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG5vZGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IG1hdGNoWzBdLmxhc3RJbmRleE9mKG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICBsZXQgbWF0Y2hTdGFydCA9IHN0YXJ0ICsgb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaFN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoU3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmQgPSBtYXRjaFN0YXJ0ICsgbWF0Y2hbMV0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnNlcnQgbGFzdCB0eXBlZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q2hhciA9IG1hdGNoWzBdW21hdGNoWzBdLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHRyLmluc2VydFRleHQobGFzdENoYXIsIHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IG5vZGUgZnJvbSBpbnB1dCBydWxlXG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgobWF0Y2hTdGFydCwgZW5kLCBuZXdOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoWzBdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0aW9uU3RhcnQgPSBjb25maWcudHlwZS5pc0lubGluZSA/IHN0YXJ0IDogc3RhcnQgLSAxO1xuICAgICAgICAgICAgICAgIHRyLmluc2VydChpbnNlcnRpb25TdGFydCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKS5kZWxldGUodHIubWFwcGluZy5tYXAoc3RhcnQpLCB0ci5tYXBwaW5nLm1hcChlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgYW4gaW5wdXQgcnVsZSB0aGF0IGNoYW5nZXMgdGhlIHR5cGUgb2YgYSB0ZXh0YmxvY2sgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZnVuY3Rpb24gdGV4dGJsb2NrVHlwZUlucHV0UnVsZShjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRzdGFydCA9IHN0YXRlLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge307XG4gICAgICAgICAgICBpZiAoISRzdGFydC5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkc3RhcnQuaW5kZXgoLTEpLCAkc3RhcnQuaW5kZXhBZnRlcigtMSksIGNvbmZpZy50eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudHJcbiAgICAgICAgICAgICAgICAuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgIC5zZXRCbG9ja1R5cGUocmFuZ2UuZnJvbSwgcmFuZ2UuZnJvbSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIHRleHRJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgICAgICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgYSB0ZXh0YmxvY2sgd2hlbiBhXG4gKiBnaXZlbiBzdHJpbmcgaXMgdHlwZWQuIFdoZW4gdXNpbmcgYSByZWd1bGFyIGV4cHJlc2lvbiB5b3XigJlsbFxuICogcHJvYmFibHkgd2FudCB0aGUgcmVnZXhwIHRvIHN0YXJ0IHdpdGggYF5gLCBzbyB0aGF0IHRoZSBwYXR0ZXJuIGNhblxuICogb25seSBvY2N1ciBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2suXG4gKlxuICogYHR5cGVgIGlzIHRoZSB0eXBlIG9mIG5vZGUgdG8gd3JhcCBpbi5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpZiB0aGVyZeKAmXMgYSBub2RlIHdpdGggdGhlIHNhbWUgdHlwZSBhYm92ZSB0aGUgbmV3bHlcbiAqIHdyYXBwZWQgbm9kZSwgdGhlIHJ1bGUgd2lsbCB0cnkgdG8gam9pbiB0aG9zZVxuICogdHdvIG5vZGVzLiBZb3UgY2FuIHBhc3MgYSBqb2luIHByZWRpY2F0ZSwgd2hpY2ggdGFrZXMgYSByZWd1bGFyXG4gKiBleHByZXNzaW9uIG1hdGNoIGFuZCB0aGUgbm9kZSBiZWZvcmUgdGhlIHdyYXBwZWQgbm9kZSwgYW5kIGNhblxuICogcmV0dXJuIGEgYm9vbGVhbiB0byBpbmRpY2F0ZSB3aGV0aGVyIGEgam9pbiBzaG91bGQgaGFwcGVuLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZnVuY3Rpb24gd3JhcHBpbmdJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgY2hhaW4sIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgdHIgPSBzdGF0ZS50ci5kZWxldGUocmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgICAgICAgY29uc3QgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSk7XG4gICAgICAgICAgICBjb25zdCBibG9ja1JhbmdlID0gJHN0YXJ0LmJsb2NrUmFuZ2UoKTtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwaW5nID0gYmxvY2tSYW5nZSAmJiBmaW5kV3JhcHBpbmcoYmxvY2tSYW5nZSwgY29uZmlnLnR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKCF3cmFwcGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIud3JhcChibG9ja1JhbmdlLCB3cmFwcGluZyk7XG4gICAgICAgICAgICBpZiAoY29uZmlnLmtlZXBNYXJrcyAmJiBjb25maWcuZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gY29uZmlnLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgICAgICAgICBpZiAobWFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzLmZpbHRlcihtYXJrID0+IHNwbGl0dGFibGVNYXJrcy5pbmNsdWRlcyhtYXJrLnR5cGUubmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhmaWx0ZXJlZE1hcmtzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgLyoqIElmIHRoZSBub2RlVHlwZSBpcyBgYnVsbGV0TGlzdGAgb3IgYG9yZGVyZWRMaXN0YCBzZXQgdGhlIGBub2RlVHlwZWAgYXMgYGxpc3RJdGVtYCAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVUeXBlID0gY29uZmlnLnR5cGUubmFtZSA9PT0gJ2J1bGxldExpc3QnIHx8IGNvbmZpZy50eXBlLm5hbWUgPT09ICdvcmRlcmVkTGlzdCcgPyAnbGlzdEl0ZW0nIDogJ3Rhc2tMaXN0JztcbiAgICAgICAgICAgICAgICBjaGFpbigpLnVwZGF0ZUF0dHJpYnV0ZXMobm9kZVR5cGUsIGF0dHJpYnV0ZXMpLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocmFuZ2UuZnJvbSAtIDEpLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICBpZiAoYmVmb3JlXG4gICAgICAgICAgICAgICAgJiYgYmVmb3JlLnR5cGUgPT09IGNvbmZpZy50eXBlXG4gICAgICAgICAgICAgICAgJiYgY2FuSm9pbih0ci5kb2MsIHJhbmdlLmZyb20gLSAxKVxuICAgICAgICAgICAgICAgICYmICghY29uZmlnLmpvaW5QcmVkaWNhdGUgfHwgY29uZmlnLmpvaW5QcmVkaWNhdGUobWF0Y2gsIGJlZm9yZSkpKSB7XG4gICAgICAgICAgICAgICAgdHIuam9pbihyYW5nZS5mcm9tIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogVGhlIE5vZGUgY2xhc3MgaXMgdXNlZCB0byBjcmVhdGUgY3VzdG9tIG5vZGUgZXh0ZW5zaW9ucy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zI2NyZWF0ZS1hLW5ldy1leHRlbnNpb25cbiAqL1xuY2xhc3MgTm9kZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ25vZGUnO1xuICAgICAgICB0aGlzLm5hbWUgPSAnbm9kZSc7XG4gICAgICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaGlsZCA9IG51bGw7XG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgZGVmYXVsdE9wdGlvbnM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbmZpZy5uYW1lO1xuICAgICAgICBpZiAoY29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGNvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke3RoaXMubmFtZX1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFkZE9wdGlvbnNgIGZhbGxiYWNrXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29uZmlnLmRlZmF1bHRPcHRpb25zO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuYWRkT3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRPcHRpb25zJywge1xuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQodGhpcywgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiB0aGlzLm9wdGlvbnMsXG4gICAgICAgIH0pKSB8fCB7fTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGUoY29uZmlnKTtcbiAgICB9XG4gICAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoe1xuICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgICAgICBhZGRPcHRpb25zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSB0aGUgY3VycmVudCBuYW1lXG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCB0byBiZSBvdXIgcGFyZW50XG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG4gICAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IE5vZGUoZXh0ZW5kZWRDb25maWcpO1xuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcztcbiAgICAgICAgdGhpcy5jaGlsZCA9IGV4dGVuc2lvbjtcbiAgICAgICAgZXh0ZW5zaW9uLm5hbWUgPSBleHRlbmRlZENvbmZpZy5uYW1lID8gZXh0ZW5kZWRDb25maWcubmFtZSA6IGV4dGVuc2lvbi5wYXJlbnQubmFtZTtcbiAgICAgICAgaWYgKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zICYmIE9iamVjdC5rZXlzKGV4dGVuZGVkQ29uZmlnLmRlZmF1bHRPcHRpb25zKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IEJSRUFLSU5HIENIQU5HRTogXCJkZWZhdWx0T3B0aW9uc1wiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJhZGRPcHRpb25zXCIgaW5zdGVhZC4gRm91bmQgaW4gZXh0ZW5zaW9uOiBcIiR7ZXh0ZW5zaW9uLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5zaW9uLm9wdGlvbnMgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICB9KSk7XG4gICAgICAgIGV4dGVuc2lvbi5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZFN0b3JhZ2UnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxufVxuXG4vKipcbiAqIE5vZGUgdmlld3MgYXJlIHVzZWQgdG8gY3VzdG9taXplIHRoZSByZW5kZXJlZCBET00gc3RydWN0dXJlIG9mIGEgbm9kZS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2d1aWRlL25vZGUtdmlld3NcbiAqL1xuY2xhc3MgTm9kZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmVkaXRvciA9IHByb3BzLmVkaXRvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgc3RvcEV2ZW50OiBudWxsLFxuICAgICAgICAgICAgaWdub3JlTXV0YXRpb246IG51bGwsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dGVuc2lvbiA9IHByb3BzLmV4dGVuc2lvbjtcbiAgICAgICAgdGhpcy5ub2RlID0gcHJvcHMubm9kZTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHByb3BzLmRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLmlubmVyRGVjb3JhdGlvbnMgPSBwcm9wcy5pbm5lckRlY29yYXRpb25zO1xuICAgICAgICB0aGlzLnZpZXcgPSBwcm9wcy52aWV3O1xuICAgICAgICB0aGlzLkhUTUxBdHRyaWJ1dGVzID0gcHJvcHMuSFRNTEF0dHJpYnV0ZXM7XG4gICAgICAgIHRoaXMuZ2V0UG9zID0gcHJvcHMuZ2V0UG9zO1xuICAgICAgICB0aGlzLm1vdW50KCk7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBnZXQgZG9tKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3Iudmlldy5kb207XG4gICAgfVxuICAgIGdldCBjb250ZW50RE9NKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgb25EcmFnU3RhcnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIC8vIGdldCB0aGUgZHJhZyBoYW5kbGUgZWxlbWVudFxuICAgICAgICAvLyBgY2xvc2VzdGAgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGV4dCBub2RlcyBzbyB3ZSBtYXkgaGF2ZSB0byB1c2UgaXRzIHBhcmVudFxuICAgICAgICBjb25zdCBkcmFnSGFuZGxlID0gdGFyZ2V0Lm5vZGVUeXBlID09PSAzXG4gICAgICAgICAgICA/IChfYSA9IHRhcmdldC5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJylcbiAgICAgICAgICAgIDogdGFyZ2V0LmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpO1xuICAgICAgICBpZiAoIXRoaXMuZG9tIHx8ICgoX2IgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jb250YWlucyh0YXJnZXQpKSB8fCAhZHJhZ0hhbmRsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgbGV0IHkgPSAwO1xuICAgICAgICAvLyBjYWxjdWxhdGUgb2Zmc2V0IGZvciBkcmFnIGVsZW1lbnQgaWYgd2UgdXNlIGEgZGlmZmVyZW50IGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICAgICAgaWYgKHRoaXMuZG9tICE9PSBkcmFnSGFuZGxlKSB7XG4gICAgICAgICAgICBjb25zdCBkb21Cb3ggPSB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUJveCA9IGRyYWdIYW5kbGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAvLyBJbiBSZWFjdCwgd2UgaGF2ZSB0byBnbyB0aHJvdWdoIG5hdGl2ZUV2ZW50IHRvIHJlYWNoIG9mZnNldFgvb2Zmc2V0WS5cbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSAoX2MgPSBldmVudC5vZmZzZXRYKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSBldmVudC5uYXRpdmVFdmVudCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm9mZnNldFg7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gKF9lID0gZXZlbnQub2Zmc2V0WSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogKF9mID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5vZmZzZXRZO1xuICAgICAgICAgICAgeCA9IGhhbmRsZUJveC54IC0gZG9tQm94LnggKyBvZmZzZXRYO1xuICAgICAgICAgICAgeSA9IGhhbmRsZUJveC55IC0gZG9tQm94LnkgKyBvZmZzZXRZO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsb25lZE5vZGUgPSB0aGlzLmRvbS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgIChfZyA9IGV2ZW50LmRhdGFUcmFuc2ZlcikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLnNldERyYWdJbWFnZShjbG9uZWROb2RlLCB4LCB5KTtcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgbmVlZCB0byB0ZWxsIFByb3NlTWlycm9yIHRoYXQgd2Ugd2FudCB0byBtb3ZlIHRoZSB3aG9sZSBub2RlXG4gICAgICAgIC8vIHNvIHdlIGNyZWF0ZSBhIE5vZGVTZWxlY3Rpb25cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHBvcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdmlldy5zdGF0ZS50ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5kb20pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5zdG9wRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50KHsgZXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCBpc0luRWxlbWVudCA9IHRoaXMuZG9tLmNvbnRhaW5zKHRhcmdldCkgJiYgISgoX2EgPSB0aGlzLmNvbnRlbnRET00pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyh0YXJnZXQpKTtcbiAgICAgICAgLy8gYW55IGV2ZW50IGZyb20gY2hpbGQgbm9kZXMgc2hvdWxkIGJlIGhhbmRsZWQgYnkgUHJvc2VNaXJyb3JcbiAgICAgICAgaWYgKCFpc0luRWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzRHJhZ0V2ZW50ID0gZXZlbnQudHlwZS5zdGFydHNXaXRoKCdkcmFnJyk7XG4gICAgICAgIGNvbnN0IGlzRHJvcEV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ2Ryb3AnO1xuICAgICAgICBjb25zdCBpc0lucHV0ID0gWydJTlBVVCcsICdCVVRUT04nLCAnU0VMRUNUJywgJ1RFWFRBUkVBJ10uaW5jbHVkZXModGFyZ2V0LnRhZ05hbWUpIHx8IHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZTtcbiAgICAgICAgLy8gYW55IGlucHV0IGV2ZW50IHdpdGhpbiBub2RlIHZpZXdzIHNob3VsZCBiZSBpZ25vcmVkIGJ5IFByb3NlTWlycm9yXG4gICAgICAgIGlmIChpc0lucHV0ICYmICFpc0Ryb3BFdmVudCAmJiAhaXNEcmFnRXZlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaXNFZGl0YWJsZSB9ID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIGNvbnN0IHsgaXNEcmFnZ2luZyB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgaXNEcmFnZ2FibGUgPSAhIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlO1xuICAgICAgICBjb25zdCBpc1NlbGVjdGFibGUgPSBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh0aGlzLm5vZGUpO1xuICAgICAgICBjb25zdCBpc0NvcHlFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjb3B5JztcbiAgICAgICAgY29uc3QgaXNQYXN0ZUV2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ3Bhc3RlJztcbiAgICAgICAgY29uc3QgaXNDdXRFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdjdXQnO1xuICAgICAgICBjb25zdCBpc0NsaWNrRXZlbnQgPSBldmVudC50eXBlID09PSAnbW91c2Vkb3duJztcbiAgICAgICAgLy8gUHJvc2VNaXJyb3IgdHJpZXMgdG8gZHJhZyBzZWxlY3RhYmxlIG5vZGVzXG4gICAgICAgIC8vIGV2ZW4gaWYgYGRyYWdnYWJsZWAgaXMgc2V0IHRvIGBmYWxzZWBcbiAgICAgICAgLy8gdGhpcyBmaXggcHJldmVudHMgdGhhdFxuICAgICAgICBpZiAoIWlzRHJhZ2dhYmxlICYmIGlzU2VsZWN0YWJsZSAmJiBpc0RyYWdFdmVudCAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0RyYWdFdmVudCAmJiAhaXNEcmFnZ2luZyAmJiBldmVudC50YXJnZXQgPT09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gc3RvcmUgdGhhdCBkcmFnZ2luZyBzdGFydGVkXG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSAmJiBpc0VkaXRhYmxlICYmICFpc0RyYWdnaW5nICYmIGlzQ2xpY2tFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWREcmFnSGFuZGxlID0gZHJhZ0hhbmRsZSAmJiAodGhpcy5kb20gPT09IGRyYWdIYW5kbGUgfHwgdGhpcy5kb20uY29udGFpbnMoZHJhZ0hhbmRsZSkpO1xuICAgICAgICAgICAgaWYgKGlzVmFsaWREcmFnSGFuZGxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBldmVudHMgYXJlIGhhbmRsZWQgYnkgcHJvc2VtaXJyb3JcbiAgICAgICAgaWYgKGlzRHJhZ2dpbmdcbiAgICAgICAgICAgIHx8IGlzRHJvcEV2ZW50XG4gICAgICAgICAgICB8fCBpc0NvcHlFdmVudFxuICAgICAgICAgICAgfHwgaXNQYXN0ZUV2ZW50XG4gICAgICAgICAgICB8fCBpc0N1dEV2ZW50XG4gICAgICAgICAgICB8fCAoaXNDbGlja0V2ZW50ICYmIGlzU2VsZWN0YWJsZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBET00gW211dGF0aW9uXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTXV0YXRpb25PYnNlcnZlcikgb3IgYSBzZWxlY3Rpb24gY2hhbmdlIGhhcHBlbnMgd2l0aGluIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm4gYGZhbHNlYCBpZiB0aGUgZWRpdG9yIHNob3VsZCByZS1yZWFkIHRoZSBzZWxlY3Rpb24gb3IgcmUtcGFyc2UgdGhlIHJhbmdlIGFyb3VuZCB0aGUgbXV0YXRpb25cbiAgICAgKiBAcmV0dXJuIGB0cnVlYCBpZiBpdCBjYW4gc2FmZWx5IGJlIGlnbm9yZWQuXG4gICAgICovXG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAhdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5pZ25vcmVNdXRhdGlvbih7IG11dGF0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGEgbGVhZi9hdG9tIG5vZGUgaXMgbGlrZSBhIGJsYWNrIGJveCBmb3IgUHJvc2VNaXJyb3JcbiAgICAgICAgLy8gYW5kIHNob3VsZCBiZSBmdWxseSBoYW5kbGVkIGJ5IHRoZSBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMubm9kZS5pc0xlYWYgfHwgdGhpcy5ub2RlLmlzQXRvbSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgc2VsZWN0aW9uc1xuICAgICAgICBpZiAobXV0YXRpb24udHlwZSA9PT0gJ3NlbGVjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cnkgdG8gcHJldmVudCBhIGJ1ZyBvbiBpT1MgYW5kIEFuZHJvaWQgdGhhdCB3aWxsIGJyZWFrIG5vZGUgdmlld3Mgb24gZW50ZXJcbiAgICAgICAgLy8gdGhpcyBpcyBiZWNhdXNlIFByb3NlTWlycm9yIGNhbuKAmXQgcHJldmVudERpc3BhdGNoIG9uIGVudGVyXG4gICAgICAgIC8vIHRoaXMgd2lsbCBsZWFkIHRvIGEgcmUtcmVuZGVyIG9mIHRoZSBub2RlIHZpZXcgb24gZW50ZXJcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzEyMTRcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI1MzRcbiAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldClcbiAgICAgICAgICAgICYmIG11dGF0aW9uLnR5cGUgPT09ICdjaGlsZExpc3QnXG4gICAgICAgICAgICAmJiAoaXNpT1MoKSB8fCBpc0FuZHJvaWQoKSlcbiAgICAgICAgICAgICYmIHRoaXMuZWRpdG9yLmlzRm9jdXNlZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlZE5vZGVzID0gW1xuICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24uYWRkZWROb2RlcyksXG4gICAgICAgICAgICAgICAgLi4uQXJyYXkuZnJvbShtdXRhdGlvbi5yZW1vdmVkTm9kZXMpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIHdl4oCZbGwgY2hlY2sgaWYgZXZlcnkgY2hhbmdlZCBub2RlIGlzIGNvbnRlbnRFZGl0YWJsZVxuICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGl04oCZcyBwcm9iYWJseSBtdXRhdGVkIGJ5IFByb3NlTWlycm9yXG4gICAgICAgICAgICBpZiAoY2hhbmdlZE5vZGVzLmV2ZXJ5KG5vZGUgPT4gbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2Ugd2lsbCBhbGxvdyBtdXRhdGlvbiBjb250ZW50RE9NIHdpdGggYXR0cmlidXRlc1xuICAgICAgICAvLyBzbyB3ZSBjYW4gZm9yIGV4YW1wbGUgYWRkaW5nIGNsYXNzZXMgd2l0aGluIG91ciBub2RlIHZpZXdcbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTSA9PT0gbXV0YXRpb24udGFyZ2V0ICYmIG11dGF0aW9uLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvc2VNaXJyb3Igc2hvdWxkIGhhbmRsZSBhbnkgY2hhbmdlcyB3aXRoaW4gY29udGVudERPTVxuICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKG11dGF0aW9uLnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBwcm9zZW1pcnJvciBub2RlLlxuICAgICAqL1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIHRoZSBub2RlLlxuICAgICAqL1xuICAgIGRlbGV0ZU5vZGUoKSB7XG4gICAgICAgIGNvbnN0IGZyb20gPSB0aGlzLmdldFBvcygpO1xuICAgICAgICBpZiAodHlwZW9mIGZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5kZWxldGVSYW5nZSh7IGZyb20sIHRvIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG1hcmtQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCwgcGFzdGVFdmVudCwgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcyA9PT0gZmFsc2UgfHwgYXR0cmlidXRlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlR3JvdXAgPSBtYXRjaFttYXRjaC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgbGV0IG1hcmtFbmQgPSByYW5nZS50bztcbiAgICAgICAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBjYW5JbnNlcnROb2RlKHN0YXRlLCBub2RlVHlwZSkge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICBjb25zdCB7ICRmcm9tIH0gPSBzZWxlY3Rpb247XG4gICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3IgTm9kZVNlbGVjdGlvblxuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gJGZyb20uaW5kZXgoKTtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gJGZyb20ucGFyZW50O1xuICAgICAgICAvLyBDYW4gd2UgcmVwbGFjZSB0aGUgc2VsZWN0ZWQgbm9kZSB3aXRoIHRoZSBob3Jpem9udGFsIHJ1bGU/XG4gICAgICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4ICsgMSwgbm9kZVR5cGUpO1xuICAgIH1cbiAgICAvLyBEZWZhdWx0OiBjaGVjayBpZiB3ZSBjYW4gaW5zZXJ0IGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uXG4gICAgbGV0IGRlcHRoID0gJGZyb20uZGVwdGg7XG4gICAgd2hpbGUgKGRlcHRoID49IDApIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCk7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBjb25zdCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbmRleCk7XG4gICAgICAgIGlmIChtYXRjaC5tYXRjaFR5cGUobm9kZVR5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBkZXB0aCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzY5Njk0ODZcbmZ1bmN0aW9uIGVzY2FwZUZvclJlZ0V4KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcucmVwbGFjZSgvWy0vXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHBhc3RlZCBpbnRvIGl0LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjcGFzdGUtcnVsZXNcbiAqL1xuZnVuY3Rpb24gbm9kZVBhc3RlUnVsZShjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IFBhc3RlUnVsZSh7XG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgICAgICBoYW5kbGVyKHsgbWF0Y2gsIGNoYWluLCByYW5nZSwgcGFzdGVFdmVudCwgfSkge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCwgcGFzdGVFdmVudCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRDb250ZW50LCB1bmRlZmluZWQsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB7IHR5cGU6IGNvbmZpZy50eXBlLm5hbWUsIGF0dHJzOiBhdHRyaWJ1dGVzIH07XG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIG5vZGUuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2guaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjaGFpbigpLmRlbGV0ZVJhbmdlKHJhbmdlKS5pbnNlcnRDb250ZW50QXQocmFuZ2UuZnJvbSwgbm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IHJlcGxhY2VzIHRleHQgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIHRleHRQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0ID0gY29uZmlnLnJlcGxhY2U7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gcmFuZ2UudG87XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ICs9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCArIG1hdGNoWzFdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgc3RhcnQgKz0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1dE9mZiA9IHN0YXJ0IC0gZW5kO1xuICAgICAgICAgICAgICAgIGlmIChjdXRPZmYgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydCA9IG1hdGNoWzBdLnNsaWNlKG9mZnNldCAtIGN1dE9mZiwgb2Zmc2V0KSArIGluc2VydDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudHIuaW5zZXJ0VGV4dChpbnNlcnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5jbGFzcyBUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0cmFuc2FjdGlvbikge1xuICAgICAgICB0aGlzLnRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMuY3VycmVudFN0ZXAgPSB0aGlzLnRyYW5zYWN0aW9uLnN0ZXBzLmxlbmd0aDtcbiAgICB9XG4gICAgbWFwKHBvc2l0aW9uKSB7XG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IG1hcHBlZFBvc2l0aW9uID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwc1xuICAgICAgICAgICAgLnNsaWNlKHRoaXMuY3VycmVudFN0ZXApXG4gICAgICAgICAgICAucmVkdWNlKChuZXdQb3NpdGlvbiwgc3RlcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWFwUmVzdWx0ID0gc3RlcC5nZXRNYXAoKS5tYXBSZXN1bHQobmV3UG9zaXRpb24pO1xuICAgICAgICAgICAgaWYgKG1hcFJlc3VsdC5kZWxldGVkKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwUmVzdWx0LnBvcztcbiAgICAgICAgfSwgcG9zaXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcG9zaXRpb246IG1hcHBlZFBvc2l0aW9uLFxuICAgICAgICAgICAgZGVsZXRlZCxcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbW1hbmRNYW5hZ2VyLCBFZGl0b3IsIEV4dGVuc2lvbiwgSW5wdXRSdWxlLCBNYXJrLCBOb2RlLCBOb2RlUG9zLCBOb2RlVmlldywgUGFzdGVSdWxlLCBUcmFja2VyLCBjYWxsT3JSZXR1cm4sIGNhbkluc2VydE5vZGUsIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzLCBjcmVhdGVDaGFpbmFibGVTdGF0ZSwgY3JlYXRlRG9jdW1lbnQsIGNyZWF0ZU5vZGVGcm9tQ29udGVudCwgY3JlYXRlU3R5bGVUYWcsIGRlZmF1bHRCbG9ja0F0LCBkZWxldGVQcm9wcywgZWxlbWVudEZyb21TdHJpbmcsIGVzY2FwZUZvclJlZ0V4LCBpbmRleCBhcyBleHRlbnNpb25zLCBmaW5kQ2hpbGRyZW4sIGZpbmRDaGlsZHJlbkluUmFuZ2UsIGZpbmREdXBsaWNhdGVzLCBmaW5kUGFyZW50Tm9kZSwgZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MsIGZyb21TdHJpbmcsIGdlbmVyYXRlSFRNTCwgZ2VuZXJhdGVKU09OLCBnZW5lcmF0ZVRleHQsIGdldEF0dHJpYnV0ZXMsIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucywgZ2V0Q2hhbmdlZFJhbmdlcywgZ2V0RGVidWdKU09OLCBnZXRFeHRlbnNpb25GaWVsZCwgZ2V0SFRNTEZyb21GcmFnbWVudCwgZ2V0TWFya0F0dHJpYnV0ZXMsIGdldE1hcmtSYW5nZSwgZ2V0TWFya1R5cGUsIGdldE1hcmtzQmV0d2VlbiwgZ2V0Tm9kZUF0UG9zaXRpb24sIGdldE5vZGVBdHRyaWJ1dGVzLCBnZXROb2RlVHlwZSwgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzLCBnZXRTY2hlbWEsIGdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zLCBnZXRTY2hlbWFUeXBlQnlOYW1lLCBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSwgZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzLCBnZXRUZXh0LCBnZXRUZXh0QmV0d2VlbiwgZ2V0VGV4dENvbnRlbnRGcm9tTm9kZXMsIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEsIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZSwgaW5wdXRSdWxlc1BsdWdpbiwgaXNBY3RpdmUsIGlzQXRFbmRPZk5vZGUsIGlzQXRTdGFydE9mTm9kZSwgaXNFbXB0eU9iamVjdCwgaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQsIGlzRnVuY3Rpb24sIGlzTGlzdCwgaXNNYWNPUywgaXNNYXJrQWN0aXZlLCBpc05vZGVBY3RpdmUsIGlzTm9kZUVtcHR5LCBpc05vZGVTZWxlY3Rpb24sIGlzTnVtYmVyLCBpc1BsYWluT2JqZWN0LCBpc1JlZ0V4cCwgaXNTdHJpbmcsIGlzVGV4dFNlbGVjdGlvbiwgaXNpT1MsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUsIG1lcmdlQXR0cmlidXRlcywgbWVyZ2VEZWVwLCBtaW5NYXgsIG5vZGVJbnB1dFJ1bGUsIG5vZGVQYXN0ZVJ1bGUsIG9iamVjdEluY2x1ZGVzLCBwYXN0ZVJ1bGVzUGx1Z2luLCBwb3NUb0RPTVJlY3QsIHJlbW92ZUR1cGxpY2F0ZXMsIHJlc29sdmVGb2N1c1Bvc2l0aW9uLCByZXdyaXRlVW5rbm93bkNvbnRlbnQsIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kLCBzcGxpdEV4dGVuc2lvbnMsIHRleHRJbnB1dFJ1bGUsIHRleHRQYXN0ZVJ1bGUsIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUsIHdyYXBwaW5nSW5wdXRSdWxlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJQbHVnaW4iLCJQbHVnaW5LZXkiLCJUZXh0U2VsZWN0aW9uIiwiU2VsZWN0aW9uIiwiQWxsU2VsZWN0aW9uIiwiTm9kZVNlbGVjdGlvbiIsIkVkaXRvclN0YXRlIiwiRWRpdG9yVmlldyIsImtleW1hcCIsIlNjaGVtYSIsIkRPTVNlcmlhbGl6ZXIiLCJGcmFnbWVudCIsIk5vZGUiLCJOb2RlJDEiLCJET01QYXJzZXIiLCJTbGljZSIsImxpZnRUYXJnZXQiLCJSZXBsYWNlU3RlcCIsIlJlcGxhY2VBcm91bmRTdGVwIiwiam9pblBvaW50IiwiVHJhbnNmb3JtIiwiY2FuU3BsaXQiLCJjYW5Kb2luIiwiZmluZFdyYXBwaW5nIiwiY3JlYXRlUGFyYWdyYXBoTmVhciIsImNyZWF0ZVBhcmFncmFwaE5lYXIkMSIsImRlbGV0ZVNlbGVjdGlvbiIsImRlbGV0ZVNlbGVjdGlvbiQxIiwiZXhpdENvZGUiLCJleGl0Q29kZSQxIiwiam9pblVwIiwiam9pblVwJDEiLCJqb2luRG93biIsImpvaW5Eb3duJDEiLCJqb2luQmFja3dhcmQiLCJqb2luQmFja3dhcmQkMSIsImpvaW5Gb3J3YXJkIiwiam9pbkZvcndhcmQkMSIsImpvaW5UZXh0YmxvY2tCYWNrd2FyZCIsImpvaW5UZXh0YmxvY2tCYWNrd2FyZCQxIiwiam9pblRleHRibG9ja0ZvcndhcmQiLCJqb2luVGV4dGJsb2NrRm9yd2FyZCQxIiwibGlmdCIsImxpZnQkMSIsImxpZnRFbXB0eUJsb2NrIiwibGlmdEVtcHR5QmxvY2skMSIsIm5ld2xpbmVJbkNvZGUiLCJuZXdsaW5lSW5Db2RlJDEiLCJzZWxlY3ROb2RlQmFja3dhcmQiLCJzZWxlY3ROb2RlQmFja3dhcmQkMSIsInNlbGVjdE5vZGVGb3J3YXJkIiwic2VsZWN0Tm9kZUZvcndhcmQkMSIsInNlbGVjdFBhcmVudE5vZGUiLCJzZWxlY3RQYXJlbnROb2RlJDEiLCJzZWxlY3RUZXh0YmxvY2tFbmQiLCJzZWxlY3RUZXh0YmxvY2tFbmQkMSIsInNlbGVjdFRleHRibG9ja1N0YXJ0Iiwic2VsZWN0VGV4dGJsb2NrU3RhcnQkMSIsInNldEJsb2NrVHlwZSIsIndyYXBJbiIsIndyYXBJbiQxIiwibGlmdExpc3RJdGVtIiwibGlmdExpc3RJdGVtJDEiLCJzaW5rTGlzdEl0ZW0iLCJzaW5rTGlzdEl0ZW0kMSIsIndyYXBJbkxpc3QiLCJ3cmFwSW5MaXN0JDEiLCJjcmVhdGVDaGFpbmFibGVTdGF0ZSIsImNvbmZpZyIsInN0YXRlIiwidHJhbnNhY3Rpb24iLCJzZWxlY3Rpb24iLCJkb2MiLCJzdG9yZWRNYXJrcyIsImFwcGx5IiwiYmluZCIsImFwcGx5VHJhbnNhY3Rpb24iLCJwbHVnaW5zIiwic2NoZW1hIiwicmVjb25maWd1cmUiLCJ0b0pTT04iLCJ0ciIsIkNvbW1hbmRNYW5hZ2VyIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsImVkaXRvciIsInJhd0NvbW1hbmRzIiwiZXh0ZW5zaW9uTWFuYWdlciIsImNvbW1hbmRzIiwiY3VzdG9tU3RhdGUiLCJoYXNDdXN0b21TdGF0ZSIsInZpZXciLCJidWlsZFByb3BzIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwibmFtZSIsImNvbW1hbmQiLCJtZXRob2QiLCJhcmdzIiwiY2FsbGJhY2siLCJnZXRNZXRhIiwiZGlzcGF0Y2giLCJjaGFpbiIsImNyZWF0ZUNoYWluIiwiY2FuIiwiY3JlYXRlQ2FuIiwic3RhcnRUciIsInNob3VsZERpc3BhdGNoIiwiY2FsbGJhY2tzIiwiaGFzU3RhcnRUcmFuc2FjdGlvbiIsInJ1biIsImV2ZXJ5IiwiY2hhaW5lZENvbW1hbmQiLCJwdXNoIiwiZm9ybWF0dGVkQ29tbWFuZHMiLCJ1bmRlZmluZWQiLCJFdmVudEVtaXR0ZXIiLCJvbiIsImV2ZW50IiwiZm4iLCJlbWl0IiwiZm9yRWFjaCIsIm9mZiIsImZpbHRlciIsIm9uY2UiLCJvbmNlRm4iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJnZXRFeHRlbnNpb25GaWVsZCIsImV4dGVuc2lvbiIsImZpZWxkIiwiY29udGV4dCIsInBhcmVudCIsInZhbHVlIiwic3BsaXRFeHRlbnNpb25zIiwiZXh0ZW5zaW9ucyIsImJhc2VFeHRlbnNpb25zIiwidHlwZSIsIm5vZGVFeHRlbnNpb25zIiwibWFya0V4dGVuc2lvbnMiLCJnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMiLCJleHRlbnNpb25BdHRyaWJ1dGVzIiwibm9kZUFuZE1hcmtFeHRlbnNpb25zIiwiZGVmYXVsdEF0dHJpYnV0ZSIsImRlZmF1bHQiLCJyZW5kZXJlZCIsInJlbmRlckhUTUwiLCJwYXJzZUhUTUwiLCJrZWVwT25TcGxpdCIsImlzUmVxdWlyZWQiLCJvcHRpb25zIiwic3RvcmFnZSIsImFkZEdsb2JhbEF0dHJpYnV0ZXMiLCJnbG9iYWxBdHRyaWJ1dGVzIiwiZ2xvYmFsQXR0cmlidXRlIiwidHlwZXMiLCJhdHRyaWJ1dGVzIiwiYXR0cmlidXRlIiwiYWRkQXR0cmlidXRlcyIsIm1lcmdlZEF0dHIiLCJnZXROb2RlVHlwZSIsIm5hbWVPclR5cGUiLCJub2RlcyIsIkVycm9yIiwibWVyZ2VBdHRyaWJ1dGVzIiwib2JqZWN0cyIsIml0ZW0iLCJyZWR1Y2UiLCJpdGVtcyIsIm1lcmdlZEF0dHJpYnV0ZXMiLCJrZXkiLCJleGlzdHMiLCJ2YWx1ZUNsYXNzZXMiLCJTdHJpbmciLCJzcGxpdCIsImV4aXN0aW5nQ2xhc3NlcyIsImluc2VydENsYXNzZXMiLCJ2YWx1ZUNsYXNzIiwiaW5jbHVkZXMiLCJqb2luIiwibmV3U3R5bGVzIiwic3R5bGUiLCJ0cmltIiwiQm9vbGVhbiIsImV4aXN0aW5nU3R5bGVzIiwic3R5bGVNYXAiLCJNYXAiLCJwcm9wZXJ0eSIsInZhbCIsInBhcnQiLCJzZXQiLCJBcnJheSIsImZyb20iLCJnZXRSZW5kZXJlZEF0dHJpYnV0ZXMiLCJub2RlT3JNYXJrIiwiYXR0cnMiLCJpc0Z1bmN0aW9uIiwiY2FsbE9yUmV0dXJuIiwiaXNFbXB0eU9iamVjdCIsImtleXMiLCJsZW5ndGgiLCJmcm9tU3RyaW5nIiwibWF0Y2giLCJOdW1iZXIiLCJpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUiLCJwYXJzZVJ1bGUiLCJnZXRBdHRycyIsIm5vZGUiLCJvbGRBdHRyaWJ1dGVzIiwibmV3QXR0cmlidXRlcyIsImdldEF0dHJpYnV0ZSIsImNsZWFuVXBTY2hlbWFJdGVtIiwiZGF0YSIsImdldFNjaGVtYUJ5UmVzb2x2ZWRFeHRlbnNpb25zIiwiX2EiLCJhbGxBdHRyaWJ1dGVzIiwidG9wTm9kZSIsImZpbmQiLCJleHRyYU5vZGVGaWVsZHMiLCJmaWVsZHMiLCJlIiwiZXh0ZW5kTm9kZVNjaGVtYSIsImNvbnRlbnQiLCJtYXJrcyIsImdyb3VwIiwiaW5saW5lIiwiYXRvbSIsInNlbGVjdGFibGUiLCJkcmFnZ2FibGUiLCJjb2RlIiwid2hpdGVzcGFjZSIsImxpbmVicmVha1JlcGxhY2VtZW50IiwiZGVmaW5pbmciLCJpc29sYXRpbmciLCJleHRlbnNpb25BdHRyaWJ1dGUiLCJwYXJzZURPTSIsInRvRE9NIiwiSFRNTEF0dHJpYnV0ZXMiLCJyZW5kZXJUZXh0IiwidG9UZXh0IiwiZXh0cmFNYXJrRmllbGRzIiwiZXh0ZW5kTWFya1NjaGVtYSIsImluY2x1c2l2ZSIsImV4Y2x1ZGVzIiwic3Bhbm5pbmciLCJtYXJrIiwiZ2V0U2NoZW1hVHlwZUJ5TmFtZSIsImlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkIiwiZW5hYmxlZCIsImlzQXJyYXkiLCJzb21lIiwiZW5hYmxlZEV4dGVuc2lvbiIsImdldEhUTUxGcm9tRnJhZ21lbnQiLCJmcmFnbWVudCIsImRvY3VtZW50RnJhZ21lbnQiLCJmcm9tU2NoZW1hIiwic2VyaWFsaXplRnJhZ21lbnQiLCJ0ZW1wb3JhcnlEb2N1bWVudCIsImRvY3VtZW50IiwiaW1wbGVtZW50YXRpb24iLCJjcmVhdGVIVE1MRG9jdW1lbnQiLCJjb250YWluZXIiLCJjcmVhdGVFbGVtZW50IiwiYXBwZW5kQ2hpbGQiLCJpbm5lckhUTUwiLCJnZXRUZXh0Q29udGVudEZyb21Ob2RlcyIsIiRmcm9tIiwibWF4TWF0Y2giLCJ0ZXh0QmVmb3JlIiwic2xpY2VFbmRQb3MiLCJwYXJlbnRPZmZzZXQiLCJub2Rlc0JldHdlZW4iLCJNYXRoIiwibWF4IiwicG9zIiwiaW5kZXgiLCJfYiIsImNodW5rIiwic3BlYyIsImNhbGwiLCJ0ZXh0Q29udGVudCIsImlzQXRvbSIsImlzVGV4dCIsInNsaWNlIiwiaXNSZWdFeHAiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsIklucHV0UnVsZSIsImhhbmRsZXIiLCJpbnB1dFJ1bGVNYXRjaGVySGFuZGxlciIsInRleHQiLCJleGVjIiwiaW5wdXRSdWxlTWF0Y2giLCJyZXN1bHQiLCJpbnB1dCIsInJlcGxhY2VXaXRoIiwiY29uc29sZSIsIndhcm4iLCJydW4kMSIsInRvIiwicnVsZXMiLCJwbHVnaW4iLCJjb21wb3NpbmciLCJyZXNvbHZlIiwibm9kZUJlZm9yZSIsIm5vZGVBZnRlciIsIm1hdGNoZWQiLCJydWxlIiwicmFuZ2UiLCJzdGVwcyIsInNldE1ldGEiLCJ0cmFuc2Zvcm0iLCJpbnB1dFJ1bGVzUGx1Z2luIiwiaW5pdCIsInByZXYiLCJzdG9yZWQiLCJzaW11bGF0ZWRJbnB1dE1ldGEiLCJpc1NpbXVsYXRlZElucHV0Iiwic2V0VGltZW91dCIsInNlbGVjdGlvblNldCIsImRvY0NoYW5nZWQiLCJoYW5kbGVUZXh0SW5wdXQiLCJoYW5kbGVET01FdmVudHMiLCJjb21wb3NpdGlvbmVuZCIsIiRjdXJzb3IiLCJoYW5kbGVLZXlEb3duIiwiaXNJbnB1dFJ1bGVzIiwiZ2V0VHlwZSIsImlzUGxhaW5PYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsIm1lcmdlRGVlcCIsInRhcmdldCIsInNvdXJjZSIsIm91dHB1dCIsIk1hcmsiLCJjaGlsZCIsImRlZmF1bHRPcHRpb25zIiwiYWRkT3B0aW9ucyIsImNyZWF0ZSIsImNvbmZpZ3VyZSIsImV4dGVuZCIsImV4dGVuZGVkQ29uZmlnIiwiaGFuZGxlRXhpdCIsImN1cnJlbnRQb3MiLCJpc0F0RW5kIiwiZW5kIiwiY3VycmVudE1hcmtzIiwiaXNJbk1hcmsiLCJtIiwicmVtb3ZlTWFyayIsInJlbW92ZVN0b3JlZE1hcmsiLCJpbnNlcnRUZXh0IiwiaXNOdW1iZXIiLCJQYXN0ZVJ1bGUiLCJwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciIsIm1hdGNoQWxsIiwibWF0Y2hlcyIsInBhc3RlUnVsZU1hdGNoIiwicGFzdGVFdmVudCIsImRyb3BFdmVudCIsImhhbmRsZXJzIiwiaXNUZXh0YmxvY2siLCJyZXNvbHZlZEZyb20iLCJyZXNvbHZlZFRvIiwibWluIiwic2l6ZSIsInRleHRUb01hdGNoIiwidGV4dEJldHdlZW4iLCJzdGFydCIsIm1hcHBpbmciLCJzdWNjZXNzIiwidGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciIsImNyZWF0ZUNsaXBib2FyZFBhc3RlRXZlbnQiLCJDbGlwYm9hcmRFdmVudCIsImNsaXBib2FyZERhdGEiLCJEYXRhVHJhbnNmZXIiLCJzZXREYXRhIiwicGFzdGVSdWxlc1BsdWdpbiIsImRyYWdTb3VyY2VFbGVtZW50IiwiaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IiLCJpc0Ryb3BwZWRGcm9tUHJvc2VNaXJyb3IiLCJEcmFnRXZlbnQiLCJwcm9jZXNzRXZlbnQiLCJwYXN0ZUV2dCIsImNoYWluYWJsZVN0YXRlIiwiYiIsImhhbmRsZURyYWdzdGFydCIsImRvbSIsInBhcmVudEVsZW1lbnQiLCJjb250YWlucyIsImhhbmRsZURyYWdlbmQiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwiZGVzdHJveSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkcm9wIiwiZHJhZ0Zyb21PdGhlckVkaXRvciIsImlzRWRpdGFibGUiLCJkZWxldGVSYW5nZSIsInBhc3RlIiwiX3ZpZXciLCJodG1sIiwiZ2V0RGF0YSIsImFwcGVuZFRyYW5zYWN0aW9uIiwidHJhbnNhY3Rpb25zIiwib2xkU3RhdGUiLCJpc1Bhc3RlIiwiaXNEcm9wIiwic2ltdWxhdGVkUGFzdGVNZXRhIiwiaXNTaW11bGF0ZWRQYXN0ZSIsImZpbmREaWZmU3RhcnQiLCJmaW5kRGlmZkVuZCIsImZpbmREdXBsaWNhdGVzIiwiZmlsdGVyZWQiLCJlbCIsImluZGV4T2YiLCJTZXQiLCJFeHRlbnNpb25NYW5hZ2VyIiwic3BsaXR0YWJsZU1hcmtzIiwic2V0dXBFeHRlbnNpb25zIiwicmVzb2x2ZWRFeHRlbnNpb25zIiwic29ydCIsImZsYXR0ZW4iLCJkdXBsaWNhdGVkTmFtZXMiLCJhZGRFeHRlbnNpb25zIiwiZmxhdCIsImRlZmF1bHRQcmlvcml0eSIsImEiLCJwcmlvcml0eUEiLCJwcmlvcml0eUIiLCJhZGRDb21tYW5kcyIsInJldmVyc2UiLCJpbnB1dFJ1bGVzIiwicGFzdGVSdWxlcyIsImFsbFBsdWdpbnMiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImRlZmF1bHRCaW5kaW5ncyIsIkFycm93UmlnaHQiLCJiaW5kaW5ncyIsInNob3J0Y3V0Iiwia2V5TWFwUGx1Z2luIiwiYWRkSW5wdXRSdWxlcyIsImVuYWJsZUlucHV0UnVsZXMiLCJhZGRQYXN0ZVJ1bGVzIiwiZW5hYmxlUGFzdGVSdWxlcyIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsInByb3NlTWlycm9yUGx1Z2lucyIsIm5vZGVWaWV3cyIsImFkZE5vZGVWaWV3Iiwibm9kZXZpZXciLCJnZXRQb3MiLCJkZWNvcmF0aW9ucyIsImlubmVyRGVjb3JhdGlvbnMiLCJleHRlbnNpb25TdG9yYWdlIiwib25CZWZvcmVDcmVhdGUiLCJvbkNyZWF0ZSIsIm9uVXBkYXRlIiwib25TZWxlY3Rpb25VcGRhdGUiLCJvblRyYW5zYWN0aW9uIiwib25Gb2N1cyIsIm9uQmx1ciIsIm9uRGVzdHJveSIsIkV4dGVuc2lvbiIsImdldFRleHRCZXR3ZWVuIiwic3RhcnROb2RlIiwiYmxvY2tTZXBhcmF0b3IiLCJ0ZXh0U2VyaWFsaXplcnMiLCJpc0Jsb2NrIiwidGV4dFNlcmlhbGl6ZXIiLCJnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hIiwiQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXIiLCJjbGlwYm9hcmRUZXh0U2VyaWFsaXplciIsInJhbmdlcyIsIiR0byIsImJsdXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJpc0Rlc3Ryb3llZCIsImdldFNlbGVjdGlvbiIsInJlbW92ZUFsbFJhbmdlcyIsImNsZWFyQ29udGVudCIsImVtaXRVcGRhdGUiLCJzZXRDb250ZW50IiwiY2xlYXJOb2RlcyIsIiRtYXBwZWRGcm9tIiwiJG1hcHBlZFRvIiwibm9kZVNpemUiLCJub2RlUmFuZ2UiLCJibG9ja1JhbmdlIiwidGFyZ2V0TGlmdERlcHRoIiwiZGVmYXVsdFR5cGUiLCJjb250ZW50TWF0Y2hBdCIsInNldE5vZGVNYXJrdXAiLCJjdXQiLCJvcmlnaW5SYW5nZSIsInRhcmdldFBvcyIsImNvbnRlbnRTbGljZSIsIm5ld1BvcyIsImluc2VydCIsInNldFNlbGVjdGlvbiIsImRlbGV0ZUN1cnJlbnROb2RlIiwiY3VycmVudE5vZGUiLCIkYW5jaG9yIiwiJHBvcyIsImRlcHRoIiwiYmVmb3JlIiwiYWZ0ZXIiLCJkZWxldGUiLCJzY3JvbGxJbnRvVmlldyIsImRlbGV0ZU5vZGUiLCJ0eXBlT3JOYW1lIiwiZW50ZXIiLCJrZXlib2FyZFNob3J0Y3V0Iiwib2JqZWN0SW5jbHVkZXMiLCJvYmplY3QxIiwib2JqZWN0MiIsInN0cmljdCIsInRlc3QiLCJmaW5kTWFya0luU2V0IiwiayIsImlzTWFya0luU2V0IiwiZ2V0TWFya1JhbmdlIiwiY2hpbGRBZnRlciIsImNoaWxkQmVmb3JlIiwic3RhcnRJbmRleCIsInN0YXJ0UG9zIiwib2Zmc2V0IiwiZW5kSW5kZXgiLCJlbmRQb3MiLCJjaGlsZENvdW50IiwiZ2V0TWFya1R5cGUiLCJleHRlbmRNYXJrUmFuZ2UiLCJuZXdTZWxlY3Rpb24iLCJmaXJzdCIsImkiLCJpc1RleHRTZWxlY3Rpb24iLCJtaW5NYXgiLCJyZXNvbHZlRm9jdXNQb3NpdGlvbiIsInBvc2l0aW9uIiwic2VsZWN0aW9uQXRTdGFydCIsImF0U3RhcnQiLCJzZWxlY3Rpb25BdEVuZCIsImF0RW5kIiwibWluUG9zIiwibWF4UG9zIiwiaXNBbmRyb2lkIiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJ1c2VyQWdlbnQiLCJpc2lPUyIsImZvY3VzIiwiZGVsYXllZEZvY3VzIiwiaGFzRm9jdXMiLCJpc1NhbWVTZWxlY3Rpb24iLCJlcSIsInNldFN0b3JlZE1hcmtzIiwiaW5zZXJ0Q29udGVudCIsImluc2VydENvbnRlbnRBdCIsInJlbW92ZVdoaXRlc3BhY2VzIiwiY2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwibm9kZVR5cGUiLCJub2RlVmFsdWUiLCJyZW1vdmVDaGlsZCIsImVsZW1lbnRGcm9tU3RyaW5nIiwid3JhcHBlZFZhbHVlIiwicGFyc2VGcm9tU3RyaW5nIiwiYm9keSIsImNyZWF0ZU5vZGVGcm9tQ29udGVudCIsInBhcnNlT3B0aW9ucyIsImlzSlNPTkNvbnRlbnQiLCJpc1RleHRDb250ZW50IiwiaXNBcnJheUNvbnRlbnQiLCJmcm9tQXJyYXkiLCJub2RlRnJvbUpTT04iLCJlcnJvck9uSW52YWxpZENvbnRlbnQiLCJjaGVjayIsImVycm9yIiwiY2F1c2UiLCJoYXNJbnZhbGlkQ29udGVudCIsImludmFsaWRDb250ZW50IiwiY29udGVudENoZWNrU2NoZW1hIiwiYXBwZW5kIiwiX190aXB0YXBfX3ByaXZhdGVfX3Vua25vd25fX2NhdGNoX19hbGxfX25vZGUiLCJ0YWciLCJvdXRlckhUTUwiLCJwYXJzZVNsaWNlIiwicGFyc2UiLCJwYXJzZXIiLCJzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCIsInN0YXJ0TGVuIiwiYmlhcyIsImxhc3QiLCJzdGVwIiwibWFwcyIsIl9mcm9tIiwiX3RvIiwiX25ld0Zyb20iLCJuZXdUbyIsIm5lYXIiLCJpc0ZyYWdtZW50Iiwibm9kZU9yRnJhZ21lbnQiLCJ1cGRhdGVTZWxlY3Rpb24iLCJhcHBseUlucHV0UnVsZXMiLCJhcHBseVBhc3RlUnVsZXMiLCJlbWl0Q29udGVudEVycm9yIiwiZGlzYWJsZUNvbGxhYm9yYXRpb24iLCJjb2xsYWJvcmF0aW9uIiwiaXNEaXNhYmxlZCIsInByZXNlcnZlV2hpdGVzcGFjZSIsImVuYWJsZUNvbnRlbnRDaGVjayIsImlzT25seVRleHRDb250ZW50IiwiaXNPbmx5QmxvY2tDb250ZW50IiwiaXNFbXB0eVRleHRCbG9jayIsIm5ld0NvbnRlbnQiLCJ2Iiwiam9pbkl0ZW1CYWNrd2FyZCIsInBvaW50Iiwiam9pbkl0ZW1Gb3J3YXJkIiwiaXNNYWNPUyIsIm5vcm1hbGl6ZUtleU5hbWUiLCJwYXJ0cyIsImFsdCIsImN0cmwiLCJzaGlmdCIsIm1ldGEiLCJtb2QiLCJLZXlib2FyZEV2ZW50IiwiYWx0S2V5IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwiY2FwdHVyZWRUcmFuc2FjdGlvbiIsImNhcHR1cmVUcmFuc2FjdGlvbiIsInNvbWVQcm9wIiwiZiIsIm5ld1N0ZXAiLCJtYXliZVN0ZXAiLCJpc05vZGVBY3RpdmUiLCJlbXB0eSIsIm5vZGVSYW5nZXMiLCJyZWxhdGl2ZUZyb20iLCJyZWxhdGl2ZVRvIiwic2VsZWN0aW9uUmFuZ2UiLCJtYXRjaGVkTm9kZVJhbmdlcyIsInN1bSIsImlzQWN0aXZlIiwiZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUiLCJkZWxldGVQcm9wcyIsIm9iaiIsInByb3BPclByb3BzIiwibmV3T2JqIiwicHJvcCIsInJlc2V0QXR0cmlidXRlcyIsIm1hcmtUeXBlIiwic2NoZW1hVHlwZSIsImFkZE1hcmsiLCJzZWxlY3RBbGwiLCJjcmVhdGVEb2N1bWVudCIsImdldE1hcmtBdHRyaWJ1dGVzIiwiJGhlYWQiLCJtYXJrSXRlbSIsImNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzIiwib2xkRG9jIiwiZGVmYXVsdEJsb2NrQXQiLCJlZGdlQ291bnQiLCJlZGdlIiwiaGFzUmVxdWlyZWRBdHRycyIsImZpbmRDaGlsZHJlbiIsInByZWRpY2F0ZSIsIm5vZGVzV2l0aFBvcyIsImRlc2NlbmRhbnRzIiwiZmluZENoaWxkcmVuSW5SYW5nZSIsImZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zIiwiZmluZFBhcmVudE5vZGUiLCJnZXRTY2hlbWEiLCJnZW5lcmF0ZUhUTUwiLCJjb250ZW50Tm9kZSIsImZyb21KU09OIiwiZ2VuZXJhdGVKU09OIiwiZ2V0VGV4dCIsImdlbmVyYXRlVGV4dCIsImdldE5vZGVBdHRyaWJ1dGVzIiwibm9kZUl0ZW0iLCJnZXRBdHRyaWJ1dGVzIiwicmVtb3ZlRHVwbGljYXRlcyIsImFycmF5IiwiYnkiLCJKU09OIiwic3RyaW5naWZ5Iiwic2VlbiIsImhhc093blByb3BlcnR5Iiwic2ltcGxpZnlDaGFuZ2VkUmFuZ2VzIiwiY2hhbmdlcyIsInVuaXF1ZUNoYW5nZXMiLCJjaGFuZ2UiLCJyZXN0IiwiXyIsIm90aGVyQ2hhbmdlIiwib2xkUmFuZ2UiLCJuZXdSYW5nZSIsImdldENoYW5nZWRSYW5nZXMiLCJzdGVwTWFwIiwibmV3U3RhcnQiLCJuZXdFbmQiLCJvbGRTdGFydCIsImludmVydCIsIm9sZEVuZCIsImdldERlYnVnSlNPTiIsInN0YXJ0T2Zmc2V0IiwiaXNUb3BOb2RlIiwidG9wTm9kZVR5cGUiLCJpbmNyZW1lbnQiLCJnZXRNYXJrc0JldHdlZW4iLCJnZXROb2RlQXRQb3NpdGlvbiIsIm1heERlcHRoIiwiY3VycmVudERlcHRoIiwiZ2V0U3BsaXR0ZWRBdHRyaWJ1dGVzIiwidHlwZU5hbWUiLCJpc01hcmtBY3RpdmUiLCJtYXJrUmFuZ2VzIiwibWF0Y2hlZFJhbmdlIiwibWFya1JhbmdlIiwiZXhjbHVkZWRSYW5nZSIsImlzQXRFbmRPZk5vZGUiLCJwYXJlbnROb2RlIiwiJHBhcmVudFBvcyIsImlzQXRTdGFydE9mTm9kZSIsImlzTGlzdCIsImlzTm9kZUVtcHR5IiwiY2hlY2tDaGlsZHJlbiIsImlnbm9yZVdoaXRlc3BhY2UiLCJpc0xlYWYiLCJpc0NvbnRlbnRFbXB0eSIsImNoaWxkTm9kZSIsImlzTm9kZVNlbGVjdGlvbiIsInBvc1RvRE9NUmVjdCIsInJlc29sdmVkRW5kIiwiY29vcmRzQXRQb3MiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwicmV3cml0ZVVua25vd25Db250ZW50SW5uZXIiLCJqc29uIiwidmFsaWRNYXJrcyIsInZhbGlkTm9kZXMiLCJyZXdyaXR0ZW5Db250ZW50IiwiaGFzIiwib3JpZ2luYWwiLCJ1bnN1cHBvcnRlZCIsImZhbGxiYWNrVG9QYXJhZ3JhcGgiLCJyZXdyaXRlVW5rbm93bkNvbnRlbnQiLCJjYW5TZXRNYXJrIiwibmV3TWFya1R5cGUiLCJjdXJzb3IiLCJpc0luU2V0Iiwic29tZU5vZGVTdXBwb3J0c01hcmsiLCJpbmxpbmVDb250ZW50IiwiYWxsb3dzTWFya1R5cGUiLCJfcG9zIiwiaXNJbmxpbmUiLCJwYXJlbnRBbGxvd3NNYXJrVHlwZSIsImN1cnJlbnRNYXJrc0FsbG93TWFya1R5cGUiLCJvdGhlck1hcmsiLCJzZXRNYXJrIiwiYWRkU3RvcmVkTWFyayIsInRyaW1tZWRGcm9tIiwidHJpbW1lZFRvIiwic29tZUhhc01hcmsiLCJzZXROb2RlIiwiYXR0cmlidXRlc1RvQ29weSIsInNhbWVQYXJlbnQiLCJjYW5TZXRCbG9jayIsInVwZGF0ZWRTdGF0ZSIsInNldE5vZGVTZWxlY3Rpb24iLCJzZXRUZXh0U2VsZWN0aW9uIiwiZW5zdXJlTWFya3MiLCJmaWx0ZXJlZE1hcmtzIiwic3BsaXRCbG9jayIsImtlZXBNYXJrcyIsImRlZmx0IiwiaW5kZXhBZnRlciIsIiRmaXJzdCIsImNhblJlcGxhY2VXaXRoIiwic3BsaXRMaXN0SXRlbSIsIm92ZXJyaWRlQXR0cnMiLCJncmFuZFBhcmVudCIsIndyYXAiLCJkZXB0aEJlZm9yZSIsImQiLCJjb3B5IiwiZGVwdGhBZnRlciIsIm5ld05leHRUeXBlQXR0cmlidXRlcyIsIm5leHRUeXBlIiwiY29udGVudE1hdGNoIiwiY3JlYXRlQW5kRmlsbCIsInJlcGxhY2UiLCJzZWwiLCJuIiwibmV3VHlwZUF0dHJpYnV0ZXMiLCJqb2luTGlzdEJhY2t3YXJkcyIsImxpc3RUeXBlIiwibGlzdCIsIm5vZGVBdCIsImNhbkpvaW5CYWNrd2FyZHMiLCJqb2luTGlzdEZvcndhcmRzIiwiY2FuSm9pbkZvcndhcmRzIiwidG9nZ2xlTGlzdCIsImxpc3RUeXBlT3JOYW1lIiwiaXRlbVR5cGVPck5hbWUiLCJpdGVtVHlwZSIsInBhcmVudExpc3QiLCJ2YWxpZENvbnRlbnQiLCJjYW5XcmFwSW5MaXN0IiwidG9nZ2xlTWFyayIsImV4dGVuZEVtcHR5TWFya1JhbmdlIiwidW5zZXRNYXJrIiwidG9nZ2xlTm9kZSIsInRvZ2dsZVR5cGVPck5hbWUiLCJ0b2dnbGVUeXBlIiwidG9nZ2xlV3JhcCIsInVuZG9JbnB1dFJ1bGUiLCJ1bmRvYWJsZSIsImdldFN0YXRlIiwidG9VbmRvIiwiaiIsImRvY3MiLCJ1bnNldEFsbE1hcmtzIiwidXBkYXRlQXR0cmlidXRlcyIsImxhc3RQb3MiLCJsYXN0Tm9kZSIsInRyaW1tZWRGcm9tMiIsInRyaW1tZWRUbzIiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJDb21tYW5kcyIsIkRyb3AiLCJoYW5kbGVEcm9wIiwibW92ZWQiLCJFZGl0YWJsZSIsImVkaXRhYmxlIiwiZm9jdXNFdmVudHNQbHVnaW5LZXkiLCJGb2N1c0V2ZW50cyIsImlzRm9jdXNlZCIsIktleW1hcCIsImhhbmRsZUJhY2tzcGFjZSIsInBhcmVudElzSXNvbGF0aW5nIiwicGFyZW50UG9zIiwiaXNBdFN0YXJ0IiwiaGFuZGxlRGVsZXRlIiwiaGFuZGxlRW50ZXIiLCJiYXNlS2V5bWFwIiwiRW50ZXIiLCJCYWNrc3BhY2UiLCJEZWxldGUiLCJwY0tleW1hcCIsIm1hY0tleW1hcCIsIm5ld1N0YXRlIiwiZG9jQ2hhbmdlcyIsImlnbm9yZVRyIiwiYWxsRnJvbSIsImFsbEVuZCIsImFsbFdhc1NlbGVjdGVkIiwiaXNFbXB0eSIsIlBhc3RlIiwiaGFuZGxlUGFzdGUiLCJUYWJpbmRleCIsInRhYmluZGV4IiwiTm9kZVBvcyIsImFjdHVhbERlcHRoIiwicmVzb2x2ZWRQb3MiLCJlbGVtZW50IiwiZG9tQXRQb3MiLCJpc05vblRleHRBdG9tIiwiY2hpbGROb2RlUG9zIiwiZmlyc3RDaGlsZCIsImxhc3RDaGlsZCIsImNsb3Nlc3QiLCJzZWxlY3RvciIsIm5vZGVBdHRyaWJ1dGVzIiwiYXR0cktleXMiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsImZpcnN0SXRlbU9ubHkiLCJjaGlsZFBvcyIsImRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2giLCJjb25jYXQiLCJzZXRBdHRyaWJ1dGUiLCJjcmVhdGVTdHlsZVRhZyIsIm5vbmNlIiwic3VmZml4IiwidGlwdGFwU3R5bGVUYWciLCJzdHlsZU5vZGUiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIkVkaXRvciIsImlzSW5pdGlhbGl6ZWQiLCJpbmplY3RDU1MiLCJpbmplY3ROb25jZSIsImF1dG9mb2N1cyIsImVkaXRvclByb3BzIiwiY29yZUV4dGVuc2lvbk9wdGlvbnMiLCJlbmFibGVDb3JlRXh0ZW5zaW9ucyIsIm9uQ29udGVudEVycm9yIiwib25QYXN0ZSIsIm9uRHJvcCIsImlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24iLCJzZXRPcHRpb25zIiwiY3JlYXRlRXh0ZW5zaW9uTWFuYWdlciIsImNyZWF0ZUNvbW1hbmRNYW5hZ2VyIiwiY3JlYXRlU2NoZW1hIiwiY3JlYXRlVmlldyIsImNvbW1hbmRNYW5hZ2VyIiwiY3NzIiwic2V0UHJvcHMiLCJ1cGRhdGVTdGF0ZSIsInNldEVkaXRhYmxlIiwicmVnaXN0ZXJQbHVnaW4iLCJoYW5kbGVQbHVnaW5zIiwidW5yZWdpc3RlclBsdWdpbiIsIm5hbWVPclBsdWdpbktleVRvUmVtb3ZlIiwicHJldlBsdWdpbnMiLCJuYW1lT3JQbHVnaW5LZXkiLCJzdGFydHNXaXRoIiwiY29yZUV4dGVuc2lvbnMiLCJleHQiLCJhbGxFeHRlbnNpb25zIiwibWVzc2FnZSIsInJvbGUiLCJkaXNwYXRjaFRyYW5zYWN0aW9uIiwiY3JlYXRlTm9kZVZpZXdzIiwicHJlcGVuZENsYXNzIiwiY2xhc3NOYW1lIiwic2VsZWN0aW9uSGFzQ2hhbmdlZCIsIm5leHRTdGF0ZSIsIm5hbWVPckF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzT3JVbmRlZmluZWQiLCJnZXRKU09OIiwiZ2V0SFRNTCIsImdldENoYXJhY3RlckNvdW50IiwiZG9jVmlldyIsIiRub2RlIiwiJGRvYyIsIiRub2RlcyIsIm1hcmtJbnB1dFJ1bGUiLCJjYXB0dXJlR3JvdXAiLCJmdWxsTWF0Y2giLCJzdGFydFNwYWNlcyIsInNlYXJjaCIsInRleHRTdGFydCIsInRleHRFbmQiLCJleGNsdWRlZE1hcmtzIiwiZXhjbHVkZWQiLCJtYXJrRW5kIiwibm9kZUlucHV0UnVsZSIsIm5ld05vZGUiLCJsYXN0SW5kZXhPZiIsIm1hdGNoU3RhcnQiLCJsYXN0Q2hhciIsImluc2VydGlvblN0YXJ0IiwidGV4dGJsb2NrVHlwZUlucHV0UnVsZSIsIiRzdGFydCIsInRleHRJbnB1dFJ1bGUiLCJjdXRPZmYiLCJ3cmFwcGluZ0lucHV0UnVsZSIsIndyYXBwaW5nIiwia2VlcEF0dHJpYnV0ZXMiLCJqb2luUHJlZGljYXRlIiwiTm9kZVZpZXciLCJjb21wb25lbnQiLCJpc0RyYWdnaW5nIiwic3RvcEV2ZW50IiwiaWdub3JlTXV0YXRpb24iLCJtb3VudCIsImNvbnRlbnRET00iLCJvbkRyYWdTdGFydCIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJkcmFnSGFuZGxlIiwiZG9tQm94IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFuZGxlQm94Iiwib2Zmc2V0WCIsIm5hdGl2ZUV2ZW50Iiwib2Zmc2V0WSIsImNsb25lZE5vZGUiLCJjbG9uZU5vZGUiLCJkYXRhVHJhbnNmZXIiLCJzZXREcmFnSW1hZ2UiLCJpc0luRWxlbWVudCIsImlzRHJhZ0V2ZW50IiwiaXNEcm9wRXZlbnQiLCJpc0lucHV0IiwidGFnTmFtZSIsImlzQ29udGVudEVkaXRhYmxlIiwiaXNEcmFnZ2FibGUiLCJpc1NlbGVjdGFibGUiLCJpc0NvcHlFdmVudCIsImlzUGFzdGVFdmVudCIsImlzQ3V0RXZlbnQiLCJpc0NsaWNrRXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImlzVmFsaWREcmFnSGFuZGxlIiwibXV0YXRpb24iLCJjaGFuZ2VkTm9kZXMiLCJhZGRlZE5vZGVzIiwicmVtb3ZlZE5vZGVzIiwibWFya1Bhc3RlUnVsZSIsImNhbkluc2VydE5vZGUiLCJtYXRjaFR5cGUiLCJlc2NhcGVGb3JSZWdFeCIsInN0cmluZyIsImlzU3RyaW5nIiwibm9kZVBhc3RlUnVsZSIsImdldENvbnRlbnQiLCJ0ZXh0UGFzdGVSdWxlIiwiVHJhY2tlciIsImN1cnJlbnRTdGVwIiwiZGVsZXRlZCIsIm1hcHBlZFBvc2l0aW9uIiwibmV3UG9zaXRpb24iLCJtYXBSZXN1bHQiLCJnZXRNYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/core/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: () => (/* binding */ Blockquote),\n/* harmony export */   \"default\": () => (/* binding */ Blockquote),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches a blockquote to a `>` as input.\n */ const inputRegex = /^\\s*>\\s$/;\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */ const Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"blockquote\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    content: \"block+\",\n    group: \"block\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"blockquote\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"blockquote\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setBlockquote: ()=>({ commands })=>{\n                    return commands.wrapIn(this.name);\n                },\n            toggleBlockquote: ()=>({ commands })=>{\n                    return commands.toggleWrap(this.name);\n                },\n            unsetBlockquote: ()=>({ commands })=>{\n                    return commands.lift(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-b\": ()=>this.editor.commands.toggleBlockquote()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0U7QUFFeEU7O0NBRUMsR0FDRCxNQUFNRyxhQUFhO0FBQ25COzs7Q0FHQyxHQUNELE1BQU1DLGFBQWFKLDhDQUFJQSxDQUFDSyxNQUFNLENBQUM7SUFDM0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0g7Z0JBQUVDLEtBQUs7WUFBYTtTQUN2QjtJQUNMO0lBQ0FDLFlBQVcsRUFBRU4sY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFjUCw2REFBZUEsQ0FBQyxJQUFJLENBQUNjLE9BQU8sQ0FBQ1AsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQzFGO0lBQ0FRO1FBQ0ksT0FBTztZQUNIQyxlQUFlLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQzlCLE9BQU9BLFNBQVNDLE1BQU0sQ0FBQyxJQUFJLENBQUNiLElBQUk7Z0JBQ3BDO1lBQ0FjLGtCQUFrQixJQUFNLENBQUMsRUFBRUYsUUFBUSxFQUFFO29CQUNqQyxPQUFPQSxTQUFTRyxVQUFVLENBQUMsSUFBSSxDQUFDZixJQUFJO2dCQUN4QztZQUNBZ0IsaUJBQWlCLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQ2hDLE9BQU9BLFNBQVNLLElBQUksQ0FBQyxJQUFJLENBQUNqQixJQUFJO2dCQUNsQztRQUNKO0lBQ0o7SUFDQWtCO1FBQ0ksT0FBTztZQUNILGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxnQkFBZ0I7UUFDOUQ7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSHhCLCtEQUFpQkEsQ0FBQztnQkFDZHlCLE1BQU14QjtnQkFDTnlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtBQUNKO0FBRXlELENBQ3pELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUvZGlzdC9pbmRleC5qcz9lMWEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIE1hdGNoZXMgYSBibG9ja3F1b3RlIHRvIGEgYD5gIGFzIGlucHV0LlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqPlxccyQvO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBibG9ja3F1b3Rlcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9ibG9ja3F1b3RlXG4gKi9cbmNvbnN0IEJsb2NrcXVvdGUgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Jsb2NrcXVvdGUnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb250ZW50OiAnYmxvY2srJyxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHRhZzogJ2Jsb2NrcXVvdGUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydibG9ja3F1b3RlJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZVdyYXAodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC1iJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQmxvY2txdW90ZSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQmxvY2txdW90ZSwgQmxvY2txdW90ZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwid3JhcHBpbmdJbnB1dFJ1bGUiLCJpbnB1dFJlZ2V4IiwiQmxvY2txdW90ZSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiSFRNTEF0dHJpYnV0ZXMiLCJjb250ZW50IiwiZ3JvdXAiLCJkZWZpbmluZyIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRCbG9ja3F1b3RlIiwiY29tbWFuZHMiLCJ3cmFwSW4iLCJ0b2dnbGVCbG9ja3F1b3RlIiwidG9nZ2xlV3JhcCIsInVuc2V0QmxvY2txdW90ZSIsImxpZnQiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwidHlwZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: () => (/* binding */ Bold),\n/* harmony export */   \"default\": () => (/* binding */ Bold),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches bold text via `**` as input.\n */ const starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\n/**\n * Matches bold text via `**` while pasting.\n */ const starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\n/**\n * Matches bold text via `__` as input.\n */ const underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\n/**\n * Matches bold text via `__` while pasting.\n */ const underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */ const Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"bold\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"strong\"\n            },\n            {\n                tag: \"b\",\n                getAttrs: (node)=>node.style.fontWeight !== \"normal\" && null\n            },\n            {\n                style: \"font-weight=400\",\n                clearMark: (mark)=>mark.type.name === this.name\n            },\n            {\n                style: \"font-weight\",\n                getAttrs: (value)=>/^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"strong\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setBold: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleBold: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetBold: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-b\": ()=>this.editor.commands.toggleBold(),\n            \"Mod-B\": ()=>this.editor.commands.toggleBold()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYm9sZC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUY7QUFFbkY7O0NBRUMsR0FDRCxNQUFNSSxpQkFBaUI7QUFDdkI7O0NBRUMsR0FDRCxNQUFNQyxpQkFBaUI7QUFDdkI7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUI7QUFDN0I7O0NBRUMsR0FDRCxNQUFNQyx1QkFBdUI7QUFDN0I7OztDQUdDLEdBQ0QsTUFBTUMsT0FBT1IsOENBQUlBLENBQUNTLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztZQUNUO1lBQ0E7Z0JBQ0lBLEtBQUs7Z0JBQ0xDLFVBQVVDLENBQUFBLE9BQVFBLEtBQUtDLEtBQUssQ0FBQ0MsVUFBVSxLQUFLLFlBQVk7WUFDNUQ7WUFDQTtnQkFDSUQsT0FBTztnQkFDUEUsV0FBV0MsQ0FBQUEsT0FBUUEsS0FBS0MsSUFBSSxDQUFDWCxJQUFJLEtBQUssSUFBSSxDQUFDQSxJQUFJO1lBQ25EO1lBQ0E7Z0JBQ0lPLE9BQU87Z0JBQ1BGLFVBQVVPLENBQUFBLFFBQVMsNEJBQTRCQyxJQUFJLENBQUNELFVBQVU7WUFDbEU7U0FDSDtJQUNMO0lBQ0FFLFlBQVcsRUFBRVosY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFVWCw2REFBZUEsQ0FBQyxJQUFJLENBQUN3QixPQUFPLENBQUNiLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUN0RjtJQUNBYztRQUNJLE9BQU87WUFDSEMsU0FBUyxJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFO29CQUN4QixPQUFPQSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDbkIsSUFBSTtnQkFDckM7WUFDQW9CLFlBQVksSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDM0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ3JCLElBQUk7Z0JBQ3hDO1lBQ0FzQixXQUFXLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzFCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUN2QixJQUFJO2dCQUN2QztRQUNKO0lBQ0o7SUFDQXdCO1FBQ0ksT0FBTztZQUNILFNBQVMsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxVQUFVO1lBQzlDLFNBQVMsSUFBTSxJQUFJLENBQUNLLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxVQUFVO1FBQ2xEO0lBQ0o7SUFDQU07UUFDSSxPQUFPO1lBQ0hsQywyREFBYUEsQ0FBQztnQkFDVm1DLE1BQU1qQztnQkFDTmlCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1lBQ0FuQiwyREFBYUEsQ0FBQztnQkFDVm1DLE1BQU0vQjtnQkFDTmUsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0lBQ0FpQjtRQUNJLE9BQU87WUFDSG5DLDJEQUFhQSxDQUFDO2dCQUNWa0MsTUFBTWhDO2dCQUNOZ0IsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7WUFDQWxCLDJEQUFhQSxDQUFDO2dCQUNWa0MsTUFBTTlCO2dCQUNOYyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUU2RyxDQUM3RyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ib2xkL2Rpc3QvaW5kZXguanM/ZGY2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgKipgIGFzIGlucHV0LlxuICovXG5jb25zdCBzdGFySW5wdXRSZWdleCA9IC8oPzpefFxccykoXFwqXFwqKD8hXFxzK1xcKlxcKikoKD86W14qXSspKVxcKlxcKig/IVxccytcXCpcXCopKSQvO1xuLyoqXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYCoqYCB3aGlsZSBwYXN0aW5nLlxuICovXG5jb25zdCBzdGFyUGFzdGVSZWdleCA9IC8oPzpefFxccykoXFwqXFwqKD8hXFxzK1xcKlxcKikoKD86W14qXSspKVxcKlxcKig/IVxccytcXCpcXCopKS9nO1xuLyoqXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYF9fYCBhcyBpbnB1dC5cbiAqL1xuY29uc3QgdW5kZXJzY29yZUlucHV0UmVnZXggPSAvKD86XnxcXHMpKF9fKD8hXFxzK19fKSgoPzpbXl9dKykpX18oPyFcXHMrX18pKSQvO1xuLyoqXG4gKiBNYXRjaGVzIGJvbGQgdGV4dCB2aWEgYF9fYCB3aGlsZSBwYXN0aW5nLlxuICovXG5jb25zdCB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpL2c7XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gbWFyayB0ZXh0IGFzIGJvbGQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbWFya3MvYm9sZFxuICovXG5jb25zdCBCb2xkID0gTWFyay5jcmVhdGUoe1xuICAgIG5hbWU6ICdib2xkJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ3N0cm9uZycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ2InLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiBub2RlID0+IG5vZGUuc3R5bGUuZm9udFdlaWdodCAhPT0gJ25vcm1hbCcgJiYgbnVsbCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICdmb250LXdlaWdodD00MDAnLFxuICAgICAgICAgICAgICAgIGNsZWFyTWFyazogbWFyayA9PiBtYXJrLnR5cGUubmFtZSA9PT0gdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtd2VpZ2h0JyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogdmFsdWUgPT4gL14oYm9sZChlcik/fFs1LTldXFxkezIsfSkkLy50ZXN0KHZhbHVlKSAmJiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3N0cm9uZycsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUJvbGQ6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtYic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKSxcbiAgICAgICAgICAgICdNb2QtQic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUJvbGQoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFySW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVJbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJQYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZVBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBCb2xkLCBCb2xkIGFzIGRlZmF1bHQsIHN0YXJJbnB1dFJlZ2V4LCBzdGFyUGFzdGVSZWdleCwgdW5kZXJzY29yZUlucHV0UmVnZXgsIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNYXJrIiwibWVyZ2VBdHRyaWJ1dGVzIiwibWFya0lucHV0UnVsZSIsIm1hcmtQYXN0ZVJ1bGUiLCJzdGFySW5wdXRSZWdleCIsInN0YXJQYXN0ZVJlZ2V4IiwidW5kZXJzY29yZUlucHV0UmVnZXgiLCJ1bmRlcnNjb3JlUGFzdGVSZWdleCIsIkJvbGQiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwicGFyc2VIVE1MIiwidGFnIiwiZ2V0QXR0cnMiLCJub2RlIiwic3R5bGUiLCJmb250V2VpZ2h0IiwiY2xlYXJNYXJrIiwibWFyayIsInR5cGUiLCJ2YWx1ZSIsInRlc3QiLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0Qm9sZCIsImNvbW1hbmRzIiwic2V0TWFyayIsInRvZ2dsZUJvbGQiLCJ0b2dnbGVNYXJrIiwidW5zZXRCb2xkIiwidW5zZXRNYXJrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsImFkZFBhc3RlUnVsZXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bubble-menu/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   BubbleMenuPlugin: () => (/* binding */ BubbleMenuPlugin),\n/* harmony export */   BubbleMenuView: () => (/* binding */ BubbleMenuView),\n/* harmony export */   \"default\": () => (/* binding */ BubbleMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\nclass BubbleMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow }){\n        this.preventHide = false;\n        this.shouldShow = ({ view, state, from, to })=>{\n            const { doc, selection } = state;\n            const { empty } = selection;\n            // Sometime check for `empty` is not enough.\n            // Doubleclick an empty paragraph returns a node size of 2.\n            // So we check also for an empty text size.\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isTextSelection)(state.selection);\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\n            // is called and the bubble menu item is focussed. In this case we should\n            // consider the menu as part of the editor and keep showing the menu\n            const isChildOfMenu = this.element.contains(document.activeElement);\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = ()=>{\n            this.preventHide = true;\n        };\n        this.dragstartHandler = ()=>{\n            this.hide();\n        };\n        this.focusHandler = ()=>{\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(()=>this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event })=>{\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event)=>{\n            this.blurHandler({\n                event\n            });\n        };\n        this.handleDebouncedUpdate = (view, oldState)=>{\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n            if (!selectionChanged && !docChanged) {\n                return;\n            }\n            if (this.updateDebounceTimer) {\n                clearTimeout(this.updateDebounceTimer);\n            }\n            this.updateDebounceTimer = window.setTimeout(()=>{\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\n            }, this.updateDelay);\n        };\n        this.updateHandler = (view, selectionChanged, docChanged, oldState)=>{\n            var _a, _b, _c;\n            const { state, composing } = view;\n            const { selection } = state;\n            const isSame = !selectionChanged && !docChanged;\n            if (composing || isSame) {\n                return;\n            }\n            this.createTooltip();\n            // support for CellSelections\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map((range)=>range.$from.pos));\n            const to = Math.max(...ranges.map((range)=>range.$to.pos));\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n                editor: this.editor,\n                element: this.element,\n                view,\n                state,\n                oldState,\n                from,\n                to\n            });\n            if (!shouldShow) {\n                this.hide();\n                return;\n            }\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (()=>{\n                    if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection)) {\n                        let node = view.nodeDOM(from);\n                        if (node) {\n                            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector(\"[data-node-view-wrapper]\");\n                            if (nodeViewWrapper) {\n                                node = nodeViewWrapper.firstChild;\n                            }\n                            if (node) {\n                                return node.getBoundingClientRect();\n                            }\n                        }\n                    }\n                    return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to);\n                })\n            });\n            this.show();\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        this.updateDelay = updateDelay;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.view.dom.addEventListener(\"dragstart\", this.dragstartHandler);\n        this.editor.on(\"focus\", this.focusHandler);\n        this.editor.on(\"blur\", this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = \"visible\";\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        this.element.tabIndex = 0;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: \"manual\",\n            placement: \"top\",\n            hideOnClick: \"toggle\",\n            ...this.tippyOptions\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener(\"blur\", this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        const { state } = view;\n        const hasValidSelection = state.selection.from !== state.selection.to;\n        if (this.updateDelay > 0 && hasValidSelection) {\n            this.handleDebouncedUpdate(view, oldState);\n            return;\n        }\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener(\"blur\", this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.view.dom.removeEventListener(\"dragstart\", this.dragstartHandler);\n        this.editor.off(\"focus\", this.focusHandler);\n        this.editor.off(\"blur\", this.blurHandler);\n    }\n}\nconst BubbleMenuPlugin = (options)=>{\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === \"string\" ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: (view)=>new BubbleMenuView({\n                view,\n                ...options\n            })\n    });\n};\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */ const BubbleMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"bubbleMenu\",\n    addOptions () {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: \"bubbleMenu\",\n            updateDelay: undefined,\n            shouldShow: null\n        };\n    },\n    addProseMirrorPlugins () {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            BubbleMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                updateDelay: this.options.updateDelay,\n                shouldShow: this.options.shouldShow\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnViYmxlLW1lbnUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXlGO0FBQ3BDO0FBQ3hCO0FBRTdCLE1BQU1PO0lBQ0ZDLFlBQVksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLElBQUksRUFBRUMsZUFBZSxDQUFDLENBQUMsRUFBRUMsY0FBYyxHQUFHLEVBQUVDLFVBQVUsRUFBRyxDQUFFO1FBQ3RGLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0QsVUFBVSxHQUFHLENBQUMsRUFBRUgsSUFBSSxFQUFFSyxLQUFLLEVBQUVDLElBQUksRUFBRUMsRUFBRSxFQUFHO1lBQ3pDLE1BQU0sRUFBRUMsR0FBRyxFQUFFQyxTQUFTLEVBQUUsR0FBR0o7WUFDM0IsTUFBTSxFQUFFSyxLQUFLLEVBQUUsR0FBR0Q7WUFDbEIsNENBQTRDO1lBQzVDLDJEQUEyRDtZQUMzRCwyQ0FBMkM7WUFDM0MsTUFBTUUsbUJBQW1CLENBQUNILElBQUlJLFdBQVcsQ0FBQ04sTUFBTUMsSUFBSU0sTUFBTSxJQUFJeEIsNkRBQWVBLENBQUNnQixNQUFNSSxTQUFTO1lBQzdGLDRFQUE0RTtZQUM1RSx5RUFBeUU7WUFDekUsb0VBQW9FO1lBQ3BFLE1BQU1LLGdCQUFnQixJQUFJLENBQUNmLE9BQU8sQ0FBQ2dCLFFBQVEsQ0FBQ0MsU0FBU0MsYUFBYTtZQUNsRSxNQUFNQyxpQkFBaUJsQixLQUFLbUIsUUFBUSxNQUFNTDtZQUMxQyxJQUFJLENBQUNJLGtCQUFrQlIsU0FBU0Msb0JBQW9CLENBQUMsSUFBSSxDQUFDYixNQUFNLENBQUNzQixVQUFVLEVBQUU7Z0JBQ3pFLE9BQU87WUFDWDtZQUNBLE9BQU87UUFDWDtRQUNBLElBQUksQ0FBQ0MsZ0JBQWdCLEdBQUc7WUFDcEIsSUFBSSxDQUFDakIsV0FBVyxHQUFHO1FBQ3ZCO1FBQ0EsSUFBSSxDQUFDa0IsZ0JBQWdCLEdBQUc7WUFD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WDFGLGFBQWErRjtZQUNiOUYsWUFBWTtRQUNoQjtJQUNKO0lBQ0ErRjtRQUNJLElBQUksQ0FBQyxJQUFJLENBQUN2QixPQUFPLENBQUM1RSxPQUFPLEVBQUU7WUFDdkIsT0FBTyxFQUFFO1FBQ2I7UUFDQSxPQUFPO1lBQ0gyRixpQkFBaUI7Z0JBQ2JFLFdBQVcsSUFBSSxDQUFDakIsT0FBTyxDQUFDaUIsU0FBUztnQkFDakM5RixRQUFRLElBQUksQ0FBQ0EsTUFBTTtnQkFDbkJDLFNBQVMsSUFBSSxDQUFDNEUsT0FBTyxDQUFDNUUsT0FBTztnQkFDN0JFLGNBQWMsSUFBSSxDQUFDMEUsT0FBTyxDQUFDMUUsWUFBWTtnQkFDdkNDLGFBQWEsSUFBSSxDQUFDeUUsT0FBTyxDQUFDekUsV0FBVztnQkFDckNDLFlBQVksSUFBSSxDQUFDd0UsT0FBTyxDQUFDeEUsVUFBVTtZQUN2QztTQUNIO0lBQ0w7QUFDSjtBQUUrRSxDQUMvRSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9kaXN0L2luZGV4LmpzPzVlNDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNUZXh0U2VsZWN0aW9uLCBpc05vZGVTZWxlY3Rpb24sIHBvc1RvRE9NUmVjdCwgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFBsdWdpbiwgUGx1Z2luS2V5IH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgdGlwcHkgZnJvbSAndGlwcHkuanMnO1xuXG5jbGFzcyBCdWJibGVNZW51VmlldyB7XG4gICAgY29uc3RydWN0b3IoeyBlZGl0b3IsIGVsZW1lbnQsIHZpZXcsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSA9IDI1MCwgc2hvdWxkU2hvdywgfSkge1xuICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9ICh7IHZpZXcsIHN0YXRlLCBmcm9tLCB0bywgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb2MsIHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGVtcHR5IH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBTb21ldGltZSBjaGVjayBmb3IgYGVtcHR5YCBpcyBub3QgZW5vdWdoLlxuICAgICAgICAgICAgLy8gRG91YmxlY2xpY2sgYW4gZW1wdHkgcGFyYWdyYXBoIHJldHVybnMgYSBub2RlIHNpemUgb2YgMi5cbiAgICAgICAgICAgIC8vIFNvIHdlIGNoZWNrIGFsc28gZm9yIGFuIGVtcHR5IHRleHQgc2l6ZS5cbiAgICAgICAgICAgIGNvbnN0IGlzRW1wdHlUZXh0QmxvY2sgPSAhZG9jLnRleHRCZXR3ZWVuKGZyb20sIHRvKS5sZW5ndGggJiYgaXNUZXh0U2VsZWN0aW9uKHN0YXRlLnNlbGVjdGlvbik7XG4gICAgICAgICAgICAvLyBXaGVuIGNsaWNraW5nIG9uIGEgZWxlbWVudCBpbnNpZGUgdGhlIGJ1YmJsZSBtZW51IHRoZSBlZGl0b3IgXCJibHVyXCIgZXZlbnRcbiAgICAgICAgICAgIC8vIGlzIGNhbGxlZCBhbmQgdGhlIGJ1YmJsZSBtZW51IGl0ZW0gaXMgZm9jdXNzZWQuIEluIHRoaXMgY2FzZSB3ZSBzaG91bGRcbiAgICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBtZW51IGFzIHBhcnQgb2YgdGhlIGVkaXRvciBhbmQga2VlcCBzaG93aW5nIHRoZSBtZW51XG4gICAgICAgICAgICBjb25zdCBpc0NoaWxkT2ZNZW51ID0gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3QgaGFzRWRpdG9yRm9jdXMgPSB2aWV3Lmhhc0ZvY3VzKCkgfHwgaXNDaGlsZE9mTWVudTtcbiAgICAgICAgICAgIGlmICghaGFzRWRpdG9yRm9jdXMgfHwgZW1wdHkgfHwgaXNFbXB0eVRleHRCbG9jayB8fCAhdGhpcy5lZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1vdXNlZG93bkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kcmFnc3RhcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmICgoX2EgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpID09PSB0aGlzLmVkaXRvci52aWV3LmRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVEZWJvdW5jZWRVcGRhdGUgPSAodmlldywgb2xkU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkNoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5zZWxlY3Rpb24uZXEodmlldy5zdGF0ZS5zZWxlY3Rpb24pKTtcbiAgICAgICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGVib3VuY2VUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUhhbmRsZXIodmlldywgc2VsZWN0aW9uQ2hhbmdlZCwgZG9jQ2hhbmdlZCwgb2xkU3RhdGUpO1xuICAgICAgICAgICAgfSwgdGhpcy51cGRhdGVEZWxheSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlciA9ICh2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXRlLCBjb21wb3NpbmcgfSA9IHZpZXc7XG4gICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICBjb25zdCBpc1NhbWUgPSAhc2VsZWN0aW9uQ2hhbmdlZCAmJiAhZG9jQ2hhbmdlZDtcbiAgICAgICAgICAgIGlmIChjb21wb3NpbmcgfHwgaXNTYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jcmVhdGVUb29sdGlwKCk7XG4gICAgICAgICAgICAvLyBzdXBwb3J0IGZvciBDZWxsU2VsZWN0aW9uc1xuICAgICAgICAgICAgY29uc3QgeyByYW5nZXMgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSBNYXRoLm1pbiguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiRmcm9tLnBvcykpO1xuICAgICAgICAgICAgY29uc3QgdG8gPSBNYXRoLm1heCguLi5yYW5nZXMubWFwKHJhbmdlID0+IHJhbmdlLiR0by5wb3MpKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNob3cgPSAoX2EgPSB0aGlzLnNob3VsZFNob3cpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB2aWV3LFxuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIG9sZFN0YXRlLFxuICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghc2hvdWxkU2hvdykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRQcm9wcyh7XG4gICAgICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogKChfYyA9IHRoaXMudGlwcHlPcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdClcbiAgICAgICAgICAgICAgICAgICAgfHwgKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05vZGVTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBub2RlID0gdmlldy5ub2RlRE9NKGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWaWV3V3JhcHBlciA9IG5vZGUuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPyBub2RlIDogbm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YS1ub2RlLXZpZXctd3JhcHBlcl0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVWaWV3V3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGVWaWV3V3JhcHBlci5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwb3NUb0RPTVJlY3QodmlldywgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnVwZGF0ZURlbGF5ID0gdXBkYXRlRGVsYXk7XG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBzaG91bGRTaG93O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcik7XG4gICAgICAgIHRoaXMudGlwcHlPcHRpb25zID0gdGlwcHlPcHRpb25zO1xuICAgICAgICAvLyBEZXRhY2hlcyBtZW51IGNvbnRlbnQgZnJvbSBpdHMgY3VycmVudCBwYXJlbnRcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG4gICAgY3JlYXRlVG9vbHRpcCgpIHtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50OiBlZGl0b3JFbGVtZW50IH0gPSB0aGlzLmVkaXRvci5vcHRpb25zO1xuICAgICAgICBjb25zdCBlZGl0b3JJc0F0dGFjaGVkID0gISFlZGl0b3JFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZWxlbWVudC50YWJJbmRleCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnRpcHB5IHx8ICFlZGl0b3JJc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aXBweSA9IHRpcHB5KGVkaXRvckVsZW1lbnQsIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogbnVsbCxcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRoaXMuZWxlbWVudCxcbiAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICd0b3AnLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxuICAgICAgICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgICAgIGNvbnN0IGhhc1ZhbGlkU2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLmZyb20gIT09IHN0YXRlLnNlbGVjdGlvbi50bztcbiAgICAgICAgaWYgKHRoaXMudXBkYXRlRGVsYXkgPiAwICYmIGhhc1ZhbGlkU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSh2aWV3LCBvbGRTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpO1xuICAgICAgICBjb25zdCBkb2NDaGFuZ2VkID0gIShvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuZG9jLmVxKHZpZXcuc3RhdGUuZG9jKSk7XG4gICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSk7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3coKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZSgpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcHBlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICB0aGlzLnRpcHB5LnBvcHBlci5maXJzdENoaWxkLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzLmRyYWdzdGFydEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICB9XG59XG5jb25zdCBCdWJibGVNZW51UGx1Z2luID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogdHlwZW9mIG9wdGlvbnMucGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IG5ldyBQbHVnaW5LZXkob3B0aW9ucy5wbHVnaW5LZXkpIDogb3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgIHZpZXc6IHZpZXcgPT4gbmV3IEJ1YmJsZU1lbnVWaWV3KHsgdmlldywgLi4ub3B0aW9ucyB9KSxcbiAgICB9KTtcbn07XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBidWJibGUgbWVudS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2J1YmJsZS1tZW51XG4gKi9cbmNvbnN0IEJ1YmJsZU1lbnUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnYnViYmxlTWVudScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICB0aXBweU9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgcGx1Z2luS2V5OiAnYnViYmxlTWVudScsXG4gICAgICAgICAgICB1cGRhdGVEZWxheTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgc2hvdWxkU2hvdzogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBCdWJibGVNZW51UGx1Z2luKHtcbiAgICAgICAgICAgICAgICBwbHVnaW5LZXk6IHRoaXMub3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHRoaXMub3B0aW9ucy50aXBweU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgdXBkYXRlRGVsYXk6IHRoaXMub3B0aW9ucy51cGRhdGVEZWxheSxcbiAgICAgICAgICAgICAgICBzaG91bGRTaG93OiB0aGlzLm9wdGlvbnMuc2hvdWxkU2hvdyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQnViYmxlTWVudSwgQnViYmxlTWVudVBsdWdpbiwgQnViYmxlTWVudVZpZXcsIEJ1YmJsZU1lbnUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiaXNUZXh0U2VsZWN0aW9uIiwiaXNOb2RlU2VsZWN0aW9uIiwicG9zVG9ET01SZWN0IiwiRXh0ZW5zaW9uIiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwidGlwcHkiLCJCdWJibGVNZW51VmlldyIsImNvbnN0cnVjdG9yIiwiZWRpdG9yIiwiZWxlbWVudCIsInZpZXciLCJ0aXBweU9wdGlvbnMiLCJ1cGRhdGVEZWxheSIsInNob3VsZFNob3ciLCJwcmV2ZW50SGlkZSIsInN0YXRlIiwiZnJvbSIsInRvIiwiZG9jIiwic2VsZWN0aW9uIiwiZW1wdHkiLCJpc0VtcHR5VGV4dEJsb2NrIiwidGV4dEJldHdlZW4iLCJsZW5ndGgiLCJpc0NoaWxkT2ZNZW51IiwiY29udGFpbnMiLCJkb2N1bWVudCIsImFjdGl2ZUVsZW1lbnQiLCJoYXNFZGl0b3JGb2N1cyIsImhhc0ZvY3VzIiwiaXNFZGl0YWJsZSIsIm1vdXNlZG93bkhhbmRsZXIiLCJkcmFnc3RhcnRIYW5kbGVyIiwiaGlkZSIsImZvY3VzSGFuZGxlciIsInNldFRpbWVvdXQiLCJ1cGRhdGUiLCJibHVySGFuZGxlciIsImV2ZW50IiwiX2EiLCJyZWxhdGVkVGFyZ2V0IiwicGFyZW50Tm9kZSIsImRvbSIsInRpcHB5Qmx1ckhhbmRsZXIiLCJoYW5kbGVEZWJvdW5jZWRVcGRhdGUiLCJvbGRTdGF0ZSIsInNlbGVjdGlvbkNoYW5nZWQiLCJlcSIsImRvY0NoYW5nZWQiLCJ1cGRhdGVEZWJvdW5jZVRpbWVyIiwiY2xlYXJUaW1lb3V0Iiwid2luZG93IiwidXBkYXRlSGFuZGxlciIsIl9iIiwiX2MiLCJjb21wb3NpbmciLCJpc1NhbWUiLCJjcmVhdGVUb29sdGlwIiwicmFuZ2VzIiwiTWF0aCIsIm1pbiIsIm1hcCIsInJhbmdlIiwiJGZyb20iLCJwb3MiLCJtYXgiLCIkdG8iLCJjYWxsIiwic2V0UHJvcHMiLCJnZXRSZWZlcmVuY2VDbGllbnRSZWN0Iiwibm9kZSIsIm5vZGVET00iLCJub2RlVmlld1dyYXBwZXIiLCJkYXRhc2V0IiwicXVlcnlTZWxlY3RvciIsImZpcnN0Q2hpbGQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJzaG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhcHR1cmUiLCJvbiIsInJlbW92ZSIsInN0eWxlIiwidmlzaWJpbGl0eSIsImVkaXRvckVsZW1lbnQiLCJvcHRpb25zIiwiZWRpdG9ySXNBdHRhY2hlZCIsInBhcmVudEVsZW1lbnQiLCJ0YWJJbmRleCIsImR1cmF0aW9uIiwiY29udGVudCIsImludGVyYWN0aXZlIiwidHJpZ2dlciIsInBsYWNlbWVudCIsImhpZGVPbkNsaWNrIiwicG9wcGVyIiwiaGFzVmFsaWRTZWxlY3Rpb24iLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9mZiIsIkJ1YmJsZU1lbnVQbHVnaW4iLCJrZXkiLCJwbHVnaW5LZXkiLCJCdWJibGVNZW51IiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJ1bmRlZmluZWQiLCJhZGRQcm9zZU1pcnJvclBsdWdpbnMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: () => (/* binding */ BulletList),\n/* harmony export */   \"default\": () => (/* binding */ BulletList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\nconst ListItemName = \"listItem\";\nconst TextStyleName = \"textStyle\";\n/**\n * Matches a bullet list to a dash or asterisk.\n */ const inputRegex = /^\\s*([-+*])\\s$/;\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */ const BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"bulletList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ul\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"ul\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleBulletList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-8\": ()=>this.editor.commands.toggleBulletList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: ()=>{\n                    return this.editor.getAttributes(TextStyleName);\n                },\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFO0FBRXhFLE1BQU1HLGVBQWU7QUFDckIsTUFBTUMsZ0JBQWdCO0FBQ3RCOztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQjs7Ozs7Q0FLQyxHQUNELE1BQU1DLGFBQWFOLDhDQUFJQSxDQUFDTyxNQUFNLENBQUM7SUFDM0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGNBQWM7WUFDZEMsZ0JBQWdCLENBQUM7WUFDakJDLFdBQVc7WUFDWEMsZ0JBQWdCO1FBQ3BCO0lBQ0o7SUFDQUMsT0FBTztJQUNQQztRQUNJLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQ0MsT0FBTyxDQUFDTixZQUFZLENBQUMsQ0FBQyxDQUFDO0lBQzFDO0lBQ0FPO1FBQ0ksT0FBTztZQUNIO2dCQUFFQyxLQUFLO1lBQUs7U0FDZjtJQUNMO0lBQ0FDLFlBQVcsRUFBRVIsY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFNViw2REFBZUEsQ0FBQyxJQUFJLENBQUNlLE9BQU8sQ0FBQ0wsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2xGO0lBQ0FTO1FBQ0ksT0FBTztZQUNIQyxrQkFBa0IsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFO29CQUN4QyxJQUFJLElBQUksQ0FBQ1AsT0FBTyxDQUFDSCxjQUFjLEVBQUU7d0JBQzdCLE9BQU9VLFFBQVFDLFVBQVUsQ0FBQyxJQUFJLENBQUNoQixJQUFJLEVBQUUsSUFBSSxDQUFDUSxPQUFPLENBQUNOLFlBQVksRUFBRSxJQUFJLENBQUNNLE9BQU8sQ0FBQ0osU0FBUyxFQUFFYSxnQkFBZ0IsQ0FBQ3RCLGNBQWMsSUFBSSxDQUFDdUIsTUFBTSxDQUFDQyxhQUFhLENBQUN2QixnQkFBZ0J3QixHQUFHO29CQUN4SztvQkFDQSxPQUFPTixTQUFTRSxVQUFVLENBQUMsSUFBSSxDQUFDaEIsSUFBSSxFQUFFLElBQUksQ0FBQ1EsT0FBTyxDQUFDTixZQUFZLEVBQUUsSUFBSSxDQUFDTSxPQUFPLENBQUNKLFNBQVM7Z0JBQzNGO1FBQ0o7SUFDSjtJQUNBaUI7UUFDSSxPQUFPO1lBQ0gsZUFBZSxJQUFNLElBQUksQ0FBQ0gsTUFBTSxDQUFDSixRQUFRLENBQUNELGdCQUFnQjtRQUM5RDtJQUNKO0lBQ0FTO1FBQ0ksSUFBSUMsWUFBWTdCLCtEQUFpQkEsQ0FBQztZQUM5QjhCLE1BQU0zQjtZQUNONEIsTUFBTSxJQUFJLENBQUNBLElBQUk7UUFDbkI7UUFDQSxJQUFJLElBQUksQ0FBQ2pCLE9BQU8sQ0FBQ0osU0FBUyxJQUFJLElBQUksQ0FBQ0ksT0FBTyxDQUFDSCxjQUFjLEVBQUU7WUFDdkRrQixZQUFZN0IsK0RBQWlCQSxDQUFDO2dCQUMxQjhCLE1BQU0zQjtnQkFDTjRCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUNmckIsV0FBVyxJQUFJLENBQUNJLE9BQU8sQ0FBQ0osU0FBUztnQkFDakNDLGdCQUFnQixJQUFJLENBQUNHLE9BQU8sQ0FBQ0gsY0FBYztnQkFDM0NjLGVBQWU7b0JBQVEsT0FBTyxJQUFJLENBQUNELE1BQU0sQ0FBQ0MsYUFBYSxDQUFDdkI7Z0JBQWdCO2dCQUN4RXNCLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ3ZCO1FBQ0o7UUFDQSxPQUFPO1lBQ0hLO1NBQ0g7SUFDTDtBQUNKO0FBRXlELENBQ3pELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0L2Rpc3QvaW5kZXguanM/NDc0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuY29uc3QgTGlzdEl0ZW1OYW1lID0gJ2xpc3RJdGVtJztcbmNvbnN0IFRleHRTdHlsZU5hbWUgPSAndGV4dFN0eWxlJztcbi8qKlxuICogTWF0Y2hlcyBhIGJ1bGxldCBsaXN0IHRvIGEgZGFzaCBvciBhc3Rlcmlzay5cbiAqL1xuY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKihbLSsqXSlcXHMkLztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYnVsbGV0IGxpc3RzLlxuICogVGhpcyByZXF1aXJlcyB0aGUgTGlzdEl0ZW0gZXh0ZW5zaW9uXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvYnVsbGV0LWxpc3RcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW0uXG4gKi9cbmNvbnN0IEJ1bGxldExpc3QgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2J1bGxldExpc3QnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ3JvdXA6ICdibG9jayBsaXN0JyxcbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdGFnOiAndWwnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWyd1bCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkpLnJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC04JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiAoKSA9PiB7IHJldHVybiB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZU5hbWUpOyB9LFxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaW5wdXRSdWxlLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQnVsbGV0TGlzdCwgQnVsbGV0TGlzdCBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwid3JhcHBpbmdJbnB1dFJ1bGUiLCJMaXN0SXRlbU5hbWUiLCJUZXh0U3R5bGVOYW1lIiwiaW5wdXRSZWdleCIsIkJ1bGxldExpc3QiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIml0ZW1UeXBlTmFtZSIsIkhUTUxBdHRyaWJ1dGVzIiwia2VlcE1hcmtzIiwia2VlcEF0dHJpYnV0ZXMiLCJncm91cCIsImNvbnRlbnQiLCJvcHRpb25zIiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsImFkZENvbW1hbmRzIiwidG9nZ2xlQnVsbGV0TGlzdCIsImNvbW1hbmRzIiwiY2hhaW4iLCJ0b2dnbGVMaXN0IiwidXBkYXRlQXR0cmlidXRlcyIsImVkaXRvciIsImdldEF0dHJpYnV0ZXMiLCJydW4iLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImFkZElucHV0UnVsZXMiLCJpbnB1dFJ1bGUiLCJmaW5kIiwidHlwZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: () => (/* binding */ CodeBlock),\n/* harmony export */   backtickInputRegex: () => (/* binding */ backtickInputRegex),\n/* harmony export */   \"default\": () => (/* binding */ CodeBlock),\n/* harmony export */   tildeInputRegex: () => (/* binding */ tildeInputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n/**\n * Matches a code block with backticks.\n */ const backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\n/**\n * Matches a code block with tildes.\n */ const tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */ const CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"codeBlock\",\n    addOptions () {\n        return {\n            languageClassPrefix: \"language-\",\n            exitOnTripleEnter: true,\n            exitOnArrowDown: true,\n            defaultLanguage: null,\n            HTMLAttributes: {}\n        };\n    },\n    content: \"text*\",\n    marks: \"\",\n    group: \"block\",\n    code: true,\n    defining: true,\n    addAttributes () {\n        return {\n            language: {\n                default: this.options.defaultLanguage,\n                parseHTML: (element)=>{\n                    var _a;\n                    const { languageClassPrefix } = this.options;\n                    const classNames = [\n                        ...((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || []\n                    ];\n                    const languages = classNames.filter((className)=>className.startsWith(languageClassPrefix)).map((className)=>className.replace(languageClassPrefix, \"\"));\n                    const language = languages[0];\n                    if (!language) {\n                        return null;\n                    }\n                    return language;\n                },\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"pre\",\n                preserveWhitespace: \"full\"\n            }\n        ];\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        return [\n            \"pre\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            [\n                \"code\",\n                {\n                    class: node.attrs.language ? this.options.languageClassPrefix + node.attrs.language : null\n                },\n                0\n            ]\n        ];\n    },\n    addCommands () {\n        return {\n            setCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleCodeBlock: (attributes)=>({ commands })=>{\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-c\": ()=>this.editor.commands.toggleCodeBlock(),\n            // remove code block when at start of document or code block is empty\n            Backspace: ()=>{\n                const { empty, $anchor } = this.editor.state.selection;\n                const isAtStart = $anchor.pos === 1;\n                if (!empty || $anchor.parent.type.name !== this.name) {\n                    return false;\n                }\n                if (isAtStart || !$anchor.parent.textContent.length) {\n                    return this.editor.commands.clearNodes();\n                }\n                return false;\n            },\n            // exit node on triple enter\n            Enter: ({ editor })=>{\n                if (!this.options.exitOnTripleEnter) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith(\"\\n\\n\");\n                if (!isAtEnd || !endsWithDoubleNewline) {\n                    return false;\n                }\n                return editor.chain().command(({ tr })=>{\n                    tr.delete($from.pos - 2, $from.pos);\n                    return true;\n                }).exitCode().run();\n            },\n            // exit node on arrow down\n            ArrowDown: ({ editor })=>{\n                if (!this.options.exitOnArrowDown) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection, doc } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                if (!isAtEnd) {\n                    return false;\n                }\n                const after = $from.after();\n                if (after === undefined) {\n                    return false;\n                }\n                const nodeAfter = doc.nodeAt(after);\n                if (nodeAfter) {\n                    return editor.commands.command(({ tr })=>{\n                        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(doc.resolve(after)));\n                        return true;\n                    });\n                }\n                return editor.commands.exitCode();\n            }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: backtickInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: tildeInputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        language: match[1]\n                    })\n            })\n        ];\n    },\n    addProseMirrorPlugins () {\n        return [\n            // this plugin creates a code block for pasted content from VS Code\n            // we can also detect the copied code language\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"codeBlockVSCodeHandler\"),\n                props: {\n                    handlePaste: (view, event)=>{\n                        if (!event.clipboardData) {\n                            return false;\n                        }\n                        // don’t create a new code block within code blocks\n                        if (this.editor.isActive(this.type.name)) {\n                            return false;\n                        }\n                        const text = event.clipboardData.getData(\"text/plain\");\n                        const vscode = event.clipboardData.getData(\"vscode-editor-data\");\n                        const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n                        if (!text || !language) {\n                            return false;\n                        }\n                        const { tr, schema } = view.state;\n                        // prepare a text node\n                        // strip carriage return chars from text pasted as code\n                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n                        const textNode = schema.text(text.replace(/\\r\\n?/g, \"\\n\"));\n                        // create a code block with the text node\n                        // replace selection with the code block\n                        tr.replaceSelectionWith(this.type.create({\n                            language\n                        }, textNode));\n                        if (tr.selection.$from.parent.type !== this.type) {\n                            // put cursor inside the newly created code block\n                            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n                        }\n                        // store meta information\n                        // this is useful for other plugins that depends on the paste event\n                        // like the paste rule plugin\n                        tr.setMeta(\"paste\", true);\n                        view.dispatch(tr);\n                        return true;\n                    }\n                }\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RTtBQUNFO0FBRS9FOztDQUVDLEdBQ0QsTUFBTU8scUJBQXFCO0FBQzNCOztDQUVDLEdBQ0QsTUFBTUMsa0JBQWtCO0FBQ3hCOzs7Q0FHQyxHQUNELE1BQU1DLFlBQVlULDhDQUFJQSxDQUFDVSxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLHFCQUFxQjtZQUNyQkMsbUJBQW1CO1lBQ25CQyxpQkFBaUI7WUFDakJDLGlCQUFpQjtZQUNqQkMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxTQUFTO0lBQ1RDLE9BQU87SUFDUEMsT0FBTztJQUNQQyxNQUFNO0lBQ05DLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0hDLFVBQVU7Z0JBQ05DLFNBQVMsSUFBSSxDQUFDQyxPQUFPLENBQUNWLGVBQWU7Z0JBQ3JDVyxXQUFXQyxDQUFBQTtvQkFDUCxJQUFJQztvQkFDSixNQUFNLEVBQUVoQixtQkFBbUIsRUFBRSxHQUFHLElBQUksQ0FBQ2EsT0FBTztvQkFDNUMsTUFBTUksYUFBYTsyQkFBSyxDQUFDLENBQUNELEtBQUtELFFBQVFHLGlCQUFpQixNQUFNLFFBQVFGLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR0csU0FBUyxLQUFLLEVBQUU7cUJBQUU7b0JBQ3BILE1BQU1DLFlBQVlILFdBQ2JJLE1BQU0sQ0FBQ0MsQ0FBQUEsWUFBYUEsVUFBVUMsVUFBVSxDQUFDdkIsc0JBQ3pDd0IsR0FBRyxDQUFDRixDQUFBQSxZQUFhQSxVQUFVRyxPQUFPLENBQUN6QixxQkFBcUI7b0JBQzdELE1BQU1XLFdBQVdTLFNBQVMsQ0FBQyxFQUFFO29CQUM3QixJQUFJLENBQUNULFVBQVU7d0JBQ1gsT0FBTztvQkFDWDtvQkFDQSxPQUFPQTtnQkFDWDtnQkFDQWUsVUFBVTtZQUNkO1FB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SyxDQUFDTixNQUFNLENBQUNDLElBQUksS0FBSyxJQUFJLENBQUNBLElBQUksRUFBRTs0QkFDOUMsaURBQWlEOzRCQUNqRGEsR0FBR1UsWUFBWSxDQUFDaEYsMkRBQWFBLENBQUNpRixJQUFJLENBQUNYLEdBQUdLLEdBQUcsQ0FBQ08sT0FBTyxDQUFDdUIsS0FBS0MsR0FBRyxDQUFDLEdBQUdwQyxHQUFHakIsU0FBUyxDQUFDc0QsSUFBSSxHQUFHO3dCQUN0Rjt3QkFDQSx5QkFBeUI7d0JBQ3pCLG1FQUFtRTt3QkFDbkUsNkJBQTZCO3dCQUM3QnJDLEdBQUdzQyxPQUFPLENBQUMsU0FBUzt3QkFDcEJqQixLQUFLa0IsUUFBUSxDQUFDdkM7d0JBQ2QsT0FBTztvQkFDWDtnQkFDSjtZQUNKO1NBQ0g7SUFDTDtBQUNKO0FBRWdGLENBQ2hGLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2svZGlzdC9pbmRleC5qcz9jYmE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhIGNvZGUgYmxvY2sgd2l0aCBiYWNrdGlja3MuXG4gKi9cbmNvbnN0IGJhY2t0aWNrSW5wdXRSZWdleCA9IC9eYGBgKFthLXpdKyk/W1xcc1xcbl0kLztcbi8qKlxuICogTWF0Y2hlcyBhIGNvZGUgYmxvY2sgd2l0aCB0aWxkZXMuXG4gKi9cbmNvbnN0IHRpbGRlSW5wdXRSZWdleCA9IC9efn5+KFthLXpdKyk/W1xcc1xcbl0kLztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgY29kZSBibG9ja3MuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvY29kZS1ibG9ja1xuICovXG5jb25zdCBDb2RlQmxvY2sgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NvZGVCbG9jaycsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhbmd1YWdlQ2xhc3NQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgICAgICAgICAgZXhpdE9uVHJpcGxlRW50ZXI6IHRydWUsXG4gICAgICAgICAgICBleGl0T25BcnJvd0Rvd246IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0TGFuZ3VhZ2U6IG51bGwsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb250ZW50OiAndGV4dConLFxuICAgIG1hcmtzOiAnJyxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBjb2RlOiB0cnVlLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0TGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlQ2xhc3NQcmVmaXggfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsuLi4oKChfYSA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QpIHx8IFtdKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlcyA9IGNsYXNzTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5zdGFydHNXaXRoKGxhbmd1YWdlQ2xhc3NQcmVmaXgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnJlcGxhY2UobGFuZ3VhZ2VDbGFzc1ByZWZpeCwgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAncHJlJyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ3ByZScsXG4gICAgICAgICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IG5vZGUuYXR0cnMubGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmxhbmd1YWdlQ2xhc3NQcmVmaXggKyBub2RlLmF0dHJzLmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0Q29kZUJsb2NrOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUNvZGVCbG9jazogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCAncGFyYWdyYXBoJywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLUFsdC1jJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZUJsb2NrKCksXG4gICAgICAgICAgICAvLyByZW1vdmUgY29kZSBibG9jayB3aGVuIGF0IHN0YXJ0IG9mIGRvY3VtZW50IG9yIGNvZGUgYmxvY2sgaXMgZW1wdHlcbiAgICAgICAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAkYW5jaG9yLnBvcyA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5IHx8ICRhbmNob3IucGFyZW50LnR5cGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQXRTdGFydCB8fCAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBleGl0IG5vZGUgb24gdHJpcGxlIGVudGVyXG4gICAgICAgICAgICBFbnRlcjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25UcmlwbGVFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZHNXaXRoRG91YmxlTmV3bGluZSA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5lbmRzV2l0aCgnXFxuXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F0RW5kIHx8ICFlbmRzV2l0aERvdWJsZU5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIC5jaGFpbigpXG4gICAgICAgICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcyAtIDIsICRmcm9tLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5leGl0Q29kZSgpXG4gICAgICAgICAgICAgICAgICAgIC5ydW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBleGl0IG5vZGUgb24gYXJyb3cgZG93blxuICAgICAgICAgICAgQXJyb3dEb3duOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPbkFycm93RG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F0RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXIgPSAkZnJvbS5hZnRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZG9jLm5vZGVBdChhZnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKGRvYy5yZXNvbHZlKGFmdGVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGJhY2t0aWNrSW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB0aWxkZUlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gdGhpcyBwbHVnaW4gY3JlYXRlcyBhIGNvZGUgYmxvY2sgZm9yIHBhc3RlZCBjb250ZW50IGZyb20gVlMgQ29kZVxuICAgICAgICAgICAgLy8gd2UgY2FuIGFsc28gZGV0ZWN0IHRoZSBjb3BpZWQgY29kZSBsYW5ndWFnZVxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjb2RlQmxvY2tWU0NvZGVIYW5kbGVyJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9u4oCZdCBjcmVhdGUgYSBuZXcgY29kZSBibG9jayB3aXRoaW4gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvci5pc0FjdGl2ZSh0aGlzLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2c2NvZGUgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3ZzY29kZS1lZGl0b3ItZGF0YScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdnNjb2RlRGF0YSA9IHZzY29kZSA/IEpTT04ucGFyc2UodnNjb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdnNjb2RlRGF0YSA9PT0gbnVsbCB8fCB2c2NvZGVEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2c2NvZGVEYXRhLm1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHQgfHwgIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0ciwgc2NoZW1hIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgY2FycmlhZ2UgcmV0dXJuIGNoYXJzIGZyb20gdGV4dCBwYXN0ZWQgYXMgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itdmlldy9jb21taXQvYTUwYTZiY2NlYjRjZTUyYWM4ZmNjNjE2MjQ4OGQ4ODc1NjEzYWFjZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBzY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNvZGUgYmxvY2sgd2l0aCB0aGUgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHNlbGVjdGlvbiB3aXRoIHRoZSBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aCh0aGlzLnR5cGUuY3JlYXRlKHsgbGFuZ3VhZ2UgfSwgdGV4dE5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ci5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCBjdXJzb3IgaW5zaWRlIHRoZSBuZXdseSBjcmVhdGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIHRyLnNlbGVjdGlvbi5mcm9tIC0gMikpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBtZXRhIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3Igb3RoZXIgcGx1Z2lucyB0aGF0IGRlcGVuZHMgb24gdGhlIHBhc3RlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZSBwYXN0ZSBydWxlIHBsdWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgncGFzdGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQ29kZUJsb2NrLCBiYWNrdGlja0lucHV0UmVnZXgsIENvZGVCbG9jayBhcyBkZWZhdWx0LCB0aWxkZUlucHV0UmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJ0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlIiwiU2VsZWN0aW9uIiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwiVGV4dFNlbGVjdGlvbiIsImJhY2t0aWNrSW5wdXRSZWdleCIsInRpbGRlSW5wdXRSZWdleCIsIkNvZGVCbG9jayIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwibGFuZ3VhZ2VDbGFzc1ByZWZpeCIsImV4aXRPblRyaXBsZUVudGVyIiwiZXhpdE9uQXJyb3dEb3duIiwiZGVmYXVsdExhbmd1YWdlIiwiSFRNTEF0dHJpYnV0ZXMiLCJjb250ZW50IiwibWFya3MiLCJncm91cCIsImNvZGUiLCJkZWZpbmluZyIsImFkZEF0dHJpYnV0ZXMiLCJsYW5ndWFnZSIsImRlZmF1bHQiLCJvcHRpb25zIiwicGFyc2VIVE1MIiwiZWxlbWVudCIsIl9hIiwiY2xhc3NOYW1lcyIsImZpcnN0RWxlbWVudENoaWxkIiwiY2xhc3NMaXN0IiwibGFuZ3VhZ2VzIiwiZmlsdGVyIiwiY2xhc3NOYW1lIiwic3RhcnRzV2l0aCIsIm1hcCIsInJlcGxhY2UiLCJyZW5kZXJlZCIsInRhZyIsInByZXNlcnZlV2hpdGVzcGFjZSIsInJlbmRlckhUTUwiLCJub2RlIiwiY2xhc3MiLCJhdHRycyIsImFkZENvbW1hbmRzIiwic2V0Q29kZUJsb2NrIiwiYXR0cmlidXRlcyIsImNvbW1hbmRzIiwic2V0Tm9kZSIsInRvZ2dsZUNvZGVCbG9jayIsInRvZ2dsZU5vZGUiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsIkJhY2tzcGFjZSIsImVtcHR5IiwiJGFuY2hvciIsInN0YXRlIiwic2VsZWN0aW9uIiwiaXNBdFN0YXJ0IiwicG9zIiwicGFyZW50IiwidHlwZSIsInRleHRDb250ZW50IiwibGVuZ3RoIiwiY2xlYXJOb2RlcyIsIkVudGVyIiwiJGZyb20iLCJpc0F0RW5kIiwicGFyZW50T2Zmc2V0Iiwibm9kZVNpemUiLCJlbmRzV2l0aERvdWJsZU5ld2xpbmUiLCJlbmRzV2l0aCIsImNoYWluIiwiY29tbWFuZCIsInRyIiwiZGVsZXRlIiwiZXhpdENvZGUiLCJydW4iLCJBcnJvd0Rvd24iLCJkb2MiLCJhZnRlciIsInVuZGVmaW5lZCIsIm5vZGVBZnRlciIsIm5vZGVBdCIsInNldFNlbGVjdGlvbiIsIm5lYXIiLCJyZXNvbHZlIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJnZXRBdHRyaWJ1dGVzIiwibWF0Y2giLCJhZGRQcm9zZU1pcnJvclBsdWdpbnMiLCJrZXkiLCJwcm9wcyIsImhhbmRsZVBhc3RlIiwidmlldyIsImV2ZW50IiwiY2xpcGJvYXJkRGF0YSIsImlzQWN0aXZlIiwidGV4dCIsImdldERhdGEiLCJ2c2NvZGUiLCJ2c2NvZGVEYXRhIiwiSlNPTiIsInBhcnNlIiwibW9kZSIsInNjaGVtYSIsInRleHROb2RlIiwicmVwbGFjZVNlbGVjdGlvbldpdGgiLCJNYXRoIiwibWF4IiwiZnJvbSIsInNldE1ldGEiLCJkaXNwYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: () => (/* binding */ Code),\n/* harmony export */   \"default\": () => (/* binding */ Code),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */ const inputRegex = /(^|[^`])`([^`]+)`(?!`)/;\n/**\n * Matches inline code while pasting.\n */ const pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */ const Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"code\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    excludes: \"_\",\n    code: true,\n    exitable: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"code\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"code\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setCode: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleCode: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetCode: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-e\": ()=>this.editor.commands.toggleCode()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29kZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1GO0FBRW5GOzs7Ozs7OztDQVFDLEdBQ0QsTUFBTUksYUFBYTtBQUNuQjs7Q0FFQyxHQUNELE1BQU1DLGFBQWE7QUFDbkI7OztDQUdDLEdBQ0QsTUFBTUMsT0FBT04sOENBQUlBLENBQUNPLE1BQU0sQ0FBQztJQUNyQkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxVQUFVO0lBQ1ZDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSDtnQkFBRUMsS0FBSztZQUFPO1NBQ2pCO0lBQ0w7SUFDQUMsWUFBVyxFQUFFTixjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQVFULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ1AsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ3BGO0lBQ0FRO1FBQ0ksT0FBTztZQUNIQyxTQUFTLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3hCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNiLElBQUk7Z0JBQ3JDO1lBQ0FjLFlBQVksSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDM0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ2YsSUFBSTtnQkFDeEM7WUFDQWdCLFdBQVcsSUFBTSxDQUFDLEVBQUVKLFFBQVEsRUFBRTtvQkFDMUIsT0FBT0EsU0FBU0ssU0FBUyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7Z0JBQ3ZDO1FBQ0o7SUFDSjtJQUNBa0I7UUFDSSxPQUFPO1lBQ0gsU0FBUyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDUCxRQUFRLENBQUNFLFVBQVU7UUFDbEQ7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSDFCLDJEQUFhQSxDQUFDO2dCQUNWMkIsTUFBTXpCO2dCQUNOMEIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0lBQ0FDO1FBQ0ksT0FBTztZQUNINUIsMkRBQWFBLENBQUM7Z0JBQ1YwQixNQUFNeEI7Z0JBQ055QixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUV5RCxDQUN6RCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlL2Rpc3QvaW5kZXguanM/MzY2MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdG8gbWF0Y2ggaW5saW5lIGNvZGUgYmxvY2tzIGVuY2xvc2VkIGluIGJhY2t0aWNrcy5cbiAqICBJdCBtYXRjaGVzOlxuICogICAgIC0gQW4gb3BlbmluZyBiYWNrdGljaywgZm9sbG93ZWQgYnlcbiAqICAgICAtIEFueSB0ZXh0IHRoYXQgZG9lc24ndCBpbmNsdWRlIGEgYmFja3RpY2sgKGNhcHR1cmVkIGZvciBtYXJraW5nKSwgZm9sbG93ZWQgYnlcbiAqICAgICAtIEEgY2xvc2luZyBiYWNrdGljay5cbiAqICBUaGlzIGVuc3VyZXMgdGhhdCBhbnkgdGV4dCBiZXR3ZWVuIGJhY2t0aWNrcyBpcyBmb3JtYXR0ZWQgYXMgY29kZSxcbiAqICByZWdhcmRsZXNzIG9mIHRoZSBzdXJyb3VuZGluZyBjaGFyYWN0ZXJzIChleGNlcHRpb24gYmVpbmcgYW5vdGhlciBiYWNrdGljaykuXG4gKi9cbmNvbnN0IGlucHV0UmVnZXggPSAvKF58W15gXSlgKFteYF0rKWAoPyFgKS87XG4vKipcbiAqIE1hdGNoZXMgaW5saW5lIGNvZGUgd2hpbGUgcGFzdGluZy5cbiAqL1xuY29uc3QgcGFzdGVSZWdleCA9IC8oXnxbXmBdKWAoW15gXSspYCg/IWApL2c7XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gbWFyayB0ZXh0IGFzIGlubGluZSBjb2RlLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL21hcmtzL2NvZGVcbiAqL1xuY29uc3QgQ29kZSA9IE1hcmsuY3JlYXRlKHtcbiAgICBuYW1lOiAnY29kZScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGV4Y2x1ZGVzOiAnXycsXG4gICAgY29kZTogdHJ1ZSxcbiAgICBleGl0YWJsZTogdHJ1ZSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHRhZzogJ2NvZGUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydjb2RlJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0Q29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlQ29kZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1lJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IENvZGUsIENvZGUgYXMgZGVmYXVsdCwgaW5wdXRSZWdleCwgcGFzdGVSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTWFyayIsIm1lcmdlQXR0cmlidXRlcyIsIm1hcmtJbnB1dFJ1bGUiLCJtYXJrUGFzdGVSdWxlIiwiaW5wdXRSZWdleCIsInBhc3RlUmVnZXgiLCJDb2RlIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImV4Y2x1ZGVzIiwiY29kZSIsImV4aXRhYmxlIiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJhZGRDb21tYW5kcyIsInNldENvZGUiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVDb2RlIiwidG9nZ2xlTWFyayIsInVuc2V0Q29kZSIsInVuc2V0TWFyayIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiYWRkSW5wdXRSdWxlcyIsImZpbmQiLCJ0eXBlIiwiYWRkUGFzdGVSdWxlcyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollaborationCursor: () => (/* binding */ CollaborationCursor),\n/* harmony export */   \"default\": () => (/* binding */ CollaborationCursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/cursor-plugin.js\");\n\n\nconst awarenessStatesToArray = (states)=>{\n    return Array.from(states.entries()).map(([key, value])=>{\n        return {\n            clientId: key,\n            ...value.user\n        };\n    });\n};\nconst defaultOnUpdate = ()=>null;\n/**\n * This extension allows you to add collaboration cursors to your editor.\n * @see https://tiptap.dev/api/extensions/collaboration-cursor\n */ const CollaborationCursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Extension.create({\n    name: \"collaborationCursor\",\n    priority: 999,\n    addOptions () {\n        return {\n            provider: null,\n            user: {\n                name: null,\n                color: null\n            },\n            render: (user)=>{\n                const cursor = document.createElement(\"span\");\n                cursor.classList.add(\"collaboration-cursor__caret\");\n                cursor.setAttribute(\"style\", `border-color: ${user.color}`);\n                const label = document.createElement(\"div\");\n                label.classList.add(\"collaboration-cursor__label\");\n                label.setAttribute(\"style\", `background-color: ${user.color}`);\n                label.insertBefore(document.createTextNode(user.name), null);\n                cursor.insertBefore(label, null);\n                return cursor;\n            },\n            selectionRender: y_prosemirror__WEBPACK_IMPORTED_MODULE_1__.defaultSelectionBuilder,\n            onUpdate: defaultOnUpdate\n        };\n    },\n    onCreate () {\n        if (this.options.onUpdate !== defaultOnUpdate) {\n            console.warn('[tiptap warn]: DEPRECATED: The \"onUpdate\" option is deprecated. Please use `editor.storage.collaborationCursor.users` instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor');\n        }\n        if (!this.options.provider) {\n            throw new Error('The \"provider\" option is required for the CollaborationCursor extension');\n        }\n    },\n    addStorage () {\n        return {\n            users: []\n        };\n    },\n    addCommands () {\n        return {\n            updateUser: (attributes)=>()=>{\n                    this.options.user = attributes;\n                    this.options.provider.awareness.setLocalStateField(\"user\", this.options.user);\n                    return true;\n                },\n            user: (attributes)=>({ editor })=>{\n                    console.warn('[tiptap warn]: DEPRECATED: The \"user\" command is deprecated. Please use \"updateUser\" instead. Read more: https://tiptap.dev/api/extensions/collaboration-cursor');\n                    return editor.commands.updateUser(attributes);\n                }\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_1__.yCursorPlugin)((()=>{\n                this.options.provider.awareness.setLocalStateField(\"user\", this.options.user);\n                this.storage.users = awarenessStatesToArray(this.options.provider.awareness.states);\n                this.options.provider.awareness.on(\"update\", ()=>{\n                    this.storage.users = awarenessStatesToArray(this.options.provider.awareness.states);\n                });\n                return this.options.provider.awareness;\n            })(), // @ts-ignore\n            {\n                cursorBuilder: this.options.render,\n                selectionBuilder: this.options.selectionRender\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbi1jdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXlDO0FBQzhCO0FBRXZFLE1BQU1HLHlCQUF5QixDQUFDQztJQUM1QixPQUFPQyxNQUFNQyxJQUFJLENBQUNGLE9BQU9HLE9BQU8sSUFBSUMsR0FBRyxDQUFDLENBQUMsQ0FBQ0MsS0FBS0MsTUFBTTtRQUNqRCxPQUFPO1lBQ0hDLFVBQVVGO1lBQ1YsR0FBR0MsTUFBTUUsSUFBSTtRQUNqQjtJQUNKO0FBQ0o7QUFDQSxNQUFNQyxrQkFBa0IsSUFBTTtBQUM5Qjs7O0NBR0MsR0FDRCxNQUFNQyxzQkFBc0JkLG1EQUFTQSxDQUFDZSxNQUFNLENBQUM7SUFDekNDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSEMsVUFBVTtZQUNWUCxNQUFNO2dCQUNGSSxNQUFNO2dCQUNOSSxPQUFPO1lBQ1g7WUFDQUMsUUFBUVQsQ0FBQUE7Z0JBQ0osTUFBTVUsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO2dCQUN0Q0YsT0FBT0csU0FBUyxDQUFDQyxHQUFHLENBQUM7Z0JBQ3JCSixPQUFPSyxZQUFZLENBQUMsU0FBUyxDQUFDLGNBQWMsRUFBRWYsS0FBS1EsS0FBSyxDQUFDLENBQUM7Z0JBQzFELE1BQU1RLFFBQVFMLFNBQVNDLGFBQWEsQ0FBQztnQkFDckNJLE1BQU1ILFNBQVMsQ0FBQ0MsR0FBRyxDQUFDO2dCQUNwQkUsTUFBTUQsWUFBWSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsRUFBRWYsS0FBS1EsS0FBSyxDQUFDLENBQUM7Z0JBQzdEUSxNQUFNQyxZQUFZLENBQUNOLFNBQVNPLGNBQWMsQ0FBQ2xCLEtBQUtJLElBQUksR0FBRztnQkFDdkRNLE9BQU9PLFlBQVksQ0FBQ0QsT0FBTztnQkFDM0IsT0FBT047WUFDWDtZQUNBUyxpQkFBaUI5QixrRUFBdUJBO1lBQ3hDK0IsVUFBVW5CO1FBQ2Q7SUFDSjtJQUNBb0I7UUFDSSxJQUFJLElBQUksQ0FBQ0MsT0FBTyxDQUFDRixRQUFRLEtBQUtuQixpQkFBaUI7WUFDM0NzQixRQUFRQyxJQUFJLENBQUM7UUFDakI7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDRixPQUFPLENBQUNmLFFBQVEsRUFBRTtZQUN4QixNQUFNLElBQUlrQixNQUFNO1FBQ3BCO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hDLE9BQU8sRUFBRTtRQUNiO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hDLFlBQVlDLENBQUFBLGFBQWM7b0JBQ3RCLElBQUksQ0FBQ1IsT0FBTyxDQUFDdEIsSUFBSSxHQUFHOEI7b0JBQ3BCLElBQUksQ0FBQ1IsT0FBTyxDQUFDZixRQUFRLENBQUN3QixTQUFTLENBQUNDLGtCQUFrQixDQUFDLFFBQVEsSUFBSSxDQUFDVixPQUFPLENBQUN0QixJQUFJO29CQUM1RSxPQUFPO2dCQUNYO1lBQ0FBLE1BQU04QixDQUFBQSxhQUFjLENBQUMsRUFBRUcsTUFBTSxFQUFFO29CQUMzQlYsUUFBUUMsSUFBSSxDQUFDO29CQUNiLE9BQU9TLE9BQU9DLFFBQVEsQ0FBQ0wsVUFBVSxDQUFDQztnQkFDdEM7UUFDSjtJQUNKO0lBQ0FLO1FBQ0ksT0FBTztZQUNIN0MsNERBQWFBLENBQUMsQ0FBQztnQkFDWCxJQUFJLENBQUNnQyxPQUFPLENBQUNmLFFBQVEsQ0FBQ3dCLFNBQVMsQ0FBQ0Msa0JBQWtCLENBQUMsUUFBUSxJQUFJLENBQUNWLE9BQU8sQ0FBQ3RCLElBQUk7Z0JBQzVFLElBQUksQ0FBQ29DLE9BQU8sQ0FBQ1QsS0FBSyxHQUFHcEMsdUJBQXVCLElBQUksQ0FBQytCLE9BQU8sQ0FBQ2YsUUFBUSxDQUFDd0IsU0FBUyxDQUFDdkMsTUFBTTtnQkFDbEYsSUFBSSxDQUFDOEIsT0FBTyxDQUFDZixRQUFRLENBQUN3QixTQUFTLENBQUNNLEVBQUUsQ0FBQyxVQUFVO29CQUN6QyxJQUFJLENBQUNELE9BQU8sQ0FBQ1QsS0FBSyxHQUFHcEMsdUJBQXVCLElBQUksQ0FBQytCLE9BQU8sQ0FBQ2YsUUFBUSxDQUFDd0IsU0FBUyxDQUFDdkMsTUFBTTtnQkFDdEY7Z0JBQ0EsT0FBTyxJQUFJLENBQUM4QixPQUFPLENBQUNmLFFBQVEsQ0FBQ3dCLFNBQVM7WUFDMUMsTUFDQSxhQUFhO1lBQ2I7Z0JBQ0lPLGVBQWUsSUFBSSxDQUFDaEIsT0FBTyxDQUFDYixNQUFNO2dCQUNsQzhCLGtCQUFrQixJQUFJLENBQUNqQixPQUFPLENBQUNILGVBQWU7WUFDbEQ7U0FDSDtJQUNMO0FBQ0o7QUFFK0QsQ0FDL0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbi1jdXJzb3IvZGlzdC9pbmRleC5qcz8yZWM0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBkZWZhdWx0U2VsZWN0aW9uQnVpbGRlciwgeUN1cnNvclBsdWdpbiB9IGZyb20gJ3ktcHJvc2VtaXJyb3InO1xuXG5jb25zdCBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5ID0gKHN0YXRlcykgPT4ge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHN0YXRlcy5lbnRyaWVzKCkpLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjbGllbnRJZDoga2V5LFxuICAgICAgICAgICAgLi4udmFsdWUudXNlcixcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5jb25zdCBkZWZhdWx0T25VcGRhdGUgPSAoKSA9PiBudWxsO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGFkZCBjb2xsYWJvcmF0aW9uIGN1cnNvcnMgdG8geW91ciBlZGl0b3IuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9jb2xsYWJvcmF0aW9uLWN1cnNvclxuICovXG5jb25zdCBDb2xsYWJvcmF0aW9uQ3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NvbGxhYm9yYXRpb25DdXJzb3InLFxuICAgIHByaW9yaXR5OiA5OTksXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiBudWxsLFxuICAgICAgICAgICAgdXNlcjoge1xuICAgICAgICAgICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgY29sb3I6IG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVuZGVyOiB1c2VyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNsYXNzTGlzdC5hZGQoJ2NvbGxhYm9yYXRpb24tY3Vyc29yX19jYXJldCcpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgYGJvcmRlci1jb2xvcjogJHt1c2VyLmNvbG9yfWApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgbGFiZWwuY2xhc3NMaXN0LmFkZCgnY29sbGFib3JhdGlvbi1jdXJzb3JfX2xhYmVsJyk7XG4gICAgICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCdzdHlsZScsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke3VzZXIuY29sb3J9YCk7XG4gICAgICAgICAgICAgICAgbGFiZWwuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHVzZXIubmFtZSksIG51bGwpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5pbnNlcnRCZWZvcmUobGFiZWwsIG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VsZWN0aW9uUmVuZGVyOiBkZWZhdWx0U2VsZWN0aW9uQnVpbGRlcixcbiAgICAgICAgICAgIG9uVXBkYXRlOiBkZWZhdWx0T25VcGRhdGUsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBvbkNyZWF0ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblVwZGF0ZSAhPT0gZGVmYXVsdE9uVXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IERFUFJFQ0FURUQ6IFRoZSBcIm9uVXBkYXRlXCIgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb25DdXJzb3IudXNlcnNgIGluc3RlYWQuIFJlYWQgbW9yZTogaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2NvbGxhYm9yYXRpb24tY3Vyc29yJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIFwicHJvdmlkZXJcIiBvcHRpb24gaXMgcmVxdWlyZWQgZm9yIHRoZSBDb2xsYWJvcmF0aW9uQ3Vyc29yIGV4dGVuc2lvbicpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRTdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdXNlcnM6IFtdLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1cGRhdGVVc2VyOiBhdHRyaWJ1dGVzID0+ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudXNlciA9IGF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByb3ZpZGVyLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ3VzZXInLCB0aGlzLm9wdGlvbnMudXNlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXNlcjogYXR0cmlidXRlcyA9PiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogREVQUkVDQVRFRDogVGhlIFwidXNlclwiIGNvbW1hbmQgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcInVwZGF0ZVVzZXJcIiBpbnN0ZWFkLiBSZWFkIG1vcmU6IGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9jb2xsYWJvcmF0aW9uLWN1cnNvcicpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlZGl0b3IuY29tbWFuZHMudXBkYXRlVXNlcihhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB5Q3Vyc29yUGx1Z2luKCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByb3ZpZGVyLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ3VzZXInLCB0aGlzLm9wdGlvbnMudXNlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLnVzZXJzID0gYXdhcmVuZXNzU3RhdGVzVG9BcnJheSh0aGlzLm9wdGlvbnMucHJvdmlkZXIuYXdhcmVuZXNzLnN0YXRlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnByb3ZpZGVyLmF3YXJlbmVzcy5vbigndXBkYXRlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3JhZ2UudXNlcnMgPSBhd2FyZW5lc3NTdGF0ZXNUb0FycmF5KHRoaXMub3B0aW9ucy5wcm92aWRlci5hd2FyZW5lc3Muc3RhdGVzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnByb3ZpZGVyLmF3YXJlbmVzcztcbiAgICAgICAgICAgIH0pKCksIFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGN1cnNvckJ1aWxkZXI6IHRoaXMub3B0aW9ucy5yZW5kZXIsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uQnVpbGRlcjogdGhpcy5vcHRpb25zLnNlbGVjdGlvblJlbmRlcixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQ29sbGFib3JhdGlvbkN1cnNvciwgQ29sbGFib3JhdGlvbkN1cnNvciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJFeHRlbnNpb24iLCJkZWZhdWx0U2VsZWN0aW9uQnVpbGRlciIsInlDdXJzb3JQbHVnaW4iLCJhd2FyZW5lc3NTdGF0ZXNUb0FycmF5Iiwic3RhdGVzIiwiQXJyYXkiLCJmcm9tIiwiZW50cmllcyIsIm1hcCIsImtleSIsInZhbHVlIiwiY2xpZW50SWQiLCJ1c2VyIiwiZGVmYXVsdE9uVXBkYXRlIiwiQ29sbGFib3JhdGlvbkN1cnNvciIsImNyZWF0ZSIsIm5hbWUiLCJwcmlvcml0eSIsImFkZE9wdGlvbnMiLCJwcm92aWRlciIsImNvbG9yIiwicmVuZGVyIiwiY3Vyc29yIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NMaXN0IiwiYWRkIiwic2V0QXR0cmlidXRlIiwibGFiZWwiLCJpbnNlcnRCZWZvcmUiLCJjcmVhdGVUZXh0Tm9kZSIsInNlbGVjdGlvblJlbmRlciIsIm9uVXBkYXRlIiwib25DcmVhdGUiLCJvcHRpb25zIiwiY29uc29sZSIsIndhcm4iLCJFcnJvciIsImFkZFN0b3JhZ2UiLCJ1c2VycyIsImFkZENvbW1hbmRzIiwidXBkYXRlVXNlciIsImF0dHJpYnV0ZXMiLCJhd2FyZW5lc3MiLCJzZXRMb2NhbFN0YXRlRmllbGQiLCJlZGl0b3IiLCJjb21tYW5kcyIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsInN0b3JhZ2UiLCJvbiIsImN1cnNvckJ1aWxkZXIiLCJzZWxlY3Rpb25CdWlsZGVyIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-collaboration-cursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-collaboration/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-collaboration/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collaboration: () => (/* binding */ Collaboration),\n/* harmony export */   \"default\": () => (/* binding */ Collaboration),\n/* harmony export */   isChangeOrigin: () => (/* binding */ isChangeOrigin)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/keys.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/undo-plugin.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/plugins/sync-plugin.js\");\n/* harmony import */ var y_prosemirror__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! y-prosemirror */ \"(ssr)/./node_modules/y-prosemirror/src/lib.js\");\n\n\n\n/**\n * This extension allows you to collaborate with others in real-time.\n * @see https://tiptap.dev/api/extensions/collaboration\n */ const Collaboration = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"collaboration\",\n    priority: 1000,\n    addOptions () {\n        return {\n            document: null,\n            field: \"default\",\n            fragment: null\n        };\n    },\n    addStorage () {\n        return {\n            isDisabled: false\n        };\n    },\n    onCreate () {\n        if (this.editor.extensionManager.extensions.find((extension)=>extension.name === \"history\")) {\n            console.warn('[tiptap warn]: \"@tiptap/extension-collaboration\" comes with its own history support and is not compatible with \"@tiptap/extension-history\".');\n        }\n    },\n    addCommands () {\n        return {\n            undo: ()=>({ tr, state, dispatch })=>{\n                    tr.setMeta(\"preventDispatch\", true);\n                    const undoManager = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.yUndoPluginKey.getState(state).undoManager;\n                    if (undoManager.undoStack.length === 0) {\n                        return false;\n                    }\n                    if (!dispatch) {\n                        return true;\n                    }\n                    return (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.undo)(state);\n                },\n            redo: ()=>({ tr, state, dispatch })=>{\n                    tr.setMeta(\"preventDispatch\", true);\n                    const undoManager = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.yUndoPluginKey.getState(state).undoManager;\n                    if (undoManager.redoStack.length === 0) {\n                        return false;\n                    }\n                    if (!dispatch) {\n                        return true;\n                    }\n                    return (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.redo)(state);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-z\": ()=>this.editor.commands.undo(),\n            \"Mod-y\": ()=>this.editor.commands.redo(),\n            \"Shift-Mod-z\": ()=>this.editor.commands.redo()\n        };\n    },\n    addProseMirrorPlugins () {\n        var _a;\n        const fragment = this.options.fragment ? this.options.fragment : this.options.document.getXmlFragment(this.options.field);\n        // Quick fix until there is an official implementation (thanks to @hamflx).\n        // See https://github.com/yjs/y-prosemirror/issues/114 and https://github.com/yjs/y-prosemirror/issues/102\n        const yUndoPluginInstance = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_3__.yUndoPlugin)(this.options.yUndoOptions);\n        const originalUndoPluginView = yUndoPluginInstance.spec.view;\n        yUndoPluginInstance.spec.view = (view)=>{\n            const { undoManager } = y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.yUndoPluginKey.getState(view.state);\n            if (undoManager.restore) {\n                undoManager.restore();\n                undoManager.restore = ()=>{\n                // noop\n                };\n            }\n            const viewRet = originalUndoPluginView ? originalUndoPluginView(view) : undefined;\n            return {\n                destroy: ()=>{\n                    const hasUndoManSelf = undoManager.trackedOrigins.has(undoManager);\n                    // eslint-disable-next-line no-underscore-dangle\n                    const observers = undoManager._observers;\n                    undoManager.restore = ()=>{\n                        if (hasUndoManSelf) {\n                            undoManager.trackedOrigins.add(undoManager);\n                        }\n                        undoManager.doc.on(\"afterTransaction\", undoManager.afterTransactionHandler);\n                        // eslint-disable-next-line no-underscore-dangle\n                        undoManager._observers = observers;\n                    };\n                    if (viewRet === null || viewRet === void 0 ? void 0 : viewRet.destroy) {\n                        viewRet.destroy();\n                    }\n                }\n            };\n        };\n        const ySyncPluginOptions = {\n            ...this.options.ySyncOptions,\n            onFirstRender: this.options.onFirstRender\n        };\n        const ySyncPluginInstance = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_4__.ySyncPlugin)(fragment, ySyncPluginOptions);\n        if (this.editor.options.enableContentCheck) {\n            (_a = fragment.doc) === null || _a === void 0 ? void 0 : _a.on(\"beforeTransaction\", ()=>{\n                try {\n                    const jsonContent = (0,y_prosemirror__WEBPACK_IMPORTED_MODULE_5__.yXmlFragmentToProsemirrorJSON)(fragment);\n                    if (jsonContent.content.length === 0) {\n                        return;\n                    }\n                    this.editor.schema.nodeFromJSON(jsonContent).check();\n                } catch (error) {\n                    this.editor.emit(\"contentError\", {\n                        error: error,\n                        editor: this.editor,\n                        disableCollaboration: ()=>{\n                            var _a;\n                            (_a = fragment.doc) === null || _a === void 0 ? void 0 : _a.destroy();\n                            this.storage.isDisabled = true;\n                        }\n                    });\n                    // If the content is invalid, return false to prevent the transaction from being applied\n                    return false;\n                }\n            });\n        }\n        return [\n            ySyncPluginInstance,\n            yUndoPluginInstance,\n            // Only add the filterInvalidContent plugin if content checking is enabled\n            this.editor.options.enableContentCheck && new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"filterInvalidContent\"),\n                filterTransaction: ()=>{\n                    var _a;\n                    // When collaboration is disabled, prevent any sync transactions from being applied\n                    if (this.storage.isDisabled) {\n                        // Destroy the Yjs document to prevent any further sync transactions\n                        (_a = fragment.doc) === null || _a === void 0 ? void 0 : _a.destroy();\n                        return true;\n                    }\n                    return true;\n                }\n            })\n        ].filter(Boolean);\n    }\n});\n/**\n * Checks if a transaction was originated from a Yjs change.\n * @param {Transaction} transaction - The transaction to check.\n * @returns {boolean} - True if the transaction was originated from a Yjs change, false otherwise.\n * @example\n * const transaction = new Transaction(doc)\n * const isOrigin = isChangeOrigin(transaction) // returns false\n */ function isChangeOrigin(transaction) {\n    return !!transaction.getMeta(y_prosemirror__WEBPACK_IMPORTED_MODULE_2__.ySyncPluginKey);\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbi9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUF5QztBQUNZO0FBQytFO0FBRXBJOzs7Q0FHQyxHQUNELE1BQU1VLGdCQUFnQlYsbURBQVNBLENBQUNXLE1BQU0sQ0FBQztJQUNuQ0MsTUFBTTtJQUNOQyxVQUFVO0lBQ1ZDO1FBQ0ksT0FBTztZQUNIQyxVQUFVO1lBQ1ZDLE9BQU87WUFDUEMsVUFBVTtRQUNkO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hDLFlBQVk7UUFDaEI7SUFDSjtJQUNBQztRQUNJLElBQUksSUFBSSxDQUFDQyxNQUFNLENBQUNDLGdCQUFnQixDQUFDQyxVQUFVLENBQUNDLElBQUksQ0FBQ0MsQ0FBQUEsWUFBYUEsVUFBVWIsSUFBSSxLQUFLLFlBQVk7WUFDekZjLFFBQVFDLElBQUksQ0FBQztRQUNqQjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIeEIsTUFBTSxJQUFNLENBQUMsRUFBRXlCLEVBQUUsRUFBRUMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQ2hDRixHQUFHRyxPQUFPLENBQUMsbUJBQW1CO29CQUM5QixNQUFNQyxjQUFjOUIseURBQWNBLENBQUMrQixRQUFRLENBQUNKLE9BQU9HLFdBQVc7b0JBQzlELElBQUlBLFlBQVlFLFNBQVMsQ0FBQ0MsTUFBTSxLQUFLLEdBQUc7d0JBQ3BDLE9BQU87b0JBQ1g7b0JBQ0EsSUFBSSxDQUFDTCxVQUFVO3dCQUNYLE9BQU87b0JBQ1g7b0JBQ0EsT0FBTzNCLG1EQUFJQSxDQUFDMEI7Z0JBQ2hCO1lBQ0F6QixNQUFNLElBQU0sQ0FBQyxFQUFFd0IsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLFFBQVEsRUFBRTtvQkFDaENGLEdBQUdHLE9BQU8sQ0FBQyxtQkFBbUI7b0JBQzlCLE1BQU1DLGNBQWM5Qix5REFBY0EsQ0FBQytCLFFBQVEsQ0FBQ0osT0FBT0csV0FBVztvQkFDOUQs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QSxPQUFPQyxPQUFPO29CQUNWLElBQUksQ0FBQ25ELE1BQU0sQ0FBQ29ELElBQUksQ0FBQyxnQkFBZ0I7d0JBQzdCRCxPQUFPQTt3QkFDUG5ELFFBQVEsSUFBSSxDQUFDQSxNQUFNO3dCQUNuQnFELHNCQUFzQjs0QkFDbEIsSUFBSWpDOzRCQUNIQSxDQUFBQSxLQUFLeEIsU0FBUzBDLEdBQUcsTUFBTSxRQUFRbEIsT0FBTyxLQUFLLElBQUksS0FBSyxJQUFJQSxHQUFHVyxPQUFPOzRCQUNuRSxJQUFJLENBQUN1QixPQUFPLENBQUN4RCxVQUFVLEdBQUc7d0JBQzlCO29CQUNKO29CQUNBLHdGQUF3RjtvQkFDeEYsT0FBTztnQkFDWDtZQUNKO1FBQ0o7UUFDQSxPQUFPO1lBQ0g4QztZQUNBckI7WUFDQSwwRUFBMEU7WUFDMUUsSUFBSSxDQUFDdkIsTUFBTSxDQUFDcUIsT0FBTyxDQUFDd0Isa0JBQWtCLElBQy9CLElBQUlqRSxvREFBTUEsQ0FBQztnQkFDVjJFLEtBQUssSUFBSTFFLHVEQUFTQSxDQUFDO2dCQUNuQjJFLG1CQUFtQjtvQkFDZixJQUFJcEM7b0JBQ0osbUZBQW1GO29CQUNuRixJQUFJLElBQUksQ0FBQ2tDLE9BQU8sQ0FBQ3hELFVBQVUsRUFBRTt3QkFDekIsb0VBQW9FO3dCQUNuRXNCLENBQUFBLEtBQUt4QixTQUFTMEMsR0FBRyxNQUFNLFFBQVFsQixPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEdBQUdXLE9BQU87d0JBQ25FLE9BQU87b0JBQ1g7b0JBQ0EsT0FBTztnQkFDWDtZQUNKO1NBQ1AsQ0FBQzBCLE1BQU0sQ0FBQ0M7SUFDYjtBQUNKO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNDLGVBQWVDLFdBQVc7SUFDL0IsT0FBTyxDQUFDLENBQUNBLFlBQVlDLE9BQU8sQ0FBQ3pFLHlEQUFjQTtBQUMvQztBQUVtRSxDQUNuRSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uL2Rpc3QvaW5kZXguanM/ZTU0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IHlVbmRvUGx1Z2luS2V5LCB1bmRvLCByZWRvLCB5VW5kb1BsdWdpbiwgeVN5bmNQbHVnaW4sIHlYbWxGcmFnbWVudFRvUHJvc2VtaXJyb3JKU09OLCB5U3luY1BsdWdpbktleSB9IGZyb20gJ3ktcHJvc2VtaXJyb3InO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY29sbGFib3JhdGUgd2l0aCBvdGhlcnMgaW4gcmVhbC10aW1lLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvY29sbGFib3JhdGlvblxuICovXG5jb25zdCBDb2xsYWJvcmF0aW9uID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NvbGxhYm9yYXRpb24nLFxuICAgIHByaW9yaXR5OiAxMDAwLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb2N1bWVudDogbnVsbCxcbiAgICAgICAgICAgIGZpZWxkOiAnZGVmYXVsdCcsXG4gICAgICAgICAgICBmcmFnbWVudDogbnVsbCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFN0b3JhZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc0Rpc2FibGVkOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIG9uQ3JlYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5leHRlbnNpb25zLmZpbmQoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lID09PSAnaGlzdG9yeScpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwiQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvblwiIGNvbWVzIHdpdGggaXRzIG93biBoaXN0b3J5IHN1cHBvcnQgYW5kIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggXCJAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5XCIuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5kbzogKCkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgncHJldmVudERpc3BhdGNoJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkudW5kb01hbmFnZXI7XG4gICAgICAgICAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLnVuZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kbyhzdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVkbzogKCkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgncHJldmVudERpc3BhdGNoJywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdW5kb01hbmFnZXIgPSB5VW5kb1BsdWdpbktleS5nZXRTdGF0ZShzdGF0ZSkudW5kb01hbmFnZXI7XG4gICAgICAgICAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVkbyhzdGF0ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAgICAgICAnTW9kLXknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgICAgICAnU2hpZnQtTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSB0aGlzLm9wdGlvbnMuZnJhZ21lbnRcbiAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmZyYWdtZW50XG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5kb2N1bWVudC5nZXRYbWxGcmFnbWVudCh0aGlzLm9wdGlvbnMuZmllbGQpO1xuICAgICAgICAvLyBRdWljayBmaXggdW50aWwgdGhlcmUgaXMgYW4gb2ZmaWNpYWwgaW1wbGVtZW50YXRpb24gKHRoYW5rcyB0byBAaGFtZmx4KS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS95anMveS1wcm9zZW1pcnJvci9pc3N1ZXMvMTE0IGFuZCBodHRwczovL2dpdGh1Yi5jb20veWpzL3ktcHJvc2VtaXJyb3IvaXNzdWVzLzEwMlxuICAgICAgICBjb25zdCB5VW5kb1BsdWdpbkluc3RhbmNlID0geVVuZG9QbHVnaW4odGhpcy5vcHRpb25zLnlVbmRvT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsVW5kb1BsdWdpblZpZXcgPSB5VW5kb1BsdWdpbkluc3RhbmNlLnNwZWMudmlldztcbiAgICAgICAgeVVuZG9QbHVnaW5JbnN0YW5jZS5zcGVjLnZpZXcgPSAodmlldykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB1bmRvTWFuYWdlciB9ID0geVVuZG9QbHVnaW5LZXkuZ2V0U3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAodW5kb01hbmFnZXIucmVzdG9yZSkge1xuICAgICAgICAgICAgICAgIHVuZG9NYW5hZ2VyLnJlc3RvcmUoKTtcbiAgICAgICAgICAgICAgICB1bmRvTWFuYWdlci5yZXN0b3JlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBub29wXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZpZXdSZXQgPSBvcmlnaW5hbFVuZG9QbHVnaW5WaWV3ID8gb3JpZ2luYWxVbmRvUGx1Z2luVmlldyh2aWV3KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGVzdHJveTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNVbmRvTWFuU2VsZiA9IHVuZG9NYW5hZ2VyLnRyYWNrZWRPcmlnaW5zLmhhcyh1bmRvTWFuYWdlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvYnNlcnZlcnMgPSB1bmRvTWFuYWdlci5fb2JzZXJ2ZXJzO1xuICAgICAgICAgICAgICAgICAgICB1bmRvTWFuYWdlci5yZXN0b3JlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc1VuZG9NYW5TZWxmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5kb01hbmFnZXIudHJhY2tlZE9yaWdpbnMuYWRkKHVuZG9NYW5hZ2VyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVuZG9NYW5hZ2VyLmRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIHVuZG9NYW5hZ2VyLmFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlcnNjb3JlLWRhbmdsZVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kb01hbmFnZXIuX29ic2VydmVycyA9IG9ic2VydmVycztcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdSZXQgPT09IG51bGwgfHwgdmlld1JldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlld1JldC5kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3UmV0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB5U3luY1BsdWdpbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMueVN5bmNPcHRpb25zLFxuICAgICAgICAgICAgb25GaXJzdFJlbmRlcjogdGhpcy5vcHRpb25zLm9uRmlyc3RSZW5kZXIsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHlTeW5jUGx1Z2luSW5zdGFuY2UgPSB5U3luY1BsdWdpbihmcmFnbWVudCwgeVN5bmNQbHVnaW5PcHRpb25zKTtcbiAgICAgICAgaWYgKHRoaXMuZWRpdG9yLm9wdGlvbnMuZW5hYmxlQ29udGVudENoZWNrKSB7XG4gICAgICAgICAgICAoX2EgPSBmcmFnbWVudC5kb2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vbignYmVmb3JlVHJhbnNhY3Rpb24nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QganNvbkNvbnRlbnQgPSAoeVhtbEZyYWdtZW50VG9Qcm9zZW1pcnJvckpTT04oZnJhZ21lbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25Db250ZW50LmNvbnRlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iuc2NoZW1hLm5vZGVGcm9tSlNPTihqc29uQ29udGVudCkuY2hlY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoJ2NvbnRlbnRFcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNhYmxlQ29sbGFib3JhdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBmcmFnbWVudC5kb2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmlzRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBjb250ZW50IGlzIGludmFsaWQsIHJldHVybiBmYWxzZSB0byBwcmV2ZW50IHRoZSB0cmFuc2FjdGlvbiBmcm9tIGJlaW5nIGFwcGxpZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB5U3luY1BsdWdpbkluc3RhbmNlLFxuICAgICAgICAgICAgeVVuZG9QbHVnaW5JbnN0YW5jZSxcbiAgICAgICAgICAgIC8vIE9ubHkgYWRkIHRoZSBmaWx0ZXJJbnZhbGlkQ29udGVudCBwbHVnaW4gaWYgY29udGVudCBjaGVja2luZyBpcyBlbmFibGVkXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVja1xuICAgICAgICAgICAgICAgICYmIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2ZpbHRlckludmFsaWRDb250ZW50JyksXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlclRyYW5zYWN0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGNvbGxhYm9yYXRpb24gaXMgZGlzYWJsZWQsIHByZXZlbnQgYW55IHN5bmMgdHJhbnNhY3Rpb25zIGZyb20gYmVpbmcgYXBwbGllZFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RvcmFnZS5pc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVzdHJveSB0aGUgWWpzIGRvY3VtZW50IHRvIHByZXZlbnQgYW55IGZ1cnRoZXIgc3luYyB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBmcmFnbWVudC5kb2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgXS5maWx0ZXIoQm9vbGVhbik7XG4gICAgfSxcbn0pO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHRyYW5zYWN0aW9uIHdhcyBvcmlnaW5hdGVkIGZyb20gYSBZanMgY2hhbmdlLlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb24gLSBUaGUgdHJhbnNhY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgb3JpZ2luYXRlZCBmcm9tIGEgWWpzIGNoYW5nZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICogQGV4YW1wbGVcbiAqIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYylcbiAqIGNvbnN0IGlzT3JpZ2luID0gaXNDaGFuZ2VPcmlnaW4odHJhbnNhY3Rpb24pIC8vIHJldHVybnMgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNDaGFuZ2VPcmlnaW4odHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gISF0cmFuc2FjdGlvbi5nZXRNZXRhKHlTeW5jUGx1Z2luS2V5KTtcbn1cblxuZXhwb3J0IHsgQ29sbGFib3JhdGlvbiwgQ29sbGFib3JhdGlvbiBhcyBkZWZhdWx0LCBpc0NoYW5nZU9yaWdpbiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiRXh0ZW5zaW9uIiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwieVVuZG9QbHVnaW5LZXkiLCJ1bmRvIiwicmVkbyIsInlVbmRvUGx1Z2luIiwieVN5bmNQbHVnaW4iLCJ5WG1sRnJhZ21lbnRUb1Byb3NlbWlycm9ySlNPTiIsInlTeW5jUGx1Z2luS2V5IiwiQ29sbGFib3JhdGlvbiIsImNyZWF0ZSIsIm5hbWUiLCJwcmlvcml0eSIsImFkZE9wdGlvbnMiLCJkb2N1bWVudCIsImZpZWxkIiwiZnJhZ21lbnQiLCJhZGRTdG9yYWdlIiwiaXNEaXNhYmxlZCIsIm9uQ3JlYXRlIiwiZWRpdG9yIiwiZXh0ZW5zaW9uTWFuYWdlciIsImV4dGVuc2lvbnMiLCJmaW5kIiwiZXh0ZW5zaW9uIiwiY29uc29sZSIsIndhcm4iLCJhZGRDb21tYW5kcyIsInRyIiwic3RhdGUiLCJkaXNwYXRjaCIsInNldE1ldGEiLCJ1bmRvTWFuYWdlciIsImdldFN0YXRlIiwidW5kb1N0YWNrIiwibGVuZ3RoIiwicmVkb1N0YWNrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJjb21tYW5kcyIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsIl9hIiwib3B0aW9ucyIsImdldFhtbEZyYWdtZW50IiwieVVuZG9QbHVnaW5JbnN0YW5jZSIsInlVbmRvT3B0aW9ucyIsIm9yaWdpbmFsVW5kb1BsdWdpblZpZXciLCJzcGVjIiwidmlldyIsInJlc3RvcmUiLCJ2aWV3UmV0IiwidW5kZWZpbmVkIiwiZGVzdHJveSIsImhhc1VuZG9NYW5TZWxmIiwidHJhY2tlZE9yaWdpbnMiLCJoYXMiLCJvYnNlcnZlcnMiLCJfb2JzZXJ2ZXJzIiwiYWRkIiwiZG9jIiwib24iLCJhZnRlclRyYW5zYWN0aW9uSGFuZGxlciIsInlTeW5jUGx1Z2luT3B0aW9ucyIsInlTeW5jT3B0aW9ucyIsIm9uRmlyc3RSZW5kZXIiLCJ5U3luY1BsdWdpbkluc3RhbmNlIiwiZW5hYmxlQ29udGVudENoZWNrIiwianNvbkNvbnRlbnQiLCJjb250ZW50Iiwic2NoZW1hIiwibm9kZUZyb21KU09OIiwiY2hlY2siLCJlcnJvciIsImVtaXQiLCJkaXNhYmxlQ29sbGFib3JhdGlvbiIsInN0b3JhZ2UiLCJrZXkiLCJmaWx0ZXJUcmFuc2FjdGlvbiIsImZpbHRlciIsIkJvb2xlYW4iLCJpc0NoYW5nZU9yaWdpbiIsInRyYW5zYWN0aW9uIiwiZ2V0TWV0YSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-collaboration/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   \"default\": () => (/* binding */ Document)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */ const Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"doc\",\n    topNode: true,\n    content: \"block+\"\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZG9jdW1lbnQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBb0M7QUFFcEM7OztDQUdDLEdBQ0QsTUFBTUMsV0FBV0QsOENBQUlBLENBQUNFLE1BQU0sQ0FBQztJQUN6QkMsTUFBTTtJQUNOQyxTQUFTO0lBQ1RDLFNBQVM7QUFDYjtBQUV5QyxDQUN6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudC9kaXN0L2luZGV4LmpzP2NjZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgZG9jdW1lbnQgbm9kZSB3aGljaCByZXByZXNlbnRzIHRoZSB0b3AgbGV2ZWwgbm9kZSBvZiB0aGUgZWRpdG9yLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL25vZGVzL2RvY3VtZW50XG4gKi9cbmNvbnN0IERvY3VtZW50ID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdkb2MnLFxuICAgIHRvcE5vZGU6IHRydWUsXG4gICAgY29udGVudDogJ2Jsb2NrKycsXG59KTtcblxuZXhwb3J0IHsgRG9jdW1lbnQsIERvY3VtZW50IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJEb2N1bWVudCIsImNyZWF0ZSIsIm5hbWUiLCJ0b3BOb2RlIiwiY29udGVudCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-dropcursor/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dropcursor: () => (/* binding */ Dropcursor),\n/* harmony export */   \"default\": () => (/* binding */ Dropcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\");\n\n\n/**\n * This extension allows you to add a drop cursor to your editor.\n * A drop cursor is a line that appears when you drag and drop content\n * inbetween nodes.\n * @see https://tiptap.dev/api/extensions/dropcursor\n */ const Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"dropCursor\",\n    addOptions () {\n        return {\n            color: \"currentColor\",\n            width: 1,\n            class: undefined\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)(this.options)\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDVTtBQUVuRDs7Ozs7Q0FLQyxHQUNELE1BQU1FLGFBQWFGLG1EQUFTQSxDQUFDRyxNQUFNLENBQUM7SUFDaENDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLE9BQU87WUFDUEMsT0FBTztZQUNQQyxPQUFPQztRQUNYO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hULGlFQUFVQSxDQUFDLElBQUksQ0FBQ1UsT0FBTztTQUMxQjtJQUNMO0FBQ0o7QUFFNkMsQ0FDN0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzP2Y5YzIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IGRyb3BDdXJzb3IgfSBmcm9tICdAdGlwdGFwL3BtL2Ryb3BjdXJzb3InO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGEgZHJvcCBjdXJzb3IgdG8geW91ciBlZGl0b3IuXG4gKiBBIGRyb3AgY3Vyc29yIGlzIGEgbGluZSB0aGF0IGFwcGVhcnMgd2hlbiB5b3UgZHJhZyBhbmQgZHJvcCBjb250ZW50XG4gKiBpbmJldHdlZW4gbm9kZXMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9kcm9wY3Vyc29yXG4gKi9cbmNvbnN0IERyb3BjdXJzb3IgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZHJvcEN1cnNvcicsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbG9yOiAnY3VycmVudENvbG9yJyxcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgY2xhc3M6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGRyb3BDdXJzb3IodGhpcy5vcHRpb25zKSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IERyb3BjdXJzb3IsIERyb3BjdXJzb3IgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiRXh0ZW5zaW9uIiwiZHJvcEN1cnNvciIsIkRyb3BjdXJzb3IiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsImNvbG9yIiwid2lkdGgiLCJjbGFzcyIsInVuZGVmaW5lZCIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsIm9wdGlvbnMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-floating-menu/dist/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   FloatingMenuPlugin: () => (/* binding */ FloatingMenuPlugin),\n/* harmony export */   FloatingMenuView: () => (/* binding */ FloatingMenuView),\n/* harmony export */   \"default\": () => (/* binding */ FloatingMenu)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(ssr)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\nclass FloatingMenuView {\n    getTextContent(node) {\n        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getText)(node, {\n            textSerializers: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getTextSerializersFromSchema)(this.editor.schema)\n        });\n    }\n    constructor({ editor, element, view, tippyOptions = {}, shouldShow }){\n        this.preventHide = false;\n        this.shouldShow = ({ view, state })=>{\n            const { selection } = state;\n            const { $anchor, empty } = selection;\n            const isRootDepth = $anchor.depth === 1;\n            const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent && $anchor.parent.childCount === 0 && !this.getTextContent($anchor.parent);\n            if (!view.hasFocus() || !empty || !isRootDepth || !isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = ()=>{\n            this.preventHide = true;\n        };\n        this.focusHandler = ()=>{\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(()=>this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event })=>{\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event)=>{\n            this.blurHandler({\n                event\n            });\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.editor.on(\"focus\", this.focusHandler);\n        this.editor.on(\"blur\", this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = \"visible\";\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        this.element.tabIndex = 0;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: \"manual\",\n            placement: \"right\",\n            hideOnClick: \"toggle\",\n            ...this.tippyOptions\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener(\"blur\", this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        var _a, _b, _c;\n        const { state } = view;\n        const { doc, selection } = state;\n        const { from, to } = selection;\n        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n        if (isSame) {\n            return;\n        }\n        this.createTooltip();\n        const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n            editor: this.editor,\n            view,\n            state,\n            oldState\n        });\n        if (!shouldShow) {\n            this.hide();\n            return;\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n            getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (()=>(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to))\n        });\n        this.show();\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener(\"blur\", this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener(\"mousedown\", this.mousedownHandler, {\n            capture: true\n        });\n        this.editor.off(\"focus\", this.focusHandler);\n        this.editor.off(\"blur\", this.blurHandler);\n    }\n}\nconst FloatingMenuPlugin = (options)=>{\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === \"string\" ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: (view)=>new FloatingMenuView({\n                view,\n                ...options\n            })\n    });\n};\n/**\n * This extension allows you to create a floating menu.\n * @see https://tiptap.dev/api/extensions/floating-menu\n */ const FloatingMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"floatingMenu\",\n    addOptions () {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: \"floatingMenu\",\n            shouldShow: null\n        };\n    },\n    addProseMirrorPlugins () {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            FloatingMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                shouldShow: this.options.shouldShow\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZmxvYXRpbmctbWVudS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBOEY7QUFDekM7QUFDeEI7QUFFN0IsTUFBTU87SUFDRkMsZUFBZUMsSUFBSSxFQUFFO1FBQ2pCLE9BQU9ULHFEQUFPQSxDQUFDUyxNQUFNO1lBQUVDLGlCQUFpQlQsMEVBQTRCQSxDQUFDLElBQUksQ0FBQ1UsTUFBTSxDQUFDQyxNQUFNO1FBQUU7SUFDN0Y7SUFDQUMsWUFBWSxFQUFFRixNQUFNLEVBQUVHLE9BQU8sRUFBRUMsSUFBSSxFQUFFQyxlQUFlLENBQUMsQ0FBQyxFQUFFQyxVQUFVLEVBQUcsQ0FBRTtRQUNuRSxJQUFJLENBQUNDLFdBQVcsR0FBRztRQUNuQixJQUFJLENBQUNELFVBQVUsR0FBRyxDQUFDLEVBQUVGLElBQUksRUFBRUksS0FBSyxFQUFFO1lBQzlCLE1BQU0sRUFBRUMsU0FBUyxFQUFFLEdBQUdEO1lBQ3RCLE1BQU0sRUFBRUUsT0FBTyxFQUFFQyxLQUFLLEVBQUUsR0FBR0Y7WUFDM0IsTUFBTUcsY0FBY0YsUUFBUUcsS0FBSyxLQUFLO1lBQ3RDLE1BQU1DLG1CQUFtQkosUUFBUUssTUFBTSxDQUFDQyxXQUFXLElBQUksQ0FBQ04sUUFBUUssTUFBTSxDQUFDRSxJQUFJLENBQUNDLElBQUksQ0FBQ0MsSUFBSSxJQUFJLENBQUNULFFBQVFLLE1BQU0sQ0FBQ0ssV0FBVyxJQUFJVixRQUFRSyxNQUFNLENBQUNNLFVBQVUsS0FBSyxLQUFLLENBQUMsSUFBSSxDQUFDeEIsY0FBYyxDQUFDYSxRQUFRSyxNQUFNO1lBQzlMLElBQUksQ0FBQ1gsS0FBS2tCLFFBQVEsTUFDWCxDQUFDWCxTQUNELENBQUNDLGVBQ0QsQ0FBQ0Usb0JBQ0QsQ0FBQyxJQUFJLENBQUNkLE1BQU0sQ0FBQ3VCLFVBQVUsRUFBRTtnQkFDNUIsT0FBTztZQUNYO1lBQ0EsT0FBTztRQUNYO1FBQ0EsSUFBSSxDQUFD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QUFDO0lBQ2xDQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIM0UsU0FBUztZQUNURSxjQUFjLENBQUM7WUFDZnFFLFdBQVc7WUFDWHBFLFlBQVk7UUFDaEI7SUFDSjtJQUNBeUU7UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDbEMsT0FBTyxDQUFDMUMsT0FBTyxFQUFFO1lBQ3ZCLE9BQU8sRUFBRTtRQUNiO1FBQ0EsT0FBTztZQUNIcUUsbUJBQW1CO2dCQUNmRSxXQUFXLElBQUksQ0FBQzdCLE9BQU8sQ0FBQzZCLFNBQVM7Z0JBQ2pDMUUsUUFBUSxJQUFJLENBQUNBLE1BQU07Z0JBQ25CRyxTQUFTLElBQUksQ0FBQzBDLE9BQU8sQ0FBQzFDLE9BQU87Z0JBQzdCRSxjQUFjLElBQUksQ0FBQ3dDLE9BQU8sQ0FBQ3hDLFlBQVk7Z0JBQ3ZDQyxZQUFZLElBQUksQ0FBQ3VDLE9BQU8sQ0FBQ3ZDLFVBQVU7WUFDdkM7U0FDSDtJQUNMO0FBQ0o7QUFFdUYsQ0FDdkYsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZmxvYXRpbmctbWVudS9kaXN0L2luZGV4LmpzPzY1ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VGV4dCwgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSwgcG9zVG9ET01SZWN0LCBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB0aXBweSBmcm9tICd0aXBweS5qcyc7XG5cbmNsYXNzIEZsb2F0aW5nTWVudVZpZXcge1xuICAgIGdldFRleHRDb250ZW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGdldFRleHQobm9kZSwgeyB0ZXh0U2VyaWFsaXplcnM6IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5lZGl0b3Iuc2NoZW1hKSB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBlZGl0b3IsIGVsZW1lbnQsIHZpZXcsIHRpcHB5T3B0aW9ucyA9IHt9LCBzaG91bGRTaG93LCB9KSB7XG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gKHsgdmlldywgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyAkYW5jaG9yLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgaXNSb290RGVwdGggPSAkYW5jaG9yLmRlcHRoID09PSAxO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmICEkYW5jaG9yLnBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQgJiYgJGFuY2hvci5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMCAmJiAhdGhpcy5nZXRUZXh0Q29udGVudCgkYW5jaG9yLnBhcmVudCk7XG4gICAgICAgICAgICBpZiAoIXZpZXcuaGFzRm9jdXMoKVxuICAgICAgICAgICAgICAgIHx8ICFlbXB0eVxuICAgICAgICAgICAgICAgIHx8ICFpc1Jvb3REZXB0aFxuICAgICAgICAgICAgICAgIHx8ICFpc0VtcHR5VGV4dEJsb2NrXG4gICAgICAgICAgICAgICAgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd25IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmICgoX2EgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpID09PSB0aGlzLmVkaXRvci52aWV3LmRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBzaG91bGRTaG93O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgICAgICB0aGlzLnRpcHB5T3B0aW9ucyA9IHRpcHB5T3B0aW9ucztcbiAgICAgICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudDogZWRpdG9yRWxlbWVudCB9ID0gdGhpcy5lZGl0b3Iub3B0aW9ucztcbiAgICAgICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgICAgICBpZiAodGhpcy50aXBweSB8fCAhZWRpdG9ySXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwcHkgPSB0aXBweShlZGl0b3JFbGVtZW50LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxuICAgICAgICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBpc1NhbWUgPSBvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5kb2MuZXEoZG9jKSAmJiBvbGRTdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGlzU2FtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCgpO1xuICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gKF9hID0gdGhpcy5zaG91bGRTaG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZFNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRQcm9wcyh7XG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKF9jID0gdGhpcy50aXBweU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0KSB8fCAoKCkgPT4gcG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvdygpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICB9XG59XG5jb25zdCBGbG9hdGluZ01lbnVQbHVnaW4gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgdmlldzogdmlldyA9PiBuZXcgRmxvYXRpbmdNZW51Vmlldyh7IHZpZXcsIC4uLm9wdGlvbnMgfSksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGEgZmxvYXRpbmcgbWVudS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2Zsb2F0aW5nLW1lbnVcbiAqL1xuY29uc3QgRmxvYXRpbmdNZW51ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Zsb2F0aW5nTWVudScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICB0aXBweU9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgcGx1Z2luS2V5OiAnZmxvYXRpbmdNZW51JyxcbiAgICAgICAgICAgIHNob3VsZFNob3c6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRmxvYXRpbmdNZW51UGx1Z2luKHtcbiAgICAgICAgICAgICAgICBwbHVnaW5LZXk6IHRoaXMub3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHRoaXMub3B0aW9ucy50aXBweU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2hvdWxkU2hvdzogdGhpcy5vcHRpb25zLnNob3VsZFNob3csXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEZsb2F0aW5nTWVudSwgRmxvYXRpbmdNZW51UGx1Z2luLCBGbG9hdGluZ01lbnVWaWV3LCBGbG9hdGluZ01lbnUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0VGV4dCIsImdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEiLCJwb3NUb0RPTVJlY3QiLCJFeHRlbnNpb24iLCJQbHVnaW4iLCJQbHVnaW5LZXkiLCJ0aXBweSIsIkZsb2F0aW5nTWVudVZpZXciLCJnZXRUZXh0Q29udGVudCIsIm5vZGUiLCJ0ZXh0U2VyaWFsaXplcnMiLCJlZGl0b3IiLCJzY2hlbWEiLCJjb25zdHJ1Y3RvciIsImVsZW1lbnQiLCJ2aWV3IiwidGlwcHlPcHRpb25zIiwic2hvdWxkU2hvdyIsInByZXZlbnRIaWRlIiwic3RhdGUiLCJzZWxlY3Rpb24iLCIkYW5jaG9yIiwiZW1wdHkiLCJpc1Jvb3REZXB0aCIsImRlcHRoIiwiaXNFbXB0eVRleHRCbG9jayIsInBhcmVudCIsImlzVGV4dGJsb2NrIiwidHlwZSIsInNwZWMiLCJjb2RlIiwidGV4dENvbnRlbnQiLCJjaGlsZENvdW50IiwiaGFzRm9jdXMiLCJpc0VkaXRhYmxlIiwibW91c2Vkb3duSGFuZGxlciIsImZvY3VzSGFuZGxlciIsInNldFRpbWVvdXQiLCJ1cGRhdGUiLCJibHVySGFuZGxlciIsImV2ZW50IiwiX2EiLCJyZWxhdGVkVGFyZ2V0IiwicGFyZW50Tm9kZSIsImNvbnRhaW5zIiwiZG9tIiwiaGlkZSIsInRpcHB5Qmx1ckhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiY2FwdHVyZSIsIm9uIiwicmVtb3ZlIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwiY3JlYXRlVG9vbHRpcCIsImVkaXRvckVsZW1lbnQiLCJvcHRpb25zIiwiZWRpdG9ySXNBdHRhY2hlZCIsInBhcmVudEVsZW1lbnQiLCJ0YWJJbmRleCIsImR1cmF0aW9uIiwiZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCIsImNvbnRlbnQiLCJpbnRlcmFjdGl2ZSIsInRyaWdnZXIiLCJwbGFjZW1lbnQiLCJoaWRlT25DbGljayIsInBvcHBlciIsImZpcnN0Q2hpbGQiLCJvbGRTdGF0ZSIsIl9iIiwiX2MiLCJkb2MiLCJmcm9tIiwidG8iLCJpc1NhbWUiLCJlcSIsImNhbGwiLCJzZXRQcm9wcyIsInNob3ciLCJkZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm9mZiIsIkZsb2F0aW5nTWVudVBsdWdpbiIsImtleSIsInBsdWdpbktleSIsIkZsb2F0aW5nTWVudSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gapcursor: () => (/* binding */ Gapcursor),\n/* harmony export */   \"default\": () => (/* binding */ Gapcursor)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\");\n\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */ const Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"gapCursor\",\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)()\n        ];\n    },\n    extendNodeSchema (extension) {\n        var _a;\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage\n        };\n        return {\n            allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, \"allowGapCursor\", context))) !== null && _a !== void 0 ? _a : null\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEwRTtBQUN6QjtBQUVqRDs7Ozs7Q0FLQyxHQUNELE1BQU1JLFlBQVlKLG1EQUFTQSxDQUFDSyxNQUFNLENBQUM7SUFDL0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hKLCtEQUFTQTtTQUNaO0lBQ0w7SUFDQUssa0JBQWlCQyxTQUFTO1FBQ3RCLElBQUlDO1FBQ0osTUFBTUMsVUFBVTtZQUNaTCxNQUFNRyxVQUFVSCxJQUFJO1lBQ3BCTSxTQUFTSCxVQUFVRyxPQUFPO1lBQzFCQyxTQUFTSixVQUFVSSxPQUFPO1FBQzlCO1FBQ0EsT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQ0osS0FBS1QsMERBQVlBLENBQUNDLCtEQUFpQkEsQ0FBQ08sV0FBVyxrQkFBa0JFLFNBQVEsTUFBTyxRQUFRRCxPQUFPLEtBQUssSUFBSUEsS0FBSztRQUNsSTtJQUNKO0FBQ0o7QUFFMkMsQ0FDM0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZ2FwY3Vyc29yL2Rpc3QvaW5kZXguanM/MGRmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb24sIGNhbGxPclJldHVybiwgZ2V0RXh0ZW5zaW9uRmllbGQgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgZ2FwQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9nYXBjdXJzb3InO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGEgZ2FwIGN1cnNvciB0byB5b3VyIGVkaXRvci5cbiAqIEEgZ2FwIGN1cnNvciBpcyBhIGN1cnNvciB0aGF0IGFwcGVhcnMgd2hlbiB5b3UgY2xpY2sgb24gYSBwbGFjZVxuICogd2hlcmUgbm8gY29udGVudCBpcyBwcmVzZW50LCBmb3IgZXhhbXBsZSBpbmJldHdlZW4gbm9kZXMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9nYXBjdXJzb3JcbiAqL1xuY29uc3QgR2FwY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2dhcEN1cnNvcicsXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZ2FwQ3Vyc29yKCksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBleHRlbmROb2RlU2NoZW1hKGV4dGVuc2lvbikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhbGxvd0dhcEN1cnNvcjogKF9hID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FsbG93R2FwQ3Vyc29yJywgY29udGV4dCkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgR2FwY3Vyc29yLCBHYXBjdXJzb3IgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiRXh0ZW5zaW9uIiwiY2FsbE9yUmV0dXJuIiwiZ2V0RXh0ZW5zaW9uRmllbGQiLCJnYXBDdXJzb3IiLCJHYXBjdXJzb3IiLCJjcmVhdGUiLCJuYW1lIiwiYWRkUHJvc2VNaXJyb3JQbHVnaW5zIiwiZXh0ZW5kTm9kZVNjaGVtYSIsImV4dGVuc2lvbiIsIl9hIiwiY29udGV4dCIsIm9wdGlvbnMiLCJzdG9yYWdlIiwiYWxsb3dHYXBDdXJzb3IiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: () => (/* binding */ HardBreak),\n/* harmony export */   \"default\": () => (/* binding */ HardBreak)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */ const HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"hardBreak\",\n    addOptions () {\n        return {\n            keepMarks: true,\n            HTMLAttributes: {}\n        };\n    },\n    inline: true,\n    group: \"inline\",\n    selectable: false,\n    linebreakReplacement: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"br\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"br\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    renderText () {\n        return \"\\n\";\n    },\n    addCommands () {\n        return {\n            setHardBreak: ()=>({ commands, chain, state, editor })=>{\n                    return commands.first([\n                        ()=>commands.exitCode(),\n                        ()=>commands.command(()=>{\n                                const { selection, storedMarks } = state;\n                                if (selection.$from.parent.type.spec.isolating) {\n                                    return false;\n                                }\n                                const { keepMarks } = this.options;\n                                const { splittableMarks } = editor.extensionManager;\n                                const marks = storedMarks || selection.$to.parentOffset && selection.$from.marks();\n                                return chain().insertContent({\n                                    type: this.name\n                                }).command(({ tr, dispatch })=>{\n                                    if (dispatch && marks && keepMarks) {\n                                        const filteredMarks = marks.filter((mark)=>splittableMarks.includes(mark.type.name));\n                                        tr.ensureMarks(filteredMarks);\n                                    }\n                                    return true;\n                                }).run();\n                            })\n                    ]);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Enter\": ()=>this.editor.commands.setHardBreak(),\n            \"Shift-Enter\": ()=>this.editor.commands.setHardBreak()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxRDtBQUVyRDs7O0NBR0MsR0FDRCxNQUFNRSxZQUFZRiw4Q0FBSUEsQ0FBQ0csTUFBTSxDQUFDO0lBQzFCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxXQUFXO1lBQ1hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFlBQVk7SUFDWkMsc0JBQXNCO0lBQ3RCQztRQUNJLE9BQU87WUFDSDtnQkFBRUMsS0FBSztZQUFLO1NBQ2Y7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTU4sNkRBQWVBLENBQUMsSUFBSSxDQUFDYyxPQUFPLENBQUNSLGNBQWMsRUFBRUE7U0FBZ0I7SUFDL0U7SUFDQVM7UUFDSSxPQUFPO0lBQ1g7SUFDQUM7UUFDSSxPQUFPO1lBQ0hDLGNBQWMsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxLQUFLLEVBQUVDLE1BQU0sRUFBRztvQkFDcEQsT0FBT0gsU0FBU0ksS0FBSyxDQUFDO3dCQUNsQixJQUFNSixTQUFTSyxRQUFRO3dCQUN2QixJQUFNTCxTQUFTTSxPQUFPLENBQUM7Z0NBQ25CLE1BQU0sRUFBRUMsU0FBUyxFQUFFQyxXQUFXLEVBQUUsR0FBR047Z0NBQ25DLElBQUlLLFVBQVVFLEtBQUssQ0FBQ0MsTUFBTSxDQUFDQyxJQUFJLENBQUNDLElBQUksQ0FBQ0MsU0FBUyxFQUFFO29DQUM1QyxPQUFPO2dDQUNYO2dDQUNBLE1BQU0sRUFBRTFCLFNBQVMsRUFBRSxHQUFHLElBQUksQ0FBQ1MsT0FBTztnQ0FDbEMsTUFBTSxFQUFFa0IsZUFBZSxFQUFFLEdBQUdYLE9BQU9ZLGdCQUFnQjtnQ0FDbkQsTUFBTUMsUUFBUVIsZUFDTkQsVUFBVVUsR0FBRyxDQUFDQyxZQUFZLElBQUlYLFVBQVVFLEtBQUssQ0FBQ08sS0FBSztnQ0FDM0QsT0FBT2YsUUFDRmtCLGFBQWEsQ0FBQztvQ0FBRVIsTUFBTSxJQUFJLENBQUMxQixJQUFJO2dDQUFDLEdBQ2hDcUIsT0FBTyxDQUFDLENBQUMsRUFBRWMsRUFBRSxFQUFFQyxRQUFRLEVBQUU7b0NBQzFCLElBQUlBLFlBQVlMLFNBQVM3QixXQUFXO3dDQUNoQyxNQUFNbUMsZ0JBQWdCTixNQUNqQk8sTUFBTSxDQUFDQyxDQUFBQSxPQUFRVixnQkFBZ0JXLFFBQVEsQ0FBQ0QsS0FBS2IsSUFBSSxDQUFDMUIsSUFBSTt3Q0FDM0RtQyxHQUFHTSxXQUFXLENBQUNKO29DQUNuQjtvQ0FDQSxPQUFPO2dDQUNYLEdBQ0tLLEdBQUc7NEJBQ1o7cUJBQ0g7Z0JBQ0w7UUFDSjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNILGFBQWEsSUFBTSxJQUFJLENBQUN6QixNQUFNLENBQUNILFFBQVEsQ0FBQ0QsWUFBWTtZQUNwRCxlQUFlLElBQU0sSUFBSSxDQUFDSSxNQUFNLENBQUNILFFBQVEsQ0FBQ0QsWUFBWTtRQUMxRDtJQUNKO0FBQ0o7QUFFMkMsQ0FDM0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhay9kaXN0L2luZGV4LmpzPzAxNTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGluc2VydCBoYXJkIGJyZWFrcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvaGFyZC1icmVha1xuICovXG5jb25zdCBIYXJkQnJlYWsgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2hhcmRCcmVhaycsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtlZXBNYXJrczogdHJ1ZSxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGlubGluZTogdHJ1ZSxcbiAgICBncm91cDogJ2lubGluZScsXG4gICAgc2VsZWN0YWJsZTogZmFsc2UsXG4gICAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6IHRydWUsXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0YWc6ICdicicgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ2JyJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpXTtcbiAgICB9LFxuICAgIHJlbmRlclRleHQoKSB7XG4gICAgICAgIHJldHVybiAnXFxuJztcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0SGFyZEJyZWFrOiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4sIHN0YXRlLCBlZGl0b3IsIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuZmlyc3QoW1xuICAgICAgICAgICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgICAgICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jb21tYW5kKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uLiRmcm9tLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBrZWVwTWFya3MgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3BsaXR0YWJsZU1hcmtzIH0gPSBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB8fCAoc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuaW5zZXJ0Q29udGVudCh7IHR5cGU6IHRoaXMubmFtZSB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoICYmIG1hcmtzICYmIGtlZXBNYXJrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAucnVuKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldEhhcmRCcmVhaygpLFxuICAgICAgICAgICAgJ1NoaWZ0LUVudGVyJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0SGFyZEJyZWFrKCksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBIYXJkQnJlYWssIEhhcmRCcmVhayBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJOb2RlIiwibWVyZ2VBdHRyaWJ1dGVzIiwiSGFyZEJyZWFrIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJrZWVwTWFya3MiLCJIVE1MQXR0cmlidXRlcyIsImlubGluZSIsImdyb3VwIiwic2VsZWN0YWJsZSIsImxpbmVicmVha1JlcGxhY2VtZW50IiwicGFyc2VIVE1MIiwidGFnIiwicmVuZGVySFRNTCIsIm9wdGlvbnMiLCJyZW5kZXJUZXh0IiwiYWRkQ29tbWFuZHMiLCJzZXRIYXJkQnJlYWsiLCJjb21tYW5kcyIsImNoYWluIiwic3RhdGUiLCJlZGl0b3IiLCJmaXJzdCIsImV4aXRDb2RlIiwiY29tbWFuZCIsInNlbGVjdGlvbiIsInN0b3JlZE1hcmtzIiwiJGZyb20iLCJwYXJlbnQiLCJ0eXBlIiwic3BlYyIsImlzb2xhdGluZyIsInNwbGl0dGFibGVNYXJrcyIsImV4dGVuc2lvbk1hbmFnZXIiLCJtYXJrcyIsIiR0byIsInBhcmVudE9mZnNldCIsImluc2VydENvbnRlbnQiLCJ0ciIsImRpc3BhdGNoIiwiZmlsdGVyZWRNYXJrcyIsImZpbHRlciIsIm1hcmsiLCJpbmNsdWRlcyIsImVuc3VyZU1hcmtzIiwicnVuIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: () => (/* binding */ Heading),\n/* harmony export */   \"default\": () => (/* binding */ Heading)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */ const Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"heading\",\n    addOptions () {\n        return {\n            levels: [\n                1,\n                2,\n                3,\n                4,\n                5,\n                6\n            ],\n            HTMLAttributes: {}\n        };\n    },\n    content: \"inline*\",\n    group: \"block\",\n    defining: true,\n    addAttributes () {\n        return {\n            level: {\n                default: 1,\n                rendered: false\n            }\n        };\n    },\n    parseHTML () {\n        return this.options.levels.map((level)=>({\n                tag: `h${level}`,\n                attrs: {\n                    level\n                }\n            }));\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        const hasLevel = this.options.levels.includes(node.attrs.level);\n        const level = hasLevel ? node.attrs.level : this.options.levels[0];\n        return [\n            `h${level}`,\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.setNode(this.name, attributes);\n                },\n            toggleHeading: (attributes)=>({ commands })=>{\n                    if (!this.options.levels.includes(attributes.level)) {\n                        return false;\n                    }\n                    return commands.toggleNode(this.name, \"paragraph\", attributes);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return this.options.levels.reduce((items, level)=>({\n                ...items,\n                ...{\n                    [`Mod-Alt-${level}`]: ()=>this.editor.commands.toggleHeading({\n                            level\n                        })\n                }\n            }), {});\n    },\n    addInputRules () {\n        return this.options.levels.map((level)=>{\n            return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n                find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n                type: this.type,\n                getAttributes: {\n                    level\n                }\n            });\n        });\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGVhZGluZy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2RTtBQUU3RTs7O0NBR0MsR0FDRCxNQUFNRyxVQUFVSCw4Q0FBSUEsQ0FBQ0ksTUFBTSxDQUFDO0lBQ3hCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxRQUFRO2dCQUFDO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2dCQUFHO2FBQUU7WUFDMUJDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsU0FBUztJQUNUQyxPQUFPO0lBQ1BDLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0hDLE9BQU87Z0JBQ0hDLFNBQVM7Z0JBQ1RDLFVBQVU7WUFDZDtRQUNKO0lBQ0o7SUFDQUM7UUFDSSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDVixNQUFNLENBQ3JCVyxHQUFHLENBQUMsQ0FBQ0wsUUFBVztnQkFDakJNLEtBQUssQ0FBQyxDQUFDLEVBQUVOLE1BQU0sQ0FBQztnQkFDaEJPLE9BQU87b0JBQUVQO2dCQUFNO1lBQ25CO0lBQ0o7SUFDQVEsWUFBVyxFQUFFQyxJQUFJLEVBQUVkLGNBQWMsRUFBRTtRQUMvQixNQUFNZSxXQUFXLElBQUksQ0FBQ04sT0FBTyxDQUFDVixNQUFNLENBQUNpQixRQUFRLENBQUNGLEtBQUtGLEtBQUssQ0FBQ1AsS0FBSztRQUM5RCxNQUFNQSxRQUFRVSxXQUNSRCxLQUFLRixLQUFLLENBQUNQLEtBQUssR0FDaEIsSUFBSSxDQUFDSSxPQUFPLENBQUNWLE1BQU0sQ0FBQyxFQUFFO1FBQzVCLE9BQU87WUFBQyxDQUFDLENBQUMsRUFBRU0sTUFBTSxDQUFDO1lBQUVaLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2dCLE9BQU8sQ0FBQ1QsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ3pGO0lBQ0FpQjtRQUNJLE9BQU87WUFDSEMsWUFBWUMsQ0FBQUEsYUFBYyxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDbkMsSUFBSSxDQUFDLElBQUksQ0FBQ1gsT0FBTyxDQUFDVixNQUFNLENBQUNpQixRQUFRLENBQUNHLFdBQVdkLEtBQUssR0FBRzt3QkFDakQsT0FBTztvQkFDWDtvQkFDQSxPQUFPZSxTQUFTQyxPQUFPLENBQUMsSUFBSSxDQUFDeEIsSUFBSSxFQUFFc0I7Z0JBQ3ZDO1lBQ0FHLGVBQWVILENBQUFBLGFBQWMsQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQ3RDLElBQUksQ0FBQyxJQUFJLENBQUNYLE9BQU8sQ0FBQ1YsTUFBTSxDQUFDaUIsUUFBUSxDQUFDRyxXQUFXZCxLQUFLLEdBQUc7d0JBQ2pELE9BQU87b0JBQ1g7b0JBQ0EsT0FBT2UsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQzFCLElBQUksRUFBRSxhQUFhc0I7Z0JBQ3ZEO1FBQ0o7SUFDSjtJQUNBSztRQUNJLE9BQU8sSUFBSSxDQUFDZixPQUFPLENBQUNWLE1BQU0sQ0FBQzBCLE1BQU0sQ0FBQyxDQUFDQyxPQUFPckIsUUFBVztnQkFDakQsR0FBR3FCLEtBQUs7Z0JBQ1IsR0FBRztvQkFDQyxDQUFDLENBQUMsUUFBUSxFQUFFckIsTUFBTSxDQUFDLENBQUMsRUFBRSxJQUFNLElBQUksQ0FBQ3NCLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxhQUFhLENBQUM7NEJBQUVqQjt3QkFBTTtnQkFDM0UsQ0FBQztZQUNMLElBQUksQ0FBQztJQUNUO0lBQ0F1QjtRQUNJLE9BQU8sSUFBSSxDQUFDbkIsT0FBTyxDQUFDVixNQUFNLENBQUNXLEdBQUcsQ0FBQ0wsQ0FBQUE7WUFDM0IsT0FBT1gsb0VBQXNCQSxDQUFDO2dCQUMxQm1DLE1BQU0sSUFBSUMsT0FBTyxDQUFDLElBQUksRUFBRUMsS0FBS0MsR0FBRyxJQUFJLElBQUksQ0FBQ3ZCLE9BQU8sQ0FBQ1YsTUFBTSxFQUFFLENBQUMsRUFBRU0sTUFBTSxNQUFNLENBQUM7Z0JBQ3pFNEIsTUFBTSxJQUFJLENBQUNBLElBQUk7Z0JBQ2ZDLGVBQWU7b0JBQ1g3QjtnQkFDSjtZQUNKO1FBQ0o7SUFDSjtBQUNKO0FBRXVDLENBQ3ZDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcvZGlzdC9pbmRleC5qcz9kMzA2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgaGVhZGluZ3MuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hlYWRpbmdcbiAqL1xuY29uc3QgSGVhZGluZyA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnaGVhZGluZycsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxldmVsczogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29udGVudDogJ2lubGluZSonLFxuICAgIGdyb3VwOiAnYmxvY2snLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZXZlbDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHNcbiAgICAgICAgICAgIC5tYXAoKGxldmVsKSA9PiAoe1xuICAgICAgICAgICAgdGFnOiBgaCR7bGV2ZWx9YCxcbiAgICAgICAgICAgIGF0dHJzOiB7IGxldmVsIH0sXG4gICAgICAgIH0pKTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIGNvbnN0IGhhc0xldmVsID0gdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhub2RlLmF0dHJzLmxldmVsKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBoYXNMZXZlbFxuICAgICAgICAgICAgPyBub2RlLmF0dHJzLmxldmVsXG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5sZXZlbHNbMF07XG4gICAgICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEhlYWRpbmc6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlSGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCAncGFyYWdyYXBoJywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLnJlZHVjZSgoaXRlbXMsIGxldmVsKSA9PiAoe1xuICAgICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgW2BNb2QtQWx0LSR7bGV2ZWx9YF06ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbCB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCB7fSk7XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5tYXAobGV2ZWwgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoYF4oI3ske01hdGgubWluKC4uLnRoaXMub3B0aW9ucy5sZXZlbHMpfSwke2xldmVsfX0pXFxcXHMkYCksXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEhlYWRpbmcsIEhlYWRpbmcgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsInRleHRibG9ja1R5cGVJbnB1dFJ1bGUiLCJIZWFkaW5nIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJsZXZlbHMiLCJIVE1MQXR0cmlidXRlcyIsImNvbnRlbnQiLCJncm91cCIsImRlZmluaW5nIiwiYWRkQXR0cmlidXRlcyIsImxldmVsIiwiZGVmYXVsdCIsInJlbmRlcmVkIiwicGFyc2VIVE1MIiwib3B0aW9ucyIsIm1hcCIsInRhZyIsImF0dHJzIiwicmVuZGVySFRNTCIsIm5vZGUiLCJoYXNMZXZlbCIsImluY2x1ZGVzIiwiYWRkQ29tbWFuZHMiLCJzZXRIZWFkaW5nIiwiYXR0cmlidXRlcyIsImNvbW1hbmRzIiwic2V0Tm9kZSIsInRvZ2dsZUhlYWRpbmciLCJ0b2dnbGVOb2RlIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJyZWR1Y2UiLCJpdGVtcyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwiUmVnRXhwIiwiTWF0aCIsIm1pbiIsInR5cGUiLCJnZXRBdHRyaWJ1dGVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-highlight/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-highlight/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Highlight: () => (/* binding */ Highlight),\n/* harmony export */   \"default\": () => (/* binding */ Highlight),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches a highlight to a ==highlight== on input.\n */ const inputRegex = /(?:^|\\s)(==(?!\\s+==)((?:[^=]+))==(?!\\s+==))$/;\n/**\n * Matches a highlight to a ==highlight== on paste.\n */ const pasteRegex = /(?:^|\\s)(==(?!\\s+==)((?:[^=]+))==(?!\\s+==))/g;\n/**\n * This extension allows you to highlight text.\n * @see https://www.tiptap.dev/api/marks/highlight\n */ const Highlight = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"highlight\",\n    addOptions () {\n        return {\n            multicolor: false,\n            HTMLAttributes: {}\n        };\n    },\n    addAttributes () {\n        if (!this.options.multicolor) {\n            return {};\n        }\n        return {\n            color: {\n                default: null,\n                parseHTML: (element)=>element.getAttribute(\"data-color\") || element.style.backgroundColor,\n                renderHTML: (attributes)=>{\n                    if (!attributes.color) {\n                        return {};\n                    }\n                    return {\n                        \"data-color\": attributes.color,\n                        style: `background-color: ${attributes.color}; color: inherit`\n                    };\n                }\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"mark\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"mark\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setHighlight: (attributes)=>({ commands })=>{\n                    return commands.setMark(this.name, attributes);\n                },\n            toggleHighlight: (attributes)=>({ commands })=>{\n                    return commands.toggleMark(this.name, attributes);\n                },\n            unsetHighlight: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-h\": ()=>this.editor.commands.toggleHighlight()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlnaGxpZ2h0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUY7QUFFbkY7O0NBRUMsR0FDRCxNQUFNSSxhQUFhO0FBQ25COztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQjs7O0NBR0MsR0FDRCxNQUFNQyxZQUFZTiw4Q0FBSUEsQ0FBQ08sTUFBTSxDQUFDO0lBQzFCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxZQUFZO1lBQ1pDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUM7UUFDSSxJQUFJLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUNILFVBQVUsRUFBRTtZQUMxQixPQUFPLENBQUM7UUFDWjtRQUNBLE9BQU87WUFDSEksT0FBTztnQkFDSEMsU0FBUztnQkFDVEMsV0FBV0MsQ0FBQUEsVUFBV0EsUUFBUUMsWUFBWSxDQUFDLGlCQUFpQkQsUUFBUUUsS0FBSyxDQUFDQyxlQUFlO2dCQUN6RkMsWUFBWUMsQ0FBQUE7b0JBQ1IsSUFBSSxDQUFDQSxXQUFXUixLQUFLLEVBQUU7d0JBQ25CLE9BQU8sQ0FBQztvQkFDWjtvQkFDQSxPQUFPO3dCQUNILGNBQWNRLFdBQVdSLEtBQUs7d0JBQzlCSyxPQUFPLENBQUMsa0JBQWtCLEVBQUVHLFdBQVdSLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQztvQkFDbEU7Z0JBQ0o7WUFDSjtRQUNKO0lBQ0o7SUFDQUU7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lPLEtBQUs7WUFDVDtTQUNIO0lBQ0w7SUFDQUYsWUFBVyxFQUFFVixjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQVFWLDZEQUFlQSxDQUFDLElBQUksQ0FBQ1ksT0FBTyxDQUFDRixjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDcEY7SUFDQWE7UUFDSSxPQUFPO1lBQ0hDLGNBQWNILENBQUFBLGFBQWMsQ0FBQyxFQUFFSSxRQUFRLEVBQUU7b0JBQ3JDLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNuQixJQUFJLEVBQUVjO2dCQUN2QztZQUNBTSxpQkFBaUJOLENBQUFBLGFBQWMsQ0FBQyxFQUFFSSxRQUFRLEVBQUU7b0JBQ3hDLE9BQU9BLFNBQVNHLFVBQVUsQ0FBQyxJQUFJLENBQUNyQixJQUFJLEVBQUVjO2dCQUMxQztZQUNBUSxnQkFBZ0IsSUFBTSxDQUFDLEVBQUVKLFFBQVEsRUFBRTtvQkFDL0IsT0FBT0EsU0FBU0ssU0FBUyxDQUFDLElBQUksQ0FBQ3ZCLElBQUk7Z0JBQ3ZDO1FBQ0o7SUFDSjtJQUNBd0I7UUFDSSxPQUFPO1lBQ0gsZUFBZSxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDUCxRQUFRLENBQUNFLGVBQWU7UUFDN0Q7SUFDSjtJQUNBTTtRQUNJLE9BQU87WUFDSGhDLDJEQUFhQSxDQUFDO2dCQUNWaUMsTUFBTS9CO2dCQUNOZ0MsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0lBQ0FDO1FBQ0ksT0FBTztZQUNIbEMsMkRBQWFBLENBQUM7Z0JBQ1ZnQyxNQUFNOUI7Z0JBQ04rQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUVtRSxDQUNuRSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oaWdobGlnaHQvZGlzdC9pbmRleC5qcz8xYzkyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhIGhpZ2hsaWdodCB0byBhID09aGlnaGxpZ2h0PT0gb24gaW5wdXQuXG4gKi9cbmNvbnN0IGlucHV0UmVnZXggPSAvKD86XnxcXHMpKD09KD8hXFxzKz09KSgoPzpbXj1dKykpPT0oPyFcXHMrPT0pKSQvO1xuLyoqXG4gKiBNYXRjaGVzIGEgaGlnaGxpZ2h0IHRvIGEgPT1oaWdobGlnaHQ9PSBvbiBwYXN0ZS5cbiAqL1xuY29uc3QgcGFzdGVSZWdleCA9IC8oPzpefFxccykoPT0oPyFcXHMrPT0pKCg/OltePV0rKSk9PSg/IVxccys9PSkpL2c7XG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gaGlnaGxpZ2h0IHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL2hpZ2hsaWdodFxuICovXG5jb25zdCBIaWdobGlnaHQgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2hpZ2hsaWdodCcsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG11bHRpY29sb3I6IGZhbHNlLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGljb2xvcikge1xuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvcjoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbG9yJykgfHwgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXR0cmlidXRlcy5jb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnZGF0YS1jb2xvcic6IGF0dHJpYnV0ZXMuY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7YXR0cmlidXRlcy5jb2xvcn07IGNvbG9yOiBpbmhlcml0YCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdtYXJrJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydtYXJrJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0SGlnaGxpZ2h0OiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUhpZ2hsaWdodDogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldEhpZ2hsaWdodDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtU2hpZnQtaCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhpZ2hsaWdodCgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogcGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEhpZ2hsaWdodCwgSGlnaGxpZ2h0IGFzIGRlZmF1bHQsIGlucHV0UmVnZXgsIHBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1hcmsiLCJtZXJnZUF0dHJpYnV0ZXMiLCJtYXJrSW5wdXRSdWxlIiwibWFya1Bhc3RlUnVsZSIsImlucHV0UmVnZXgiLCJwYXN0ZVJlZ2V4IiwiSGlnaGxpZ2h0IiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJtdWx0aWNvbG9yIiwiSFRNTEF0dHJpYnV0ZXMiLCJhZGRBdHRyaWJ1dGVzIiwib3B0aW9ucyIsImNvbG9yIiwiZGVmYXVsdCIsInBhcnNlSFRNTCIsImVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciIsInJlbmRlckhUTUwiLCJhdHRyaWJ1dGVzIiwidGFnIiwiYWRkQ29tbWFuZHMiLCJzZXRIaWdobGlnaHQiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVIaWdobGlnaHQiLCJ0b2dnbGVNYXJrIiwidW5zZXRIaWdobGlnaHQiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImFkZElucHV0UnVsZXMiLCJmaW5kIiwidHlwZSIsImFkZFBhc3RlUnVsZXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-highlight/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-history/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   History: () => (/* binding */ History),\n/* harmony export */   \"default\": () => (/* binding */ History)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/history */ \"(ssr)/./node_modules/@tiptap/pm/history/dist/index.js\");\n\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */ const History = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: \"history\",\n    addOptions () {\n        return {\n            depth: 100,\n            newGroupDelay: 500\n        };\n    },\n    addCommands () {\n        return {\n            undo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.undo)(state, dispatch);\n                },\n            redo: ()=>({ state, dispatch })=>{\n                    return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.redo)(state, dispatch);\n                }\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.history)(this.options)\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-z\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-z\": ()=>this.editor.commands.redo(),\n            \"Mod-y\": ()=>this.editor.commands.redo(),\n            // Russian keyboard layouts\n            \"Mod-я\": ()=>this.editor.commands.undo(),\n            \"Shift-Mod-я\": ()=>this.editor.commands.redo()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBeUM7QUFDZ0I7QUFFekQ7Ozs7Ozs7O0NBUUMsR0FDRCxNQUFNSSxVQUFVSixtREFBU0EsQ0FBQ0ssTUFBTSxDQUFDO0lBQzdCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxPQUFPO1lBQ1BDLGVBQWU7UUFDbkI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSFQsTUFBTSxJQUFNLENBQUMsRUFBRVUsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQzVCLE9BQU9YLHdEQUFJQSxDQUFDVSxPQUFPQztnQkFDdkI7WUFDQVYsTUFBTSxJQUFNLENBQUMsRUFBRVMsS0FBSyxFQUFFQyxRQUFRLEVBQUU7b0JBQzVCLE9BQU9WLHdEQUFJQSxDQUFDUyxPQUFPQztnQkFDdkI7UUFDSjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIViwyREFBT0EsQ0FBQyxJQUFJLENBQUNXLE9BQU87U0FDdkI7SUFDTDtJQUNBQztRQUNJLE9BQU87WUFDSCxTQUFTLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNDLFFBQVEsQ0FBQ2hCLElBQUk7WUFDeEMsZUFBZSxJQUFNLElBQUksQ0FBQ2UsTUFBTSxDQUFDQyxRQUFRLENBQUNmLElBQUk7WUFDOUMsU0FBUyxJQUFNLElBQUksQ0FBQ2MsTUFBTSxDQUFDQyxRQUFRLENBQUNmLElBQUk7WUFDeEMsMkJBQTJCO1lBQzNCLFNBQVMsSUFBTSxJQUFJLENBQUNjLE1BQU0sQ0FBQ0MsUUFBUSxDQUFDaEIsSUFBSTtZQUN4QyxlQUFlLElBQU0sSUFBSSxDQUFDZSxNQUFNLENBQUNDLFFBQVEsQ0FBQ2YsSUFBSTtRQUNsRDtJQUNKO0FBQ0o7QUFFdUMsQ0FDdkMsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeS9kaXN0L2luZGV4LmpzPzI2ZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0ZW5zaW9uIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IHVuZG8sIHJlZG8sIGhpc3RvcnkgfSBmcm9tICdAdGlwdGFwL3BtL2hpc3RvcnknO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gdW5kbyBhbmQgcmVkbyByZWNlbnQgY2hhbmdlcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9oaXN0b3J5XG4gKlxuICogKipJbXBvcnRhbnQqKjogSWYgdGhlIGBAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uYCBwYWNrYWdlIGlzIHVzZWQsIG1ha2Ugc3VyZSB0byByZW1vdmVcbiAqIHRoZSBgaGlzdG9yeWAgZXh0ZW5zaW9uLCBhcyBpdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZSBgY29sbGFib3JhdGlvbmAgZXh0ZW5zaW9uLlxuICpcbiAqIGBAdGlwdGFwL2V4dGVuc2lvbi1jb2xsYWJvcmF0aW9uYCB1c2VzIGl0cyBvd24gaGlzdG9yeSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY29uc3QgSGlzdG9yeSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdoaXN0b3J5JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGVwdGg6IDEwMCxcbiAgICAgICAgICAgIG5ld0dyb3VwRGVsYXk6IDUwMCxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5kbzogKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kbyhzdGF0ZSwgZGlzcGF0Y2gpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZG8oc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoaXN0b3J5KHRoaXMub3B0aW9ucyksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICAgICAgICdTaGlmdC1Nb2Qteic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgICAgICAgICdNb2QteSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlZG8oKSxcbiAgICAgICAgICAgIC8vIFJ1c3NpYW4ga2V5Ym9hcmQgbGF5b3V0c1xuICAgICAgICAgICAgJ01vZC3Rjyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnVuZG8oKSxcbiAgICAgICAgICAgICdTaGlmdC1Nb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBIaXN0b3J5LCBIaXN0b3J5IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkV4dGVuc2lvbiIsInVuZG8iLCJyZWRvIiwiaGlzdG9yeSIsIkhpc3RvcnkiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsImRlcHRoIiwibmV3R3JvdXBEZWxheSIsImFkZENvbW1hbmRzIiwic3RhdGUiLCJkaXNwYXRjaCIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsIm9wdGlvbnMiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImNvbW1hbmRzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: () => (/* binding */ HorizontalRule),\n/* harmony export */   \"default\": () => (/* binding */ HorizontalRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */ const HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: \"horizontalRule\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block\",\n    parseHTML () {\n        return [\n            {\n                tag: \"hr\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"hr\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)\n        ];\n    },\n    addCommands () {\n        return {\n            setHorizontalRule: ()=>({ chain, state })=>{\n                    // Check if we can insert the node at the current selection\n                    if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.canInsertNode)(state, state.schema.nodes[this.name])) {\n                        return false;\n                    }\n                    const { selection } = state;\n                    const { $from: $originFrom, $to: $originTo } = selection;\n                    const currentChain = chain();\n                    if ($originFrom.parentOffset === 0) {\n                        currentChain.insertContentAt({\n                            from: Math.max($originFrom.pos - 1, 0),\n                            to: $originTo.pos\n                        }, {\n                            type: this.name\n                        });\n                    } else if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(selection)) {\n                        currentChain.insertContentAt($originTo.pos, {\n                            type: this.name\n                        });\n                    } else {\n                        currentChain.insertContent({\n                            type: this.name\n                        });\n                    }\n                    return currentChain// set cursor after horizontal rule\n                    .command(({ tr, dispatch })=>{\n                        var _a;\n                        if (dispatch) {\n                            const { $to } = tr.selection;\n                            const posAfter = $to.end();\n                            if ($to.nodeAfter) {\n                                if ($to.nodeAfter.isTextblock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n                                } else if ($to.nodeAfter.isBlock) {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n                                } else {\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n                                }\n                            } else {\n                                // add node after horizontal rule if it’s the end of the document\n                                const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n                                if (node) {\n                                    tr.insert(posAfter, node);\n                                    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n                                }\n                            }\n                            tr.scrollIntoView();\n                        }\n                        return true;\n                    }).run();\n                }\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n                find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFvRztBQUNwQztBQUVoRTs7O0NBR0MsR0FDRCxNQUFNTyxpQkFBaUJQLDhDQUFJQSxDQUFDUSxNQUFNLENBQUM7SUFDL0JDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUMsT0FBTztJQUNQQztRQUNJLE9BQU87WUFBQztnQkFBRUMsS0FBSztZQUFLO1NBQUU7SUFDMUI7SUFDQUMsWUFBVyxFQUFFSixjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQU1WLDZEQUFlQSxDQUFDLElBQUksQ0FBQ2UsT0FBTyxDQUFDTCxjQUFjLEVBQUVBO1NBQWdCO0lBQy9FO0lBQ0FNO1FBQ0ksT0FBTztZQUNIQyxtQkFBbUIsSUFBTSxDQUFDLEVBQUVDLEtBQUssRUFBRUMsS0FBSyxFQUFFO29CQUN0QywyREFBMkQ7b0JBQzNELElBQUksQ0FBQ2xCLDJEQUFhQSxDQUFDa0IsT0FBT0EsTUFBTUMsTUFBTSxDQUFDQyxLQUFLLENBQUMsSUFBSSxDQUFDYixJQUFJLENBQUMsR0FBRzt3QkFDdEQsT0FBTztvQkFDWDtvQkFDQSxNQUFNLEVBQUVjLFNBQVMsRUFBRSxHQUFHSDtvQkFDdEIsTUFBTSxFQUFFSSxPQUFPQyxXQUFXLEVBQUVDLEtBQUtDLFNBQVMsRUFBRSxHQUFHSjtvQkFDL0MsTUFBTUssZUFBZVQ7b0JBQ3JCLElBQUlNLFlBQVlJLFlBQVksS0FBSyxHQUFHO3dCQUNoQ0QsYUFBYUUsZUFBZSxDQUFDOzRCQUN6QkMsTUFBTUMsS0FBS0MsR0FBRyxDQUFDUixZQUFZUyxHQUFHLEdBQUcsR0FBRzs0QkFDcENDLElBQUlSLFVBQVVPLEdBQUc7d0JBQ3JCLEdBQUc7NEJBQ0NFLE1BQU0sSUFBSSxDQUFDM0IsSUFBSTt3QkFDbkI7b0JBQ0osT0FDSyxJQUFJTiw2REFBZUEsQ0FBQ29CLFlBQVk7d0JBQ2pDSyxhQUFhRSxlQUFlLENBQUNILFVBQVVPLEdBQUcsRUFBRTs0QkFDeENFLE1BQU0sSUFBSSxDQUFDM0IsSUFBSTt3QkFDbkI7b0JBQ0osT0FDSzt3QkFDRG1CLGFBQWFTLGFBQWEsQ0FBQzs0QkFBRUQsTUFBTSxJQUFJLENBQUMzQixJQUFJO3dCQUFDO29CQUNqRDtvQkFDQSxPQUFRbUIsWUFDSixtQ0FBbUM7cUJBQ2xDVSxPQUFPLENBQUMsQ0FBQyxFQUFFQyxFQUFFLEVBQUVDLFFBQVEsRUFBRTt3QkFDMUIsSUFBSUM7d0JBQ0osSUFBSUQsVUFBVTs0QkFDVixNQUFNLEVBQUVkLEdBQUcsRUFBRSxHQUFHYSxHQUFHaEIsU0FBUzs0QkFDNUIsTUFBTW1CLFdBQVdoQixJQUFJaUIsR0FBRzs0QkFDeEIsSUFBSWpCLElBQUlrQixTQUFTLEVBQUU7Z0NBQ2YsSUFBSWxCLElBQUlrQixTQUFTLENBQUNDLFdBQVcsRUFBRTtvQ0FDM0JOLEdBQUdPLFlBQVksQ0FBQ3pDLDJEQUFhQSxDQUFDRyxNQUFNLENBQUMrQixHQUFHUSxHQUFHLEVBQUVyQixJQUFJUSxHQUFHLEdBQUc7Z0NBQzNELE9BQ0ssSUFBSVIsSUFBSWtCLFNBQVMsQ0FBQ0ksT0FBTyxFQUFFO29DQUM1QlQsR0FBR08sWUFBWSxDQUFDeEMsMkRBQWFBLENBQUNFLE1BQU0sQ0FBQytCLEdBQUdRLEdBQUcsRUFBRXJCLElBQUlRLEdBQUc7Z0NBQ3hELE9BQ0s7b0NBQ0RLLEdBQUdPLFlBQVksQ0FBQ3pDLDJEQUFhQSxDQUFDRyxNQUFNLENBQUMrQixHQUFHUSxHQUFHLEVBQUVyQixJQUFJUSxHQUFHO2dDQUN4RDs0QkFDSixPQUNLO2dDQUNELGlFQUFpRTtnQ0FDakUsTUFBTWUsT0FBTyxDQUFDUixLQUFLZixJQUFJd0IsTUFBTSxDQUFDZCxJQUFJLENBQUNlLFlBQVksQ0FBQ0MsV0FBVyxNQUFNLFFBQVFYLE9BQU8sS0FBSyxJQUFJLEtBQUssSUFBSUEsR0FBR2pDLE1BQU07Z0NBQzNHLElBQUl5QyxNQUFNO29DQUNOVixHQUFHYyxNQUFNLENBQUNYLFVBQVVPO29DQUNwQlYsR0FBR08sWUFBWSxDQUFDekMsMkRBQWFBLENBQUNHLE1BQU0sQ0FBQytCLEdBQUdRLEdBQUcsRUFBRUwsV0FBVztnQ0FDNUQ7NEJBQ0o7NEJBQ0FILEdBQUdlLGNBQWM7d0JBQ3JCO3dCQUNBLE9BQU87b0JBQ1gsR0FDS0MsR0FBRztnQkFDWjtRQUNKO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0hwRCwyREFBYUEsQ0FBQztnQkFDVnFELE1BQU07Z0JBQ05yQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUVxRCxDQUNyRCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUvZGlzdC9pbmRleC5qcz8yNzAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgY2FuSW5zZXJ0Tm9kZSwgaXNOb2RlU2VsZWN0aW9uLCBub2RlSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmltcG9ydCB7IFRleHRTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24gfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGluc2VydCBob3Jpem9udGFsIHJ1bGVzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9ob3Jpem9udGFsLXJ1bGVcbiAqL1xuY29uc3QgSG9yaXpvbnRhbFJ1bGUgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2hvcml6b250YWxSdWxlJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ3JvdXA6ICdibG9jaycsXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW3sgdGFnOiAnaHInIH1dO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnaHInLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyldO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRIb3Jpem9udGFsUnVsZTogKCkgPT4gKHsgY2hhaW4sIHN0YXRlIH0pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gaW5zZXJ0IHRoZSBub2RlIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGlmICghY2FuSW5zZXJ0Tm9kZShzdGF0ZSwgc3RhdGUuc2NoZW1hLm5vZGVzW3RoaXMubmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgJGZyb206ICRvcmlnaW5Gcm9tLCAkdG86ICRvcmlnaW5UbyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGFpbiA9IGNoYWluKCk7XG4gICAgICAgICAgICAgICAgaWYgKCRvcmlnaW5Gcm9tLnBhcmVudE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2hhaW4uaW5zZXJ0Q29udGVudEF0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb206IE1hdGgubWF4KCRvcmlnaW5Gcm9tLnBvcyAtIDEsIDApLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86ICRvcmlnaW5Uby5wb3MsXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTm9kZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50QXQoJG9yaWdpblRvLnBvcywge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50KHsgdHlwZTogdGhpcy5uYW1lIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKGN1cnJlbnRDaGFpblxuICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY3Vyc29yIGFmdGVyIGhvcml6b250YWwgcnVsZVxuICAgICAgICAgICAgICAgICAgICAuY29tbWFuZCgoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyAkdG8gfSA9IHRyLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc0FmdGVyID0gJHRvLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR0by5ub2RlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlci5pc1RleHRibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICgkdG8ubm9kZUFmdGVyLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJHRvLnBvcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFkZCBub2RlIGFmdGVyIGhvcml6b250YWwgcnVsZSBpZiBpdOKAmXMgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gKF9hID0gJHRvLnBhcmVudC50eXBlLmNvbnRlbnRNYXRjaC5kZWZhdWx0VHlwZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNyZWF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmluc2VydChwb3NBZnRlciwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHBvc0FmdGVyICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLnJ1bigpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbm9kZUlucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogL14oPzotLS184oCULXxfX19cXHN8XFwqXFwqXFwqXFxzKSQvLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgSG9yaXpvbnRhbFJ1bGUsIEhvcml6b250YWxSdWxlIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJjYW5JbnNlcnROb2RlIiwiaXNOb2RlU2VsZWN0aW9uIiwibm9kZUlucHV0UnVsZSIsIlRleHRTZWxlY3Rpb24iLCJOb2RlU2VsZWN0aW9uIiwiSG9yaXpvbnRhbFJ1bGUiLCJjcmVhdGUiLCJuYW1lIiwiYWRkT3B0aW9ucyIsIkhUTUxBdHRyaWJ1dGVzIiwiZ3JvdXAiLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0SG9yaXpvbnRhbFJ1bGUiLCJjaGFpbiIsInN0YXRlIiwic2NoZW1hIiwibm9kZXMiLCJzZWxlY3Rpb24iLCIkZnJvbSIsIiRvcmlnaW5Gcm9tIiwiJHRvIiwiJG9yaWdpblRvIiwiY3VycmVudENoYWluIiwicGFyZW50T2Zmc2V0IiwiaW5zZXJ0Q29udGVudEF0IiwiZnJvbSIsIk1hdGgiLCJtYXgiLCJwb3MiLCJ0byIsInR5cGUiLCJpbnNlcnRDb250ZW50IiwiY29tbWFuZCIsInRyIiwiZGlzcGF0Y2giLCJfYSIsInBvc0FmdGVyIiwiZW5kIiwibm9kZUFmdGVyIiwiaXNUZXh0YmxvY2siLCJzZXRTZWxlY3Rpb24iLCJkb2MiLCJpc0Jsb2NrIiwibm9kZSIsInBhcmVudCIsImNvbnRlbnRNYXRjaCIsImRlZmF1bHRUeXBlIiwiaW5zZXJ0Iiwic2Nyb2xsSW50b1ZpZXciLCJydW4iLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: () => (/* binding */ Italic),\n/* harmony export */   \"default\": () => (/* binding */ Italic),\n/* harmony export */   starInputRegex: () => (/* binding */ starInputRegex),\n/* harmony export */   starPasteRegex: () => (/* binding */ starPasteRegex),\n/* harmony export */   underscoreInputRegex: () => (/* binding */ underscoreInputRegex),\n/* harmony export */   underscorePasteRegex: () => (/* binding */ underscorePasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches an italic to a *italic* on input.\n */ const starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\n/**\n * Matches an italic to a *italic* on paste.\n */ const starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\n/**\n * Matches an italic to a _italic_ on input.\n */ const underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\n/**\n * Matches an italic to a _italic_ on paste.\n */ const underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */ const Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"italic\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"em\"\n            },\n            {\n                tag: \"i\",\n                getAttrs: (node)=>node.style.fontStyle !== \"normal\" && null\n            },\n            {\n                style: \"font-style=normal\",\n                clearMark: (mark)=>mark.type.name === this.name\n            },\n            {\n                style: \"font-style=italic\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"em\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setItalic: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleItalic: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetItalic: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-i\": ()=>this.editor.commands.toggleItalic(),\n            \"Mod-I\": ()=>this.editor.commands.toggleItalic()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRjtBQUVuRjs7Q0FFQyxHQUNELE1BQU1JLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLGlCQUFpQjtBQUN2Qjs7Q0FFQyxHQUNELE1BQU1DLHVCQUF1QjtBQUM3Qjs7Q0FFQyxHQUNELE1BQU1DLHVCQUF1QjtBQUM3Qjs7O0NBR0MsR0FDRCxNQUFNQyxTQUFTUiw4Q0FBSUEsQ0FBQ1MsTUFBTSxDQUFDO0lBQ3ZCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztRQUNyQjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIO2dCQUNJQyxLQUFLO1lBQ1Q7WUFDQTtnQkFDSUEsS0FBSztnQkFDTEMsVUFBVUMsQ0FBQUEsT0FBUUEsS0FBS0MsS0FBSyxDQUFDQyxTQUFTLEtBQUssWUFBWTtZQUMzRDtZQUNBO2dCQUNJRCxPQUFPO2dCQUNQRSxXQUFXQyxDQUFBQSxPQUFRQSxLQUFLQyxJQUFJLENBQUNYLElBQUksS0FBSyxJQUFJLENBQUNBLElBQUk7WUFDbkQ7WUFDQTtnQkFDSU8sT0FBTztZQUNYO1NBQ0g7SUFDTDtJQUNBSyxZQUFXLEVBQUVWLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTVgsNkRBQWVBLENBQUMsSUFBSSxDQUFDc0IsT0FBTyxDQUFDWCxjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDbEY7SUFDQVk7UUFDSSxPQUFPO1lBQ0hDLFdBQVcsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDMUIsT0FBT0EsU0FBU0MsT0FBTyxDQUFDLElBQUksQ0FBQ2pCLElBQUk7Z0JBQ3JDO1lBQ0FrQixjQUFjLElBQU0sQ0FBQyxFQUFFRixRQUFRLEVBQUU7b0JBQzdCLE9BQU9BLFNBQVNHLFVBQVUsQ0FBQyxJQUFJLENBQUNuQixJQUFJO2dCQUN4QztZQUNBb0IsYUFBYSxJQUFNLENBQUMsRUFBRUosUUFBUSxFQUFFO29CQUM1QixPQUFPQSxTQUFTSyxTQUFTLENBQUMsSUFBSSxDQUFDckIsSUFBSTtnQkFDdkM7UUFDSjtJQUNKO0lBQ0FzQjtRQUNJLE9BQU87WUFDSCxTQUFTLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsWUFBWTtZQUNoRCxTQUFTLElBQU0sSUFBSSxDQUFDSyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsWUFBWTtRQUNwRDtJQUNKO0lBQ0FNO1FBQ0ksT0FBTztZQUNIaEMsMkRBQWFBLENBQUM7Z0JBQ1ZpQyxNQUFNL0I7Z0JBQ05pQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtZQUNBbkIsMkRBQWFBLENBQUM7Z0JBQ1ZpQyxNQUFNN0I7Z0JBQ05lLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtJQUNBZTtRQUNJLE9BQU87WUFDSGpDLDJEQUFhQSxDQUFDO2dCQUNWZ0MsTUFBTTlCO2dCQUNOZ0IsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7WUFDQWxCLDJEQUFhQSxDQUFDO2dCQUNWZ0MsTUFBTTVCO2dCQUNOYyxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNuQjtTQUNIO0lBQ0w7QUFDSjtBQUVpSCxDQUNqSCxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvZGlzdC9pbmRleC5qcz8xMzc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSAqaXRhbGljKiBvbiBpbnB1dC5cbiAqL1xuY29uc3Qgc3RhcklucHV0UmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkkLztcbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSAqaXRhbGljKiBvbiBwYXN0ZS5cbiAqL1xuY29uc3Qgc3RhclBhc3RlUmVnZXggPSAvKD86XnxcXHMpKFxcKig/IVxccytcXCopKCg/OlteKl0rKSlcXCooPyFcXHMrXFwqKSkvZztcbi8qKlxuICogTWF0Y2hlcyBhbiBpdGFsaWMgdG8gYSBfaXRhbGljXyBvbiBpbnB1dC5cbiAqL1xuY29uc3QgdW5kZXJzY29yZUlucHV0UmVnZXggPSAvKD86XnxcXHMpKF8oPyFcXHMrXykoKD86W15fXSspKV8oPyFcXHMrXykpJC87XG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgX2l0YWxpY18gb24gcGFzdGUuXG4gKi9cbmNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKS9nO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBpdGFsaWMgdGV4dC5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3MvaXRhbGljXG4gKi9cbmNvbnN0IEl0YWxpYyA9IE1hcmsuY3JlYXRlKHtcbiAgICBuYW1lOiAnaXRhbGljJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ2VtJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnaScsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gbm9kZS5zdHlsZS5mb250U3R5bGUgIT09ICdub3JtYWwnICYmIG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC1zdHlsZT1ub3JtYWwnLFxuICAgICAgICAgICAgICAgIGNsZWFyTWFyazogbWFyayA9PiBtYXJrLnR5cGUubmFtZSA9PT0gdGhpcy5uYW1lLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtc3R5bGU9aXRhbGljJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydlbScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlSXRhbGljOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldEl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtaSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgICAgICAgJ01vZC1JJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlSXRhbGljKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogc3RhcklucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlSW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBzdGFyUGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgSXRhbGljLCBJdGFsaWMgYXMgZGVmYXVsdCwgc3RhcklucHV0UmVnZXgsIHN0YXJQYXN0ZVJlZ2V4LCB1bmRlcnNjb3JlSW5wdXRSZWdleCwgdW5kZXJzY29yZVBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk1hcmsiLCJtZXJnZUF0dHJpYnV0ZXMiLCJtYXJrSW5wdXRSdWxlIiwibWFya1Bhc3RlUnVsZSIsInN0YXJJbnB1dFJlZ2V4Iiwic3RhclBhc3RlUmVnZXgiLCJ1bmRlcnNjb3JlSW5wdXRSZWdleCIsInVuZGVyc2NvcmVQYXN0ZVJlZ2V4IiwiSXRhbGljIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsInBhcnNlSFRNTCIsInRhZyIsImdldEF0dHJzIiwibm9kZSIsInN0eWxlIiwiZm9udFN0eWxlIiwiY2xlYXJNYXJrIiwibWFyayIsInR5cGUiLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0SXRhbGljIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlSXRhbGljIiwidG9nZ2xlTWFyayIsInVuc2V0SXRhbGljIiwidW5zZXRNYXJrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsImFkZFBhc3RlUnVsZXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListItem: () => (/* binding */ ListItem),\n/* harmony export */   \"default\": () => (/* binding */ ListItem)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */ const ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"listItem\",\n    addOptions () {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: \"bulletList\",\n            orderedListTypeName: \"orderedList\"\n        };\n    },\n    content: \"paragraph block*\",\n    defining: true,\n    parseHTML () {\n        return [\n            {\n                tag: \"li\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addKeyboardShortcuts () {\n        return {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            Tab: ()=>this.editor.commands.sinkListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tbGlzdC1pdGVtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFdBQVdGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDekJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1lBQ2pCQyxvQkFBb0I7WUFDcEJDLHFCQUFxQjtRQUN6QjtJQUNKO0lBQ0FDLFNBQVM7SUFDVEMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSDtnQkFDSUMsS0FBSztZQUNUO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTUwsNkRBQWVBLENBQUMsSUFBSSxDQUFDYSxPQUFPLENBQUNSLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUNsRjtJQUNBUztRQUNJLE9BQU87WUFDSEMsT0FBTyxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDQyxRQUFRLENBQUNDLGFBQWEsQ0FBQyxJQUFJLENBQUNmLElBQUk7WUFDekRnQixLQUFLLElBQU0sSUFBSSxDQUFDSCxNQUFNLENBQUNDLFFBQVEsQ0FBQ0csWUFBWSxDQUFDLElBQUksQ0FBQ2pCLElBQUk7WUFDdEQsYUFBYSxJQUFNLElBQUksQ0FBQ2EsTUFBTSxDQUFDQyxRQUFRLENBQUNJLFlBQVksQ0FBQyxJQUFJLENBQUNsQixJQUFJO1FBQ2xFO0lBQ0o7QUFDSjtBQUV5QyxDQUN6QyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vZGlzdC9pbmRleC5qcz81ZTI0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgbGlzdCBpdGVtcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvbGlzdC1pdGVtXG4gKi9cbmNvbnN0IExpc3RJdGVtID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdsaXN0SXRlbScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgIGJ1bGxldExpc3RUeXBlTmFtZTogJ2J1bGxldExpc3QnLFxuICAgICAgICAgICAgb3JkZXJlZExpc3RUeXBlTmFtZTogJ29yZGVyZWRMaXN0JyxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGNvbnRlbnQ6ICdwYXJhZ3JhcGggYmxvY2sqJyxcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnbGknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ2xpJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgICAgIFRhYjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2lua0xpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAgICAgICAnU2hpZnQtVGFiJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMubGlmdExpc3RJdGVtKHRoaXMubmFtZSksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBMaXN0SXRlbSwgTGlzdEl0ZW0gYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsIkxpc3RJdGVtIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImJ1bGxldExpc3RUeXBlTmFtZSIsIm9yZGVyZWRMaXN0VHlwZU5hbWUiLCJjb250ZW50IiwiZGVmaW5pbmciLCJwYXJzZUhUTUwiLCJ0YWciLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiRW50ZXIiLCJlZGl0b3IiLCJjb21tYW5kcyIsInNwbGl0TGlzdEl0ZW0iLCJUYWIiLCJzaW5rTGlzdEl0ZW0iLCJsaWZ0TGlzdEl0ZW0iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderedList: () => (/* binding */ OrderedList),\n/* harmony export */   \"default\": () => (/* binding */ OrderedList),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\nconst ListItemName = \"listItem\";\nconst TextStyleName = \"textStyle\";\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */ const inputRegex = /^(\\d+)\\.\\s$/;\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */ const OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"orderedList\",\n    addOptions () {\n        return {\n            itemTypeName: \"listItem\",\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    addAttributes () {\n        return {\n            start: {\n                default: 1,\n                parseHTML: (element)=>{\n                    return element.hasAttribute(\"start\") ? parseInt(element.getAttribute(\"start\") || \"\", 10) : 1;\n                }\n            },\n            type: {\n                default: null,\n                parseHTML: (element)=>element.getAttribute(\"type\")\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"ol\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        const { start, ...attributesWithoutStart } = HTMLAttributes;\n        return start === 1 ? [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart),\n            0\n        ] : [\n            \"ol\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleOrderedList: ()=>({ commands, chain })=>{\n                    if (this.options.keepAttributes) {\n                        return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n                    }\n                    return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-7\": ()=>this.editor.commands.toggleOrderedList()\n        };\n    },\n    addInputRules () {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type,\n            getAttributes: (match)=>({\n                    start: +match[1]\n                }),\n            joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1]\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: (match)=>({\n                        start: +match[1],\n                        ...this.editor.getAttributes(TextStyleName)\n                    }),\n                joinPredicate: (match, node)=>node.childCount + node.attrs.start === +match[1],\n                editor: this.editor\n            });\n        }\n        return [\n            inputRule\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTtBQUV4RSxNQUFNRyxlQUFlO0FBQ3JCLE1BQU1DLGdCQUFnQjtBQUN0Qjs7Q0FFQyxHQUNELE1BQU1DLGFBQWE7QUFDbkI7Ozs7O0NBS0MsR0FDRCxNQUFNQyxjQUFjTiw4Q0FBSUEsQ0FBQ08sTUFBTSxDQUFDO0lBQzVCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxjQUFjO1lBQ2RDLGdCQUFnQixDQUFDO1lBQ2pCQyxXQUFXO1lBQ1hDLGdCQUFnQjtRQUNwQjtJQUNKO0lBQ0FDLE9BQU87SUFDUEM7UUFDSSxPQUFPLENBQUMsRUFBRSxJQUFJLENBQUNDLE9BQU8sQ0FBQ04sWUFBWSxDQUFDLENBQUMsQ0FBQztJQUMxQztJQUNBTztRQUNJLE9BQU87WUFDSEMsT0FBTztnQkFDSEMsU0FBUztnQkFDVEMsV0FBV0MsQ0FBQUE7b0JBQ1AsT0FBT0EsUUFBUUMsWUFBWSxDQUFDLFdBQ3RCQyxTQUFTRixRQUFRRyxZQUFZLENBQUMsWUFBWSxJQUFJLE1BQzlDO2dCQUNWO1lBQ0o7WUFDQUMsTUFBTTtnQkFDRk4sU0FBUztnQkFDVEMsV0FBV0MsQ0FBQUEsVUFBV0EsUUFBUUcsWUFBWSxDQUFDO1lBQy9DO1FBQ0o7SUFDSjtJQUNBSjtRQUNJLE9BQU87WUFDSDtnQkFDSU0sS0FBSztZQUNUO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVoQixjQUFjLEVBQUU7UUFDekIsTUFBTSxFQUFFTyxLQUFLLEVBQUUsR0FBR1Usd0JBQXdCLEdBQUdqQjtRQUM3QyxPQUFPTyxVQUFVLElBQ1g7WUFBQztZQUFNakIsNkRBQWVBLENBQUMsSUFBSSxDQUFDZSxPQUFPLENBQUNMLGNBQWMsRUFBRWlCO1lBQXlCO1NBQUUsR0FDL0U7WUFBQztZQUFNM0IsNkRBQWVBLENBQUMsSUFBSSxDQUFDZSxPQUFPLENBQUNMLGNBQWMsRUFBRUE7WUFBaUI7U0FBRTtJQUNqRjtJQUNBa0I7UUFDSSxPQUFPO1lBQ0hDLG1CQUFtQixJQUFNLENBQUMsRUFBRUMsUUFBUSxFQUFFQyxLQUFLLEVBQUU7b0JBQ3pDLElBQUksSUFBSSxDQUFDaEIsT0FBTyxDQUFDSCxjQUFjLEVBQUU7d0JBQzdCLE9BQU9tQixRQUFRQyxVQUFVLENBQUMsSUFBSSxDQUFDekIsSUFBSSxFQUFFLElBQUksQ0FBQ1EsT0FBTyxDQUFDTixZQUFZLEVBQUUsSUFBSSxDQUFDTSxPQUFPLENBQUNKLFNBQVMsRUFBRXNCLGdCQUFnQixDQUFDL0IsY0FBYyxJQUFJLENBQUNnQyxNQUFNLENBQUNDLGFBQWEsQ0FBQ2hDLGdCQUFnQmlDLEdBQUc7b0JBQ3hLO29CQUNBLE9BQU9OLFNBQVNFLFVBQVUsQ0FBQyxJQUFJLENBQUN6QixJQUFJLEVBQUUsSUFBSSxDQUFDUSxPQUFPLENBQUNOLFlBQVksRUFBRSxJQUFJLENBQUNNLE9BQU8sQ0FBQ0osU0FBUztnQkFDM0Y7UUFDSjtJQUNKO0lBQ0EwQjtRQUNJLE9BQU87WUFDSCxlQUFlLElBQU0sSUFBSSxDQUFDSCxNQUFNLENBQUNKLFFBQVEsQ0FBQ0QsaUJBQWlCO1FBQy9EO0lBQ0o7SUFDQVM7UUFDSSxJQUFJQyxZQUFZdEMsK0RBQWlCQSxDQUFDO1lBQzlCdUMsTUFBTXBDO1lBQ05vQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmVyxlQUFlTSxDQUFBQSxRQUFVO29CQUFFeEIsT0FBTyxDQUFDd0IsS0FBSyxDQUFDLEVBQUU7Z0JBQUM7WUFDNUNDLGVBQWUsQ0FBQ0QsT0FBT0UsT0FBU0EsS0FBS0MsVUFBVSxHQUFHRCxLQUFLRSxLQUFLLENBQUM1QixLQUFLLEtBQUssQ0FBQ3dCLEtBQUssQ0FBQyxFQUFFO1FBQ3BGO1FBQ0EsSUFBSSxJQUFJLENBQUMxQixPQUFPLENBQUNKLFNBQVMsSUFBSSxJQUFJLENBQUNJLE9BQU8sQ0FBQ0gsY0FBYyxFQUFFO1lBQ3ZEMkIsWUFBWXRDLCtEQUFpQkEsQ0FBQztnQkFDMUJ1QyxNQUFNcEM7Z0JBQ05vQixNQUFNLElBQUksQ0FBQ0EsSUFBSTtnQkFDZmIsV0FBVyxJQUFJLENBQUNJLE9BQU8sQ0FBQ0osU0FBUztnQkFDakNDLGdCQUFnQixJQUFJLENBQUNHLE9BQU8sQ0FBQ0gsY0FBYztnQkFDM0N1QixlQUFlTSxDQUFBQSxRQUFVO3dCQUFFeEIsT0FBTyxDQUFDd0IsS0FBSyxDQUFDLEVBQUU7d0JBQUUsR0FBRyxJQUFJLENBQUNQLE1BQU0sQ0FBQ0MsYUFBYSxDQUFDaEMsY0FBYztvQkFBQztnQkFDekZ1QyxlQUFlLENBQUNELE9BQU9FLE9BQVNBLEtBQUtDLFVBQVUsR0FBR0QsS0FBS0UsS0FBSyxDQUFDNUIsS0FBSyxLQUFLLENBQUN3QixLQUFLLENBQUMsRUFBRTtnQkFDaEZQLFFBQVEsSUFBSSxDQUFDQSxNQUFNO1lBQ3ZCO1FBQ0o7UUFDQSxPQUFPO1lBQ0hLO1NBQ0g7SUFDTDtBQUNKO0FBRTJELENBQzNELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdC9kaXN0L2luZGV4LmpzPzNlZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbmNvbnN0IExpc3RJdGVtTmFtZSA9ICdsaXN0SXRlbSc7XG5jb25zdCBUZXh0U3R5bGVOYW1lID0gJ3RleHRTdHlsZSc7XG4vKipcbiAqIE1hdGNoZXMgYW4gb3JkZXJlZCBsaXN0IHRvIGEgMS4gb24gaW5wdXQgKG9yIGFueSBudW1iZXIgZm9sbG93ZWQgYnkgYSBkb3QpLlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gL14oXFxkKylcXC5cXHMkLztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgb3JkZXJlZCBsaXN0cy5cbiAqIFRoaXMgcmVxdWlyZXMgdGhlIExpc3RJdGVtIGV4dGVuc2lvblxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9vcmRlcmVkLWxpc3RcbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvbGlzdC1pdGVtXG4gKi9cbmNvbnN0IE9yZGVyZWRMaXN0ID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdvcmRlcmVkTGlzdCcsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGl0ZW1UeXBlTmFtZTogJ2xpc3RJdGVtJyxcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgICAgIGtlZXBNYXJrczogZmFsc2UsXG4gICAgICAgICAgICBrZWVwQXR0cmlidXRlczogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBncm91cDogJ2Jsb2NrIGxpc3QnLFxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lfStgO1xuICAgIH0sXG4gICAgYWRkQXR0cmlidXRlcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogMSxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3N0YXJ0JylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0YXJ0JykgfHwgJycsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAxO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHlwZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0eXBlJyksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ29sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICBjb25zdCB7IHN0YXJ0LCAuLi5hdHRyaWJ1dGVzV2l0aG91dFN0YXJ0IH0gPSBIVE1MQXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIHN0YXJ0ID09PSAxXG4gICAgICAgICAgICA/IFsnb2wnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzV2l0aG91dFN0YXJ0KSwgMF1cbiAgICAgICAgICAgIDogWydvbCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvZ2dsZU9yZGVyZWRMaXN0OiAoKSA9PiAoeyBjb21tYW5kcywgY2hhaW4gfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluKCkudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpLnVwZGF0ZUF0dHJpYnV0ZXMoTGlzdEl0ZW1OYW1lLCB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZU5hbWUpKS5ydW4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZUxpc3QodGhpcy5uYW1lLCB0aGlzLm9wdGlvbnMuaXRlbVR5cGVOYW1lLCB0aGlzLm9wdGlvbnMua2VlcE1hcmtzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtU2hpZnQtNyc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZU9yZGVyZWRMaXN0KCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICBsZXQgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0gfSksXG4gICAgICAgICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMua2VlcE1hcmtzIHx8IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgaW5wdXRSdWxlID0gd3JhcHBpbmdJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGtlZXBNYXJrczogdGhpcy5vcHRpb25zLmtlZXBNYXJrcyxcbiAgICAgICAgICAgICAgICBrZWVwQXR0cmlidXRlczogdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7IHN0YXJ0OiArbWF0Y2hbMV0sIC4uLnRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkgfSksXG4gICAgICAgICAgICAgICAgam9pblByZWRpY2F0ZTogKG1hdGNoLCBub2RlKSA9PiBub2RlLmNoaWxkQ291bnQgKyBub2RlLmF0dHJzLnN0YXJ0ID09PSArbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBpbnB1dFJ1bGUsXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBPcmRlcmVkTGlzdCwgT3JkZXJlZExpc3QgYXMgZGVmYXVsdCwgaW5wdXRSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsIndyYXBwaW5nSW5wdXRSdWxlIiwiTGlzdEl0ZW1OYW1lIiwiVGV4dFN0eWxlTmFtZSIsImlucHV0UmVnZXgiLCJPcmRlcmVkTGlzdCIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiaXRlbVR5cGVOYW1lIiwiSFRNTEF0dHJpYnV0ZXMiLCJrZWVwTWFya3MiLCJrZWVwQXR0cmlidXRlcyIsImdyb3VwIiwiY29udGVudCIsIm9wdGlvbnMiLCJhZGRBdHRyaWJ1dGVzIiwic3RhcnQiLCJkZWZhdWx0IiwicGFyc2VIVE1MIiwiZWxlbWVudCIsImhhc0F0dHJpYnV0ZSIsInBhcnNlSW50IiwiZ2V0QXR0cmlidXRlIiwidHlwZSIsInRhZyIsInJlbmRlckhUTUwiLCJhdHRyaWJ1dGVzV2l0aG91dFN0YXJ0IiwiYWRkQ29tbWFuZHMiLCJ0b2dnbGVPcmRlcmVkTGlzdCIsImNvbW1hbmRzIiwiY2hhaW4iLCJ0b2dnbGVMaXN0IiwidXBkYXRlQXR0cmlidXRlcyIsImVkaXRvciIsImdldEF0dHJpYnV0ZXMiLCJydW4iLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImFkZElucHV0UnVsZXMiLCJpbnB1dFJ1bGUiLCJmaW5kIiwibWF0Y2giLCJqb2luUHJlZGljYXRlIiwibm9kZSIsImNoaWxkQ291bnQiLCJhdHRycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: () => (/* binding */ Paragraph),\n/* harmony export */   \"default\": () => (/* binding */ Paragraph)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */ const Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"paragraph\",\n    priority: 1000,\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block\",\n    content: \"inline*\",\n    parseHTML () {\n        return [\n            {\n                tag: \"p\"\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"p\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setParagraph: ()=>({ commands })=>{\n                    return commands.setNode(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Alt-0\": ()=>this.editor.commands.setParagraph()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFlBQVlGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkMsVUFBVTtJQUNWQztRQUNJLE9BQU87WUFDSEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxPQUFPO0lBQ1BDLFNBQVM7SUFDVEM7UUFDSSxPQUFPO1lBQ0g7Z0JBQUVDLEtBQUs7WUFBSTtTQUNkO0lBQ0w7SUFDQUMsWUFBVyxFQUFFTCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQUtOLDZEQUFlQSxDQUFDLElBQUksQ0FBQ1ksT0FBTyxDQUFDTixjQUFjLEVBQUVBO1lBQWlCO1NBQUU7SUFDakY7SUFDQU87UUFDSSxPQUFPO1lBQ0hDLGNBQWMsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0MsT0FBTyxDQUFDLElBQUksQ0FBQ2IsSUFBSTtnQkFDckM7UUFDSjtJQUNKO0lBQ0FjO1FBQ0ksT0FBTztZQUNILGFBQWEsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ0gsUUFBUSxDQUFDRCxZQUFZO1FBQ3hEO0lBQ0o7QUFDSjtBQUUyQyxDQUMzQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgvZGlzdC9pbmRleC5qcz84YmEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgcGFyYWdyYXBocy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvcGFyYWdyYXBoXG4gKi9cbmNvbnN0IFBhcmFncmFwaCA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAncGFyYWdyYXBoJyxcbiAgICBwcmlvcml0eTogMTAwMCxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ3JvdXA6ICdibG9jaycsXG4gICAgY29udGVudDogJ2lubGluZSonLFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdGFnOiAncCcgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3AnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRQYXJhZ3JhcGg6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1BbHQtMCc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldFBhcmFncmFwaCgpLFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgUGFyYWdyYXBoLCBQYXJhZ3JhcGggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsIlBhcmFncmFwaCIsImNyZWF0ZSIsIm5hbWUiLCJwcmlvcml0eSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsImdyb3VwIiwiY29udGVudCIsInBhcnNlSFRNTCIsInRhZyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRQYXJhZ3JhcGgiLCJjb21tYW5kcyIsInNldE5vZGUiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-placeholder/dist/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Placeholder: () => (/* binding */ Placeholder),\n/* harmony export */   \"default\": () => (/* binding */ Placeholder)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\");\n\n\n\n/**\n * This extension allows you to add a placeholder to your editor.\n * A placeholder is a text that appears when the editor or a node is empty.\n * @see https://www.tiptap.dev/api/extensions/placeholder\n */ const Placeholder = _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension.create({\n    name: \"placeholder\",\n    addOptions () {\n        return {\n            emptyEditorClass: \"is-editor-empty\",\n            emptyNodeClass: \"is-empty\",\n            placeholder: \"Write something …\",\n            showOnlyWhenEditable: true,\n            showOnlyCurrent: true,\n            includeChildren: false\n        };\n    },\n    addProseMirrorPlugins () {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(\"placeholder\"),\n                props: {\n                    decorations: ({ doc, selection })=>{\n                        const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n                        const { anchor } = selection;\n                        const decorations = [];\n                        if (!active) {\n                            return null;\n                        }\n                        const isEmptyDoc = this.editor.isEmpty;\n                        doc.descendants((node, pos)=>{\n                            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n                            const isEmpty = !node.isLeaf && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeEmpty)(node);\n                            if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                                const classes = [\n                                    this.options.emptyNodeClass\n                                ];\n                                if (isEmptyDoc) {\n                                    classes.push(this.options.emptyEditorClass);\n                                }\n                                const decoration = _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.Decoration.node(pos, pos + node.nodeSize, {\n                                    class: classes.join(\" \"),\n                                    \"data-placeholder\": typeof this.options.placeholder === \"function\" ? this.options.placeholder({\n                                        editor: this.editor,\n                                        node,\n                                        pos,\n                                        hasAnchor\n                                    }) : this.options.placeholder\n                                });\n                                decorations.push(decoration);\n                            }\n                            return this.options.includeChildren;\n                        });\n                        return _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.DecorationSet.create(doc, decorations);\n                    }\n                }\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGxhY2Vob2xkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFzRDtBQUNEO0FBQ087QUFFNUQ7Ozs7Q0FJQyxHQUNELE1BQU1NLGNBQWNOLG1EQUFTQSxDQUFDTyxNQUFNLENBQUM7SUFDakNDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGtCQUFrQjtZQUNsQkMsZ0JBQWdCO1lBQ2hCQyxhQUFhO1lBQ2JDLHNCQUFzQjtZQUN0QkMsaUJBQWlCO1lBQ2pCQyxpQkFBaUI7UUFDckI7SUFDSjtJQUNBQztRQUNJLE9BQU87WUFDSCxJQUFJZCxvREFBTUEsQ0FBQztnQkFDUGUsS0FBSyxJQUFJZCx1REFBU0EsQ0FBQztnQkFDbkJlLE9BQU87b0JBQ0hDLGFBQWEsQ0FBQyxFQUFFQyxHQUFHLEVBQUVDLFNBQVMsRUFBRTt3QkFDNUIsTUFBTUMsU0FBUyxJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsVUFBVSxJQUFJLENBQUMsSUFBSSxDQUFDQyxPQUFPLENBQUNaLG9CQUFvQjt3QkFDM0UsTUFBTSxFQUFFYSxNQUFNLEVBQUUsR0FBR0w7d0JBQ25CLE1BQU1GLGNBQWMsRUFBRTt3QkFDdEIsSUFBSSxDQUFDRyxRQUFROzRCQUNULE9BQU87d0JBQ1g7d0JBQ0EsTUFBTUssYUFBYSxJQUFJLENBQUNKLE1BQU0sQ0FBQ0ssT0FBTzt3QkFDdENSLElBQUlTLFdBQVcsQ0FBQyxDQUFDQyxNQUFNQzs0QkFDbkIsTUFBTUMsWUFBWU4sVUFBVUssT0FBT0wsVUFBVUssTUFBTUQsS0FBS0csUUFBUTs0QkFDaEUsTUFBTUwsVUFBVSxDQUFDRSxLQUFLSSxNQUFNLElBQUlqQyx5REFBV0EsQ0FBQzZCOzRCQUM1QyxJQUFJLENBQUNFLGFBQWEsQ0FBQyxJQUFJLENBQUNQLE9BQU8sQ0FBQ1gsZUFBZSxLQUFLYyxTQUFTO2dDQUN6RCxNQUFNTyxVQUFVO29DQUFDLElBQUksQ0FBQ1YsT0FBTyxDQUFDZCxjQUFjO2lDQUFDO2dDQUM3QyxJQUFJZ0IsWUFBWTtvQ0FDWlEsUUFBUUMsSUFBSSxDQUFDLElBQUksQ0FBQ1gsT0FBTyxDQUFDZixnQkFBZ0I7Z0NBQzlDO2dDQUNBLE1BQU0yQixhQUFhakMsdURBQVVBLENBQUMwQixJQUFJLENBQUNDLEtBQUtBLE1BQU1ELEtBQUtHLFFBQVEsRUFBRTtvQ0FDekRLLE9BQU9ILFFBQVFJLElBQUksQ0FBQztvQ0FDcEIsb0JBQW9CLE9BQU8sSUFBSSxDQUFDZCxPQUFPLENBQUNiLFdBQVcsS0FBSyxhQUNsRCxJQUFJLENBQUNhLE9BQU8sQ0FBQ2IsV0FBVyxDQUFDO3dDQUN2QlcsUUFBUSxJQUFJLENBQUNBLE1BQU07d0NBQ25CTzt3Q0FDQUM7d0NBQ0FDO29DQUNKLEtBQ0UsSUFBSSxDQUFDUCxPQUFPLENBQUNiLFdBQVc7Z0NBQ2xDO2dDQUNBTyxZQUFZaUIsSUFBSSxDQUFDQzs0QkFDckI7NEJBQ0EsT0FBTyxJQUFJLENBQUNaLE9BQU8sQ0FBQ1YsZUFBZTt3QkFDdkM7d0JBQ0EsT0FBT1YsMERBQWFBLENBQUNFLE1BQU0sQ0FBQ2EsS0FBS0Q7b0JBQ3JDO2dCQUNKO1lBQ0o7U0FDSDtJQUNMO0FBQ0o7QUFFK0MsQ0FDL0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tcGxhY2Vob2xkZXIvZGlzdC9pbmRleC5qcz8yM2ExIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiwgaXNOb2RlRW1wdHkgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQgfSBmcm9tICdAdGlwdGFwL3BtL3ZpZXcnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gYWRkIGEgcGxhY2Vob2xkZXIgdG8geW91ciBlZGl0b3IuXG4gKiBBIHBsYWNlaG9sZGVyIGlzIGEgdGV4dCB0aGF0IGFwcGVhcnMgd2hlbiB0aGUgZWRpdG9yIG9yIGEgbm9kZSBpcyBlbXB0eS5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucy9wbGFjZWhvbGRlclxuICovXG5jb25zdCBQbGFjZWhvbGRlciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdwbGFjZWhvbGRlcicsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVtcHR5RWRpdG9yQ2xhc3M6ICdpcy1lZGl0b3ItZW1wdHknLFxuICAgICAgICAgICAgZW1wdHlOb2RlQ2xhc3M6ICdpcy1lbXB0eScsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogJ1dyaXRlIHNvbWV0aGluZyDigKYnLFxuICAgICAgICAgICAgc2hvd09ubHlXaGVuRWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICBzaG93T25seUN1cnJlbnQ6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlQ2hpbGRyZW46IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdwbGFjZWhvbGRlcicpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zOiAoeyBkb2MsIHNlbGVjdGlvbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmVkaXRvci5pc0VkaXRhYmxlIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlXaGVuRWRpdGFibGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5RG9jID0gdGhpcy5lZGl0b3IuaXNFbXB0eTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5kZXNjZW5kYW50cygobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzQW5jaG9yID0gYW5jaG9yID49IHBvcyAmJiBhbmNob3IgPD0gcG9zICsgbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0gIW5vZGUuaXNMZWFmICYmIGlzTm9kZUVtcHR5KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoaGFzQW5jaG9yIHx8ICF0aGlzLm9wdGlvbnMuc2hvd09ubHlDdXJyZW50KSAmJiBpc0VtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzZXMgPSBbdGhpcy5vcHRpb25zLmVtcHR5Tm9kZUNsYXNzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHlEb2MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCh0aGlzLm9wdGlvbnMuZW1wdHlFZGl0b3JDbGFzcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjb3JhdGlvbiA9IERlY29yYXRpb24ubm9kZShwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBjbGFzc2VzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkYXRhLXBsYWNlaG9sZGVyJzogdHlwZW9mIHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNBbmNob3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5wbGFjZWhvbGRlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlY29yYXRpb25zLnB1c2goZGVjb3JhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaW5jbHVkZUNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoZG9jLCBkZWNvcmF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgUGxhY2Vob2xkZXIsIFBsYWNlaG9sZGVyIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkV4dGVuc2lvbiIsImlzTm9kZUVtcHR5IiwiUGx1Z2luIiwiUGx1Z2luS2V5IiwiRGVjb3JhdGlvbiIsIkRlY29yYXRpb25TZXQiLCJQbGFjZWhvbGRlciIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiZW1wdHlFZGl0b3JDbGFzcyIsImVtcHR5Tm9kZUNsYXNzIiwicGxhY2Vob2xkZXIiLCJzaG93T25seVdoZW5FZGl0YWJsZSIsInNob3dPbmx5Q3VycmVudCIsImluY2x1ZGVDaGlsZHJlbiIsImFkZFByb3NlTWlycm9yUGx1Z2lucyIsImtleSIsInByb3BzIiwiZGVjb3JhdGlvbnMiLCJkb2MiLCJzZWxlY3Rpb24iLCJhY3RpdmUiLCJlZGl0b3IiLCJpc0VkaXRhYmxlIiwib3B0aW9ucyIsImFuY2hvciIsImlzRW1wdHlEb2MiLCJpc0VtcHR5IiwiZGVzY2VuZGFudHMiLCJub2RlIiwicG9zIiwiaGFzQW5jaG9yIiwibm9kZVNpemUiLCJpc0xlYWYiLCJjbGFzc2VzIiwicHVzaCIsImRlY29yYXRpb24iLCJjbGFzcyIsImpvaW4iLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-placeholder/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: () => (/* binding */ Strike),\n/* harmony export */   \"default\": () => (/* binding */ Strike),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex),\n/* harmony export */   pasteRegex: () => (/* binding */ pasteRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */ const inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */ const pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */ const Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"strike\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"s\"\n            },\n            {\n                tag: \"del\"\n            },\n            {\n                tag: \"strike\"\n            },\n            {\n                style: \"text-decoration\",\n                consuming: false,\n                getAttrs: (style)=>style.includes(\"line-through\") ? {} : false\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"s\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setStrike: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleStrike: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetStrike: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-s\": ()=>this.editor.commands.toggleStrike()\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type\n            })\n        ];\n    },\n    addPasteRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUY7QUFFbkY7O0NBRUMsR0FDRCxNQUFNSSxhQUFhO0FBQ25COztDQUVDLEdBQ0QsTUFBTUMsYUFBYTtBQUNuQjs7O0NBR0MsR0FDRCxNQUFNQyxTQUFTTiw4Q0FBSUEsQ0FBQ08sTUFBTSxDQUFDO0lBQ3ZCQyxNQUFNO0lBQ05DO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsQ0FBQztRQUNyQjtJQUNKO0lBQ0FDO1FBQ0ksT0FBTztZQUNIO2dCQUNJQyxLQUFLO1lBQ1Q7WUFDQTtnQkFDSUEsS0FBSztZQUNUO1lBQ0E7Z0JBQ0lBLEtBQUs7WUFDVDtZQUNBO2dCQUNJQyxPQUFPO2dCQUNQQyxXQUFXO2dCQUNYQyxVQUFVRixDQUFBQSxRQUFVQSxNQUFNRyxRQUFRLENBQUMsa0JBQWtCLENBQUMsSUFBSTtZQUM5RDtTQUNIO0lBQ0w7SUFDQUMsWUFBVyxFQUFFUCxjQUFjLEVBQUU7UUFDekIsT0FBTztZQUFDO1lBQUtULDZEQUFlQSxDQUFDLElBQUksQ0FBQ2lCLE9BQU8sQ0FBQ1IsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2pGO0lBQ0FTO1FBQ0ksT0FBTztZQUNIQyxXQUFXLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQzFCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNkLElBQUk7Z0JBQ3JDO1lBQ0FlLGNBQWMsSUFBTSxDQUFDLEVBQUVGLFFBQVEsRUFBRTtvQkFDN0IsT0FBT0EsU0FBU0csVUFBVSxDQUFDLElBQUksQ0FBQ2hCLElBQUk7Z0JBQ3hDO1lBQ0FpQixhQUFhLElBQU0sQ0FBQyxFQUFFSixRQUFRLEVBQUU7b0JBQzVCLE9BQU9BLFNBQVNLLFNBQVMsQ0FBQyxJQUFJLENBQUNsQixJQUFJO2dCQUN2QztRQUNKO0lBQ0o7SUFDQW1CO1FBQ0ksT0FBTztZQUNILGVBQWUsSUFBTSxJQUFJLENBQUNDLE1BQU0sQ0FBQ1AsUUFBUSxDQUFDRSxZQUFZO1FBQzFEO0lBQ0o7SUFDQU07UUFDSSxPQUFPO1lBQ0gzQiwyREFBYUEsQ0FBQztnQkFDVjRCLE1BQU0xQjtnQkFDTjJCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO1lBQ25CO1NBQ0g7SUFDTDtJQUNBQztRQUNJLE9BQU87WUFDSDdCLDJEQUFhQSxDQUFDO2dCQUNWMkIsTUFBTXpCO2dCQUNOMEIsTUFBTSxJQUFJLENBQUNBLElBQUk7WUFDbkI7U0FDSDtJQUNMO0FBQ0o7QUFFNkQsQ0FDN0QsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlL2Rpc3QvaW5kZXguanM/OGU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIE1hdGNoZXMgYSBzdHJpa2UgdG8gYSB+fnN0cmlrZX5+IG9uIGlucHV0LlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKSh+fig/IVxccyt+fikoKD86W15+XSspKX5+KD8hXFxzK35+KSkkLztcbi8qKlxuICogTWF0Y2hlcyBhIHN0cmlrZSB0byBhIH5+c3RyaWtlfn4gb24gcGFzdGUuXG4gKi9cbmNvbnN0IHBhc3RlUmVnZXggPSAvKD86XnxcXHMpKH5+KD8hXFxzK35+KSgoPzpbXn5dKykpfn4oPyFcXHMrfn4pKS9nO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBzdHJpa2UgdGV4dC5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbWFya3Mvc3RyaWtlXG4gKi9cbmNvbnN0IFN0cmlrZSA9IE1hcmsuY3JlYXRlKHtcbiAgICBuYW1lOiAnc3RyaWtlJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ3MnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdkZWwnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdzdHJpa2UnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ3RleHQtZGVjb3JhdGlvbicsXG4gICAgICAgICAgICAgICAgY29uc3VtaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZXRBdHRyczogc3R5bGUgPT4gKHN0eWxlLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKSA/IHt9IDogZmFsc2UpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ3MnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVN0cmlrZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXRTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLVNoaWZ0LXMnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVTdHJpa2UoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUGFzdGVSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtQYXN0ZVJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBTdHJpa2UsIFN0cmlrZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4LCBwYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNYXJrIiwibWVyZ2VBdHRyaWJ1dGVzIiwibWFya0lucHV0UnVsZSIsIm1hcmtQYXN0ZVJ1bGUiLCJpbnB1dFJlZ2V4IiwicGFzdGVSZWdleCIsIlN0cmlrZSIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiSFRNTEF0dHJpYnV0ZXMiLCJwYXJzZUhUTUwiLCJ0YWciLCJzdHlsZSIsImNvbnN1bWluZyIsImdldEF0dHJzIiwiaW5jbHVkZXMiLCJyZW5kZXJIVE1MIiwib3B0aW9ucyIsImFkZENvbW1hbmRzIiwic2V0U3RyaWtlIiwiY29tbWFuZHMiLCJzZXRNYXJrIiwidG9nZ2xlU3RyaWtlIiwidG9nZ2xlTWFyayIsInVuc2V0U3RyaWtlIiwidW5zZXRNYXJrIiwiYWRkS2V5Ym9hcmRTaG9ydGN1dHMiLCJlZGl0b3IiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsInR5cGUiLCJhZGRQYXN0ZVJ1bGVzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-task-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-task-item/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaskItem: () => (/* binding */ TaskItem),\n/* harmony export */   \"default\": () => (/* binding */ TaskItem),\n/* harmony export */   inputRegex: () => (/* binding */ inputRegex)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * Matches a task item to a - [ ] on input.\n */ const inputRegex = /^\\s*(\\[([( |x])?\\])\\s$/;\n/**\n * This extension allows you to create task items.\n * @see https://www.tiptap.dev/api/nodes/task-item\n */ const TaskItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"taskItem\",\n    addOptions () {\n        return {\n            nested: false,\n            HTMLAttributes: {},\n            taskListTypeName: \"taskList\",\n            a11y: undefined\n        };\n    },\n    content () {\n        return this.options.nested ? \"paragraph block*\" : \"paragraph+\";\n    },\n    defining: true,\n    addAttributes () {\n        return {\n            checked: {\n                default: false,\n                keepOnSplit: false,\n                parseHTML: (element)=>{\n                    const dataChecked = element.getAttribute(\"data-checked\");\n                    return dataChecked === \"\" || dataChecked === \"true\";\n                },\n                renderHTML: (attributes)=>({\n                        \"data-checked\": attributes.checked\n                    })\n            }\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: `li[data-type=\"${this.name}\"]`,\n                priority: 51\n            }\n        ];\n    },\n    renderHTML ({ node, HTMLAttributes }) {\n        return [\n            \"li\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n                \"data-type\": this.name\n            }),\n            [\n                \"label\",\n                [\n                    \"input\",\n                    {\n                        type: \"checkbox\",\n                        checked: node.attrs.checked ? \"checked\" : null\n                    }\n                ],\n                [\n                    \"span\"\n                ]\n            ],\n            [\n                \"div\",\n                0\n            ]\n        ];\n    },\n    addKeyboardShortcuts () {\n        const shortcuts = {\n            Enter: ()=>this.editor.commands.splitListItem(this.name),\n            \"Shift-Tab\": ()=>this.editor.commands.liftListItem(this.name)\n        };\n        if (!this.options.nested) {\n            return shortcuts;\n        }\n        return {\n            ...shortcuts,\n            Tab: ()=>this.editor.commands.sinkListItem(this.name)\n        };\n    },\n    addNodeView () {\n        return ({ node, HTMLAttributes, getPos, editor })=>{\n            const listItem = document.createElement(\"li\");\n            const checkboxWrapper = document.createElement(\"label\");\n            const checkboxStyler = document.createElement(\"span\");\n            const checkbox = document.createElement(\"input\");\n            const content = document.createElement(\"div\");\n            const updateA11Y = ()=>{\n                var _a, _b;\n                checkbox.ariaLabel = ((_b = (_a = this.options.a11y) === null || _a === void 0 ? void 0 : _a.checkboxLabel) === null || _b === void 0 ? void 0 : _b.call(_a, node, checkbox.checked)) || `Task item checkbox for ${node.textContent || \"empty task item\"}`;\n            };\n            updateA11Y();\n            checkboxWrapper.contentEditable = \"false\";\n            checkbox.type = \"checkbox\";\n            checkbox.addEventListener(\"mousedown\", (event)=>event.preventDefault());\n            checkbox.addEventListener(\"change\", (event)=>{\n                // if the editor isn’t editable and we don't have a handler for\n                // readonly checks we have to undo the latest change\n                if (!editor.isEditable && !this.options.onReadOnlyChecked) {\n                    checkbox.checked = !checkbox.checked;\n                    return;\n                }\n                const { checked } = event.target;\n                if (editor.isEditable && typeof getPos === \"function\") {\n                    editor.chain().focus(undefined, {\n                        scrollIntoView: false\n                    }).command(({ tr })=>{\n                        const position = getPos();\n                        if (typeof position !== \"number\") {\n                            return false;\n                        }\n                        const currentNode = tr.doc.nodeAt(position);\n                        tr.setNodeMarkup(position, undefined, {\n                            ...currentNode === null || currentNode === void 0 ? void 0 : currentNode.attrs,\n                            checked\n                        });\n                        return true;\n                    }).run();\n                }\n                if (!editor.isEditable && this.options.onReadOnlyChecked) {\n                    // Reset state if onReadOnlyChecked returns false\n                    if (!this.options.onReadOnlyChecked(node, checked)) {\n                        checkbox.checked = !checkbox.checked;\n                    }\n                }\n            });\n            Object.entries(this.options.HTMLAttributes).forEach(([key, value])=>{\n                listItem.setAttribute(key, value);\n            });\n            listItem.dataset.checked = node.attrs.checked;\n            checkbox.checked = node.attrs.checked;\n            checkboxWrapper.append(checkbox, checkboxStyler);\n            listItem.append(checkboxWrapper, content);\n            Object.entries(HTMLAttributes).forEach(([key, value])=>{\n                listItem.setAttribute(key, value);\n            });\n            return {\n                dom: listItem,\n                contentDOM: content,\n                update: (updatedNode)=>{\n                    if (updatedNode.type !== this.type) {\n                        return false;\n                    }\n                    listItem.dataset.checked = updatedNode.attrs.checked;\n                    checkbox.checked = updatedNode.attrs.checked;\n                    updateA11Y();\n                    return true;\n                }\n            };\n        };\n    },\n    addInputRules () {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                getAttributes: (match)=>({\n                        checked: match[match.length - 1] === \"x\"\n                    })\n            })\n        ];\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFzay1pdGVtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTtBQUV4RTs7Q0FFQyxHQUNELE1BQU1HLGFBQWE7QUFDbkI7OztDQUdDLEdBQ0QsTUFBTUMsV0FBV0osOENBQUlBLENBQUNLLE1BQU0sQ0FBQztJQUN6QkMsTUFBTTtJQUNOQztRQUNJLE9BQU87WUFDSEMsUUFBUTtZQUNSQyxnQkFBZ0IsQ0FBQztZQUNqQkMsa0JBQWtCO1lBQ2xCQyxNQUFNQztRQUNWO0lBQ0o7SUFDQUM7UUFDSSxPQUFPLElBQUksQ0FBQ0MsT0FBTyxDQUFDTixNQUFNLEdBQUcscUJBQXFCO0lBQ3REO0lBQ0FPLFVBQVU7SUFDVkM7UUFDSSxPQUFPO1lBQ0hDLFNBQVM7Z0JBQ0xDLFNBQVM7Z0JBQ1RDLGFBQWE7Z0JBQ2JDLFdBQVdDLENBQUFBO29CQUNQLE1BQU1DLGNBQWNELFFBQVFFLFlBQVksQ0FBQztvQkFDekMsT0FBT0QsZ0JBQWdCLE1BQU1BLGdCQUFnQjtnQkFDakQ7Z0JBQ0FFLFlBQVlDLENBQUFBLGFBQWU7d0JBQ3ZCLGdCQUFnQkEsV0FBV1IsT0FBTztvQkFDdEM7WUFDSjtRQUNKO0lBQ0o7SUFDQUc7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lNLEtBQUssQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDcEIsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDbkNxQixVQUFVO1lBQ2Q7U0FDSDtJQUNMO0lBQ0FILFlBQVcsRUFBRUksSUFBSSxFQUFFbkIsY0FBYyxFQUFFO1FBQy9CLE9BQU87WUFDSDtZQUNBUiw2REFBZUEsQ0FBQyxJQUFJLENBQUNhLE9BQU8sQ0FBQ0wsY0FBYyxFQUFFQSxnQkFBZ0I7Z0JBQ3pELGFBQWEsSUFBSSxDQUFDSCxJQUFJO1lBQzFCO1lBQ0E7Z0JBQ0k7Z0JBQ0E7b0JBQ0k7b0JBQ0E7d0JBQ0l1QixNQUFNO3dCQUNOWixTQUFTVyxLQUFLRSxLQUFLLENBQUNi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Q0FBQztnQkFDZG9GLE1BQU1uRjtnQkFDTjBCLE1BQU0sSUFBSSxDQUFDQSxJQUFJO2dCQUNmMEQsZUFBZUMsQ0FBQUEsUUFBVTt3QkFDckJ2RSxTQUFTdUUsS0FBSyxDQUFDQSxNQUFNQyxNQUFNLEdBQUcsRUFBRSxLQUFLO29CQUN6QztZQUNKO1NBQ0g7SUFDTDtBQUNKO0FBRXFELENBQ3JELGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRhc2staXRlbS9kaXN0L2luZGV4LmpzPzM3Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCB3cmFwcGluZ0lucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhIHRhc2sgaXRlbSB0byBhIC0gWyBdIG9uIGlucHV0LlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqKFxcWyhbKCB8eF0pP1xcXSlcXHMkLztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgdGFzayBpdGVtcy5cbiAqIEBzZWUgaHR0cHM6Ly93d3cudGlwdGFwLmRldi9hcGkvbm9kZXMvdGFzay1pdGVtXG4gKi9cbmNvbnN0IFRhc2tJdGVtID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICd0YXNrSXRlbScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5lc3RlZDogZmFsc2UsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgICAgICB0YXNrTGlzdFR5cGVOYW1lOiAndGFza0xpc3QnLFxuICAgICAgICAgICAgYTExeTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5uZXN0ZWQgPyAncGFyYWdyYXBoIGJsb2NrKicgOiAncGFyYWdyYXBoKyc7XG4gICAgfSxcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2hlY2tlZDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGtlZXBPblNwbGl0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhQ2hlY2tlZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNoZWNrZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFDaGVja2VkID09PSAnJyB8fCBkYXRhQ2hlY2tlZCA9PT0gJ3RydWUnO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuZGVySFRNTDogYXR0cmlidXRlcyA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAnZGF0YS1jaGVja2VkJzogYXR0cmlidXRlcy5jaGVja2VkLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6IGBsaVtkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiA1MSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ2xpJyxcbiAgICAgICAgICAgIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzLCB7XG4gICAgICAgICAgICAgICAgJ2RhdGEtdHlwZSc6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICdsYWJlbCcsXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAnaW5wdXQnLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogbm9kZS5hdHRycy5jaGVja2VkID8gJ2NoZWNrZWQnIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIFsnc3BhbiddLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFsnZGl2JywgMF0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRjdXRzID0ge1xuICAgICAgICAgICAgRW50ZXI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNwbGl0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubmVzdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gc2hvcnRjdXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5zaG9ydGN1dHMsXG4gICAgICAgICAgICBUYWI6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNpbmtMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkTm9kZVZpZXcoKSB7XG4gICAgICAgIHJldHVybiAoeyBub2RlLCBIVE1MQXR0cmlidXRlcywgZ2V0UG9zLCBlZGl0b3IsIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgICAgICBjb25zdCBjaGVja2JveFN0eWxlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUExMVkgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjaGVja2JveC5hcmlhTGFiZWwgPSAoKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmExMXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGVja2JveExhYmVsKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgbm9kZSwgY2hlY2tib3guY2hlY2tlZCkpXG4gICAgICAgICAgICAgICAgICAgIHx8IGBUYXNrIGl0ZW0gY2hlY2tib3ggZm9yICR7bm9kZS50ZXh0Q29udGVudCB8fCAnZW1wdHkgdGFzayBpdGVtJ31gO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHVwZGF0ZUExMVkoKTtcbiAgICAgICAgICAgIGNoZWNrYm94V3JhcHBlci5jb250ZW50RWRpdGFibGUgPSAnZmFsc2UnO1xuICAgICAgICAgICAgY2hlY2tib3gudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgICAgICBjaGVja2JveC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICAgICAgICAgIGNoZWNrYm94LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZWRpdG9yIGlzbuKAmXQgZWRpdGFibGUgYW5kIHdlIGRvbid0IGhhdmUgYSBoYW5kbGVyIGZvclxuICAgICAgICAgICAgICAgIC8vIHJlYWRvbmx5IGNoZWNrcyB3ZSBoYXZlIHRvIHVuZG8gdGhlIGxhdGVzdCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvci5pc0VkaXRhYmxlICYmICF0aGlzLm9wdGlvbnMub25SZWFkT25seUNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3guY2hlY2tlZCA9ICFjaGVja2JveC5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2hlY2tlZCB9ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuaXNFZGl0YWJsZSAmJiB0eXBlb2YgZ2V0UG9zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICAgICAgLmNoYWluKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5mb2N1cyh1bmRlZmluZWQsIHsgc2Nyb2xsSW50b1ZpZXc6IGZhbHNlIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFBvcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3NpdGlvbiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudE5vZGUgPT09IG51bGwgfHwgY3VycmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnROb2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvci5pc0VkaXRhYmxlICYmIHRoaXMub3B0aW9ucy5vblJlYWRPbmx5Q2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXNldCBzdGF0ZSBpZiBvblJlYWRPbmx5Q2hlY2tlZCByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLm9uUmVhZE9ubHlDaGVja2VkKG5vZGUsIGNoZWNrZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gIWNoZWNrYm94LmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsaXN0SXRlbS5kYXRhc2V0LmNoZWNrZWQgPSBub2RlLmF0dHJzLmNoZWNrZWQ7XG4gICAgICAgICAgICBjaGVja2JveC5jaGVja2VkID0gbm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgICAgY2hlY2tib3hXcmFwcGVyLmFwcGVuZChjaGVja2JveCwgY2hlY2tib3hTdHlsZXIpO1xuICAgICAgICAgICAgbGlzdEl0ZW0uYXBwZW5kKGNoZWNrYm94V3JhcHBlciwgY29udGVudCk7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhIVE1MQXR0cmlidXRlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGRvbTogbGlzdEl0ZW0sXG4gICAgICAgICAgICAgICAgY29udGVudERPTTogY29udGVudCxcbiAgICAgICAgICAgICAgICB1cGRhdGU6IHVwZGF0ZWROb2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZWROb2RlLnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxpc3RJdGVtLmRhdGFzZXQuY2hlY2tlZCA9IHVwZGF0ZWROb2RlLmF0dHJzLmNoZWNrZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94LmNoZWNrZWQgPSB1cGRhdGVkTm9kZS5hdHRycy5jaGVja2VkO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVBMTFZKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiBtYXRjaCA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBtYXRjaFttYXRjaC5sZW5ndGggLSAxXSA9PT0gJ3gnLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBUYXNrSXRlbSwgVGFza0l0ZW0gYXMgZGVmYXVsdCwgaW5wdXRSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiTm9kZSIsIm1lcmdlQXR0cmlidXRlcyIsIndyYXBwaW5nSW5wdXRSdWxlIiwiaW5wdXRSZWdleCIsIlRhc2tJdGVtIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJuZXN0ZWQiLCJIVE1MQXR0cmlidXRlcyIsInRhc2tMaXN0VHlwZU5hbWUiLCJhMTF5IiwidW5kZWZpbmVkIiwiY29udGVudCIsIm9wdGlvbnMiLCJkZWZpbmluZyIsImFkZEF0dHJpYnV0ZXMiLCJjaGVja2VkIiwiZGVmYXVsdCIsImtlZXBPblNwbGl0IiwicGFyc2VIVE1MIiwiZWxlbWVudCIsImRhdGFDaGVja2VkIiwiZ2V0QXR0cmlidXRlIiwicmVuZGVySFRNTCIsImF0dHJpYnV0ZXMiLCJ0YWciLCJwcmlvcml0eSIsIm5vZGUiLCJ0eXBlIiwiYXR0cnMiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsInNob3J0Y3V0cyIsIkVudGVyIiwiZWRpdG9yIiwiY29tbWFuZHMiLCJzcGxpdExpc3RJdGVtIiwibGlmdExpc3RJdGVtIiwiVGFiIiwic2lua0xpc3RJdGVtIiwiYWRkTm9kZVZpZXciLCJnZXRQb3MiLCJsaXN0SXRlbSIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImNoZWNrYm94V3JhcHBlciIsImNoZWNrYm94U3R5bGVyIiwiY2hlY2tib3giLCJ1cGRhdGVBMTFZIiwiX2EiLCJfYiIsImFyaWFMYWJlbCIsImNoZWNrYm94TGFiZWwiLCJjYWxsIiwidGV4dENvbnRlbnQiLCJjb250ZW50RWRpdGFibGUiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsImlzRWRpdGFibGUiLCJvblJlYWRPbmx5Q2hlY2tlZCIsInRhcmdldCIsImNoYWluIiwiZm9jdXMiLCJzY3JvbGxJbnRvVmlldyIsImNvbW1hbmQiLCJ0ciIsInBvc2l0aW9uIiwiY3VycmVudE5vZGUiLCJkb2MiLCJub2RlQXQiLCJzZXROb2RlTWFya3VwIiwicnVuIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJrZXkiLCJ2YWx1ZSIsInNldEF0dHJpYnV0ZSIsImRhdGFzZXQiLCJhcHBlbmQiLCJkb20iLCJjb250ZW50RE9NIiwidXBkYXRlIiwidXBkYXRlZE5vZGUiLCJhZGRJbnB1dFJ1bGVzIiwiZmluZCIsImdldEF0dHJpYnV0ZXMiLCJtYXRjaCIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-task-item/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-task-list/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-task-list/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TaskList: () => (/* binding */ TaskList),\n/* harmony export */   \"default\": () => (/* binding */ TaskList)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create task lists.\n * @see https://www.tiptap.dev/api/nodes/task-list\n */ const TaskList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"taskList\",\n    addOptions () {\n        return {\n            itemTypeName: \"taskItem\",\n            HTMLAttributes: {}\n        };\n    },\n    group: \"block list\",\n    content () {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML () {\n        return [\n            {\n                tag: `ul[data-type=\"${this.name}\"]`,\n                priority: 51\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"ul\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes, {\n                \"data-type\": this.name\n            }),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            toggleTaskList: ()=>({ commands })=>{\n                    return commands.toggleList(this.name, this.options.itemTypeName);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-Shift-9\": ()=>this.editor.commands.toggleTaskList()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGFzay1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFdBQVdGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDekJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGNBQWM7WUFDZEMsZ0JBQWdCLENBQUM7UUFDckI7SUFDSjtJQUNBQyxPQUFPO0lBQ1BDO1FBQ0ksT0FBTyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxPQUFPLENBQUNKLFlBQVksQ0FBQyxDQUFDLENBQUM7SUFDMUM7SUFDQUs7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lDLEtBQUssQ0FBQyxjQUFjLEVBQUUsSUFBSSxDQUFDUixJQUFJLENBQUMsRUFBRSxDQUFDO2dCQUNuQ1MsVUFBVTtZQUNkO1NBQ0g7SUFDTDtJQUNBQyxZQUFXLEVBQUVQLGNBQWMsRUFBRTtRQUN6QixPQUFPO1lBQUM7WUFBTU4sNkRBQWVBLENBQUMsSUFBSSxDQUFDUyxPQUFPLENBQUNILGNBQWMsRUFBRUEsZ0JBQWdCO2dCQUFFLGFBQWEsSUFBSSxDQUFDSCxJQUFJO1lBQUM7WUFBSTtTQUFFO0lBQzlHO0lBQ0FXO1FBQ0ksT0FBTztZQUNIQyxnQkFBZ0IsSUFBTSxDQUFDLEVBQUVDLFFBQVEsRUFBRTtvQkFDL0IsT0FBT0EsU0FBU0MsVUFBVSxDQUFDLElBQUksQ0FBQ2QsSUFBSSxFQUFFLElBQUksQ0FBQ00sT0FBTyxDQUFDSixZQUFZO2dCQUNuRTtRQUNKO0lBQ0o7SUFDQWE7UUFDSSxPQUFPO1lBQ0gsZUFBZSxJQUFNLElBQUksQ0FBQ0MsTUFBTSxDQUFDSCxRQUFRLENBQUNELGNBQWM7UUFDNUQ7SUFDSjtBQUNKO0FBRXlDLENBQ3pDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXRhc2stbGlzdC9kaXN0L2luZGV4LmpzPzIwYzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0YXNrIGxpc3RzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy90YXNrLWxpc3RcbiAqL1xuY29uc3QgVGFza0xpc3QgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3Rhc2tMaXN0JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXRlbVR5cGVOYW1lOiAndGFza0l0ZW0nLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ3JvdXA6ICdibG9jayBsaXN0JyxcbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6IGB1bFtkYXRhLXR5cGU9XCIke3RoaXMubmFtZX1cIl1gLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiA1MSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWyd1bCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzLCB7ICdkYXRhLXR5cGUnOiB0aGlzLm5hbWUgfSksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2dnbGVUYXNrTGlzdDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLVNoaWZ0LTknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVUYXNrTGlzdCgpLFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgVGFza0xpc3QsIFRhc2tMaXN0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJtZXJnZUF0dHJpYnV0ZXMiLCJUYXNrTGlzdCIsImNyZWF0ZSIsIm5hbWUiLCJhZGRPcHRpb25zIiwiaXRlbVR5cGVOYW1lIiwiSFRNTEF0dHJpYnV0ZXMiLCJncm91cCIsImNvbnRlbnQiLCJvcHRpb25zIiwicGFyc2VIVE1MIiwidGFnIiwicHJpb3JpdHkiLCJyZW5kZXJIVE1MIiwiYWRkQ29tbWFuZHMiLCJ0b2dnbGVUYXNrTGlzdCIsImNvbW1hbmRzIiwidG9nZ2xlTGlzdCIsImFkZEtleWJvYXJkU2hvcnRjdXRzIiwiZWRpdG9yIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-task-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   \"default\": () => (/* binding */ Text)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */ const Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: \"text\",\n    group: \"inline\"\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdGV4dC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQztBQUVwQzs7O0NBR0MsR0FDRCxNQUFNQyxPQUFPRCw4Q0FBSUEsQ0FBQ0UsTUFBTSxDQUFDO0lBQ3JCQyxNQUFNO0lBQ05DLE9BQU87QUFDWDtBQUVpQyxDQUNqQyxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L2Rpc3QvaW5kZXguanM/OWU0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0ZXh0IG5vZGVzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy90ZXh0XG4gKi9cbmNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3RleHQnLFxuICAgIGdyb3VwOiAnaW5saW5lJyxcbn0pO1xuXG5leHBvcnQgeyBUZXh0LCBUZXh0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIk5vZGUiLCJUZXh0IiwiY3JlYXRlIiwibmFtZSIsImdyb3VwIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-underline/dist/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Underline: () => (/* binding */ Underline),\n/* harmony export */   \"default\": () => (/* binding */ Underline)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */ const Underline = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: \"underline\",\n    addOptions () {\n        return {\n            HTMLAttributes: {}\n        };\n    },\n    parseHTML () {\n        return [\n            {\n                tag: \"u\"\n            },\n            {\n                style: \"text-decoration\",\n                consuming: false,\n                getAttrs: (style)=>style.includes(\"underline\") ? {} : false\n            }\n        ];\n    },\n    renderHTML ({ HTMLAttributes }) {\n        return [\n            \"u\",\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            0\n        ];\n    },\n    addCommands () {\n        return {\n            setUnderline: ()=>({ commands })=>{\n                    return commands.setMark(this.name);\n                },\n            toggleUnderline: ()=>({ commands })=>{\n                    return commands.toggleMark(this.name);\n                },\n            unsetUnderline: ()=>({ commands })=>{\n                    return commands.unsetMark(this.name);\n                }\n        };\n    },\n    addKeyboardShortcuts () {\n        return {\n            \"Mod-u\": ()=>this.editor.commands.toggleUnderline(),\n            \"Mod-U\": ()=>this.editor.commands.toggleUnderline()\n        };\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEO0FBRXJEOzs7Q0FHQyxHQUNELE1BQU1FLFlBQVlGLDhDQUFJQSxDQUFDRyxNQUFNLENBQUM7SUFDMUJDLE1BQU07SUFDTkM7UUFDSSxPQUFPO1lBQ0hDLGdCQUFnQixDQUFDO1FBQ3JCO0lBQ0o7SUFDQUM7UUFDSSxPQUFPO1lBQ0g7Z0JBQ0lDLEtBQUs7WUFDVDtZQUNBO2dCQUNJQyxPQUFPO2dCQUNQQyxXQUFXO2dCQUNYQyxVQUFVRixDQUFBQSxRQUFVQSxNQUFNRyxRQUFRLENBQUMsZUFBZSxDQUFDLElBQUk7WUFDM0Q7U0FDSDtJQUNMO0lBQ0FDLFlBQVcsRUFBRVAsY0FBYyxFQUFFO1FBQ3pCLE9BQU87WUFBQztZQUFLTCw2REFBZUEsQ0FBQyxJQUFJLENBQUNhLE9BQU8sQ0FBQ1IsY0FBYyxFQUFFQTtZQUFpQjtTQUFFO0lBQ2pGO0lBQ0FTO1FBQ0ksT0FBTztZQUNIQyxjQUFjLElBQU0sQ0FBQyxFQUFFQyxRQUFRLEVBQUU7b0JBQzdCLE9BQU9BLFNBQVNDLE9BQU8sQ0FBQyxJQUFJLENBQUNkLElBQUk7Z0JBQ3JDO1lBQ0FlLGlCQUFpQixJQUFNLENBQUMsRUFBRUYsUUFBUSxFQUFFO29CQUNoQyxPQUFPQSxTQUFTRyxVQUFVLENBQUMsSUFBSSxDQUFDaEIsSUFBSTtnQkFDeEM7WUFDQWlCLGdCQUFnQixJQUFNLENBQUMsRUFBRUosUUFBUSxFQUFFO29CQUMvQixPQUFPQSxTQUFTSyxTQUFTLENBQUMsSUFBSSxDQUFDbEIsSUFBSTtnQkFDdkM7UUFDSjtJQUNKO0lBQ0FtQjtRQUNJLE9BQU87WUFDSCxTQUFTLElBQU0sSUFBSSxDQUFDQyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsZUFBZTtZQUNuRCxTQUFTLElBQU0sSUFBSSxDQUFDSyxNQUFNLENBQUNQLFFBQVEsQ0FBQ0UsZUFBZTtRQUN2RDtJQUNKO0FBQ0o7QUFFMkMsQ0FDM0MsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tdW5kZXJsaW5lL2Rpc3QvaW5kZXguanM/MzY1MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIHVuZGVybGluZSB0ZXh0LlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9tYXJrcy91bmRlcmxpbmVcbiAqL1xuY29uc3QgVW5kZXJsaW5lID0gTWFyay5jcmVhdGUoe1xuICAgIG5hbWU6ICd1bmRlcmxpbmUnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAndScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAndGV4dC1kZWNvcmF0aW9uJyxcbiAgICAgICAgICAgICAgICBjb25zdW1pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiBzdHlsZSA9PiAoc3R5bGUuaW5jbHVkZXMoJ3VuZGVybGluZScpID8ge30gOiBmYWxzZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsndScsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldFVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlVW5kZXJsaW5lOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldFVuZGVybGluZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtdSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZVVuZGVybGluZSgpLFxuICAgICAgICAgICAgJ01vZC1VJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlVW5kZXJsaW5lKCksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBVbmRlcmxpbmUsIFVuZGVybGluZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJNYXJrIiwibWVyZ2VBdHRyaWJ1dGVzIiwiVW5kZXJsaW5lIiwiY3JlYXRlIiwibmFtZSIsImFkZE9wdGlvbnMiLCJIVE1MQXR0cmlidXRlcyIsInBhcnNlSFRNTCIsInRhZyIsInN0eWxlIiwiY29uc3VtaW5nIiwiZ2V0QXR0cnMiLCJpbmNsdWRlcyIsInJlbmRlckhUTUwiLCJvcHRpb25zIiwiYWRkQ29tbWFuZHMiLCJzZXRVbmRlcmxpbmUiLCJjb21tYW5kcyIsInNldE1hcmsiLCJ0b2dnbGVVbmRlcmxpbmUiLCJ0b2dnbGVNYXJrIiwidW5zZXRVbmRlcmxpbmUiLCJ1bnNldE1hcmsiLCJhZGRLZXlib2FyZFNob3J0Y3V0cyIsImVkaXRvciIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/extension-underline/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/commands/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin),\n/* harmony export */   baseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap),\n/* harmony export */   chainCommands: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands),\n/* harmony export */   createParagraphNear: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear),\n/* harmony export */   deleteSelection: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection),\n/* harmony export */   exitCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode),\n/* harmony export */   joinBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward),\n/* harmony export */   joinDown: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown),\n/* harmony export */   joinForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward),\n/* harmony export */   joinTextblockBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward),\n/* harmony export */   joinTextblockForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward),\n/* harmony export */   joinUp: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp),\n/* harmony export */   lift: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift),\n/* harmony export */   liftEmptyBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock),\n/* harmony export */   macBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap),\n/* harmony export */   newlineInCode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode),\n/* harmony export */   pcBaseKeymap: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap),\n/* harmony export */   selectAll: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll),\n/* harmony export */   selectNodeBackward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward),\n/* harmony export */   selectNodeForward: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward),\n/* harmony export */   selectParentNode: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode),\n/* harmony export */   selectTextblockEnd: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd),\n/* harmony export */   selectTextblockStart: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart),\n/* harmony export */   setBlockType: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType),\n/* harmony export */   splitBlock: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock),\n/* harmony export */   splitBlockAs: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs),\n/* harmony export */   splitBlockKeepMarks: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks),\n/* harmony export */   toggleMark: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark),\n/* harmony export */   wrapIn: () => (/* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn)\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(ssr)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLG9CQUFvQjtBQUNpQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vY29tbWFuZHMvZGlzdC9pbmRleC5qcz85MTJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbW1hbmRzL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/commands/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dropcursor/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: () => (/* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(ssr)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxzQkFBc0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Ryb3BjdXJzb3IvZGlzdC9pbmRleC5qcz9iZDM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRyb3BjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/gapcursor/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor),\n/* harmony export */   gapCursor: () => (/* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(ssr)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2dhcGN1cnNvci9kaXN0L2luZGV4LmpzP2MwYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2FwY3Vyc29yL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItZ2FwY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/history/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/history/dist/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory),\n/* harmony export */   history: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history),\n/* harmony export */   isHistoryTransaction: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.isHistoryTransaction),\n/* harmony export */   redo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo),\n/* harmony export */   redoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth),\n/* harmony export */   redoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll),\n/* harmony export */   undo: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo),\n/* harmony export */   undoDepth: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth),\n/* harmony export */   undoNoScroll: () => (/* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll)\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(ssr)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBLG1CQUFtQjtBQUNpQiIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vaGlzdG9yeS9kaXN0L2luZGV4LmpzPzE2NjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaGlzdG9yeS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLWhpc3RvcnlcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/history/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/keymap/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler),\n/* harmony export */   keymap: () => (/* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap)\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(ssr)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9rZXltYXAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxrQkFBa0I7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2tleW1hcC9kaXN0L2luZGV4LmpzPzRiZWIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8ga2V5bWFwL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/keymap/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/model/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/model/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch),\n/* harmony export */   DOMParser: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser),\n/* harmony export */   DOMSerializer: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer),\n/* harmony export */   Fragment: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment),\n/* harmony export */   Mark: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark),\n/* harmony export */   MarkType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType),\n/* harmony export */   Node: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node),\n/* harmony export */   NodeRange: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange),\n/* harmony export */   NodeType: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType),\n/* harmony export */   ReplaceError: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError),\n/* harmony export */   ResolvedPos: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos),\n/* harmony export */   Schema: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema),\n/* harmony export */   Slice: () => (/* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9tb2RlbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsaUJBQWlCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9tb2RlbC9kaXN0L2luZGV4LmpzP2E1YTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9kZWwvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/model/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/schema-list/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes),\n/* harmony export */   bulletList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList),\n/* harmony export */   liftListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem),\n/* harmony export */   listItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem),\n/* harmony export */   orderedList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList),\n/* harmony export */   sinkListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem),\n/* harmony export */   splitListItem: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem),\n/* harmony export */   splitListItemKeepMarks: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks),\n/* harmony export */   wrapInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList),\n/* harmony export */   wrapRangeInList: () => (/* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList)\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(ssr)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdUJBQXVCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzPzU0ZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2NoZW1hLWxpc3QvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1zY2hlbWEtbGlzdFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/schema-list/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/state/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/state/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection),\n/* harmony export */   EditorState: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState),\n/* harmony export */   NodeSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection),\n/* harmony export */   Plugin: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin),\n/* harmony export */   PluginKey: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey),\n/* harmony export */   Selection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection),\n/* harmony export */   SelectionRange: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange),\n/* harmony export */   TextSelection: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection),\n/* harmony export */   Transaction: () => (/* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction)\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(ssr)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxpQkFBaUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3N0YXRlL2Rpc3QvaW5kZXguanM/NzJlZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/state/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/transform/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep),\n/* harmony export */   DocAttrStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep),\n/* harmony export */   MapResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult),\n/* harmony export */   Mapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep),\n/* harmony export */   Step: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step),\n/* harmony export */   StepMap: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap),\n/* harmony export */   StepResult: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult),\n/* harmony export */   Transform: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform),\n/* harmony export */   TransformError: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError),\n/* harmony export */   canJoin: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin),\n/* harmony export */   canSplit: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit),\n/* harmony export */   dropPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint),\n/* harmony export */   findWrapping: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping),\n/* harmony export */   insertPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint),\n/* harmony export */   joinPoint: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint),\n/* harmony export */   liftTarget: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget),\n/* harmony export */   replaceStep: () => (/* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(ssr)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS90cmFuc2Zvcm0vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDaUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3RyYW5zZm9ybS9kaXN0L2luZGV4LmpzPzhhNGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNmb3JtL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/transform/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/pm/view/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/view/dist/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration),\n/* harmony export */   DecorationSet: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet),\n/* harmony export */   EditorView: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView),\n/* harmony export */   __endComposition: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition),\n/* harmony export */   __parseFromClipboard: () => (/* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard)\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(ssr)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS92aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsZ0JBQWdCO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vY29sbGFiLWRvY3MtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS92aWV3L2Rpc3QvaW5kZXguanM/NzU5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aWV3L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/pm/view/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: () => (/* binding */ BubbleMenu),\n/* harmony export */   CommandManager: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.CommandManager),\n/* harmony export */   Editor: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor),\n/* harmony export */   EditorConsumer: () => (/* binding */ EditorConsumer),\n/* harmony export */   EditorContent: () => (/* binding */ EditorContent),\n/* harmony export */   EditorContext: () => (/* binding */ EditorContext),\n/* harmony export */   EditorProvider: () => (/* binding */ EditorProvider),\n/* harmony export */   Extension: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension),\n/* harmony export */   FloatingMenu: () => (/* binding */ FloatingMenu),\n/* harmony export */   InputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.InputRule),\n/* harmony export */   Mark: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark),\n/* harmony export */   Node: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Node),\n/* harmony export */   NodePos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodePos),\n/* harmony export */   NodeView: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView),\n/* harmony export */   NodeViewContent: () => (/* binding */ NodeViewContent),\n/* harmony export */   NodeViewWrapper: () => (/* binding */ NodeViewWrapper),\n/* harmony export */   PasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.PasteRule),\n/* harmony export */   PureEditorContent: () => (/* binding */ PureEditorContent),\n/* harmony export */   ReactNodeView: () => (/* binding */ ReactNodeView),\n/* harmony export */   ReactNodeViewContext: () => (/* binding */ ReactNodeViewContext),\n/* harmony export */   ReactNodeViewRenderer: () => (/* binding */ ReactNodeViewRenderer),\n/* harmony export */   ReactRenderer: () => (/* binding */ ReactRenderer),\n/* harmony export */   Tracker: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Tracker),\n/* harmony export */   callOrReturn: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.callOrReturn),\n/* harmony export */   canInsertNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.canInsertNode),\n/* harmony export */   combineTransactionSteps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps),\n/* harmony export */   createChainableState: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createChainableState),\n/* harmony export */   createDocument: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createDocument),\n/* harmony export */   createNodeFromContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createNodeFromContent),\n/* harmony export */   createStyleTag: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createStyleTag),\n/* harmony export */   defaultBlockAt: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.defaultBlockAt),\n/* harmony export */   deleteProps: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.deleteProps),\n/* harmony export */   elementFromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.elementFromString),\n/* harmony export */   escapeForRegEx: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx),\n/* harmony export */   extensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.extensions),\n/* harmony export */   findChildren: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildren),\n/* harmony export */   findChildrenInRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange),\n/* harmony export */   findDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findDuplicates),\n/* harmony export */   findParentNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNode),\n/* harmony export */   findParentNodeClosestToPos: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNodeClosestToPos),\n/* harmony export */   fromString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.fromString),\n/* harmony export */   generateHTML: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateHTML),\n/* harmony export */   generateJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateJSON),\n/* harmony export */   generateText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateText),\n/* harmony export */   getAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes),\n/* harmony export */   getAttributesFromExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributesFromExtensions),\n/* harmony export */   getChangedRanges: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges),\n/* harmony export */   getDebugJSON: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getDebugJSON),\n/* harmony export */   getExtensionField: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getExtensionField),\n/* harmony export */   getHTMLFromFragment: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getHTMLFromFragment),\n/* harmony export */   getMarkAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkAttributes),\n/* harmony export */   getMarkRange: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkRange),\n/* harmony export */   getMarkType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkType),\n/* harmony export */   getMarksBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween),\n/* harmony export */   getNodeAtPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAtPosition),\n/* harmony export */   getNodeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAttributes),\n/* harmony export */   getNodeType: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeType),\n/* harmony export */   getRenderedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes),\n/* harmony export */   getSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchema),\n/* harmony export */   getSchemaByResolvedExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaByResolvedExtensions),\n/* harmony export */   getSchemaTypeByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeByName),\n/* harmony export */   getSchemaTypeNameByName: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeNameByName),\n/* harmony export */   getSplittedAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSplittedAttributes),\n/* harmony export */   getText: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getText),\n/* harmony export */   getTextBetween: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextBetween),\n/* harmony export */   getTextContentFromNodes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextContentFromNodes),\n/* harmony export */   getTextSerializersFromSchema: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextSerializersFromSchema),\n/* harmony export */   injectExtensionAttributesToParseRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.injectExtensionAttributesToParseRule),\n/* harmony export */   inputRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.inputRulesPlugin),\n/* harmony export */   isActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isActive),\n/* harmony export */   isAtEndOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtEndOfNode),\n/* harmony export */   isAtStartOfNode: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtStartOfNode),\n/* harmony export */   isEmptyObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject),\n/* harmony export */   isExtensionRulesEnabled: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isExtensionRulesEnabled),\n/* harmony export */   isFunction: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isFunction),\n/* harmony export */   isList: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isList),\n/* harmony export */   isMacOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMacOS),\n/* harmony export */   isMarkActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMarkActive),\n/* harmony export */   isNodeActive: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeActive),\n/* harmony export */   isNodeEmpty: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeEmpty),\n/* harmony export */   isNodeSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeSelection),\n/* harmony export */   isNumber: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNumber),\n/* harmony export */   isPlainObject: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isPlainObject),\n/* harmony export */   isRegExp: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isRegExp),\n/* harmony export */   isString: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isString),\n/* harmony export */   isTextSelection: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isTextSelection),\n/* harmony export */   isiOS: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isiOS),\n/* harmony export */   markInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markInputRule),\n/* harmony export */   markPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule),\n/* harmony export */   mergeAttributes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes),\n/* harmony export */   mergeDeep: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeDeep),\n/* harmony export */   minMax: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.minMax),\n/* harmony export */   nodeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodeInputRule),\n/* harmony export */   nodePasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodePasteRule),\n/* harmony export */   objectIncludes: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.objectIncludes),\n/* harmony export */   pasteRulesPlugin: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.pasteRulesPlugin),\n/* harmony export */   posToDOMRect: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.posToDOMRect),\n/* harmony export */   removeDuplicates: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.removeDuplicates),\n/* harmony export */   resolveFocusPosition: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.resolveFocusPosition),\n/* harmony export */   rewriteUnknownContent: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.rewriteUnknownContent),\n/* harmony export */   selectionToInsertionEnd: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.selectionToInsertionEnd),\n/* harmony export */   splitExtensions: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.splitExtensions),\n/* harmony export */   textInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textInputRule),\n/* harmony export */   textPasteRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textPasteRule),\n/* harmony export */   textblockTypeInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textblockTypeInputRule),\n/* harmony export */   useCurrentEditor: () => (/* binding */ useCurrentEditor),\n/* harmony export */   useEditor: () => (/* binding */ useEditor),\n/* harmony export */   useEditorState: () => (/* binding */ useEditorState),\n/* harmony export */   useReactNodeView: () => (/* binding */ useReactNodeView),\n/* harmony export */   wrappingInputRule: () => (/* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.wrappingInputRule)\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-bubble-menu */ \"(ssr)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-floating-menu */ \"(ssr)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\");\n\n\n\n\n\n\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar shim = {\n    exports: {}\n};\nvar useSyncExternalStoreShim_production_min = {};\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredUseSyncExternalStoreShim_production_min;\nfunction requireUseSyncExternalStoreShim_production_min() {\n    if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;\n    hasRequiredUseSyncExternalStoreShim_production_min = 1;\n    var e = react__WEBPACK_IMPORTED_MODULE_0__;\n    function h(a, b) {\n        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;\n    }\n    var k = \"function\" === typeof Object.is ? Object.is : h, l = e.useState, m = e.useEffect, n = e.useLayoutEffect, p = e.useDebugValue;\n    function q(a, b) {\n        var d = b(), f = l({\n            inst: {\n                value: d,\n                getSnapshot: b\n            }\n        }), c = f[0].inst, g = f[1];\n        n(function() {\n            c.value = d;\n            c.getSnapshot = b;\n            r(c) && g({\n                inst: c\n            });\n        }, [\n            a,\n            d,\n            b\n        ]);\n        m(function() {\n            r(c) && g({\n                inst: c\n            });\n            return a(function() {\n                r(c) && g({\n                    inst: c\n                });\n            });\n        }, [\n            a\n        ]);\n        p(d);\n        return d;\n    }\n    function r(a) {\n        var b = a.getSnapshot;\n        a = a.value;\n        try {\n            var d = b();\n            return !k(a, d);\n        } catch (f) {\n            return !0;\n        }\n    }\n    function t(a, b) {\n        return b();\n    }\n    var u =  true ? t : 0;\n    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e.useSyncExternalStore ? e.useSyncExternalStore : u;\n    return useSyncExternalStoreShim_production_min;\n}\nvar useSyncExternalStoreShim_development = {};\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredUseSyncExternalStoreShim_development;\nfunction requireUseSyncExternalStoreShim_development() {\n    if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;\n    hasRequiredUseSyncExternalStoreShim_development = 1;\n    if (true) {\n        (function() {\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n            }\n            var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n            var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n            function error(format) {\n                {\n                    {\n                        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                            args[_key2 - 1] = arguments[_key2];\n                        }\n                        printWarning(\"error\", format, args);\n                    }\n                }\n            }\n            function printWarning(level, format, args) {\n                // When changing this logic, you might want to also\n                // update consoleWithStackDev.www.js as well.\n                {\n                    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                    var stack = ReactDebugCurrentFrame.getStackAddendum();\n                    if (stack !== \"\") {\n                        format += \"%s\";\n                        args = args.concat([\n                            stack\n                        ]);\n                    } // eslint-disable-next-line react-internal/safe-string-coercion\n                    var argsWithFormat = args.map(function(item) {\n                        return String(item);\n                    }); // Careful: RN currently depends on this prefix\n                    argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                    // breaks IE9: https://github.com/facebook/react/issues/13610\n                    // eslint-disable-next-line react-internal/no-production-logging\n                    Function.prototype.apply.call(console[level], console, argsWithFormat);\n                }\n            }\n            /**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */ function is(x, y) {\n                return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n                ;\n            }\n            var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n            // dispatch for CommonJS interop named imports.\n            var useState = React$1.useState, useEffect = React$1.useEffect, useLayoutEffect = React$1.useLayoutEffect, useDebugValue = React$1.useDebugValue;\n            var didWarnOld18Alpha = false;\n            var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n            // because of a very particular set of implementation details and assumptions\n            // -- change any one of them and it will break. The most important assumption\n            // is that updates are always synchronous, because concurrent rendering is\n            // only available in versions of React that also have a built-in\n            // useSyncExternalStore API. And we only use this shim when the built-in API\n            // does not exist.\n            //\n            // Do not assume that the clever hacks used by this hook also work in general.\n            // The point of this shim is to replace the need for hacks by other libraries.\n            function useSyncExternalStore(subscribe, getSnapshot, // React do not expose a way to check if we're hydrating. So users of the shim\n            // will need to track that themselves and return the correct value\n            // from `getSnapshot`.\n            getServerSnapshot) {\n                {\n                    if (!didWarnOld18Alpha) {\n                        if (React$1.startTransition !== undefined) {\n                            didWarnOld18Alpha = true;\n                            error(\"You are using an outdated, pre-release alpha of React 18 that \" + \"does not support useSyncExternalStore. The \" + \"use-sync-external-store shim will not work correctly. Upgrade \" + \"to a newer pre-release.\");\n                        }\n                    }\n                }\n                // breaks the rules of React, and only works here because of specific\n                // implementation details, most importantly that updates are\n                // always synchronous.\n                var value = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedValue = getSnapshot();\n                        if (!objectIs(value, cachedValue)) {\n                            error(\"The result of getSnapshot should be cached to avoid an infinite loop\");\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // re-render whenever the subscribed state changes by updating an some\n                // arbitrary useState hook. Then, during render, we call getSnapshot to read\n                // the current value.\n                //\n                // Because we don't actually use the state returned by the useState hook, we\n                // can save a bit of memory by storing other stuff in that slot.\n                //\n                // To implement the early bailout, we need to track some things on a mutable\n                // object. Usually, we would put that in a useRef hook, but we can stash it in\n                // our useState hook instead.\n                //\n                // To force a re-render, we call forceUpdate({inst}). That works because the\n                // new object always fails an equality check.\n                var _useState = useState({\n                    inst: {\n                        value: value,\n                        getSnapshot: getSnapshot\n                    }\n                }), inst = _useState[0].inst, forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n                // in the layout phase so we can access it during the tearing check that\n                // happens on subscribe.\n                useLayoutEffect(function() {\n                    inst.value = value;\n                    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n                    // commit phase if there was an interleaved mutation. In concurrent mode\n                    // this can happen all the time, but even in synchronous mode, an earlier\n                    // effect may have mutated the store.\n                    if (checkIfSnapshotChanged(inst)) {\n                        // Force a re-render.\n                        forceUpdate({\n                            inst: inst\n                        });\n                    }\n                }, [\n                    subscribe,\n                    value,\n                    getSnapshot\n                ]);\n                useEffect(function() {\n                    // Check for changes right before subscribing. Subsequent changes will be\n                    // detected in the subscription handler.\n                    if (checkIfSnapshotChanged(inst)) {\n                        // Force a re-render.\n                        forceUpdate({\n                            inst: inst\n                        });\n                    }\n                    var handleStoreChange = function() {\n                        // TODO: Because there is no cross-renderer API for batching updates, it's\n                        // up to the consumer of this library to wrap their subscription event\n                        // with unstable_batchedUpdates. Should we try to detect when this isn't\n                        // the case and print a warning in development?\n                        // The store changed. Check if the snapshot changed since the last time we\n                        // read from the store.\n                        if (checkIfSnapshotChanged(inst)) {\n                            // Force a re-render.\n                            forceUpdate({\n                                inst: inst\n                            });\n                        }\n                    }; // Subscribe to the store and return a clean-up function.\n                    return subscribe(handleStoreChange);\n                }, [\n                    subscribe\n                ]);\n                useDebugValue(value);\n                return value;\n            }\n            function checkIfSnapshotChanged(inst) {\n                var latestGetSnapshot = inst.getSnapshot;\n                var prevValue = inst.value;\n                try {\n                    var nextValue = latestGetSnapshot();\n                    return !objectIs(prevValue, nextValue);\n                } catch (error) {\n                    return true;\n                }\n            }\n            function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n                // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n                // React do not expose a way to check if we're hydrating. So users of the shim\n                // will need to track that themselves and return the correct value\n                // from `getSnapshot`.\n                return getSnapshot();\n            }\n            var canUseDOM = !!( false && 0);\n            var isServerEnvironment = !canUseDOM;\n            var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n            var useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;\n            useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n            }\n        })();\n    }\n    return useSyncExternalStoreShim_development;\n}\nif (false) {} else {\n    shim.exports = requireUseSyncExternalStoreShim_development();\n}\nvar shimExports = shim.exports;\nconst mergeRefs = (...refs)=>{\n    return (node)=>{\n        refs.forEach((ref)=>{\n            if (typeof ref === \"function\") {\n                ref(node);\n            } else if (ref) {\n                ref.current = node;\n            }\n        });\n    };\n};\n/**\n * This component renders all of the editor's node views.\n */ const Portals = ({ contentComponent })=>{\n    // For performance reasons, we render the node view portals on state changes only\n    const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n    // This allows us to directly render the portals without any additional wrapper\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Object.values(renderers));\n};\nfunction getInstance() {\n    const subscribers = new Set();\n    let renderers = {};\n    return {\n        /**\n         * Subscribe to the editor instance's changes.\n         */ subscribe (callback) {\n            subscribers.add(callback);\n            return ()=>{\n                subscribers.delete(callback);\n            };\n        },\n        getSnapshot () {\n            return renderers;\n        },\n        getServerSnapshot () {\n            return renderers;\n        },\n        /**\n         * Adds a new NodeView Renderer to the editor.\n         */ setRenderer (id, renderer) {\n            renderers = {\n                ...renderers,\n                [id]: /*#__PURE__*/ react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id)\n            };\n            subscribers.forEach((subscriber)=>subscriber());\n        },\n        /**\n         * Removes a NodeView Renderer from the editor.\n         */ removeRenderer (id) {\n            const nextRenderers = {\n                ...renderers\n            };\n            delete nextRenderers[id];\n            renderers = nextRenderers;\n            subscribers.forEach((subscriber)=>subscriber());\n        }\n    };\n}\nclass PureEditorContent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        var _a;\n        super(props);\n        this.editorContentRef = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.initialized = false;\n        this.state = {\n            hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent)\n        };\n    }\n    componentDidMount() {\n        this.init();\n    }\n    componentDidUpdate() {\n        this.init();\n    }\n    init() {\n        const editor = this.props.editor;\n        if (editor && !editor.isDestroyed && editor.options.element) {\n            if (editor.contentComponent) {\n                return;\n            }\n            const element = this.editorContentRef.current;\n            element.append(...editor.options.element.childNodes);\n            editor.setOptions({\n                element\n            });\n            editor.contentComponent = getInstance();\n            // Has the content component been initialized?\n            if (!this.state.hasContentComponentInitialized) {\n                // Subscribe to the content component\n                this.unsubscribeToContentComponent = editor.contentComponent.subscribe(()=>{\n                    this.setState((prevState)=>{\n                        if (!prevState.hasContentComponentInitialized) {\n                            return {\n                                hasContentComponentInitialized: true\n                            };\n                        }\n                        return prevState;\n                    });\n                    // Unsubscribe to previous content component\n                    if (this.unsubscribeToContentComponent) {\n                        this.unsubscribeToContentComponent();\n                    }\n                });\n            }\n            editor.createNodeViews();\n            this.initialized = true;\n        }\n    }\n    componentWillUnmount() {\n        const editor = this.props.editor;\n        if (!editor) {\n            return;\n        }\n        this.initialized = false;\n        if (!editor.isDestroyed) {\n            editor.view.setProps({\n                nodeViews: {}\n            });\n        }\n        if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n        }\n        editor.contentComponent = null;\n        if (!editor.options.element.firstChild) {\n            return;\n        }\n        const newElement = document.createElement(\"div\");\n        newElement.append(...editor.options.element.childNodes);\n        editor.setOptions({\n            element: newElement\n        });\n    }\n    render() {\n        const { editor, innerRef, ...rest } = this.props;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n            ref: mergeRefs(innerRef, this.editorContentRef),\n            ...rest\n        }), (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portals, {\n            contentComponent: editor.contentComponent\n        }));\n    }\n}\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref)=>{\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return Math.floor(Math.random() * 0xffffffff).toString();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        props.editor\n    ]);\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n        key,\n        innerRef: ref,\n        ...props\n    });\n});\nconst EditorContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\nvar react = function equal(a, b) {\n    if (a === b) return true;\n    if (a && b && typeof a == \"object\" && typeof b == \"object\") {\n        if (a.constructor !== b.constructor) return false;\n        var length, i, keys;\n        if (Array.isArray(a)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;\n            return true;\n        }\n        if (a instanceof Map && b instanceof Map) {\n            if (a.size !== b.size) return false;\n            for (i of a.entries())if (!b.has(i[0])) return false;\n            for (i of a.entries())if (!equal(i[1], b.get(i[0]))) return false;\n            return true;\n        }\n        if (a instanceof Set && b instanceof Set) {\n            if (a.size !== b.size) return false;\n            for (i of a.entries())if (!b.has(i[0])) return false;\n            return true;\n        }\n        if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n            length = a.length;\n            if (length != b.length) return false;\n            for(i = length; i-- !== 0;)if (a[i] !== b[i]) return false;\n            return true;\n        }\n        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n        keys = Object.keys(a);\n        length = keys.length;\n        if (length !== Object.keys(b).length) return false;\n        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n        for(i = length; i-- !== 0;){\n            var key = keys[i];\n            if (key === \"_owner\" && a.$$typeof) {\n                continue;\n            }\n            if (!equal(a[key], b[key])) return false;\n        }\n        return true;\n    }\n    // true if both NaN, false otherwise\n    return a !== a && b !== b;\n};\nvar deepEqual = /*@__PURE__*/ getDefaultExportFromCjs(react);\nvar withSelector = {\n    exports: {}\n};\nvar withSelector_production_min = {};\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredWithSelector_production_min;\nfunction requireWithSelector_production_min() {\n    if (hasRequiredWithSelector_production_min) return withSelector_production_min;\n    hasRequiredWithSelector_production_min = 1;\n    var h = react__WEBPACK_IMPORTED_MODULE_0__, n = shimExports;\n    function p(a, b) {\n        return a === b && (0 !== a || 1 / a === 1 / b) || a !== a && b !== b;\n    }\n    var q = \"function\" === typeof Object.is ? Object.is : p, r = n.useSyncExternalStore, t = h.useRef, u = h.useEffect, v = h.useMemo, w = h.useDebugValue;\n    withSelector_production_min.useSyncExternalStoreWithSelector = function(a, b, e, l, g) {\n        var c = t(null);\n        if (null === c.current) {\n            var f = {\n                hasValue: !1,\n                value: null\n            };\n            c.current = f;\n        } else f = c.current;\n        c = v(function() {\n            function a(a) {\n                if (!c) {\n                    c = !0;\n                    d = a;\n                    a = l(a);\n                    if (void 0 !== g && f.hasValue) {\n                        var b = f.value;\n                        if (g(b, a)) return k = b;\n                    }\n                    return k = a;\n                }\n                b = k;\n                if (q(d, a)) return b;\n                var e = l(a);\n                if (void 0 !== g && g(b, e)) return b;\n                d = a;\n                return k = e;\n            }\n            var c = !1, d, k, m = void 0 === e ? null : e;\n            return [\n                function() {\n                    return a(b());\n                },\n                null === m ? void 0 : function() {\n                    return a(m());\n                }\n            ];\n        }, [\n            b,\n            e,\n            l,\n            g\n        ]);\n        var d = r(a, c[0], c[1]);\n        u(function() {\n            f.hasValue = !0;\n            f.value = d;\n        }, [\n            d\n        ]);\n        w(d);\n        return d;\n    };\n    return withSelector_production_min;\n}\nvar withSelector_development = {};\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var hasRequiredWithSelector_development;\nfunction requireWithSelector_development() {\n    if (hasRequiredWithSelector_development) return withSelector_development;\n    hasRequiredWithSelector_development = 1;\n    if (true) {\n        (function() {\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n            }\n            var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n            var shim = shimExports;\n            /**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */ function is(x, y) {\n                return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n                ;\n            }\n            var objectIs = typeof Object.is === \"function\" ? Object.is : is;\n            var useSyncExternalStore = shim.useSyncExternalStore;\n            // for CommonJS interop.\n            var useRef = React$1.useRef, useEffect = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n            function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n                // Use this to track the rendered snapshot.\n                var instRef = useRef(null);\n                var inst;\n                if (instRef.current === null) {\n                    inst = {\n                        hasValue: false,\n                        value: null\n                    };\n                    instRef.current = inst;\n                } else {\n                    inst = instRef.current;\n                }\n                var _useMemo = useMemo(function() {\n                    // Track the memoized state using closure variables that are local to this\n                    // memoized instance of a getSnapshot function. Intentionally not using a\n                    // useRef hook, because that state would be shared across all concurrent\n                    // copies of the hook/component.\n                    var hasMemo = false;\n                    var memoizedSnapshot;\n                    var memoizedSelection;\n                    var memoizedSelector = function(nextSnapshot) {\n                        if (!hasMemo) {\n                            // The first time the hook is called, there is no memoized result.\n                            hasMemo = true;\n                            memoizedSnapshot = nextSnapshot;\n                            var _nextSelection = selector(nextSnapshot);\n                            if (isEqual !== undefined) {\n                                // Even if the selector has changed, the currently rendered selection\n                                // may be equal to the new selection. We should attempt to reuse the\n                                // current value if possible, to preserve downstream memoizations.\n                                if (inst.hasValue) {\n                                    var currentSelection = inst.value;\n                                    if (isEqual(currentSelection, _nextSelection)) {\n                                        memoizedSelection = currentSelection;\n                                        return currentSelection;\n                                    }\n                                }\n                            }\n                            memoizedSelection = _nextSelection;\n                            return _nextSelection;\n                        } // We may be able to reuse the previous invocation's result.\n                        // We may be able to reuse the previous invocation's result.\n                        var prevSnapshot = memoizedSnapshot;\n                        var prevSelection = memoizedSelection;\n                        if (objectIs(prevSnapshot, nextSnapshot)) {\n                            // The snapshot is the same as last time. Reuse the previous selection.\n                            return prevSelection;\n                        } // The snapshot has changed, so we need to compute a new selection.\n                        // The snapshot has changed, so we need to compute a new selection.\n                        var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n                        // has changed. If it hasn't, return the previous selection. That signals\n                        // to React that the selections are conceptually equal, and we can bail\n                        // out of rendering.\n                        // If a custom isEqual function is provided, use that to check if the data\n                        // has changed. If it hasn't, return the previous selection. That signals\n                        // to React that the selections are conceptually equal, and we can bail\n                        // out of rendering.\n                        if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n                            return prevSelection;\n                        }\n                        memoizedSnapshot = nextSnapshot;\n                        memoizedSelection = nextSelection;\n                        return nextSelection;\n                    }; // Assigning this to a constant so that Flow knows it can't change.\n                    // Assigning this to a constant so that Flow knows it can't change.\n                    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n                    var getSnapshotWithSelector = function() {\n                        return memoizedSelector(getSnapshot());\n                    };\n                    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function() {\n                        return memoizedSelector(maybeGetServerSnapshot());\n                    };\n                    return [\n                        getSnapshotWithSelector,\n                        getServerSnapshotWithSelector\n                    ];\n                }, [\n                    getSnapshot,\n                    getServerSnapshot,\n                    selector,\n                    isEqual\n                ]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];\n                var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n                useEffect(function() {\n                    inst.hasValue = true;\n                    inst.value = value;\n                }, [\n                    value\n                ]);\n                useDebugValue(value);\n                return value;\n            }\n            withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n            /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n                __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n            }\n        })();\n    }\n    return withSelector_development;\n}\nif (false) {} else {\n    withSelector.exports = requireWithSelector_development();\n}\nvar withSelectorExports = withSelector.exports;\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */ class EditorStateManager {\n    constructor(initialEditor){\n        this.transactionNumber = 0;\n        this.lastTransactionNumber = 0;\n        this.subscribers = new Set();\n        this.editor = initialEditor;\n        this.lastSnapshot = {\n            editor: initialEditor,\n            transactionNumber: 0\n        };\n        this.getSnapshot = this.getSnapshot.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.watch = this.watch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n    }\n    /**\n     * Get the current editor instance.\n     */ getSnapshot() {\n        if (this.transactionNumber === this.lastTransactionNumber) {\n            return this.lastSnapshot;\n        }\n        this.lastTransactionNumber = this.transactionNumber;\n        this.lastSnapshot = {\n            editor: this.editor,\n            transactionNumber: this.transactionNumber\n        };\n        return this.lastSnapshot;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */ getServerSnapshot() {\n        return {\n            editor: null,\n            transactionNumber: 0\n        };\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */ subscribe(callback) {\n        this.subscribers.add(callback);\n        return ()=>{\n            this.subscribers.delete(callback);\n        };\n    }\n    /**\n     * Watch the editor instance for changes.\n     */ watch(nextEditor) {\n        this.editor = nextEditor;\n        if (this.editor) {\n            /**\n             * This will force a re-render when the editor state changes.\n             * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n             * This could be more efficient, but it's a good trade-off for now.\n             */ const fn = ()=>{\n                this.transactionNumber += 1;\n                this.subscribers.forEach((callback)=>callback());\n            };\n            const currentEditor = this.editor;\n            currentEditor.on(\"transaction\", fn);\n            return ()=>{\n                currentEditor.off(\"transaction\", fn);\n            };\n        }\n        return undefined;\n    }\n}\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */ function useEditorState(options) {\n    var _a;\n    const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new EditorStateManager(options.editor));\n    // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);\n    useIsomorphicLayoutEffect(()=>{\n        return editorStateManager.watch(options.editor);\n    }, [\n        options.editor,\n        editorStateManager\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n    return selectedState;\n}\nconst isDev = \"development\" !== \"production\";\nconst isSSR = \"undefined\" === \"undefined\";\nconst isNext = isSSR || Boolean( false && 0);\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */ class EditorInstanceManager {\n    constructor(options){\n        /**\n         * The current editor instance.\n         */ this.editor = null;\n        /**\n         * The subscriptions to notify when the editor instance\n         * has been created or destroyed.\n         */ this.subscriptions = new Set();\n        /**\n         * Whether the editor has been mounted.\n         */ this.isComponentMounted = false;\n        /**\n         * The most recent dependencies array.\n         */ this.previousDeps = null;\n        /**\n         * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n         */ this.instanceId = \"\";\n        this.options = options;\n        this.subscriptions = new Set();\n        this.setEditor(this.getInitialEditor());\n        this.scheduleDestroy();\n        this.getEditor = this.getEditor.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n        this.scheduleDestroy = this.scheduleDestroy.bind(this);\n        this.onRender = this.onRender.bind(this);\n        this.createEditor = this.createEditor.bind(this);\n    }\n    setEditor(editor) {\n        this.editor = editor;\n        this.instanceId = Math.random().toString(36).slice(2, 9);\n        // Notify all subscribers that the editor instance has been created\n        this.subscriptions.forEach((cb)=>cb());\n    }\n    getInitialEditor() {\n        if (this.options.current.immediatelyRender === undefined) {\n            if (isSSR || isNext) {\n                // TODO in the next major release, we should throw an error here\n                if (isDev) {\n                    /**\n                     * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n                     * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n                     */ console.warn(\"Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.\");\n                }\n                // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n                return null;\n            }\n            // Default to immediately rendering when client-side rendering\n            return this.createEditor();\n        }\n        if (this.options.current.immediatelyRender && isSSR && isDev) {\n            // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n            throw new Error(\"Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.\");\n        }\n        if (this.options.current.immediatelyRender) {\n            return this.createEditor();\n        }\n        return null;\n    }\n    /**\n     * Create a new editor instance. And attach event listeners.\n     */ createEditor() {\n        const optionsToApply = {\n            ...this.options.current,\n            // Always call the most recent version of the callback function by default\n            onBeforeCreate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onBlur: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onCreate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onDestroy: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onFocus: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onSelectionUpdate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onTransaction: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onUpdate: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onContentError: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onDrop: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            },\n            onPaste: (...args)=>{\n                var _a, _b;\n                return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args);\n            }\n        };\n        const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor(optionsToApply);\n        // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n        return editor;\n    }\n    /**\n     * Get the current editor instance.\n     */ getEditor() {\n        return this.editor;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */ getServerSnapshot() {\n        return null;\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */ subscribe(onStoreChange) {\n        this.subscriptions.add(onStoreChange);\n        return ()=>{\n            this.subscriptions.delete(onStoreChange);\n        };\n    }\n    static compareOptions(a, b) {\n        return Object.keys(a).every((key)=>{\n            if ([\n                \"onCreate\",\n                \"onBeforeCreate\",\n                \"onDestroy\",\n                \"onUpdate\",\n                \"onTransaction\",\n                \"onFocus\",\n                \"onBlur\",\n                \"onSelectionUpdate\",\n                \"onContentError\",\n                \"onDrop\",\n                \"onPaste\"\n            ].includes(key)) {\n                // we don't want to compare callbacks, they are always different and only registered once\n                return true;\n            }\n            // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n            if (key === \"extensions\" && a.extensions && b.extensions) {\n                if (a.extensions.length !== b.extensions.length) {\n                    return false;\n                }\n                return a.extensions.every((extension, index)=>{\n                    var _a;\n                    if (extension !== ((_a = b.extensions) === null || _a === void 0 ? void 0 : _a[index])) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            if (a[key] !== b[key]) {\n                // if any of the options have changed, we should update the editor options\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * On each render, we will create, update, or destroy the editor instance.\n     * @param deps The dependencies to watch for changes\n     * @returns A cleanup function\n     */ onRender(deps) {\n        // The returned callback will run on each render\n        return ()=>{\n            this.isComponentMounted = true;\n            // Cleanup any scheduled destructions, since we are currently rendering\n            clearTimeout(this.scheduledDestructionTimeout);\n            if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n                // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n                if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n                    // But, the options are different, so we need to update the editor options\n                    // Still, this is faster than re-creating the editor\n                    this.editor.setOptions({\n                        ...this.options.current,\n                        editable: this.editor.isEditable\n                    });\n                }\n            } else {\n                // When the editor:\n                // - does not yet exist\n                // - is destroyed\n                // - the deps array changes\n                // We need to destroy the editor instance and re-initialize it\n                this.refreshEditorInstance(deps);\n            }\n            return ()=>{\n                this.isComponentMounted = false;\n                this.scheduleDestroy();\n            };\n        };\n    }\n    /**\n     * Recreate the editor instance if the dependencies have changed.\n     */ refreshEditorInstance(deps) {\n        if (this.editor && !this.editor.isDestroyed) {\n            // Editor instance already exists\n            if (this.previousDeps === null) {\n                // If lastDeps has not yet been initialized, reuse the current editor instance\n                this.previousDeps = deps;\n                return;\n            }\n            const depsAreEqual = this.previousDeps.length === deps.length && this.previousDeps.every((dep, index)=>dep === deps[index]);\n            if (depsAreEqual) {\n                // deps exist and are equal, no need to recreate\n                return;\n            }\n        }\n        if (this.editor && !this.editor.isDestroyed) {\n            // Destroy the editor instance if it exists\n            this.editor.destroy();\n        }\n        this.setEditor(this.createEditor());\n        // Update the lastDeps to the current deps\n        this.previousDeps = deps;\n    }\n    /**\n     * Schedule the destruction of the editor instance.\n     * This will only destroy the editor if it was not mounted on the next tick.\n     * This is to avoid destroying the editor instance when it's actually still mounted.\n     */ scheduleDestroy() {\n        const currentInstanceId = this.instanceId;\n        const currentEditor = this.editor;\n        // Wait two ticks to see if the component is still mounted\n        this.scheduledDestructionTimeout = setTimeout(()=>{\n            if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n                // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n                if (currentEditor) {\n                    // just re-apply options as they might have changed\n                    currentEditor.setOptions(this.options.current);\n                }\n                return;\n            }\n            if (currentEditor && !currentEditor.isDestroyed) {\n                currentEditor.destroy();\n                if (this.instanceId === currentInstanceId) {\n                    this.setEditor(null);\n                }\n            }\n        // This allows the effect to run again between ticks\n        // which may save us from having to re-create the editor\n        }, 1);\n    }\n}\nfunction useEditor(options = {}, deps = []) {\n    const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    mostRecentOptions.current = options;\n    const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(()=>new EditorInstanceManager(mostRecentOptions));\n    const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n    // This effect will handle creating/updating the editor instance\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n    // The default behavior is to re-render on each transaction\n    // This is legacy behavior that will be removed in future versions\n    useEditorState({\n        editor,\n        selector: ({ transactionNumber })=>{\n            if (options.shouldRerenderOnTransaction === false) {\n                // This will prevent the editor from re-rendering on each transaction\n                return null;\n            }\n            // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n            if (options.immediatelyRender && transactionNumber === 0) {\n                return 0;\n            }\n            return transactionNumber + 1;\n        }\n    });\n    return editor;\n}\nconst EditorContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    editor: null\n});\nconst EditorConsumer = EditorContext.Consumer;\n/**\n * A hook to get the current editor instance.\n */ const useCurrentEditor = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */ function EditorProvider({ children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions }) {\n    const editor = useEditor(editorOptions);\n    if (!editor) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContext.Provider, {\n        value: {\n            editor\n        }\n    }, slotBefore, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorConsumer, null, ({ editor: currentEditor })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContent, {\n            editor: currentEditor,\n            ...editorContainerProps\n        })), children, slotAfter);\n}\nconst BubbleMenu = (props)=>{\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = \"bubbleMenu\", editor, tippyOptions = {}, updateDelay, shouldShow = null } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn(\"BubbleMenu component is not rendered inside of an editor component or does not have editor prop.\");\n            return;\n        }\n        const plugin = (0,_tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__.BubbleMenuPlugin)({\n            updateDelay,\n            editor: menuEditor,\n            element,\n            pluginKey,\n            shouldShow,\n            tippyOptions\n        });\n        menuEditor.registerPlugin(plugin);\n        return ()=>{\n            menuEditor.unregisterPlugin(pluginKey);\n        };\n    }, [\n        props.editor,\n        currentEditor,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: setElement,\n        className: props.className,\n        style: {\n            visibility: \"hidden\"\n        }\n    }, props.children);\n};\nconst FloatingMenu = (props)=>{\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = \"floatingMenu\", editor, tippyOptions = {}, shouldShow = null } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn(\"FloatingMenu component is not rendered inside of an editor component or does not have editor prop.\");\n            return;\n        }\n        const plugin = (0,_tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__.FloatingMenuPlugin)({\n            pluginKey,\n            editor: menuEditor,\n            element,\n            tippyOptions,\n            shouldShow\n        });\n        menuEditor.registerPlugin(plugin);\n        return ()=>{\n            menuEditor.unregisterPlugin(pluginKey);\n        };\n    }, [\n        props.editor,\n        currentEditor,\n        element\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: setElement,\n        className: props.className,\n        style: {\n            visibility: \"hidden\"\n        }\n    }, props.children);\n};\nconst ReactNodeViewContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    onDragStart: undefined\n});\nconst useReactNodeView = ()=>(0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\nconst NodeViewContent = (props)=>{\n    const Tag = props.as || \"div\";\n    const { nodeViewContentRef } = useReactNodeView();\n    return(// @ts-ignore\n    /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, {\n        ...props,\n        ref: nodeViewContentRef,\n        \"data-node-view-content\": \"\",\n        style: {\n            whiteSpace: \"pre-wrap\",\n            ...props.style\n        }\n    }));\n};\nconst NodeViewWrapper = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n    const { onDragStart } = useReactNodeView();\n    const Tag = props.as || \"div\";\n    return(// @ts-ignore\n    /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, {\n        ...props,\n        ref: ref,\n        \"data-node-view-wrapper\": \"\",\n        onDragStart: onDragStart,\n        style: {\n            whiteSpace: \"normal\",\n            ...props.style\n        }\n    }));\n});\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */ function isClassComponent(Component) {\n    return !!(typeof Component === \"function\" && Component.prototype && Component.prototype.isReactComponent);\n}\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */ function isForwardRefComponent(Component) {\n    return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.forward_ref)\" || Component.$$typeof.description === \"react.forward_ref\"));\n}\n/**\n * Check if a component is a memoized component.\n * @param Component\n * @returns {boolean}\n */ function isMemoComponent(Component) {\n    return !!(typeof Component === \"object\" && Component.$$typeof && (Component.$$typeof.toString() === \"Symbol(react.memo)\" || Component.$$typeof.description === \"react.memo\"));\n}\n/**\n * Check if a component can safely receive a ref prop.\n * This includes class components, forwardRef components, and memoized components\n * that wrap forwardRef or class components.\n * @param Component\n * @returns {boolean}\n */ function canReceiveRef(Component) {\n    // Check if it's a class component\n    if (isClassComponent(Component)) {\n        return true;\n    }\n    // Check if it's a forwardRef component\n    if (isForwardRefComponent(Component)) {\n        return true;\n    }\n    // Check if it's a memoized component\n    if (isMemoComponent(Component)) {\n        // For memoized components, check the wrapped component\n        const wrappedComponent = Component.type;\n        if (wrappedComponent) {\n            return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n        }\n    }\n    return false;\n}\n/**\n * Check if we're running React 19+ by detecting if function components support ref props\n * @returns {boolean}\n */ function isReact19Plus() {\n    // React 19 is detected by checking React version if available\n    // In practice, we'll use a more conservative approach and assume React 18 behavior\n    // unless we can definitively detect React 19\n    try {\n        // @ts-ignore\n        if (react__WEBPACK_IMPORTED_MODULE_0__.version) {\n            const majorVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version.split(\".\")[0], 10);\n            return majorVersion >= 19;\n        }\n    } catch  {\n    // Fallback to React 18 behavior if we can't determine version\n    }\n    return false;\n}\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n*/ class ReactRenderer {\n    /**\n     * Immediately creates element and renders the provided React component.\n     */ constructor(component, { editor, props = {}, as = \"div\", className = \"\" }){\n        this.ref = null;\n        this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n        this.component = component;\n        this.editor = editor;\n        this.props = props;\n        this.element = document.createElement(as);\n        this.element.classList.add(\"react-renderer\");\n        if (className) {\n            this.element.classList.add(...className.split(\" \"));\n        }\n        // If the editor is already initialized, we will need to\n        // synchronously render the component to ensure it renders\n        // together with Prosemirror's rendering.\n        if (this.editor.isInitialized) {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(()=>{\n                this.render();\n            });\n        } else {\n            queueMicrotask(()=>{\n                this.render();\n            });\n        }\n    }\n    /**\n     * Render the React component.\n     */ render() {\n        var _a;\n        const Component = this.component;\n        const props = this.props;\n        const editor = this.editor;\n        // Handle ref forwarding with React 18/19 compatibility\n        const isReact19 = isReact19Plus();\n        const componentCanReceiveRef = canReceiveRef(Component);\n        const elementProps = {\n            ...props\n        };\n        // Always remove ref if the component cannot receive it (unless React 19+)\n        if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n            delete elementProps.ref;\n        }\n        // Only assign our own ref if allowed\n        if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n            // @ts-ignore - Setting ref prop for compatible components\n            elementProps.ref = (ref)=>{\n                this.ref = ref;\n            };\n        }\n        this.reactElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, {\n            ...elementProps\n        });\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);\n    }\n    /**\n     * Re-renders the React component with new props.\n     */ updateProps(props = {}) {\n        this.props = {\n            ...this.props,\n            ...props\n        };\n        this.render();\n    }\n    /**\n     * Destroy the React component.\n     */ destroy() {\n        var _a;\n        const editor = this.editor;\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);\n    }\n    /**\n     * Update the attributes of the element that holds the React component.\n     */ updateAttributes(attributes) {\n        Object.keys(attributes).forEach((key)=>{\n            this.element.setAttribute(key, attributes[key]);\n        });\n    }\n}\nclass ReactNodeView extends _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView {\n    constructor(component, props, options){\n        super(component, props, options);\n        if (!this.node.isLeaf) {\n            if (this.options.contentDOMElementTag) {\n                this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n            } else {\n                this.contentDOMElement = document.createElement(this.node.isInline ? \"span\" : \"div\");\n            }\n            this.contentDOMElement.dataset.nodeViewContentReact = \"\";\n            this.contentDOMElement.dataset.nodeViewWrapper = \"\";\n            // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n            // With this fix it seems to work fine\n            // See: https://github.com/ueberdosis/tiptap/issues/1197\n            this.contentDOMElement.style.whiteSpace = \"inherit\";\n            const contentTarget = this.dom.querySelector(\"[data-node-view-content]\");\n            if (!contentTarget) {\n                return;\n            }\n            contentTarget.appendChild(this.contentDOMElement);\n        }\n    }\n    /**\n     * Setup the React component.\n     * Called on initialization.\n     */ mount() {\n        const props = {\n            editor: this.editor,\n            node: this.node,\n            decorations: this.decorations,\n            innerDecorations: this.innerDecorations,\n            view: this.view,\n            selected: false,\n            extension: this.extension,\n            HTMLAttributes: this.HTMLAttributes,\n            getPos: ()=>this.getPos(),\n            updateAttributes: (attributes = {})=>this.updateAttributes(attributes),\n            deleteNode: ()=>this.deleteNode(),\n            ref: /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)()\n        };\n        if (!this.component.displayName) {\n            const capitalizeFirstChar = (string)=>{\n                return string.charAt(0).toUpperCase() + string.substring(1);\n            };\n            this.component.displayName = capitalizeFirstChar(this.extension.name);\n        }\n        const onDragStart = this.onDragStart.bind(this);\n        const nodeViewContentRef = (element)=>{\n            if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n                // remove the nodeViewWrapper attribute from the element\n                if (element.hasAttribute(\"data-node-view-wrapper\")) {\n                    element.removeAttribute(\"data-node-view-wrapper\");\n                }\n                element.appendChild(this.contentDOMElement);\n            }\n        };\n        const context = {\n            onDragStart,\n            nodeViewContentRef\n        };\n        const Component = this.component;\n        // For performance reasons, we memoize the provider component\n        // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n        const ReactNodeViewProvider = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)((componentProps)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactNodeViewContext.Provider, {\n                value: context\n            }, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, componentProps));\n        });\n        ReactNodeViewProvider.displayName = \"ReactNodeView\";\n        let as = this.node.isInline ? \"span\" : \"div\";\n        if (this.options.as) {\n            as = this.options.as;\n        }\n        const { className = \"\" } = this.options;\n        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n        this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n            editor: this.editor,\n            props,\n            as,\n            className: `node-${this.node.type.name} ${className}`.trim()\n        });\n        this.editor.on(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.updateElementAttributes();\n    }\n    /**\n     * Return the DOM element.\n     * This is the element that will be used to display the node view.\n     */ get dom() {\n        var _a;\n        if (this.renderer.element.firstElementChild && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute(\"data-node-view-wrapper\"))) {\n            throw Error(\"Please use the NodeViewWrapper component for your node view.\");\n        }\n        return this.renderer.element;\n    }\n    /**\n     * Return the content DOM element.\n     * This is the element that will be used to display the rich-text content of the node.\n     */ get contentDOM() {\n        if (this.node.isLeaf) {\n            return null;\n        }\n        return this.contentDOMElement;\n    }\n    /**\n     * On editor selection update, check if the node is selected.\n     * If it is, call `selectNode`, otherwise call `deselectNode`.\n     */ handleSelectionUpdate() {\n        const { from, to } = this.editor.state.selection;\n        const pos = this.getPos();\n        if (typeof pos !== \"number\") {\n            return;\n        }\n        if (from <= pos && to >= pos + this.node.nodeSize) {\n            if (this.renderer.props.selected) {\n                return;\n            }\n            this.selectNode();\n        } else {\n            if (!this.renderer.props.selected) {\n                return;\n            }\n            this.deselectNode();\n        }\n    }\n    /**\n     * On update, update the React component.\n     * To prevent unnecessary updates, the `update` option can be used.\n     */ update(node, decorations, innerDecorations) {\n        const rerenderComponent = (props)=>{\n            this.renderer.updateProps(props);\n            if (typeof this.options.attrs === \"function\") {\n                this.updateElementAttributes();\n            }\n        };\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        if (typeof this.options.update === \"function\") {\n            const oldNode = this.node;\n            const oldDecorations = this.decorations;\n            const oldInnerDecorations = this.innerDecorations;\n            this.node = node;\n            this.decorations = decorations;\n            this.innerDecorations = innerDecorations;\n            return this.options.update({\n                oldNode,\n                oldDecorations,\n                newNode: node,\n                newDecorations: decorations,\n                oldInnerDecorations,\n                innerDecorations,\n                updateProps: ()=>rerenderComponent({\n                        node,\n                        decorations,\n                        innerDecorations\n                    })\n            });\n        }\n        if (node === this.node && this.decorations === decorations && this.innerDecorations === innerDecorations) {\n            return true;\n        }\n        this.node = node;\n        this.decorations = decorations;\n        this.innerDecorations = innerDecorations;\n        rerenderComponent({\n            node,\n            decorations,\n            innerDecorations\n        });\n        return true;\n    }\n    /**\n     * Select the node.\n     * Add the `selected` prop and the `ProseMirror-selectednode` class.\n     */ selectNode() {\n        this.renderer.updateProps({\n            selected: true\n        });\n        this.renderer.element.classList.add(\"ProseMirror-selectednode\");\n    }\n    /**\n     * Deselect the node.\n     * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n     */ deselectNode() {\n        this.renderer.updateProps({\n            selected: false\n        });\n        this.renderer.element.classList.remove(\"ProseMirror-selectednode\");\n    }\n    /**\n     * Destroy the React component instance.\n     */ destroy() {\n        this.renderer.destroy();\n        this.editor.off(\"selectionUpdate\", this.handleSelectionUpdate);\n        this.contentDOMElement = null;\n    }\n    /**\n     * Update the attributes of the top-level element that holds the React component.\n     * Applying the attributes defined in the `attrs` option.\n     */ updateElementAttributes() {\n        if (this.options.attrs) {\n            let attrsObj = {};\n            if (typeof this.options.attrs === \"function\") {\n                const extensionAttributes = this.editor.extensionManager.attributes;\n                const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes)(this.node, extensionAttributes);\n                attrsObj = this.options.attrs({\n                    node: this.node,\n                    HTMLAttributes\n                });\n            } else {\n                attrsObj = this.options.attrs;\n            }\n            this.renderer.updateAttributes(attrsObj);\n        }\n    }\n}\n/**\n * Create a React node view renderer.\n */ function ReactNodeViewRenderer(component, options) {\n    return (props)=>{\n        // try to get the parent component\n        // this is important for vue devtools to show the component hierarchy correctly\n        // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n        if (!props.editor.contentComponent) {\n            return {};\n        }\n        return new ReactNodeView(component, props, options);\n    };\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9yZWFjdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUU7QUFDMEc7QUFDM0g7QUFDdUI7QUFDMUM7QUFDd0M7QUFFckUsU0FBU29CLHdCQUF5QkMsQ0FBQztJQUNsQyxPQUFPQSxLQUFLQSxFQUFFQyxVQUFVLElBQUlDLE9BQU9DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNMLEdBQUcsYUFBYUEsQ0FBQyxDQUFDLFVBQVUsR0FBR0E7QUFDakc7QUFFQSxJQUFJTSxPQUFPO0lBQUNDLFNBQVMsQ0FBQztBQUFDO0FBRXZCLElBQUlDLDBDQUEwQyxDQUFDO0FBRS9DOzs7Ozs7OztDQVFDLEdBRUQsSUFBSUM7QUFFSixTQUFTQztJQUNSLElBQUlELG9EQUFvRCxPQUFPRDtJQUMvREMscURBQXFEO0lBQ3RELElBQUlFLElBQUUvQixrQ0FBS0E7SUFBQyxTQUFTZ0MsRUFBRUMsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsT0FBT0QsTUFBSUMsS0FBSSxPQUFJRCxLQUFHLElBQUVBLE1BQUksSUFBRUMsQ0FBQUEsS0FBSUQsTUFBSUEsS0FBR0MsTUFBSUE7SUFBQztJQUFDLElBQUlDLElBQUUsZUFBYSxPQUFPYixPQUFPYyxFQUFFLEdBQUNkLE9BQU9jLEVBQUUsR0FBQ0osR0FBRUssSUFBRU4sRUFBRTdCLFFBQVEsRUFBQ29DLElBQUVQLEVBQUUxQixTQUFTLEVBQUNrQyxJQUFFUixFQUFFM0IsZUFBZSxFQUFDb0MsSUFBRVQsRUFBRTVCLGFBQWE7SUFBQyxTQUFTc0MsRUFBRVIsQ0FBQyxFQUFDQyxDQUFDO1FBQUUsSUFBSVEsSUFBRVIsS0FBSVMsSUFBRU4sRUFBRTtZQUFDTyxNQUFLO2dC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QUFDQSxJQUFJO29CQUFFa1E7Z0JBQWU7WUFDcEUsT0FDSztnQkFDRG9DLFdBQVcsSUFBSSxDQUFDL1AsT0FBTyxDQUFDd1AsS0FBSztZQUNqQztZQUNBLElBQUksQ0FBQzlRLFFBQVEsQ0FBQzhOLGdCQUFnQixDQUFDdUQ7UUFDbkM7SUFDSjtBQUNKO0FBQ0E7O0NBRUMsR0FDRCxTQUFTRyxzQkFBc0JsRSxTQUFTLEVBQUVoTSxPQUFPO0lBQzdDLE9BQU9aLENBQUFBO1FBQ0gsa0NBQWtDO1FBQ2xDLCtFQUErRTtRQUMvRSxxRUFBcUU7UUFDckUsSUFBSSxDQUFDQSxNQUFNTyxNQUFNLENBQUM3QixnQkFBZ0IsRUFBRTtZQUNoQyxPQUFPLENBQUM7UUFDWjtRQUNBLE9BQU8sSUFBSTZPLGNBQWNYLFdBQVc1TSxPQUFPWTtJQUMvQztBQUNKO0FBRWlTLENBQ2pTLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbGxhYi1kb2NzLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcmVhY3QvZGlzdC9pbmRleC5qcz9hYmJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1YmJsZU1lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudSc7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZURlYnVnVmFsdWUsIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHZlcnNpb24sIGNyZWF0ZVJlZiwgbWVtbywgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgRWRpdG9yLCBOb2RlVmlldywgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBGbG9hdGluZ01lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1mbG9hdGluZy1tZW51JztcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHNoaW0gPSB7ZXhwb3J0czoge319O1xuXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG5cbmZ1bmN0aW9uIHJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW4gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW4pIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG5cdGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluID0gMTtcbnZhciBlPVJlYWN0O2Z1bmN0aW9uIGgoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBrPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOmgsbD1lLnVzZVN0YXRlLG09ZS51c2VFZmZlY3Qsbj1lLnVzZUxheW91dEVmZmVjdCxwPWUudXNlRGVidWdWYWx1ZTtmdW5jdGlvbiBxKGEsYil7dmFyIGQ9YigpLGY9bCh7aW5zdDp7dmFsdWU6ZCxnZXRTbmFwc2hvdDpifX0pLGM9ZlswXS5pbnN0LGc9ZlsxXTtuKGZ1bmN0aW9uKCl7Yy52YWx1ZT1kO2MuZ2V0U25hcHNob3Q9YjtyKGMpJiZnKHtpbnN0OmN9KTt9LFthLGQsYl0pO20oZnVuY3Rpb24oKXtyKGMpJiZnKHtpbnN0OmN9KTtyZXR1cm4gYShmdW5jdGlvbigpe3IoYykmJmcoe2luc3Q6Y30pO30pfSxbYV0pO3AoZCk7cmV0dXJuIGR9XG5cdGZ1bmN0aW9uIHIoYSl7dmFyIGI9YS5nZXRTbmFwc2hvdDthPWEudmFsdWU7dHJ5e3ZhciBkPWIoKTtyZXR1cm4gIWsoYSxkKX1jYXRjaChmKXtyZXR1cm4gITB9fWZ1bmN0aW9uIHQoYSxiKXtyZXR1cm4gYigpfXZhciB1PVwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudD90OnE7dXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluLnVzZVN5bmNFeHRlcm5hbFN0b3JlPXZvaWQgMCE9PWUudXNlU3luY0V4dGVybmFsU3RvcmU/ZS51c2VTeW5jRXh0ZXJuYWxTdG9yZTp1O1xuXHRyZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluO1xufVxuXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQpIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQ7XG5cdGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ID0gMTtcblxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdCAgKGZ1bmN0aW9uKCkge1xuXG5cdC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0aWYgKFxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG5cdCAgICAnZnVuY3Rpb24nXG5cdCkge1xuXHQgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xuXHR9XG5cdCAgICAgICAgICB2YXIgUmVhY3QkMSA9IFJlYWN0O1xuXG5cdHZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0JDEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cblx0ZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG5cdCAge1xuXHQgICAge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuXHQgIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuXHQgIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuXHQgIHtcblx0ICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblx0ICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG5cdCAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG5cdCAgICAgIGZvcm1hdCArPSAnJXMnO1xuXHQgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG5cdCAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cblx0ICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG5cdCAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuXHQgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG5cdCAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblx0ICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG5cdCAqL1xuXHRmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdCAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICA7XG5cdH1cblxuXHR2YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cblx0Ly8gZGlzcGF0Y2ggZm9yIENvbW1vbkpTIGludGVyb3AgbmFtZWQgaW1wb3J0cy5cblxuXHR2YXIgdXNlU3RhdGUgPSBSZWFjdCQxLnVzZVN0YXRlLFxuXHQgICAgdXNlRWZmZWN0ID0gUmVhY3QkMS51c2VFZmZlY3QsXG5cdCAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdCQxLnVzZUxheW91dEVmZmVjdCxcblx0ICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdCQxLnVzZURlYnVnVmFsdWU7XG5cdHZhciBkaWRXYXJuT2xkMThBbHBoYSA9IGZhbHNlO1xuXHR2YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSBmYWxzZTsgLy8gRGlzY2xhaW1lcjogVGhpcyBzaGltIGJyZWFrcyBtYW55IG9mIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3Ncblx0Ly8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcblx0Ly8gLS0gY2hhbmdlIGFueSBvbmUgb2YgdGhlbSBhbmQgaXQgd2lsbCBicmVhay4gVGhlIG1vc3QgaW1wb3J0YW50IGFzc3VtcHRpb25cblx0Ly8gaXMgdGhhdCB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIGJlY2F1c2UgY29uY3VycmVudCByZW5kZXJpbmcgaXNcblx0Ly8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuXHQvLyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBBUEkuIEFuZCB3ZSBvbmx5IHVzZSB0aGlzIHNoaW0gd2hlbiB0aGUgYnVpbHQtaW4gQVBJXG5cdC8vIGRvZXMgbm90IGV4aXN0LlxuXHQvL1xuXHQvLyBEbyBub3QgYXNzdW1lIHRoYXQgdGhlIGNsZXZlciBoYWNrcyB1c2VkIGJ5IHRoaXMgaG9vayBhbHNvIHdvcmsgaW4gZ2VuZXJhbC5cblx0Ly8gVGhlIHBvaW50IG9mIHRoaXMgc2hpbSBpcyB0byByZXBsYWNlIHRoZSBuZWVkIGZvciBoYWNrcyBieSBvdGhlciBsaWJyYXJpZXMuXG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuXHQvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cblx0Ly8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG5cdC8vIGZyb20gYGdldFNuYXBzaG90YC5cblx0Z2V0U2VydmVyU25hcHNob3QpIHtcblx0ICB7XG5cdCAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG5cdCAgICAgIGlmIChSZWFjdCQxLnN0YXJ0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG5cdCAgICAgICAgZXJyb3IoJ1lvdSBhcmUgdXNpbmcgYW4gb3V0ZGF0ZWQsIHByZS1yZWxlYXNlIGFscGhhIG9mIFJlYWN0IDE4IHRoYXQgJyArICdkb2VzIG5vdCBzdXBwb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlLiBUaGUgJyArICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZSBzaGltIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LiBVcGdyYWRlICcgKyAndG8gYSBuZXdlciBwcmUtcmVsZWFzZS4nKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIEFnYWluLCB0aGlzXG5cdCAgLy8gYnJlYWtzIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIG9mIHNwZWNpZmljXG5cdCAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG5cdCAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cblx0ICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdCAge1xuXHQgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuXHQgICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdCAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuXHQgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG5cdCAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSAvLyBCZWNhdXNlIHVwZGF0ZXMgYXJlIHN5bmNocm9ub3VzLCB3ZSBkb24ndCBxdWV1ZSB0aGVtLiBJbnN0ZWFkIHdlIGZvcmNlIGFcblx0ICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG5cdCAgLy8gYXJiaXRyYXJ5IHVzZVN0YXRlIGhvb2suIFRoZW4sIGR1cmluZyByZW5kZXIsIHdlIGNhbGwgZ2V0U25hcHNob3QgdG8gcmVhZFxuXHQgIC8vIHRoZSBjdXJyZW50IHZhbHVlLlxuXHQgIC8vXG5cdCAgLy8gQmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSB1c2UgdGhlIHN0YXRlIHJldHVybmVkIGJ5IHRoZSB1c2VTdGF0ZSBob29rLCB3ZVxuXHQgIC8vIGNhbiBzYXZlIGEgYml0IG9mIG1lbW9yeSBieSBzdG9yaW5nIG90aGVyIHN0dWZmIGluIHRoYXQgc2xvdC5cblx0ICAvL1xuXHQgIC8vIFRvIGltcGxlbWVudCB0aGUgZWFybHkgYmFpbG91dCwgd2UgbmVlZCB0byB0cmFjayBzb21lIHRoaW5ncyBvbiBhIG11dGFibGVcblx0ICAvLyBvYmplY3QuIFVzdWFsbHksIHdlIHdvdWxkIHB1dCB0aGF0IGluIGEgdXNlUmVmIGhvb2ssIGJ1dCB3ZSBjYW4gc3Rhc2ggaXQgaW5cblx0ICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuXHQgIC8vXG5cdCAgLy8gVG8gZm9yY2UgYSByZS1yZW5kZXIsIHdlIGNhbGwgZm9yY2VVcGRhdGUoe2luc3R9KS4gVGhhdCB3b3JrcyBiZWNhdXNlIHRoZVxuXHQgIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cblx0ICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoe1xuXHQgICAgaW5zdDoge1xuXHQgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuXHQgICAgfVxuXHQgIH0pLFxuXHQgICAgICBpbnN0ID0gX3VzZVN0YXRlWzBdLmluc3QsXG5cdCAgICAgIGZvcmNlVXBkYXRlID0gX3VzZVN0YXRlWzFdOyAvLyBUcmFjayB0aGUgbGF0ZXN0IGdldFNuYXBzaG90IGZ1bmN0aW9uIHdpdGggYSByZWYuIFRoaXMgbmVlZHMgdG8gYmUgdXBkYXRlZFxuXHQgIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuXHQgIC8vIGhhcHBlbnMgb24gc3Vic2NyaWJlLlxuXG5cblx0ICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuXHQgICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuXHQgICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcblx0ICAgIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuXHQgICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuXHQgICAgLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuXG5cdCAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cblx0ICAgICAgZm9yY2VVcGRhdGUoe1xuXHQgICAgICAgIGluc3Q6IGluc3Rcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSk7XG5cdCAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIHJpZ2h0IGJlZm9yZSBzdWJzY3JpYmluZy4gU3Vic2VxdWVudCBjaGFuZ2VzIHdpbGwgYmVcblx0ICAgIC8vIGRldGVjdGVkIGluIHRoZSBzdWJzY3JpcHRpb24gaGFuZGxlci5cblx0ICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG5cdCAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuXHQgICAgICBmb3JjZVVwZGF0ZSh7XG5cdCAgICAgICAgaW5zdDogaW5zdFxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBUT0RPOiBCZWNhdXNlIHRoZXJlIGlzIG5vIGNyb3NzLXJlbmRlcmVyIEFQSSBmb3IgYmF0Y2hpbmcgdXBkYXRlcywgaXQnc1xuXHQgICAgICAvLyB1cCB0byB0aGUgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5IHRvIHdyYXAgdGhlaXIgc3Vic2NyaXB0aW9uIGV2ZW50XG5cdCAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuXHQgICAgICAvLyB0aGUgY2FzZSBhbmQgcHJpbnQgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50P1xuXHQgICAgICAvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuXHQgICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuXHQgICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuXHQgICAgICAgIGZvcmNlVXBkYXRlKHtcblx0ICAgICAgICAgIGluc3Q6IGluc3Rcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuXHQgICAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG5cdCAgfSwgW3N1YnNjcmliZV0pO1xuXHQgIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuXHQgIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuXHQgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG5cdCAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cblx0ICB0cnkge1xuXHQgICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG5cdCAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUkMShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuXHQgIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2Zcblx0ICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cblx0ICAvLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcblx0ICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG5cdCAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG5cdH1cblxuXHR2YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cblx0dmFyIGlzU2VydmVyRW52aXJvbm1lbnQgPSAhY2FuVXNlRE9NO1xuXG5cdHZhciBzaGltID0gaXNTZXJ2ZXJFbnZpcm9ubWVudCA/IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEgOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblx0dmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdCQxLnVzZVN5bmNFeHRlcm5hbFN0b3JlICE9PSB1bmRlZmluZWQgPyBSZWFjdCQxLnVzZVN5bmNFeHRlcm5hbFN0b3JlIDogc2hpbTtcblxuXHR1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyO1xuXHQgICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuXHRpZiAoXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuXHQgICAgJ2Z1bmN0aW9uJ1xuXHQpIHtcblx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuXHR9XG5cdCAgICAgICAgXG5cdCAgfSkoKTtcblx0fVxuXHRyZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50O1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluKCk7XG59IGVsc2Uge1xuICBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50KCk7XG59XG5cbnZhciBzaGltRXhwb3J0cyA9IHNoaW0uZXhwb3J0cztcblxuY29uc3QgbWVyZ2VSZWZzID0gKC4uLnJlZnMpID0+IHtcbiAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlZihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgYWxsIG9mIHRoZSBlZGl0b3IncyBub2RlIHZpZXdzLlxuICovXG5jb25zdCBQb3J0YWxzID0gKHsgY29udGVudENvbXBvbmVudCwgfSkgPT4ge1xuICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSByZW5kZXIgdGhlIG5vZGUgdmlldyBwb3J0YWxzIG9uIHN0YXRlIGNoYW5nZXMgb25seVxuICAgIGNvbnN0IHJlbmRlcmVycyA9IHNoaW1FeHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlKGNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlLCBjb250ZW50Q29tcG9uZW50LmdldFNuYXBzaG90LCBjb250ZW50Q29tcG9uZW50LmdldFNlcnZlclNuYXBzaG90KTtcbiAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBkaXJlY3RseSByZW5kZXIgdGhlIHBvcnRhbHMgd2l0aG91dCBhbnkgYWRkaXRpb25hbCB3cmFwcGVyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBPYmplY3QudmFsdWVzKHJlbmRlcmVycykpKTtcbn07XG5mdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcmVuZGVyZXJzID0ge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmliZSB0byB0aGUgZWRpdG9yIGluc3RhbmNlJ3MgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNuYXBzaG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXJzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyBOb2RlVmlldyBSZW5kZXJlciB0byB0aGUgZWRpdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZW5kZXJlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVuZGVyZXJzLFxuICAgICAgICAgICAgICAgIFtpZF06IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChyZW5kZXJlci5yZWFjdEVsZW1lbnQsIHJlbmRlcmVyLmVsZW1lbnQsIGlkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcigpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBOb2RlVmlldyBSZW5kZXJlciBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVSZW5kZXJlcihpZCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFJlbmRlcmVycyA9IHsgLi4ucmVuZGVyZXJzIH07XG4gICAgICAgICAgICBkZWxldGUgbmV4dFJlbmRlcmVyc1tpZF07XG4gICAgICAgICAgICByZW5kZXJlcnMgPSBuZXh0UmVuZGVyZXJzO1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNsYXNzIFB1cmVFZGl0b3JDb250ZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250ZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZDogQm9vbGVhbigoX2EgPSBwcm9wcy5lZGl0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50Q29tcG9uZW50KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICAgICAgaWYgKGVkaXRvciAmJiAhZWRpdG9yLmlzRGVzdHJveWVkICYmIGVkaXRvci5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVkaXRvckNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKC4uLmVkaXRvci5vcHRpb25zLmVsZW1lbnQuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdG9yLmNvbnRlbnRDb21wb25lbnQgPSBnZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLy8gSGFzIHRoZSBjb250ZW50IGNvbXBvbmVudCBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgY29udGVudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50ID0gZWRpdG9yLmNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUuaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5zdWJzY3JpYmUgdG8gcHJldmlvdXMgY29udGVudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdG9yLmNyZWF0ZU5vZGVWaWV3cygpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGVkaXRvci52aWV3LnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICBub2RlVmlld3M6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIGlmICghZWRpdG9yLm9wdGlvbnMuZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBuZXdFbGVtZW50LmFwcGVuZCguLi5lZGl0b3Iub3B0aW9ucy5lbGVtZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBlbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGVkaXRvciwgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IG1lcmdlUmVmcyhpbm5lclJlZiwgdGhpcy5lZGl0b3JDb250ZW50UmVmKSwgLi4ucmVzdCB9KSxcbiAgICAgICAgICAgIChlZGl0b3IgPT09IG51bGwgfHwgZWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWxzLCB7IGNvbnRlbnRDb21wb25lbnQ6IGVkaXRvci5jb250ZW50Q29tcG9uZW50IH0pKSk7XG4gICAgfVxufVxuLy8gRWRpdG9yQ29udGVudCBzaG91bGQgYmUgcmUtY3JlYXRlZCB3aGVuZXZlciB0aGUgRWRpdG9yIGluc3RhbmNlIGNoYW5nZXNcbmNvbnN0IEVkaXRvckNvbnRlbnRXaXRoS2V5ID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IGtleSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtwcm9wcy5lZGl0b3JdKTtcbiAgICAvLyBDYW4ndCB1c2UgSlNYIGhlcmUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCB0aGUgdHlwZSBkZWZpbml0aW9uIG9mIFZ1ZSdzIEpTWCwgc28gdXNlIGNyZWF0ZUVsZW1lbnRcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQdXJlRWRpdG9yQ29udGVudCwge1xuICAgICAgICBrZXksXG4gICAgICAgIGlubmVyUmVmOiByZWYsXG4gICAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xufSk7XG5jb25zdCBFZGl0b3JDb250ZW50ID0gUmVhY3QubWVtbyhFZGl0b3JDb250ZW50V2l0aEtleSk7XG5cbnZhciByZWFjdCA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKChhIGluc3RhbmNlb2YgTWFwKSAmJiAoYiBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpIG9mIGEuZW50cmllcygpKVxuICAgICAgICBpZiAoIWIuaGFzKGlbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghZXF1YWwoaVsxXSwgYi5nZXQoaVswXSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoKGEgaW5zdGFuY2VvZiBTZXQpICYmIChiIGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghYi5oYXMoaVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgLy8gUmVhY3Qtc3BlY2lmaWM6IGF2b2lkIHRyYXZlcnNpbmcgUmVhY3QgZWxlbWVudHMnIF9vd25lci5cbiAgICAgICAgLy8gIF9vd25lciBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgIC8vIGFuZCBpcyBub3QgbmVlZGVkIHdoZW4gY29tcGFyaW5nIHRoZSBhY3R1YWwgZWxlbWVudHMgKGFuZCBub3QgdGhlaXIgb3duZXJzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuXG52YXIgZGVlcEVxdWFsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHJlYWN0KTtcblxudmFyIHdpdGhTZWxlY3RvciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciB3aXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW4gPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuXG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKSByZXR1cm4gd2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuXHRoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbiA9IDE7XG52YXIgaD1SZWFjdCxuPXNoaW1FeHBvcnRzO2Z1bmN0aW9uIHAoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBxPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOnAscj1uLnVzZVN5bmNFeHRlcm5hbFN0b3JlLHQ9aC51c2VSZWYsdT1oLnVzZUVmZmVjdCx2PWgudXNlTWVtbyx3PWgudXNlRGVidWdWYWx1ZTtcblx0d2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yPWZ1bmN0aW9uKGEsYixlLGwsZyl7dmFyIGM9dChudWxsKTtpZihudWxsPT09Yy5jdXJyZW50KXt2YXIgZj17aGFzVmFsdWU6ITEsdmFsdWU6bnVsbH07Yy5jdXJyZW50PWY7fWVsc2UgZj1jLmN1cnJlbnQ7Yz12KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtpZighYyl7Yz0hMDtkPWE7YT1sKGEpO2lmKHZvaWQgMCE9PWcmJmYuaGFzVmFsdWUpe3ZhciBiPWYudmFsdWU7aWYoZyhiLGEpKXJldHVybiBrPWJ9cmV0dXJuIGs9YX1iPWs7aWYocShkLGEpKXJldHVybiBiO3ZhciBlPWwoYSk7aWYodm9pZCAwIT09ZyYmZyhiLGUpKXJldHVybiBiO2Q9YTtyZXR1cm4gaz1lfXZhciBjPSExLGQsayxtPXZvaWQgMD09PWU/bnVsbDplO3JldHVybiBbZnVuY3Rpb24oKXtyZXR1cm4gYShiKCkpfSxudWxsPT09bT92b2lkIDA6ZnVuY3Rpb24oKXtyZXR1cm4gYShtKCkpfV19LFtiLGUsbCxnXSk7dmFyIGQ9cihhLGNbMF0sY1sxXSk7XG5cdHUoZnVuY3Rpb24oKXtmLmhhc1ZhbHVlPSEwO2YudmFsdWU9ZDt9LFtkXSk7dyhkKTtyZXR1cm4gZH07XG5cdHJldHVybiB3aXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW47XG59XG5cbnZhciB3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQgPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50KSByZXR1cm4gd2l0aFNlbGVjdG9yX2RldmVsb3BtZW50O1xuXHRoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudCA9IDE7XG5cblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHQgIChmdW5jdGlvbigpIHtcblxuXHQvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5cdGlmIChcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuXHQgICAgJ2Z1bmN0aW9uJ1xuXHQpIHtcblx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgICAgdmFyIFJlYWN0JDEgPSBSZWFjdDtcblx0dmFyIHNoaW0gPSBzaGltRXhwb3J0cztcblxuXHQvKipcblx0ICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuXHQgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcblx0ICovXG5cdGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0ICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHQgIDtcblx0fVxuXG5cdHZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxuXHR2YXIgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBzaGltLnVzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG5cdC8vIGZvciBDb21tb25KUyBpbnRlcm9wLlxuXG5cdHZhciB1c2VSZWYgPSBSZWFjdCQxLnVzZVJlZixcblx0ICAgIHVzZUVmZmVjdCA9IFJlYWN0JDEudXNlRWZmZWN0LFxuXHQgICAgdXNlTWVtbyA9IFJlYWN0JDEudXNlTWVtbyxcblx0ICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdCQxLnVzZURlYnVnVmFsdWU7IC8vIFNhbWUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUsIGJ1dCBzdXBwb3J0cyBzZWxlY3RvciBhbmQgaXNFcXVhbCBhcmd1bWVudHMuXG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG5cdCAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuXHQgIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuXHQgIHZhciBpbnN0O1xuXG5cdCAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgaW5zdCA9IHtcblx0ICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuXHQgICAgICB2YWx1ZTogbnVsbFxuXHQgICAgfTtcblx0ICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG5cdCAgfVxuXG5cdCAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBUcmFjayB0aGUgbWVtb2l6ZWQgc3RhdGUgdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMgdGhhdCBhcmUgbG9jYWwgdG8gdGhpc1xuXHQgICAgLy8gbWVtb2l6ZWQgaW5zdGFuY2Ugb2YgYSBnZXRTbmFwc2hvdCBmdW5jdGlvbi4gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYVxuXHQgICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG5cdCAgICAvLyBjb3BpZXMgb2YgdGhlIGhvb2svY29tcG9uZW50LlxuXHQgICAgdmFyIGhhc01lbW8gPSBmYWxzZTtcblx0ICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuXHQgICAgdmFyIG1lbW9pemVkU2VsZWN0aW9uO1xuXG5cdCAgICB2YXIgbWVtb2l6ZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChuZXh0U25hcHNob3QpIHtcblx0ICAgICAgaWYgKCFoYXNNZW1vKSB7XG5cdCAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgdGhlIGhvb2sgaXMgY2FsbGVkLCB0aGVyZSBpcyBubyBtZW1vaXplZCByZXN1bHQuXG5cdCAgICAgICAgaGFzTWVtbyA9IHRydWU7XG5cdCAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuXHQgICAgICAgIHZhciBfbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG5cblx0ICAgICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cblx0ICAgICAgICAgIC8vIG1heSBiZSBlcXVhbCB0byB0aGUgbmV3IHNlbGVjdGlvbi4gV2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmV1c2UgdGhlXG5cdCAgICAgICAgICAvLyBjdXJyZW50IHZhbHVlIGlmIHBvc3NpYmxlLCB0byBwcmVzZXJ2ZSBkb3duc3RyZWFtIG1lbW9pemF0aW9ucy5cblx0ICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcblxuXHQgICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBfbmV4dFNlbGVjdGlvbikpIHtcblx0ICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IF9uZXh0U2VsZWN0aW9uO1xuXHQgICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcblx0ICAgICAgfSAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cblxuXG5cdCAgICAgIC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuXHQgICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcblx0ICAgICAgdmFyIHByZXZTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcblxuXHQgICAgICBpZiAob2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpKSB7XG5cdCAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cblx0ICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcblx0ICAgICAgfSAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cblxuXHQgICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cdCAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTsgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcblx0ICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuXHQgICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuXHQgICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuXG5cdCAgICAgIC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG5cdCAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcblx0ICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcblx0ICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblx0ICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG5cdCAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG5cdCAgICAgIH1cblxuXHQgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuXHQgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb247XG5cdCAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uO1xuXHQgICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cblx0ICAgIC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cblx0ICAgIHZhciBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcblxuXHQgICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuXHQgIH0sIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXSksXG5cdCAgICAgIGdldFNlbGVjdGlvbiA9IF91c2VNZW1vWzBdLFxuXHQgICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuXHQgIHZhciB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U2VsZWN0aW9uLCBnZXRTZXJ2ZXJTZWxlY3Rpb24pO1xuXHQgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG5cdCAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcblx0ICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcblx0ICB9LCBbdmFsdWVdKTtcblx0ICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcblx0ICByZXR1cm4gdmFsdWU7XG5cdH1cblxuXHR3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3Rvcjtcblx0ICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0aWYgKFxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cblx0ICAgICdmdW5jdGlvbidcblx0KSB7XG5cdCAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgIFxuXHQgIH0pKCk7XG5cdH1cblx0cmV0dXJuIHdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgd2l0aFNlbGVjdG9yLmV4cG9ydHMgPSByZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKCk7XG59IGVsc2Uge1xuICB3aXRoU2VsZWN0b3IuZXhwb3J0cyA9IHJlcXVpcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQoKTtcbn1cblxudmFyIHdpdGhTZWxlY3RvckV4cG9ydHMgPSB3aXRoU2VsZWN0b3IuZXhwb3J0cztcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuLyoqXG4gKiBUbyBzeW5jaHJvbml6ZSB0aGUgZWRpdG9yIGluc3RhbmNlIHdpdGggdGhlIGNvbXBvbmVudCBzdGF0ZSxcbiAqIHdlIG5lZWQgdG8gY3JlYXRlIGEgc2VwYXJhdGUgaW5zdGFuY2UgdGhhdCBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzLlxuICovXG5jbGFzcyBFZGl0b3JTdGF0ZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxFZGl0b3IpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBpbml0aWFsRWRpdG9yO1xuICAgICAgICB0aGlzLmxhc3RTbmFwc2hvdCA9IHsgZWRpdG9yOiBpbml0aWFsRWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogMCB9O1xuICAgICAgICB0aGlzLmdldFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFNlcnZlclNuYXBzaG90ID0gdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLndhdGNoID0gdGhpcy53YXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0U25hcHNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uTnVtYmVyID09PSB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uTnVtYmVyID0gdGhpcy50cmFuc2FjdGlvbk51bWJlcjtcbiAgICAgICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogdGhpcy5lZGl0b3IsIHRyYW5zYWN0aW9uTnVtYmVyOiB0aGlzLnRyYW5zYWN0aW9uTnVtYmVyIH07XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RTbmFwc2hvdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiB7IGVkaXRvcjogbnVsbCwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhdGNoIHRoZSBlZGl0b3IgaW5zdGFuY2UgZm9yIGNoYW5nZXMuXG4gICAgICovXG4gICAgd2F0Y2gobmV4dEVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IG5leHRFZGl0b3I7XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgZm9yY2UgYSByZS1yZW5kZXIgd2hlbiB0aGUgZWRpdG9yIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRvIHN1cHBvcnQgdGhpbmdzIGxpa2UgYGVkaXRvci5jYW4oKS50b2dnbGVCb2xkKClgIGluIGNvbXBvbmVudHMgdGhhdCBgdXNlRWRpdG9yYC5cbiAgICAgICAgICAgICAqIFRoaXMgY291bGQgYmUgbW9yZSBlZmZpY2llbnQsIGJ1dCBpdCdzIGEgZ29vZCB0cmFkZS1vZmYgZm9yIG5vdy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgZm4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgICAgICBjdXJyZW50RWRpdG9yLm9uKCd0cmFuc2FjdGlvbicsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudEVkaXRvci5vZmYoJ3RyYW5zYWN0aW9uJywgZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBob29rIGFsbG93cyB5b3UgdG8gd2F0Y2ggZm9yIGNoYW5nZXMgb24gdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAqIEl0IHdpbGwgYWxsb3cgeW91IHRvIHNlbGVjdCBhIHBhcnQgb2YgdGhlIGVkaXRvciBzdGF0ZSBhbmQgcmUtcmVuZGVyIHRoZSBjb21wb25lbnQgd2hlbiBpdCBjaGFuZ2VzLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKHsuLi5vcHRpb25zfSlcbiAqIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdXNlRWRpdG9yU3RhdGUoe1xuICogIGVkaXRvcixcbiAqICBzZWxlY3Rvcjogc25hcHNob3QgPT4gKHsgY3VycmVudFNlbGVjdGlvbjogc25hcHNob3QuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbiB9KSxcbiAqIH0pXG4gKi9cbmZ1bmN0aW9uIHVzZUVkaXRvclN0YXRlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgW2VkaXRvclN0YXRlTWFuYWdlcl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgRWRpdG9yU3RhdGVNYW5hZ2VyKG9wdGlvbnMuZWRpdG9yKSk7XG4gICAgLy8gVXNpbmcgdGhlIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZWAgaG9vayB0byBzeW5jIHRoZSBlZGl0b3IgaW5zdGFuY2Ugd2l0aCB0aGUgY29tcG9uZW50IHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHdpdGhTZWxlY3RvckV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoZWRpdG9yU3RhdGVNYW5hZ2VyLnN1YnNjcmliZSwgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNuYXBzaG90LCBlZGl0b3JTdGF0ZU1hbmFnZXIuZ2V0U2VydmVyU25hcHNob3QsIG9wdGlvbnMuc2VsZWN0b3IsIChfYSA9IG9wdGlvbnMuZXF1YWxpdHlGbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVlcEVxdWFsKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVkaXRvclN0YXRlTWFuYWdlci53YXRjaChvcHRpb25zLmVkaXRvcik7XG4gICAgfSwgW29wdGlvbnMuZWRpdG9yLCBlZGl0b3JTdGF0ZU1hbmFnZXJdKTtcbiAgICB1c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuXG5jb25zdCBpc0RldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5jb25zdCBpc1NTUiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNOZXh0ID0gaXNTU1IgfHwgQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmV4dCk7XG4vKipcbiAqIFRoaXMgY2xhc3MgaGFuZGxlcyB0aGUgY3JlYXRpb24sIGRlc3RydWN0aW9uLCBhbmQgcmUtY3JlYXRpb24gb2YgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgRWRpdG9ySW5zdGFuY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Vic2NyaXB0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAqIGhhcyBiZWVuIGNyZWF0ZWQgb3IgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZWRpdG9yIGhhcyBiZWVuIG1vdW50ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vc3QgcmVjZW50IGRlcGVuZGVuY2llcyBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXNEZXBzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUgaW5zdGFuY2UgSUQuIFRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgZWRpdG9yIGluc3RhbmNlLiBBbmQgd2lsbCBiZSByZS1nZW5lcmF0ZWQgZm9yIGVhY2ggbmV3IGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gJyc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5zZXRFZGl0b3IodGhpcy5nZXRJbml0aWFsRWRpdG9yKCkpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgICAgICB0aGlzLmdldEVkaXRvciA9IHRoaXMuZ2V0RWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0U2VydmVyU25hcHNob3QgPSB0aGlzLmdldFNlcnZlclNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UgPSB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSA9IHRoaXMuc2NoZWR1bGVEZXN0cm95LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZW5kZXIgPSB0aGlzLm9uUmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRWRpdG9yID0gdGhpcy5jcmVhdGVFZGl0b3IuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgc2V0RWRpdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOSk7XG4gICAgICAgIC8vIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgdGhhdCB0aGUgZWRpdG9yIGluc3RhbmNlIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goY2IgPT4gY2IoKSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxFZGl0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VycmVudC5pbW1lZGlhdGVseVJlbmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNTU1IgfHwgaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLCB3ZSBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpc0Rldikge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhyb3cgYW4gZXJyb3IgaW4gZGV2ZWxvcG1lbnQsIHRvIG1ha2Ugc3VyZSB0aGUgZGV2ZWxvcGVyIGlzIGF3YXJlIHRoYXQgdGlwdGFwIGNhbm5vdCBiZSBTU1InZFxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgdGhhdCB0aGV5IG5lZWQgdG8gc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgdG8gYGZhbHNlYCB0byBhdm9pZCBoeWRyYXRpb24gbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGlwdGFwIEVycm9yOiBTU1IgaGFzIGJlZW4gZGV0ZWN0ZWQsIHBsZWFzZSBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCBleHBsaWNpdGx5IHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJlc3QgZmFpdGggZWZmb3J0IGluIHByb2R1Y3Rpb24sIHJ1biB0aGUgY29kZSBpbiB0aGUgbGVnYWN5IG1vZGUgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMgYW5kIGVycm9ycyBpbiBwcm9kdWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGltbWVkaWF0ZWx5IHJlbmRlcmluZyB3aGVuIGNsaWVudC1zaWRlIHJlbmRlcmluZ1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyICYmIGlzU1NSICYmIGlzRGV2KSB7XG4gICAgICAgICAgICAvLyBXYXJuIGluIGRldmVsb3BtZW50LCB0byBtYWtlIHN1cmUgdGhlIGRldmVsb3BlciBpcyBhd2FyZSB0aGF0IHRpcHRhcCBjYW5ub3QgYmUgU1NSJ2QsIHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpcHRhcCBFcnJvcjogU1NSIGhhcyBiZWVuIGRldGVjdGVkLCBhbmQgYGltbWVkaWF0ZWx5UmVuZGVyYCBoYXMgYmVlbiBzZXQgdG8gYHRydWVgIHRoaXMgaXMgYW4gdW5zdXBwb3J0ZWQgY29uZmlndXJhdGlvbiB0aGF0IG1heSByZXN1bHQgaW4gZXJyb3JzLCBleHBsaWNpdGx5IHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGVkaXRvciBpbnN0YW5jZS4gQW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgY3JlYXRlRWRpdG9yKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zVG9BcHBseSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5jdXJyZW50LFxuICAgICAgICAgICAgLy8gQWx3YXlzIGNhbGwgdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIG9uQmVmb3JlQ3JlYXRlOiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uQmVmb3JlQ3JlYXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvbkJsdXI6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25CbHVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvbkNyZWF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkNyZWF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25EZXN0cm95OiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRGVzdHJveSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25Gb2N1czogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkZvY3VzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblNlbGVjdGlvblVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25UcmFuc2FjdGlvbjogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25Db250ZW50RXJyb3I6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Db250ZW50RXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uRHJvcDogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkRyb3ApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uUGFzdGU6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25QYXN0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKG9wdGlvbnNUb0FwcGx5KTtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGVkaXRvciBpcyBkZXN0cm95ZWRcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChvblN0b3JlQ2hhbmdlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUob25TdG9yZUNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlT3B0aW9ucyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhKS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKFsnb25DcmVhdGUnLCAnb25CZWZvcmVDcmVhdGUnLCAnb25EZXN0cm95JywgJ29uVXBkYXRlJywgJ29uVHJhbnNhY3Rpb24nLCAnb25Gb2N1cycsICdvbkJsdXInLCAnb25TZWxlY3Rpb25VcGRhdGUnLCAnb25Db250ZW50RXJyb3InLCAnb25Ecm9wJywgJ29uUGFzdGUnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjb21wYXJlIGNhbGxiYWNrcywgdGhleSBhcmUgYWx3YXlzIGRpZmZlcmVudCBhbmQgb25seSByZWdpc3RlcmVkIG9uY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG9mdGVuIGVuY291cmFnZSBwdXR0aW5nIGV4dGVuc2lvbnMgaW5saW5lZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QsIHNvIHdlIHdpbGwgZG8gYSBzbGlnaHRseSBkZWVwZXIgY29tcGFyaXNvbiBoZXJlXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnZXh0ZW5zaW9ucycgJiYgYS5leHRlbnNpb25zICYmIGIuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhLmV4dGVuc2lvbnMubGVuZ3RoICE9PSBiLmV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZXh0ZW5zaW9ucy5ldmVyeSgoZXh0ZW5zaW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24gIT09ICgoX2EgPSBiLmV4dGVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbnkgb2YgdGhlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdXBkYXRlIHRoZSBlZGl0b3Igb3B0aW9uc1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZWFjaCByZW5kZXIsIHdlIHdpbGwgY3JlYXRlLCB1cGRhdGUsIG9yIGRlc3Ryb3kgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gZGVwcyBUaGUgZGVwZW5kZW5jaWVzIHRvIHdhdGNoIGZvciBjaGFuZ2VzXG4gICAgICogQHJldHVybnMgQSBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb25SZW5kZXIoZGVwcykge1xuICAgICAgICAvLyBUaGUgcmV0dXJuZWQgY2FsbGJhY2sgd2lsbCBydW4gb24gZWFjaCByZW5kZXJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIENsZWFudXAgYW55IHNjaGVkdWxlZCBkZXN0cnVjdGlvbnMsIHNpbmNlIHdlIGFyZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yICYmICF0aGlzLmVkaXRvci5pc0Rlc3Ryb3llZCAmJiBkZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlZGl0b3IgZG9lcyBleGlzdCAmIGRlcHMgYXJlIGVtcHR5LCB3ZSBkb24ndCBuZWVkIHRvIHJlLWluaXRpYWxpemUgdGhlIGVkaXRvciBnZW5lcmFsbHlcbiAgICAgICAgICAgICAgICBpZiAoIUVkaXRvckluc3RhbmNlTWFuYWdlci5jb21wYXJlT3B0aW9ucyh0aGlzLm9wdGlvbnMuY3VycmVudCwgdGhpcy5lZGl0b3Iub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0LCB0aGUgb3B0aW9ucyBhcmUgZGlmZmVyZW50LCBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgZWRpdG9yIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RpbGwsIHRoaXMgaXMgZmFzdGVyIHRoYW4gcmUtY3JlYXRpbmcgdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGVkaXRvcjpcbiAgICAgICAgICAgICAgICAvLyAtIGRvZXMgbm90IHlldCBleGlzdFxuICAgICAgICAgICAgICAgIC8vIC0gaXMgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgLy8gLSB0aGUgZGVwcyBhcnJheSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UgYW5kIHJlLWluaXRpYWxpemUgaXRcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZShkZXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjcmVhdGUgdGhlIGVkaXRvciBpbnN0YW5jZSBpZiB0aGUgZGVwZW5kZW5jaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICByZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcykge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBFZGl0b3IgaW5zdGFuY2UgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzRGVwcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGxhc3REZXBzIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQsIHJldXNlIHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNEZXBzID0gZGVwcztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXBzQXJlRXF1YWwgPSB0aGlzLnByZXZpb3VzRGVwcy5sZW5ndGggPT09IGRlcHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5wcmV2aW91c0RlcHMuZXZlcnkoKGRlcCwgaW5kZXgpID0+IGRlcCA9PT0gZGVwc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKGRlcHNBcmVFcXVhbCkge1xuICAgICAgICAgICAgICAgIC8vIGRlcHMgZXhpc3QgYW5kIGFyZSBlcXVhbCwgbm8gbmVlZCB0byByZWNyZWF0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRFZGl0b3IodGhpcy5jcmVhdGVFZGl0b3IoKSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdERlcHMgdG8gdGhlIGN1cnJlbnQgZGVwc1xuICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IGRlcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIHRoZSBkZXN0cnVjdGlvbiBvZiB0aGUgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqIFRoaXMgd2lsbCBvbmx5IGRlc3Ryb3kgdGhlIGVkaXRvciBpZiBpdCB3YXMgbm90IG1vdW50ZWQgb24gdGhlIG5leHQgdGljay5cbiAgICAgKiBUaGlzIGlzIHRvIGF2b2lkIGRlc3Ryb3lpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSB3aGVuIGl0J3MgYWN0dWFsbHkgc3RpbGwgbW91bnRlZC5cbiAgICAgKi9cbiAgICBzY2hlZHVsZURlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbnN0YW5jZUlkID0gdGhpcy5pbnN0YW5jZUlkO1xuICAgICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIC8vIFdhaXQgdHdvIHRpY2tzIHRvIHNlZSBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWRcbiAgICAgICAgdGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50TW91bnRlZCAmJiB0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3RpbGwgbW91bnRlZCBvbiB0aGUgZm9sbG93aW5nIHRpY2ssIHdpdGggdGhlIHNhbWUgaW5zdGFuY2VJZCwgZG8gbm90IGRlc3Ryb3kgdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmUtYXBwbHkgb3B0aW9ucyBhcyB0aGV5IG1pZ2h0IGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWRpdG9yLnNldE9wdGlvbnModGhpcy5vcHRpb25zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEVkaXRvciAmJiAhY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RWRpdG9yKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBlZmZlY3QgdG8gcnVuIGFnYWluIGJldHdlZW4gdGlja3NcbiAgICAgICAgICAgIC8vIHdoaWNoIG1heSBzYXZlIHVzIGZyb20gaGF2aW5nIHRvIHJlLWNyZWF0ZSB0aGUgZWRpdG9yXG4gICAgICAgIH0sIDEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVzZUVkaXRvcihvcHRpb25zID0ge30sIGRlcHMgPSBbXSkge1xuICAgIGNvbnN0IG1vc3RSZWNlbnRPcHRpb25zID0gdXNlUmVmKG9wdGlvbnMpO1xuICAgIG1vc3RSZWNlbnRPcHRpb25zLmN1cnJlbnQgPSBvcHRpb25zO1xuICAgIGNvbnN0IFtpbnN0YW5jZU1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVkaXRvckluc3RhbmNlTWFuYWdlcihtb3N0UmVjZW50T3B0aW9ucykpO1xuICAgIGNvbnN0IGVkaXRvciA9IHNoaW1FeHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlKGluc3RhbmNlTWFuYWdlci5zdWJzY3JpYmUsIGluc3RhbmNlTWFuYWdlci5nZXRFZGl0b3IsIGluc3RhbmNlTWFuYWdlci5nZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgdXNlRGVidWdWYWx1ZShlZGl0b3IpO1xuICAgIC8vIFRoaXMgZWZmZWN0IHdpbGwgaGFuZGxlIGNyZWF0aW5nL3VwZGF0aW5nIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgdXNlRWZmZWN0KGluc3RhbmNlTWFuYWdlci5vblJlbmRlcihkZXBzKSk7XG4gICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmUtcmVuZGVyIG9uIGVhY2ggdHJhbnNhY3Rpb25cbiAgICAvLyBUaGlzIGlzIGxlZ2FjeSBiZWhhdmlvciB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnNcbiAgICB1c2VFZGl0b3JTdGF0ZSh7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc2VsZWN0b3I6ICh7IHRyYW5zYWN0aW9uTnVtYmVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlcmVuZGVyT25UcmFuc2FjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCB0aGUgZWRpdG9yIGZyb20gcmUtcmVuZGVyaW5nIG9uIGVhY2ggdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBhdm9pZCByZS1yZW5kZXJpbmcgb24gdGhlIGZpcnN0IHRyYW5zYWN0aW9uIHdoZW4gYGltbWVkaWF0ZWx5UmVuZGVyYCBpcyBzZXQgdG8gYHRydWVgXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGVseVJlbmRlciAmJiB0cmFuc2FjdGlvbk51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uTnVtYmVyICsgMTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCBFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgZWRpdG9yOiBudWxsLFxufSk7XG5jb25zdCBFZGl0b3JDb25zdW1lciA9IEVkaXRvckNvbnRleHQuQ29uc3VtZXI7XG4vKipcbiAqIEEgaG9vayB0byBnZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICovXG5jb25zdCB1c2VDdXJyZW50RWRpdG9yID0gKCkgPT4gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbi8qKlxuICogVGhpcyBpcyB0aGUgcHJvdmlkZXIgY29tcG9uZW50IGZvciB0aGUgZWRpdG9yLlxuICogSXQgYWxsb3dzIHRoZSBlZGl0b3IgdG8gYmUgYWNjZXNzaWJsZSBhY3Jvc3MgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZVxuICogd2l0aCBgdXNlQ3VycmVudEVkaXRvcmAuXG4gKi9cbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHsgY2hpbGRyZW4sIHNsb3RBZnRlciwgc2xvdEJlZm9yZSwgZWRpdG9yQ29udGFpbmVyUHJvcHMgPSB7fSwgLi4uZWRpdG9yT3B0aW9ucyB9KSB7XG4gICAgY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKGVkaXRvck9wdGlvbnMpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBlZGl0b3IgfSB9LFxuICAgICAgICBzbG90QmVmb3JlLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnN1bWVyLCBudWxsLCAoeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGVudCwgeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IsIC4uLmVkaXRvckNvbnRhaW5lclByb3BzIH0pKSksXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzbG90QWZ0ZXIpKTtcbn1cblxuY29uc3QgQnViYmxlTWVudSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IFtlbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0gPSB1c2VDdXJyZW50RWRpdG9yKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHByb3BzLmVkaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRGVzdHJveWVkKSB8fCAoY3VycmVudEVkaXRvciA9PT0gbnVsbCB8fCBjdXJyZW50RWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RWRpdG9yLmlzRGVzdHJveWVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGx1Z2luS2V5ID0gJ2J1YmJsZU1lbnUnLCBlZGl0b3IsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSwgc2hvdWxkU2hvdyA9IG51bGwsIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbWVudUVkaXRvciA9IGVkaXRvciB8fCBjdXJyZW50RWRpdG9yO1xuICAgICAgICBpZiAoIW1lbnVFZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQnViYmxlTWVudSBjb21wb25lbnQgaXMgbm90IHJlbmRlcmVkIGluc2lkZSBvZiBhbiBlZGl0b3IgY29tcG9uZW50IG9yIGRvZXMgbm90IGhhdmUgZWRpdG9yIHByb3AuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGx1Z2luID0gQnViYmxlTWVudVBsdWdpbih7XG4gICAgICAgICAgICB1cGRhdGVEZWxheSxcbiAgICAgICAgICAgIGVkaXRvcjogbWVudUVkaXRvcixcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBwbHVnaW5LZXksXG4gICAgICAgICAgICBzaG91bGRTaG93LFxuICAgICAgICAgICAgdGlwcHlPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgbWVudUVkaXRvci5yZWdpc3RlclBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBtZW51RWRpdG9yLnVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luS2V5KTsgfTtcbiAgICB9LCBbcHJvcHMuZWRpdG9yLCBjdXJyZW50RWRpdG9yLCBlbGVtZW50XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBzZXRFbGVtZW50LCBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSwgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xufTtcblxuY29uc3QgRmxvYXRpbmdNZW51ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IgfSA9IHVzZUN1cnJlbnRFZGl0b3IoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gcHJvcHMuZWRpdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEZXN0cm95ZWQpIHx8IChjdXJyZW50RWRpdG9yID09PSBudWxsIHx8IGN1cnJlbnRFZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRFZGl0b3IuaXNEZXN0cm95ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwbHVnaW5LZXkgPSAnZmxvYXRpbmdNZW51JywgZWRpdG9yLCB0aXBweU9wdGlvbnMgPSB7fSwgc2hvdWxkU2hvdyA9IG51bGwsIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbWVudUVkaXRvciA9IGVkaXRvciB8fCBjdXJyZW50RWRpdG9yO1xuICAgICAgICBpZiAoIW1lbnVFZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmxvYXRpbmdNZW51IGNvbXBvbmVudCBpcyBub3QgcmVuZGVyZWQgaW5zaWRlIG9mIGFuIGVkaXRvciBjb21wb25lbnQgb3IgZG9lcyBub3QgaGF2ZSBlZGl0b3IgcHJvcC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbHVnaW4gPSBGbG9hdGluZ01lbnVQbHVnaW4oe1xuICAgICAgICAgICAgcGx1Z2luS2V5LFxuICAgICAgICAgICAgZWRpdG9yOiBtZW51RWRpdG9yLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHRpcHB5T3B0aW9ucyxcbiAgICAgICAgICAgIHNob3VsZFNob3csXG4gICAgICAgIH0pO1xuICAgICAgICBtZW51RWRpdG9yLnJlZ2lzdGVyUGx1Z2luKHBsdWdpbik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7IG1lbnVFZGl0b3IudW5yZWdpc3RlclBsdWdpbihwbHVnaW5LZXkpOyB9O1xuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuZWRpdG9yLFxuICAgICAgICBjdXJyZW50RWRpdG9yLFxuICAgICAgICBlbGVtZW50LFxuICAgIF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogc2V0RWxlbWVudCwgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsIHN0eWxlOiB7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn07XG5cbmNvbnN0IFJlYWN0Tm9kZVZpZXdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgb25EcmFnU3RhcnQ6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgdXNlUmVhY3ROb2RlVmlldyA9ICgpID0+IHVzZUNvbnRleHQoUmVhY3ROb2RlVmlld0NvbnRleHQpO1xuXG5jb25zdCBOb2RlVmlld0NvbnRlbnQgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgJ2Rpdic7XG4gICAgY29uc3QgeyBub2RlVmlld0NvbnRlbnRSZWYgfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgICByZXR1cm4gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgeyAuLi5wcm9wcywgcmVmOiBub2RlVmlld0NvbnRlbnRSZWYsIFwiZGF0YS1ub2RlLXZpZXctY29udGVudFwiOiBcIlwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgICAgICAgIC4uLnByb3BzLnN0eWxlLFxuICAgICAgICB9IH0pKTtcbn07XG5cbmNvbnN0IE5vZGVWaWV3V3JhcHBlciA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IG9uRHJhZ1N0YXJ0IH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XG4gICAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgJ2Rpdic7XG4gICAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHsgLi4ucHJvcHMsIHJlZjogcmVmLCBcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIjogXCJcIiwgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LCBzdHlsZToge1xuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vcm1hbCcsXG4gICAgICAgICAgICAuLi5wcm9wcy5zdHlsZSxcbiAgICAgICAgfSB9KSk7XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBpcyBhIGNsYXNzIGNvbXBvbmVudC5cbiAqIEBwYXJhbSBDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICYmIENvbXBvbmVudC5wcm90b3R5cGVcbiAgICAgICAgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb25lbnQgaXMgYSBmb3J3YXJkIHJlZiBjb21wb25lbnQuXG4gKiBAcGFyYW0gQ29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSAnb2JqZWN0J1xuICAgICAgICAmJiBDb21wb25lbnQuJCR0eXBlb2ZcbiAgICAgICAgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSAnU3ltYm9sKHJlYWN0LmZvcndhcmRfcmVmKSdcbiAgICAgICAgICAgIHx8IENvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbiA9PT0gJ3JlYWN0LmZvcndhcmRfcmVmJykpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBpcyBhIG1lbW9pemVkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSBDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc01lbW9Db21wb25lbnQoQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuICEhKHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICYmIENvbXBvbmVudC4kJHR5cGVvZlxuICAgICAgICAmJiAoQ29tcG9uZW50LiQkdHlwZW9mLnRvU3RyaW5nKCkgPT09ICdTeW1ib2wocmVhY3QubWVtbyknIHx8IENvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbiA9PT0gJ3JlYWN0Lm1lbW8nKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9uZW50IGNhbiBzYWZlbHkgcmVjZWl2ZSBhIHJlZiBwcm9wLlxuICogVGhpcyBpbmNsdWRlcyBjbGFzcyBjb21wb25lbnRzLCBmb3J3YXJkUmVmIGNvbXBvbmVudHMsIGFuZCBtZW1vaXplZCBjb21wb25lbnRzXG4gKiB0aGF0IHdyYXAgZm9yd2FyZFJlZiBvciBjbGFzcyBjb21wb25lbnRzLlxuICogQHBhcmFtIENvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNhblJlY2VpdmVSZWYoQ29tcG9uZW50KSB7XG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNsYXNzIGNvbXBvbmVudFxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGl0J3MgYSBmb3J3YXJkUmVmIGNvbXBvbmVudFxuICAgIGlmIChpc0ZvcndhcmRSZWZDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIG1lbW9pemVkIGNvbXBvbmVudFxuICAgIGlmIChpc01lbW9Db21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICAvLyBGb3IgbWVtb2l6ZWQgY29tcG9uZW50cywgY2hlY2sgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gICAgICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQudHlwZTtcbiAgICAgICAgaWYgKHdyYXBwZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KHdyYXBwZWRDb21wb25lbnQpIHx8IGlzRm9yd2FyZFJlZkNvbXBvbmVudCh3cmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJ1bm5pbmcgUmVhY3QgMTkrIGJ5IGRldGVjdGluZyBpZiBmdW5jdGlvbiBjb21wb25lbnRzIHN1cHBvcnQgcmVmIHByb3BzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZWFjdDE5UGx1cygpIHtcbiAgICAvLyBSZWFjdCAxOSBpcyBkZXRlY3RlZCBieSBjaGVja2luZyBSZWFjdCB2ZXJzaW9uIGlmIGF2YWlsYWJsZVxuICAgIC8vIEluIHByYWN0aWNlLCB3ZSdsbCB1c2UgYSBtb3JlIGNvbnNlcnZhdGl2ZSBhcHByb2FjaCBhbmQgYXNzdW1lIFJlYWN0IDE4IGJlaGF2aW9yXG4gICAgLy8gdW5sZXNzIHdlIGNhbiBkZWZpbml0aXZlbHkgZGV0ZWN0IFJlYWN0IDE5XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvbi5zcGxpdCgnLicpWzBdLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gbWFqb3JWZXJzaW9uID49IDE5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gUmVhY3QgMTggYmVoYXZpb3IgaWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIHZlcnNpb25cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBUaGUgUmVhY3RSZW5kZXJlciBjbGFzcy4gSXQncyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgaW5zaWRlIHRoZSBlZGl0b3IuXG4gKiBAZXhhbXBsZVxuICogbmV3IFJlYWN0UmVuZGVyZXIoTXlDb21wb25lbnQsIHtcbiAqICAgZWRpdG9yLFxuICogICBwcm9wczoge1xuICogICAgIGZvbzogJ2JhcicsXG4gKiAgIH0sXG4gKiAgIGFzOiAnc3BhbicsXG4gKiB9KVxuKi9cbmNsYXNzIFJlYWN0UmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNyZWF0ZXMgZWxlbWVudCBhbmQgcmVuZGVycyB0aGUgcHJvdmlkZWQgUmVhY3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlZGl0b3IsIHByb3BzID0ge30sIGFzID0gJ2RpdicsIGNsYXNzTmFtZSA9ICcnLCB9KSB7XG4gICAgICAgIHRoaXMucmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3JlYWN0LXJlbmRlcmVyJyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIHdlIHdpbGwgbmVlZCB0b1xuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IHJlbmRlciB0aGUgY29tcG9uZW50IHRvIGVuc3VyZSBpdCByZW5kZXJzXG4gICAgICAgIC8vIHRvZ2V0aGVyIHdpdGggUHJvc2VtaXJyb3IncyByZW5kZXJpbmcuXG4gICAgICAgIGlmICh0aGlzLmVkaXRvci5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICAvLyBIYW5kbGUgcmVmIGZvcndhcmRpbmcgd2l0aCBSZWFjdCAxOC8xOSBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IGlzUmVhY3QxOSA9IGlzUmVhY3QxOVBsdXMoKTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50Q2FuUmVjZWl2ZVJlZiA9IGNhblJlY2VpdmVSZWYoQ29tcG9uZW50KTtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BzID0geyAuLi5wcm9wcyB9O1xuICAgICAgICAvLyBBbHdheXMgcmVtb3ZlIHJlZiBpZiB0aGUgY29tcG9uZW50IGNhbm5vdCByZWNlaXZlIGl0ICh1bmxlc3MgUmVhY3QgMTkrKVxuICAgICAgICBpZiAoZWxlbWVudFByb3BzLnJlZiAmJiAhKGlzUmVhY3QxOSB8fCBjb21wb25lbnRDYW5SZWNlaXZlUmVmKSkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRQcm9wcy5yZWY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBhc3NpZ24gb3VyIG93biByZWYgaWYgYWxsb3dlZFxuICAgICAgICBpZiAoIWVsZW1lbnRQcm9wcy5yZWYgJiYgKGlzUmVhY3QxOSB8fCBjb21wb25lbnRDYW5SZWNlaXZlUmVmKSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFNldHRpbmcgcmVmIHByb3AgZm9yIGNvbXBhdGlibGUgY29tcG9uZW50c1xuICAgICAgICAgICAgZWxlbWVudFByb3BzLnJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFjdEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgeyAuLi5lbGVtZW50UHJvcHMgfSk7XG4gICAgICAgIChfYSA9IGVkaXRvciA9PT0gbnVsbCB8fCBlZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRvci5jb250ZW50Q29tcG9uZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0UmVuZGVyZXIodGhpcy5pZCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlLXJlbmRlcnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIG5ldyBwcm9wcy5cbiAgICAgKi9cbiAgICB1cGRhdGVQcm9wcyhwcm9wcyA9IHt9KSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICAoX2EgPSBlZGl0b3IgPT09IG51bGwgfHwgZWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVJlbmRlcmVyKHRoaXMuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQgdGhhdCBob2xkcyB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBSZWFjdE5vZGVWaWV3IGV4dGVuZHMgTm9kZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGUuaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LmRhdGFzZXQubm9kZVZpZXdDb250ZW50UmVhY3QgPSAnJztcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPSAnJztcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiB0aGUgd2hpdGVTcGFjZSBwcm9wIGlzIG5vdCBpbmhlcml0ZWQgcHJvcGVybHkgaW4gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIC8vIFdpdGggdGhpcyBmaXggaXQgc2VlbXMgdG8gd29yayBmaW5lXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTE5N1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gJ2luaGVyaXQnO1xuICAgICAgICAgICAgY29uc3QgY29udGVudFRhcmdldCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5vZGUtdmlldy1jb250ZW50XScpO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudFRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgICAqIENhbGxlZCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IHRoaXMuZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICBpbm5lckRlY29yYXRpb25zOiB0aGlzLmlubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgICAgICB2aWV3OiB0aGlzLnZpZXcsXG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb246IHRoaXMuZXh0ZW5zaW9uLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHRoaXMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBnZXRQb3M6ICgpID0+IHRoaXMuZ2V0UG9zKCksXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoYXR0cmlidXRlcyA9IHt9KSA9PiB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgICAgICAgICBkZWxldGVOb2RlOiAoKSA9PiB0aGlzLmRlbGV0ZU5vZGUoKSxcbiAgICAgICAgICAgIHJlZjogY3JlYXRlUmVmKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGl0YWxpemVGaXJzdENoYXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUgPSBjYXBpdGFsaXplRmlyc3RDaGFyKHRoaXMuZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBub2RlVmlld0NvbnRlbnRSZWYgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRoaXMuY29udGVudERPTUVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSB0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBub2RlVmlld1dyYXBwZXIgYXR0cmlidXRlIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbm9kZS12aWV3LXdyYXBwZXInKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1ub2RlLXZpZXctd3JhcHBlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBvbkRyYWdTdGFydCwgbm9kZVZpZXdDb250ZW50UmVmIH07XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgbWVtb2l6ZSB0aGUgcHJvdmlkZXIgY29tcG9uZW50XG4gICAgICAgIC8vIEFuZCBhbGwgb2YgdGhlIHRoaW5ncyBpdCByZXF1aXJlcyBhcmUgZGVjbGFyZWQgb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50LCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gcmUtcmVuZGVyXG4gICAgICAgIGNvbnN0IFJlYWN0Tm9kZVZpZXdQcm92aWRlciA9IG1lbW8oY29tcG9uZW50UHJvcHMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBjb21wb25lbnRQcm9wcykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFJlYWN0Tm9kZVZpZXdQcm92aWRlci5kaXNwbGF5TmFtZSA9ICdSZWFjdE5vZGVWaWV3JztcbiAgICAgICAgbGV0IGFzID0gdGhpcy5ub2RlLmlzSW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXMpIHtcbiAgICAgICAgICAgIGFzID0gdGhpcy5vcHRpb25zLmFzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lID0gJycgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUgPSB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlYWN0UmVuZGVyZXIoUmVhY3ROb2RlVmlld1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYG5vZGUtJHt0aGlzLm5vZGUudHlwZS5uYW1lfSAke2NsYXNzTmFtZX1gLnRyaW0oKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBET00gZWxlbWVudC5cbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIG5vZGUgdmlldy5cbiAgICAgKi9cbiAgICBnZXQgZG9tKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICAgICYmICEoKF9hID0gdGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzQXR0cmlidXRlKCdkYXRhLW5vZGUtdmlldy13cmFwcGVyJykpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUGxlYXNlIHVzZSB0aGUgTm9kZVZpZXdXcmFwcGVyIGNvbXBvbmVudCBmb3IgeW91ciBub2RlIHZpZXcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjb250ZW50IERPTSBlbGVtZW50LlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSB0aGUgcmljaC10ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZWRpdG9yIHNlbGVjdGlvbiB1cGRhdGUsIGNoZWNrIGlmIHRoZSBub2RlIGlzIHNlbGVjdGVkLlxuICAgICAqIElmIGl0IGlzLCBjYWxsIGBzZWxlY3ROb2RlYCwgb3RoZXJ3aXNlIGNhbGwgYGRlc2VsZWN0Tm9kZWAuXG4gICAgICovXG4gICAgaGFuZGxlU2VsZWN0aW9uVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MgKyB0aGlzLm5vZGUubm9kZVNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIHVwZGF0ZSwgdXBkYXRlIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICogVG8gcHJldmVudCB1bm5lY2Vzc2FyeSB1cGRhdGVzLCB0aGUgYHVwZGF0ZWAgb3B0aW9uIGNhbiBiZSB1c2VkLlxuICAgICAqL1xuICAgIHVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZXJlbmRlckNvbXBvbmVudCA9IChwcm9wcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gdGhpcy5ub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy51cGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBvbGREZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBvbGRJbm5lckRlY29yYXRpb25zID0gdGhpcy5pbm5lckRlY29yYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgICAgICAgICBvbGREZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBuZXdOb2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIG5ld0RlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBvbGRJbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgIGlubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHM6ICgpID0+IHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5ub2RlXG4gICAgICAgICAgICAmJiB0aGlzLmRlY29yYXRpb25zID09PSBkZWNvcmF0aW9uc1xuICAgICAgICAgICAgJiYgdGhpcy5pbm5lckRlY29yYXRpb25zID09PSBpbm5lckRlY29yYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgICAgIHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIG5vZGUuXG4gICAgICogQWRkIHRoZSBgc2VsZWN0ZWRgIHByb3AgYW5kIHRoZSBgUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlYCBjbGFzcy5cbiAgICAgKi9cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1Byb3NlTWlycm9yLXNlbGVjdGVkbm9kZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdCB0aGUgbm9kZS5cbiAgICAgKiBSZW1vdmUgdGhlIGBzZWxlY3RlZGAgcHJvcCBhbmQgdGhlIGBQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVgIGNsYXNzLlxuICAgICAqL1xuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7XG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRvcC1sZXZlbCBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKiBBcHBseWluZyB0aGUgYXR0cmlidXRlcyBkZWZpbmVkIGluIHRoZSBgYXR0cnNgIG9wdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGVFbGVtZW50QXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdHRycykge1xuICAgICAgICAgICAgbGV0IGF0dHJzT2JqID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXModGhpcy5ub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICBhdHRyc09iaiA9IHRoaXMub3B0aW9ucy5hdHRycyh7IG5vZGU6IHRoaXMubm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyc09iaiA9IHRoaXMub3B0aW9ucy5hdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQXR0cmlidXRlcyhhdHRyc09iaik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIFJlYWN0IG5vZGUgdmlldyByZW5kZXJlci5cbiAqL1xuZnVuY3Rpb24gUmVhY3ROb2RlVmlld1JlbmRlcmVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBwcm9wcyA9PiB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgdGhlIHBhcmVudCBjb21wb25lbnRcbiAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIHZ1ZSBkZXZ0b29scyB0byBzaG93IHRoZSBjb21wb25lbnQgaGllcmFyY2h5IGNvcnJlY3RseVxuICAgICAgICAvLyBtYXliZSBpdOKAmXMgYHVuZGVmaW5lZGAgYmVjYXVzZSA8ZWRpdG9yLWNvbnRlbnQ+IGlzbuKAmXQgcmVuZGVyZWQgeWV0XG4gICAgICAgIGlmICghcHJvcHMuZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlYWN0Tm9kZVZpZXcoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgQnViYmxlTWVudSwgRWRpdG9yQ29uc3VtZXIsIEVkaXRvckNvbnRlbnQsIEVkaXRvckNvbnRleHQsIEVkaXRvclByb3ZpZGVyLCBGbG9hdGluZ01lbnUsIE5vZGVWaWV3Q29udGVudCwgTm9kZVZpZXdXcmFwcGVyLCBQdXJlRWRpdG9yQ29udGVudCwgUmVhY3ROb2RlVmlldywgUmVhY3ROb2RlVmlld0NvbnRleHQsIFJlYWN0Tm9kZVZpZXdSZW5kZXJlciwgUmVhY3RSZW5kZXJlciwgdXNlQ3VycmVudEVkaXRvciwgdXNlRWRpdG9yLCB1c2VFZGl0b3JTdGF0ZSwgdXNlUmVhY3ROb2RlVmlldyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOlsiQnViYmxlTWVudVBsdWdpbiIsIlJlYWN0IiwiZm9yd2FyZFJlZiIsInVzZVN0YXRlIiwidXNlRGVidWdWYWx1ZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUVmZmVjdCIsInVzZVJlZiIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidmVyc2lvbiIsImNyZWF0ZVJlZiIsIm1lbW8iLCJjcmVhdGVFbGVtZW50IiwiUmVhY3RET00iLCJmbHVzaFN5bmMiLCJFZGl0b3IiLCJOb2RlVmlldyIsImdldFJlbmRlcmVkQXR0cmlidXRlcyIsIkZsb2F0aW5nTWVudVBsdWdpbiIsImdldERlZmF1bHRFeHBvcnRGcm9tQ2pzIiwieCIsIl9fZXNNb2R1bGUiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJzaGltIiwiZXhwb3J0cyIsInVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbiIsImhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluIiwicmVxdWlyZVVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9wcm9kdWN0aW9uX21pbiIsImUiLCJoIiwiYSIsImIiLCJrIiwiaXMiLCJsIiwibSIsIm4iLCJwIiwicSIsImQiLCJmIiwiaW5zdCIsInZhbHVlIiwiZ2V0U25hcHNob3QiLCJjIiwiZyIsInIiLCJ0IiwidSIsIndpbmRvdyIsImRvY3VtZW50IiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQiLCJoYXNSZXF1aXJlZFVzZVN5bmNFeHRlcm5hbFN0b3JlU2hpbV9kZXZlbG9wbWVudCIsInJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQiLCJwcm9jZXNzIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwicmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0IiwiRXJyb3IiLCJSZWFjdCQxIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsImVycm9yIiwiZm9ybWF0IiwiX2xlbjIiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5MiIsInByaW50V2FybmluZyIsImxldmVsIiwiUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSIsInN0YWNrIiwiZ2V0U3RhY2tBZGRlbmR1bSIsImNvbmNhdCIsImFyZ3NXaXRoRm9ybWF0IiwibWFwIiwiaXRlbSIsIlN0cmluZyIsInVuc2hpZnQiLCJGdW5jdGlvbiIsImFwcGx5IiwiY29uc29sZSIsInkiLCJvYmplY3RJcyIsImRpZFdhcm5PbGQxOEFscGhhIiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJzdWJzY3JpYmUiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsInN0YXJ0VHJhbnNpdGlvbiIsInVuZGVmaW5lZCIsImNhY2hlZFZhbHVlIiwiX3VzZVN0YXRlIiwiZm9yY2VVcGRhdGUiLCJjaGVja0lmU25hcHNob3RDaGFuZ2VkIiwiaGFuZGxlU3RvcmVDaGFuZ2UiLCJsYXRlc3RHZXRTbmFwc2hvdCIsInByZXZWYWx1ZSIsIm5leHRWYWx1ZSIsInVzZVN5bmNFeHRlcm5hbFN0b3JlJDEiLCJjYW5Vc2VET00iLCJpc1NlcnZlckVudmlyb25tZW50IiwidXNlU3luY0V4dGVybmFsU3RvcmUkMiIsInJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wIiwic2hpbUV4cG9ydHMiLCJtZXJnZVJlZnMiLCJyZWZzIiwibm9kZSIsImZvckVhY2giLCJyZWYiLCJjdXJyZW50IiwiUG9ydGFscyIsImNvbnRlbnRDb21wb25lbnQiLCJyZW5kZXJlcnMiLCJGcmFnbWVudCIsInZhbHVlcyIsImdldEluc3RhbmNlIiwic3Vic2NyaWJlcnMiLCJTZXQiLCJjYWxsYmFjayIsImFkZCIsImRlbGV0ZSIsInNldFJlbmRlcmVyIiwiaWQiLCJyZW5kZXJlciIsImNyZWF0ZVBvcnRhbCIsInJlYWN0RWxlbWVudCIsImVsZW1lbnQiLCJzdWJzY3JpYmVyIiwicmVtb3ZlUmVuZGVyZXIiLCJuZXh0UmVuZGVyZXJzIiwiUHVyZUVkaXRvckNvbnRlbnQiLCJDb21wb25lbnQiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwiX2EiLCJlZGl0b3JDb250ZW50UmVmIiwiaW5pdGlhbGl6ZWQiLCJzdGF0ZSIsImhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCIsIkJvb2xlYW4iLCJlZGl0b3IiLCJjb21wb25lbnREaWRNb3VudCIsImluaXQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJpc0Rlc3Ryb3llZCIsIm9wdGlvbnMiLCJhcHBlbmQiLCJjaGlsZE5vZGVzIiwic2V0T3B0aW9ucyIsInVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50Iiwic2V0U3RhdGUiLCJwcmV2U3RhdGUiLCJjcmVhdGVOb2RlVmlld3MiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInZpZXciLCJzZXRQcm9wcyIsIm5vZGVWaWV3cyIsImZpcnN0Q2hpbGQiLCJuZXdFbGVtZW50IiwicmVuZGVyIiwiaW5uZXJSZWYiLCJyZXN0IiwiRWRpdG9yQ29udGVudFdpdGhLZXkiLCJrZXkiLCJ1c2VNZW1vIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwidG9TdHJpbmciLCJFZGl0b3JDb250ZW50IiwicmVhY3QiLCJlcXVhbCIsImkiLCJrZXlzIiwiaXNBcnJheSIsIk1hcCIsInNpemUiLCJlbnRyaWVzIiwiaGFzIiwiZ2V0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJSZWdFeHAiLCJzb3VyY2UiLCJmbGFncyIsInZhbHVlT2YiLCIkJHR5cGVvZiIsImRlZXBFcXVhbCIsIndpdGhTZWxlY3RvciIsIndpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbiIsImhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluIiwicmVxdWlyZVdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbiIsInYiLCJ3IiwidXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IiLCJoYXNWYWx1ZSIsIndpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudCIsImhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50IiwicmVxdWlyZVdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudCIsInNlbGVjdG9yIiwiaXNFcXVhbCIsImluc3RSZWYiLCJfdXNlTWVtbyIsImhhc01lbW8iLCJtZW1vaXplZFNuYXBzaG90IiwibWVtb2l6ZWRTZWxlY3Rpb24iLCJtZW1vaXplZFNlbGVjdG9yIiwibmV4dFNuYXBzaG90IiwiX25leHRTZWxlY3Rpb24iLCJjdXJyZW50U2VsZWN0aW9uIiwicHJldlNuYXBzaG90IiwicHJldlNlbGVjdGlvbiIsIm5leHRTZWxlY3Rpb24iLCJtYXliZUdldFNlcnZlclNuYXBzaG90IiwiZ2V0U25hcHNob3RXaXRoU2VsZWN0b3IiLCJnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciIsImdldFNlbGVjdGlvbiIsImdldFNlcnZlclNlbGVjdGlvbiIsIndpdGhTZWxlY3RvckV4cG9ydHMiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiRWRpdG9yU3RhdGVNYW5hZ2VyIiwiaW5pdGlhbEVkaXRvciIsInRyYW5zYWN0aW9uTnVtYmVyIiwibGFzdFRyYW5zYWN0aW9uTnVtYmVyIiwibGFzdFNuYXBzaG90IiwiYmluZCIsIndhdGNoIiwibmV4dEVkaXRvciIsImZuIiwiY3VycmVudEVkaXRvciIsIm9uIiwib2ZmIiwidXNlRWRpdG9yU3RhdGUiLCJlZGl0b3JTdGF0ZU1hbmFnZXIiLCJzZWxlY3RlZFN0YXRlIiwiZXF1YWxpdHlGbiIsImlzRGV2IiwiaXNTU1IiLCJpc05leHQiLCJuZXh0IiwiRWRpdG9ySW5zdGFuY2VNYW5hZ2VyIiwic3Vic2NyaXB0aW9ucyIsImlzQ29tcG9uZW50TW91bnRlZCIsInByZXZpb3VzRGVwcyIsImluc3RhbmNlSWQiLCJzZXRFZGl0b3IiLCJnZXRJbml0aWFsRWRpdG9yIiwic2NoZWR1bGVEZXN0cm95IiwiZ2V0RWRpdG9yIiwicmVmcmVzaEVkaXRvckluc3RhbmNlIiwib25SZW5kZXIiLCJjcmVhdGVFZGl0b3IiLCJzbGljZSIsImNiIiwiaW1tZWRpYXRlbHlSZW5kZXIiLCJ3YXJuIiwib3B0aW9uc1RvQXBwbHkiLCJvbkJlZm9yZUNyZWF0ZSIsIl9iIiwib25CbHVyIiwib25DcmVhdGUiLCJvbkRlc3Ryb3kiLCJvbkZvY3VzIiwib25TZWxlY3Rpb25VcGRhdGUiLCJvblRyYW5zYWN0aW9uIiwib25VcGRhdGUiLCJvbkNvbnRlbnRFcnJvciIsIm9uRHJvcCIsIm9uUGFzdGUiLCJvblN0b3JlQ2hhbmdlIiwiY29tcGFyZU9wdGlvbnMiLCJldmVyeSIsImluY2x1ZGVzIiwiZXh0ZW5zaW9ucyIsImV4dGVuc2lvbiIsImluZGV4IiwiZGVwcyIsImNsZWFyVGltZW91dCIsInNjaGVkdWxlZERlc3RydWN0aW9uVGltZW91dCIsImVkaXRhYmxlIiwiaXNFZGl0YWJsZSIsImRlcHNBcmVFcXVhbCIsImRlcCIsImRlc3Ryb3kiLCJjdXJyZW50SW5zdGFuY2VJZCIsInNldFRpbWVvdXQiLCJ1c2VFZGl0b3IiLCJtb3N0UmVjZW50T3B0aW9ucyIsImluc3RhbmNlTWFuYWdlciIsInNob3VsZFJlcmVuZGVyT25UcmFuc2FjdGlvbiIsIkVkaXRvckNvbnRleHQiLCJFZGl0b3JDb25zdW1lciIsIkNvbnN1bWVyIiwidXNlQ3VycmVudEVkaXRvciIsIkVkaXRvclByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzbG90QWZ0ZXIiLCJzbG90QmVmb3JlIiwiZWRpdG9yQ29udGFpbmVyUHJvcHMiLCJlZGl0b3JPcHRpb25zIiwiUHJvdmlkZXIiLCJCdWJibGVNZW51Iiwic2V0RWxlbWVudCIsInBsdWdpbktleSIsInRpcHB5T3B0aW9ucyIsInVwZGF0ZURlbGF5Iiwic2hvdWxkU2hvdyIsIm1lbnVFZGl0b3IiLCJwbHVnaW4iLCJyZWdpc3RlclBsdWdpbiIsInVucmVnaXN0ZXJQbHVnaW4iLCJjbGFzc05hbWUiLCJzdHlsZSIsInZpc2liaWxpdHkiLCJGbG9hdGluZ01lbnUiLCJSZWFjdE5vZGVWaWV3Q29udGV4dCIsIm9uRHJhZ1N0YXJ0IiwidXNlUmVhY3ROb2RlVmlldyIsIk5vZGVWaWV3Q29udGVudCIsIlRhZyIsImFzIiwibm9kZVZpZXdDb250ZW50UmVmIiwid2hpdGVTcGFjZSIsIk5vZGVWaWV3V3JhcHBlciIsImlzQ2xhc3NDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiaXNGb3J3YXJkUmVmQ29tcG9uZW50IiwiZGVzY3JpcHRpb24iLCJpc01lbW9Db21wb25lbnQiLCJjYW5SZWNlaXZlUmVmIiwid3JhcHBlZENvbXBvbmVudCIsInR5cGUiLCJpc1JlYWN0MTlQbHVzIiwibWFqb3JWZXJzaW9uIiwicGFyc2VJbnQiLCJzcGxpdCIsIlJlYWN0UmVuZGVyZXIiLCJjb21wb25lbnQiLCJjbGFzc0xpc3QiLCJpc0luaXRpYWxpemVkIiwicXVldWVNaWNyb3Rhc2siLCJpc1JlYWN0MTkiLCJjb21wb25lbnRDYW5SZWNlaXZlUmVmIiwiZWxlbWVudFByb3BzIiwidXBkYXRlUHJvcHMiLCJ1cGRhdGVBdHRyaWJ1dGVzIiwiYXR0cmlidXRlcyIsInNldEF0dHJpYnV0ZSIsIlJlYWN0Tm9kZVZpZXciLCJpc0xlYWYiLCJjb250ZW50RE9NRWxlbWVudFRhZyIsImNvbnRlbnRET01FbGVtZW50IiwiaXNJbmxpbmUiLCJkYXRhc2V0Iiwibm9kZVZpZXdDb250ZW50UmVhY3QiLCJub2RlVmlld1dyYXBwZXIiLCJjb250ZW50VGFyZ2V0IiwiZG9tIiwicXVlcnlTZWxlY3RvciIsImFwcGVuZENoaWxkIiwibW91bnQiLCJkZWNvcmF0aW9ucyIsImlubmVyRGVjb3JhdGlvbnMiLCJzZWxlY3RlZCIsIkhUTUxBdHRyaWJ1dGVzIiwiZ2V0UG9zIiwiZGVsZXRlTm9kZSIsImRpc3BsYXlOYW1lIiwiY2FwaXRhbGl6ZUZpcnN0Q2hhciIsInN0cmluZyIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwic3Vic3RyaW5nIiwibmFtZSIsImhhc0F0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImNvbnRleHQiLCJSZWFjdE5vZGVWaWV3UHJvdmlkZXIiLCJjb21wb25lbnRQcm9wcyIsImhhbmRsZVNlbGVjdGlvblVwZGF0ZSIsInRyaW0iLCJ1cGRhdGVFbGVtZW50QXR0cmlidXRlcyIsImZpcnN0RWxlbWVudENoaWxkIiwiY29udGVudERPTSIsImZyb20iLCJ0byIsInNlbGVjdGlvbiIsInBvcyIsIm5vZGVTaXplIiwic2VsZWN0Tm9kZSIsImRlc2VsZWN0Tm9kZSIsInVwZGF0ZSIsInJlcmVuZGVyQ29tcG9uZW50IiwiYXR0cnMiLCJvbGROb2RlIiwib2xkRGVjb3JhdGlvbnMiLCJvbGRJbm5lckRlY29yYXRpb25zIiwibmV3Tm9kZSIsIm5ld0RlY29yYXRpb25zIiwicmVtb3ZlIiwiYXR0cnNPYmoiLCJleHRlbnNpb25BdHRyaWJ1dGVzIiwiZXh0ZW5zaW9uTWFuYWdlciIsIlJlYWN0Tm9kZVZpZXdSZW5kZXJlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/react/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: () => (/* binding */ StarterKit),\n/* harmony export */   \"default\": () => (/* binding */ StarterKit)\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/core */ \"(ssr)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(ssr)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(ssr)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bullet-list */ \"(ssr)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code */ \"(ssr)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(ssr)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ \"(ssr)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"(ssr)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"(ssr)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(ssr)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(ssr)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ \"(ssr)/./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(ssr)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(ssr)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-list-item */ \"(ssr)/./node_modules/@tiptap/extension-list-item/dist/index.js\");\n/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ \"(ssr)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(ssr)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(ssr)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-text */ \"(ssr)/./node_modules/@tiptap/extension-text/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The starter kit is a collection of essential editor extensions.\n *\n * It’s a good starting point for building your own editor.\n */ const StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_18__.Extension.create({\n    name: \"starterKit\",\n    addExtensions () {\n        const extensions = [];\n        if (this.options.bold !== false) {\n            extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure(this.options.bold));\n        }\n        if (this.options.blockquote !== false) {\n            extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure(this.options.blockquote));\n        }\n        if (this.options.bulletList !== false) {\n            extensions.push(_tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__.BulletList.configure(this.options.bulletList));\n        }\n        if (this.options.code !== false) {\n            extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__.Code.configure(this.options.code));\n        }\n        if (this.options.codeBlock !== false) {\n            extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__.CodeBlock.configure(this.options.codeBlock));\n        }\n        if (this.options.document !== false) {\n            extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__.Document.configure(this.options.document));\n        }\n        if (this.options.dropcursor !== false) {\n            extensions.push(_tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__.Dropcursor.configure(this.options.dropcursor));\n        }\n        if (this.options.gapcursor !== false) {\n            extensions.push(_tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__.Gapcursor.configure(this.options.gapcursor));\n        }\n        if (this.options.hardBreak !== false) {\n            extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__.HardBreak.configure(this.options.hardBreak));\n        }\n        if (this.options.heading !== false) {\n            extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__.Heading.configure(this.options.heading));\n        }\n        if (this.options.history !== false) {\n            extensions.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History.configure(this.options.history));\n        }\n        if (this.options.horizontalRule !== false) {\n            extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__.HorizontalRule.configure(this.options.horizontalRule));\n        }\n        if (this.options.italic !== false) {\n            extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__.Italic.configure(this.options.italic));\n        }\n        if (this.options.listItem !== false) {\n            extensions.push(_tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__.ListItem.configure(this.options.listItem));\n        }\n        if (this.options.orderedList !== false) {\n            extensions.push(_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__.OrderedList.configure(this.options.orderedList));\n        }\n        if (this.options.paragraph !== false) {\n            extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__.Paragraph.configure(this.options.paragraph));\n        }\n        if (this.options.strike !== false) {\n            extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__.Strike.configure(this.options.strike));\n        }\n        if (this.options.text !== false) {\n            extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__.Text.configure(this.options.text));\n        }\n        return extensions;\n    }\n});\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9zdGFydGVyLWtpdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF5QztBQUNpQjtBQUNaO0FBQ2E7QUFDYjtBQUNXO0FBQ0g7QUFDSTtBQUNGO0FBQ0M7QUFDTDtBQUNBO0FBQ2U7QUFDakI7QUFDSztBQUNNO0FBQ0w7QUFDTjtBQUNKO0FBRTlDOzs7O0NBSUMsR0FDRCxNQUFNbUIsYUFBYW5CLG9EQUFTQSxDQUFDb0IsTUFBTSxDQUFDO0lBQ2hDQyxNQUFNO0lBQ05DO1FBQ0ksTUFBTUMsYUFBYSxFQUFFO1FBQ3JCLElBQUksSUFBSSxDQUFDQyxPQUFPLENBQUNDLElBQUksS0FBSyxPQUFPO1lBQzdCRixXQUFXRyxJQUFJLENBQUN4Qix3REFBSUEsQ0FBQ3lCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0MsSUFBSTtRQUNwRDtRQUNBLElBQUksSUFBSSxDQUFDRCxPQUFPLENBQUNJLFVBQVUsS0FBSyxPQUFPO1lBQ25DTCxXQUFXRyxJQUFJLENBQUN6QixvRUFBVUEsQ0FBQzBCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksVUFBVTtRQUNoRTtRQUNBLElBQUksSUFBSSxDQUFDSixPQUFPLENBQUNLLFVBQVUsS0FBSyxPQUFPO1lBQ25DTixXQUFXRyxJQUFJLENBQUN2QixxRUFBVUEsQ0FBQ3dCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ssVUFBVTtRQUNoRTtRQUNBLElBQUksSUFBSSxDQUFDTCxPQUFPLENBQUNNLElBQUksS0FBSyxPQUFPO1lBQzdCUCxXQUFXRyxJQUFJLENBQUN0Qix3REFBSUEsQ0FBQ3VCLFNBQVMsQ0FBQyxJQUFJLENBQUNILE9BQU8sQ0FBQ00sSUFBSTtRQUNwRDtRQUNBLElBQUksSUFBSSxDQUFDTixPQUFPLENBQUNPLFNBQVMsS0FBSyxPQUFPO1lBQ2xDUixXQUFXRyxJQUFJLENBQUNyQixtRUFB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b2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L2Rpc3QvaW5kZXguanM/OWRiZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgQmxvY2txdW90ZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUnO1xuaW1wb3J0IHsgQm9sZCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQnO1xuaW1wb3J0IHsgQnVsbGV0TGlzdCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0JztcbmltcG9ydCB7IENvZGUgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1jb2RlJztcbmltcG9ydCB7IENvZGVCbG9jayB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2snO1xuaW1wb3J0IHsgRG9jdW1lbnQgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudCc7XG5pbXBvcnQgeyBEcm9wY3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tZHJvcGN1cnNvcic7XG5pbXBvcnQgeyBHYXBjdXJzb3IgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3InO1xuaW1wb3J0IHsgSGFyZEJyZWFrIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGFyZC1icmVhayc7XG5pbXBvcnQgeyBIZWFkaW5nIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGVhZGluZyc7XG5pbXBvcnQgeyBIaXN0b3J5IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taGlzdG9yeSc7XG5pbXBvcnQgeyBIb3Jpem9udGFsUnVsZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZSc7XG5pbXBvcnQgeyBJdGFsaWMgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMnO1xuaW1wb3J0IHsgTGlzdEl0ZW0gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0nO1xuaW1wb3J0IHsgT3JkZXJlZExpc3QgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1vcmRlcmVkLWxpc3QnO1xuaW1wb3J0IHsgUGFyYWdyYXBoIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tcGFyYWdyYXBoJztcbmltcG9ydCB7IFN0cmlrZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZSc7XG5pbXBvcnQgeyBUZXh0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tdGV4dCc7XG5cbi8qKlxuICogVGhlIHN0YXJ0ZXIga2l0IGlzIGEgY29sbGVjdGlvbiBvZiBlc3NlbnRpYWwgZWRpdG9yIGV4dGVuc2lvbnMuXG4gKlxuICogSXTigJlzIGEgZ29vZCBzdGFydGluZyBwb2ludCBmb3IgYnVpbGRpbmcgeW91ciBvd24gZWRpdG9yLlxuICovXG5jb25zdCBTdGFydGVyS2l0ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3N0YXJ0ZXJLaXQnLFxuICAgIGFkZEV4dGVuc2lvbnMoKSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ib2xkICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJvbGQuY29uZmlndXJlKHRoaXMub3B0aW9ucy5ib2xkKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ibG9ja3F1b3RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJsb2NrcXVvdGUuY29uZmlndXJlKHRoaXMub3B0aW9ucy5ibG9ja3F1b3RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEJ1bGxldExpc3QuY29uZmlndXJlKHRoaXMub3B0aW9ucy5idWxsZXRMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKENvZGUuY29uZmlndXJlKHRoaXMub3B0aW9ucy5jb2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2RlQmxvY2sgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQ29kZUJsb2NrLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuY29kZUJsb2NrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kb2N1bWVudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChEb2N1bWVudC5jb25maWd1cmUodGhpcy5vcHRpb25zLmRvY3VtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKERyb3BjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucy5kcm9wY3Vyc29yKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5nYXBjdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goR2FwY3Vyc29yLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuZ2FwY3Vyc29yKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oYXJkQnJlYWsgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSGFyZEJyZWFrLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaGFyZEJyZWFrKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkaW5nICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhlYWRpbmcuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oZWFkaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaXN0b3J5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhpc3RvcnkuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oaXN0b3J5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5ob3Jpem9udGFsUnVsZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChIb3Jpem9udGFsUnVsZS5jb25maWd1cmUodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pdGFsaWMgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSXRhbGljLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaXRhbGljKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXN0SXRlbSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChMaXN0SXRlbS5jb25maWd1cmUodGhpcy5vcHRpb25zLmxpc3RJdGVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcmRlcmVkTGlzdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChPcmRlcmVkTGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGggIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goUGFyYWdyYXBoLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMucGFyYWdyYXBoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHJpa2UgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goU3RyaWtlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuc3RyaWtlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50ZXh0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKFRleHQuY29uZmlndXJlKHRoaXMub3B0aW9ucy50ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbnM7XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBTdGFydGVyS2l0LCBTdGFydGVyS2l0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbIkV4dGVuc2lvbiIsIkJsb2NrcXVvdGUiLCJCb2xkIiwiQnVsbGV0TGlzdCIsIkNvZGUiLCJDb2RlQmxvY2siLCJEb2N1bWVudCIsIkRyb3BjdXJzb3IiLCJHYXBjdXJzb3IiLCJIYXJkQnJlYWsiLCJIZWFkaW5nIiwiSGlzdG9yeSIsIkhvcml6b250YWxSdWxlIiwiSXRhbGljIiwiTGlzdEl0ZW0iLCJPcmRlcmVkTGlzdCIsIlBhcmFncmFwaCIsIlN0cmlrZSIsIlRleHQiLCJTdGFydGVyS2l0IiwiY3JlYXRlIiwibmFtZSIsImFkZEV4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwib3B0aW9ucyIsImJvbGQiLCJwdXNoIiwiY29uZmlndXJlIiwiYmxvY2txdW90ZSIsImJ1bGxldExpc3QiLCJjb2RlIiwiY29kZUJsb2NrIiwiZG9jdW1lbnQiLCJkcm9wY3Vyc29yIiwiZ2FwY3Vyc29yIiwiaGFyZEJyZWFrIiwiaGVhZGluZyIsImhpc3RvcnkiLCJob3Jpem9udGFsUnVsZSIsIml0YWxpYyIsImxpc3RJdGVtIiwib3JkZXJlZExpc3QiLCJwYXJhZ3JhcGgiLCJzdHJpa2UiLCJ0ZXh0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@tiptap/starter-kit/dist/index.js\n");

/***/ })

};
;
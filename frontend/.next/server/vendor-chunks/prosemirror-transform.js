"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/prosemirror-transform";
exports.ids = ["vendor-chunks/prosemirror-transform"];
exports.modules = {

/***/ "(ssr)/./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: () => (/* binding */ AddMarkStep),\n/* harmony export */   AddNodeMarkStep: () => (/* binding */ AddNodeMarkStep),\n/* harmony export */   AttrStep: () => (/* binding */ AttrStep),\n/* harmony export */   DocAttrStep: () => (/* binding */ DocAttrStep),\n/* harmony export */   MapResult: () => (/* binding */ MapResult),\n/* harmony export */   Mapping: () => (/* binding */ Mapping),\n/* harmony export */   RemoveMarkStep: () => (/* binding */ RemoveMarkStep),\n/* harmony export */   RemoveNodeMarkStep: () => (/* binding */ RemoveNodeMarkStep),\n/* harmony export */   ReplaceAroundStep: () => (/* binding */ ReplaceAroundStep),\n/* harmony export */   ReplaceStep: () => (/* binding */ ReplaceStep),\n/* harmony export */   Step: () => (/* binding */ Step),\n/* harmony export */   StepMap: () => (/* binding */ StepMap),\n/* harmony export */   StepResult: () => (/* binding */ StepResult),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   TransformError: () => (/* binding */ TransformError),\n/* harmony export */   canJoin: () => (/* binding */ canJoin),\n/* harmony export */   canSplit: () => (/* binding */ canSplit),\n/* harmony export */   dropPoint: () => (/* binding */ dropPoint),\n/* harmony export */   findWrapping: () => (/* binding */ findWrapping),\n/* harmony export */   insertPoint: () => (/* binding */ insertPoint),\n/* harmony export */   joinPoint: () => (/* binding */ joinPoint),\n/* harmony export */   liftTarget: () => (/* binding */ liftTarget),\n/* harmony export */   replaceStep: () => (/* binding */ replaceStep)\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(ssr)/./node_modules/prosemirror-model/dist/index.js\");\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) {\n    return index + offset * factor16;\n}\nfunction recoverIndex(value) {\n    return value & lower16;\n}\nfunction recoverOffset(value) {\n    return (value - (value & lower16)) / factor16;\n}\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/ class MapResult {\n    /**\n    @internal\n    */ constructor(/**\n    The mapped version of the position.\n    */ pos, /**\n    @internal\n    */ delInfo, /**\n    @internal\n    */ recover){\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */ get deleted() {\n        return (this.delInfo & DEL_SIDE) > 0;\n    }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */ get deletedBefore() {\n        return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0;\n    }\n    /**\n    True when the token after the mapped position was deleted.\n    */ get deletedAfter() {\n        return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0;\n    }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */ get deletedAcross() {\n        return (this.delInfo & DEL_ACROSS) > 0;\n    }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/ class StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */ constructor(/**\n    @internal\n    */ ranges, /**\n    @internal\n    */ inverted = false){\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty) return StepMap.empty;\n    }\n    /**\n    @internal\n    */ recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted) for(let i = 0; i < index; i++)diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) {\n        return this._map(pos, assoc, false);\n    }\n    map(pos, assoc = 1) {\n        return this._map(pos, assoc, true);\n    }\n    /**\n    @internal\n    */ _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for(let i = 0; i < this.ranges.length; i += 3){\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos) break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple) return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end) del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */ touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for(let i = 0; i < this.ranges.length; i += 3){\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos) break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3) return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */ forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for(let i = 0, diff = 0; i < this.ranges.length; i += 3){\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */ invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */ toString() {\n        return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */ static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [\n            0,\n            -n,\n            0\n        ] : [\n            0,\n            0,\n            n\n        ]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/ StepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n‘[rebasing](https://prosemirror.net/docs/guide/#transform.rebasing)’ steps for\ncollaboration or history management.)\n*/ class Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */ constructor(maps, /**\n    @internal\n    */ mirror, /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */ from = 0, /**\n    The end position in the `maps` array.\n    */ to = maps ? maps.length : 0){\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n        this._maps = maps || [];\n        this.ownData = !(maps || mirror);\n    }\n    /**\n    The step maps in this mapping.\n    */ get maps() {\n        return this._maps;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */ slice(from = 0, to = this.maps.length) {\n        return new Mapping(this._maps, this.mirror, from, to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */ appendMap(map, mirrors) {\n        if (!this.ownData) {\n            this._maps = this._maps.slice();\n            this.mirror = this.mirror && this.mirror.slice();\n            this.ownData = true;\n        }\n        this.to = this._maps.push(map);\n        if (mirrors != null) this.setMirror(this._maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */ appendMapping(mapping) {\n        for(let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++){\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */ getMirror(n) {\n        if (this.mirror) {\n            for(let i = 0; i < this.mirror.length; i++)if (this.mirror[i] == n) return this.mirror[i + (i % 2 ? -1 : 1)];\n        }\n    }\n    /**\n    @internal\n    */ setMirror(n, m) {\n        if (!this.mirror) this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */ appendMappingInverted(mapping) {\n        for(let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--){\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */ invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */ map(pos, assoc = 1) {\n        if (this.mirror) return this._map(pos, assoc, true);\n        for(let i = this.from; i < this.to; i++)pos = this._maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */ mapResult(pos, assoc = 1) {\n        return this._map(pos, assoc, false);\n    }\n    /**\n    @internal\n    */ _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for(let i = this.from; i < this.to; i++){\n            let map = this._maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this._maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/ class Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */ getMap() {\n        return StepMap.empty;\n    }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */ merge(other) {\n        return null;\n    }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */ static fromJSON(schema, json) {\n        if (!json || !json.stepType) throw new RangeError(\"Invalid input for Step.fromJSON\");\n        let type = stepsByID[json.stepType];\n        if (!type) throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */ static jsonID(id, stepClass) {\n        if (id in stepsByID) throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/ class StepResult {\n    /**\n    @internal\n    */ constructor(/**\n    The transformed document, if successful.\n    */ doc, /**\n    The failure message, if unsuccessful.\n    */ failed){\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */ static ok(doc) {\n        return new StepResult(doc, null);\n    }\n    /**\n    Create a failed step result.\n    */ static fail(message) {\n        return new StepResult(null, message);\n    }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */ static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        } catch (e) {\n            if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError) return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for(let i = 0; i < fragment.childCount; i++){\n        let child = fragment.child(i);\n        if (child.content.size) child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline) child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/ class AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */ constructor(/**\n    The start of the marked range.\n    */ from, /**\n    The end of the marked range.\n    */ to, /**\n    The mark to add.\n    */ mark){\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node, parent)=>{\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type)) return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return {\n            stepType: \"addMark\",\n            mark: this.mark.toJSON(),\n            from: this.from,\n            to: this.to\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/ class RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */ constructor(/**\n    The start of the unmarked range.\n    */ from, /**\n    The end of the unmarked range.\n    */ to, /**\n    The mark to remove.\n    */ mark){\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node)=>{\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos) return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep && other.mark.eq(this.mark) && this.from <= other.to && this.to >= other.from) return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return {\n            stepType: \"removeMark\",\n            mark: this.mark.toJSON(),\n            from: this.from,\n            to: this.to\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/ class AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */ constructor(/**\n    The position of the target node.\n    */ pos, /**\n    The mark to add.\n    */ mark){\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node) return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for(let i = 0; i < node.marks.length; i++)if (!node.marks[i].isInSet(newSet)) return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return {\n            stepType: \"addNodeMark\",\n            pos: this.pos,\n            mark: this.mark.toJSON()\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/ class RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */ constructor(/**\n    The position of the target node.\n    */ pos, /**\n    The mark to remove.\n    */ mark){\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node) return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks)) return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return {\n            stepType: \"removeNodeMark\",\n            pos: this.pos,\n            mark: this.mark.toJSON()\n        };\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\") throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n/**\nReplace a part of the document with a slice of new content.\n*/ class ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */ constructor(/**\n    The start position of the replaced range.\n    */ from, /**\n    The end position of the replaced range.\n    */ to, /**\n    The slice to insert.\n    */ slice, /**\n    @internal\n    */ structure = false){\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to)) return StepResult.fail(\"Structure replace would overwrite content\");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([\n            this.from,\n            this.to - this.from,\n            this.slice.size\n        ]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross) return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure) return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        } else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        } else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = {\n            stepType: \"replace\",\n            from: this.from,\n            to: this.to\n        };\n        if (this.slice.size) json.slice = this.slice.toJSON();\n        if (this.structure) json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\") throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n        return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/ class ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */ constructor(/**\n    The start position of the replaced range.\n    */ from, /**\n    The end position of the replaced range.\n    */ to, /**\n    The start of preserved range.\n    */ gapFrom, /**\n    The end of preserved range.\n    */ gapTo, /**\n    The slice to insert.\n    */ slice, /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */ insert, /**\n    @internal\n    */ structure = false){\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) || contentBetween(doc, this.gapTo, this.to))) return StepResult.fail(\"Structure gap-replace would overwrite content\");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd) return StepResult.fail(\"Gap is not a flat range\");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted) return StepResult.fail(\"Content does not fit in gap\");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([\n            this.from,\n            this.gapFrom - this.from,\n            this.insert,\n            this.gapTo,\n            this.to - this.gapTo,\n            this.slice.size - this.insert\n        ]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n        let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n        if (from.deletedAcross && to.deletedAcross || gapFrom < from.pos || gapTo > to.pos) return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = {\n            stepType: \"replaceAround\",\n            from: this.from,\n            to: this.to,\n            gapFrom: this.gapFrom,\n            gapTo: this.gapTo,\n            insert: this.insert\n        };\n        if (this.slice.size) json.slice = this.slice.toJSON();\n        if (this.structure) json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */ static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\" || typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\") throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while(dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount){\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while(dist > 0){\n            if (!next || next.isLeaf) return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent)=>{\n        if (!node.isInline) return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for(let i = 0; i < marks.length; i++){\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i])) removing.to = end;\n                    else removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start) adding.to = end;\n            else added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach((s)=>tr.step(s));\n    added.forEach((s)=>tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos)=>{\n        if (!node.isInline) return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n            let set = node.marks, found;\n            while(found = mark.isInSet(set)){\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        } else if (mark) {\n            if (mark.isInSet(node.marks)) toRemove = [\n                mark\n            ];\n        } else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for(let i = 0; i < toRemove.length; i++){\n                let style = toRemove[i], found;\n                for(let j = 0; j < matched.length; j++){\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style)) found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                } else {\n                    matched.push({\n                        style,\n                        from: Math.max(pos, from),\n                        to: end,\n                        step\n                    });\n                }\n            }\n        }\n    });\n    matched.forEach((m)=>tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for(let i = 0; i < node.childCount; i++){\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            replSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n        } else {\n            match = allowed;\n            for(let j = 0; j < child.marks.length; j++)if (!parentType.allowsMarkType(child.marks[j].type)) tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n            if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n                let m, newline = /\\r?\\n|\\r/g, slice;\n                while(m = newline.exec(child.text)){\n                    if (!slice) slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n                    replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n                }\n            }\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n    }\n    for(let i = replSteps.length - 1; i >= 0; i--)tr.step(replSteps[i]);\n}\nfunction canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) && (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/ function liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for(let depth = range.depth, contentBefore = 0, contentAfter = 0;; --depth){\n        let node = range.$from.node(depth);\n        let index = range.$from.index(depth) + contentBefore, endIndex = range.$to.indexAfter(depth) - contentAfter;\n        if (depth < range.depth && node.canReplace(index, endIndex, content)) return depth;\n        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex)) break;\n        if (index) contentBefore = 1;\n        if (endIndex < node.childCount) contentAfter = 1;\n    }\n    return null;\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;\n    for(let d = depth, splitting = false; d > target; d--)if (splitting || $from.index(d) > 0) {\n        splitting = true;\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n        openStart++;\n    } else {\n        start--;\n    }\n    let after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;\n    for(let d = depth, splitting = false; d > target; d--)if (splitting || $to.after(d + 1) < $to.end(d)) {\n        splitting = true;\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d).copy(after));\n        openEnd++;\n    } else {\n        end++;\n    }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range's content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/ function findWrapping(range, nodeType, attrs = null, innerRange = range) {\n    let around = findWrappingOutside(range, nodeType);\n    let inner = around && findWrappingInside(innerRange, nodeType);\n    if (!inner) return null;\n    return around.map(withAttrs).concat({\n        type: nodeType,\n        attrs\n    }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) {\n    return {\n        type,\n        attrs: null\n    };\n}\nfunction findWrappingOutside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (!around) return null;\n    let outer = around.length ? around[0] : type;\n    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let inner = parent.child(startIndex);\n    let inside = type.contentMatch.findWrapping(inner.type);\n    if (!inside) return null;\n    let lastType = inside.length ? inside[inside.length - 1] : type;\n    let innerMatch = lastType.contentMatch;\n    for(let i = startIndex; innerMatch && i < endIndex; i++)innerMatch = innerMatch.matchType(parent.child(i).type);\n    if (!innerMatch || !innerMatch.validEnd) return null;\n    return inside;\n}\nfunction wrap(tr, range, wrappers) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for(let i = wrappers.length - 1; i >= 0; i--){\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd) throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n        }\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock) throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos)=>{\n        let attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n        if (node.isTextblock && !node.hasMarkup(type, attrsHere) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            let convertNewlines = null;\n            if (type.schema.linebreakReplacement) {\n                let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n                if (pre && !supportLinebreak) convertNewlines = false;\n                else if (!pre && supportLinebreak) convertNewlines = true;\n            }\n            // Ensure all markup that isn't allowed in the new node type is cleared\n            if (convertNewlines === false) replaceLinebreaks(tr, node, pos, mapFrom);\n            clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n            if (convertNewlines === true) replaceNewlines(tr, node, pos, mapFrom);\n            return false;\n        }\n    });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n    node.forEach((child, offset)=>{\n        if (child.isText) {\n            let m, newline = /\\r?\\n|\\r/g;\n            while(m = newline.exec(child.text)){\n                let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n                tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n            }\n        }\n    });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n    node.forEach((child, offset)=>{\n        if (child.type == child.type.schema.linebreakReplacement) {\n            let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n            tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/ function setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node) throw new RangeError(\"No node at given position\");\n    if (!type) type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf) return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content)) throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/ function canSplit(doc, pos, depth = 1, typesAfter) {\n    let $pos = doc.resolve(pos), base = $pos.depth - depth;\n    let innerType = typesAfter && typesAfter[typesAfter.length - 1] || $pos.parent;\n    if (base < 0 || $pos.parent.type.spec.isolating || !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) || !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount))) return false;\n    for(let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--){\n        let node = $pos.node(d), index = $pos.index(d);\n        if (node.type.spec.isolating) return false;\n        let rest = node.content.cutByIndex(index, node.childCount);\n        let overrideChild = typesAfter && typesAfter[i + 1];\n        if (overrideChild) rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n        let after = typesAfter && typesAfter[i] || node;\n        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest)) return false;\n    }\n    let index = $pos.indexAfter(base);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for(let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--){\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/ function canJoin(doc, pos) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return joinable($pos.nodeBefore, $pos.nodeAfter) && $pos.parent.canReplace(index, index + 1);\n}\nfunction canAppendWithSubstitutedLinebreaks(a, b) {\n    if (!b.content.size) a.type.compatibleContent(b.type);\n    let match = a.contentMatchAt(a.childCount);\n    let { linebreakReplacement } = a.type.schema;\n    for(let i = 0; i < b.childCount; i++){\n        let child = b.child(i);\n        let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n        match = match.matchType(type);\n        if (!match) return false;\n        if (!a.type.allowsMarks(child.marks)) return false;\n    }\n    return match.validEnd;\n}\nfunction joinable(a, b) {\n    return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/ function joinPoint(doc, pos, dir = -1) {\n    let $pos = doc.resolve(pos);\n    for(let d = $pos.depth;; d--){\n        let before, after, index = $pos.index(d);\n        if (d == $pos.depth) {\n            before = $pos.nodeBefore;\n            after = $pos.nodeAfter;\n        } else if (dir > 0) {\n            before = $pos.node(d + 1);\n            index++;\n            after = $pos.node(d).maybeChild(index);\n        } else {\n            before = $pos.node(d).maybeChild(index - 1);\n            after = $pos.node(d + 1);\n        }\n        if (before && !before.isTextblock && joinable(before, after) && $pos.node(d).canReplace(index, index + 1)) return pos;\n        if (d == 0) break;\n        pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n    }\n}\nfunction join(tr, pos, depth) {\n    let convertNewlines = null;\n    let { linebreakReplacement } = tr.doc.type.schema;\n    let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;\n    if (linebreakReplacement && beforeType.inlineContent) {\n        let pre = beforeType.whitespace == \"pre\";\n        let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n        if (pre && !supportLinebreak) convertNewlines = false;\n        else if (!pre && supportLinebreak) convertNewlines = true;\n    }\n    let mapFrom = tr.steps.length;\n    if (convertNewlines === false) {\n        let $after = tr.doc.resolve(pos + depth);\n        replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n    }\n    if (beforeType.inlineContent) clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n    let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);\n    tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true));\n    if (convertNewlines === true) {\n        let $full = tr.doc.resolve(start);\n        replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n    }\n    return tr;\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/ function insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType)) return pos;\n    if ($pos.parentOffset == 0) for(let d = $pos.depth - 1; d >= 0; d--){\n        let index = $pos.index(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.before(d + 1);\n        if (index > 0) return null;\n    }\n    if ($pos.parentOffset == $pos.parent.content.size) for(let d = $pos.depth - 1; d >= 0; d--){\n        let index = $pos.indexAfter(d);\n        if ($pos.node(d).canReplaceWith(index, index, nodeType)) return $pos.after(d + 1);\n        if (index < $pos.node(d).childCount) return null;\n    }\n    return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes' nearest boundary\nand try there, even if the original position wasn't directly at the\nstart or end of that node. Returns null when no position was found.\n*/ function dropPoint(doc, pos, slice) {\n    let $pos = doc.resolve(pos);\n    if (!slice.content.size) return pos;\n    let content = slice.content;\n    for(let i = 0; i < slice.openStart; i++)content = content.firstChild.content;\n    for(let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++){\n        for(let d = $pos.depth; d >= 0; d--){\n            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n            let parent = $pos.node(d), fits = false;\n            if (pass == 1) {\n                fits = parent.canReplace(insertPos, insertPos, content);\n            } else {\n                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n            }\n            if (fits) return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n        }\n    }\n    return null;\n}\n/**\n‘Fit’ a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/ function replaceStep(doc, from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    if (from == to && !slice.size) return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it's obvious that it's not needed.\n    if (fitsTrivially($from, $to, slice)) return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() && $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced){\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        for(let i = 0; i <= $from.depth; i++){\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for(let i = $from.depth; i > 0; i--)this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() {\n        return this.frontier.length - 1;\n    }\n    fit() {\n        // As long as there's unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while(this.unplaced.size){\n            let fit = this.findFittable();\n            if (fit) this.placeNodes(fit);\n            else this.openMore() || this.dropNode();\n        }\n        // When there's inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to) return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while(openStart && openEnd && content.childCount == 1){\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n        if (moveInline > -1) return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        let startDepth = this.unplaced.openStart;\n        for(let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++){\n            let node = cur.firstChild;\n            if (cur.childCount > 1) openEnd = 0;\n            if (node.type.spec.isolating && openEnd <= d) {\n                startDepth = d;\n                break;\n            }\n            cur = node.content;\n        }\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for(let pass = 1; pass <= 2; pass++){\n            for(let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--){\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                } else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for(let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--){\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we've found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false)) : parent && type.compatibleContent(parent.type))) return {\n                        sliceDepth,\n                        frontierDepth,\n                        parent,\n                        inject\n                    };\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type))) return {\n                        sliceDepth,\n                        frontierDepth,\n                        parent,\n                        wrap\n                    };\n                    // Don't continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type)) break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf) return false;\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        } else {\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while(this.depth > frontierDepth)this.closeFrontierNode();\n        if (wrap) for(let i = 0; i < wrap.length; i++)this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for(let i = 0; i < inject.childCount; i++)add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = fragment.size + sliceDepth - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while(taken < fragment.childCount){\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches) break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) {\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd) openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it's not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1) this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for(let i = 0, cur = fragment; i < openEndCount; i++){\n            let node = cur.lastChild;\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt(node.childCount)\n            });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd) : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock) return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) || this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth) return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while(depth > 1 && after == this.$to.end(--depth))++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for(let i = Math.min(this.depth, $to.depth); i >= 0; i--){\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit) continue;\n            for(let d = i - 1; d >= 0; d--){\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount) continue scan;\n            }\n            return {\n                depth: i,\n                fit,\n                move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to\n            };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close) return null;\n        while(this.depth > close.depth)this.closeFrontierNode();\n        if (close.fit.childCount) this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for(let d = close.depth + 1; d <= $to.depth; d++){\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n        this.frontier.push({\n            type,\n            match: type.contentMatch\n        });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        if (add.childCount) this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0) return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0) return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for(let i = 0; i < depth; i++)fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0) return node;\n    let frag = node.content;\n    if (openStart > 1) frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0) frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type)) return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for(let i = start; i < fragment.childCount; i++)if (!type.allowsMarks(fragment.child(i).marks)) return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size) return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice)) return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, $to);\n    // Can't replace the whole document, so remove 0 if it's present\n    if (targetDepths[targetDepths.length - 1] == 0) targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for(let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--){\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating) break;\n        if (targetDepths.indexOf(d) > -1) preferredTarget = d;\n        else if ($from.before(d) == pos) targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for(let content = slice.content, i = 0;; i++){\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart) break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for(let d = preferredDepth - 1; d >= 0; d--){\n        let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1))) preferredDepth = d;\n        else if (def || !leftNode.type.isTextblock) break;\n    }\n    for(let j = slice.openStart; j >= 0; j--){\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert) continue;\n        for(let i = 0; i < targetDepths.length; i++){\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks)) return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for(let i = targetDepths.length - 1; i >= 0; i--){\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps) break;\n        let depth = targetDepths[i];\n        if (depth < 0) continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null) from = to = point;\n    }\n    tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for(let i = 0; i < covered.length; i++){\n        let depth = covered[i], last = i == covered.length - 1;\n        if (last && depth == 0 || $from.node(depth).type.contentMatch.validEnd) return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1)))) return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for(let d = 1; d <= $from.depth && d <= $to.depth; d++){\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d && $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1))) return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for(let d = minDepth; d >= 0; d--){\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) || $to.end(d) > $to.pos + ($to.depth - d) || $from.node(d).type.spec.isolating || $to.node(d).type.spec.isolating) break;\n        if (start == $to.start(d) || d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent && d && $to.start(d - 1) == start - 1) result.push(d);\n    }\n    return result;\n}\n/**\nUpdate an attribute in a specific node.\n*/ class AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */ constructor(/**\n    The position of the target node.\n    */ pos, /**\n    The attribute to set.\n    */ attr, // The attribute's new value.\n    value){\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node) return StepResult.fail(\"No node at attribute step's position\");\n        let attrs = Object.create(null);\n        for(let name in node.attrs)attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return {\n            stepType: \"attr\",\n            pos: this.pos,\n            attr: this.attr,\n            value: this.value\n        };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\" || typeof json.attr != \"string\") throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID(\"attr\", AttrStep);\n/**\nUpdate an attribute in the doc node.\n*/ class DocAttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */ constructor(/**\n    The attribute to set.\n    */ attr, // The attribute's new value.\n    value){\n        super();\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let attrs = Object.create(null);\n        for(let name in doc.attrs)attrs[name] = doc.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = doc.type.create(attrs, doc.content, doc.marks);\n        return StepResult.ok(updated);\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new DocAttrStep(this.attr, doc.attrs[this.attr]);\n    }\n    map(mapping) {\n        return this;\n    }\n    toJSON() {\n        return {\n            stepType: \"docAttr\",\n            attr: this.attr,\n            value: this.value\n        };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.attr != \"string\") throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n        return new DocAttrStep(json.attr, json.value);\n    }\n}\nStep.jsonID(\"docAttr\", DocAttrStep);\n/**\n@internal\n*/ let TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/ class Transform {\n    /**\n    Create a transform that starts with the given document.\n    */ constructor(/**\n    The current document (the result of applying the steps in the\n    transform).\n    */ doc){\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */ this.steps = [];\n        /**\n        The documents before each of the steps.\n        */ this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */ this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */ get before() {\n        return this.docs.length ? this.docs[0] : this.doc;\n    }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */ step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed) throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */ maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed) this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */ get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */ addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */ replace(from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step) this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */ replaceWith(from, to, content) {\n        return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */ delete(from, to) {\n        return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */ insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */ replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */ replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */ deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */ lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */ join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */ wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */ setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */ setNodeMarkup(pos, type, attrs = null, marks) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */ setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */ setDocAttribute(attr, value) {\n        this.step(new DocAttrStep(attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */ addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or all marks of the given type) from the node at\n    position `pos`.\n    */ removeNodeMark(pos, mark) {\n        let node = this.doc.nodeAt(pos);\n        if (!node) throw new RangeError(\"No node at position \" + pos);\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark) {\n            if (mark.isInSet(node.marks)) this.step(new RemoveNodeMarkStep(pos, mark));\n        } else {\n            let set = node.marks, found, steps = [];\n            while(found = mark.isInSet(set)){\n                steps.push(new RemoveNodeMarkStep(pos, found));\n                set = found.removeFromSet(set);\n            }\n            for(let i = steps.length - 1; i >= 0; i--)this.step(steps[i]);\n        }\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split (with the outermost nodes coming first).\n    */ split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */ addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */ removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */ clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItdHJhbnNmb3JtL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtGO0FBRWxGLCtEQUErRDtBQUMvRCxvRUFBb0U7QUFDcEUsb0VBQW9FO0FBQ3BFLGtFQUFrRTtBQUNsRSxFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLG9FQUFvRTtBQUNwRSw4REFBOEQ7QUFDOUQsc0JBQXNCO0FBQ3RCLE1BQU1LLFVBQVU7QUFDaEIsTUFBTUMsV0FBV0MsS0FBS0MsR0FBRyxDQUFDLEdBQUc7QUFDN0IsU0FBU0MsWUFBWUMsS0FBSyxFQUFFQyxNQUFNO0lBQUksT0FBT0QsUUFBUUMsU0FBU0w7QUFBVTtBQUN4RSxTQUFTTSxhQUFhQyxLQUFLO0lBQUksT0FBT0EsUUFBUVI7QUFBUztBQUN2RCxTQUFTUyxjQUFjRCxLQUFLO0lBQUksT0FBTyxDQUFDQSxRQUFTQSxDQUFBQSxRQUFRUixPQUFNLENBQUMsSUFBS0M7QUFBVTtBQUMvRSxNQUFNUyxhQUFhLEdBQUdDLFlBQVksR0FBR0MsYUFBYSxHQUFHQyxXQUFXO0FBQ2hFOzs7QUFHQSxHQUNBLE1BQU1DO0lBQ0Y7O0lBRUEsR0FDQUMsWUFDQTs7SUFFQSxHQUNBQyxHQUFHLEVBQ0g7O0lBRUEsR0FDQUMsT0FBTyxFQUNQOztJQUVBLEdBQ0FDLE9BQU8sQ0FBRTtRQUNMLElBQUksQ0FBQ0YsR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHQTtJQUNuQjtJQUNBOzs7O0lBSUEsR0FDQSxJQUFJQyxVQUFVO1FBQUUsT0FBTyxDQUFDLElBQUksQ0FBQ0YsT0FBTyxHQUFHSixRQUFPLElBQUs7SUFBRztJQUN0RDs7SUFFQSxHQUNBLElBQUlPLGdCQUFnQjtRQUFFLE9BQU8sQ0FBQyxJQUFJLENBQUNILE9BQU8sR0FBSVAsQ0FBQUEsYUFBYUUsVUFBUyxDQUFDLElB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TUMsSUFBSXlEO1FBQ3hCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0lBS0EsR0FDQXdELFdBQVdsSCxJQUFJLEVBQUVDLEVBQUUsRUFBRXlELElBQUksRUFBRTtRQUN2QndELFdBQVcsSUFBSSxFQUFFbEgsTUFBTUMsSUFBSXlEO1FBQzNCLE9BQU8sSUFBSTtJQUNmO0lBQ0E7Ozs7O0lBS0EsR0FDQStELGtCQUFrQmxLLEdBQUcsRUFBRW1LLFVBQVUsRUFBRUMsS0FBSyxFQUFFO1FBQ3RDRixrQkFBa0IsSUFBSSxFQUFFbEssS0FBS21LLFlBQVlDO1FBQ3pDLE9BQU8sSUFBSTtJQUNmO0FBQ0o7QUFFMFMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jb2xsYWItZG9jcy1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10cmFuc2Zvcm0vZGlzdC9pbmRleC5qcz9iYTAwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJlcGxhY2VFcnJvciwgU2xpY2UsIEZyYWdtZW50LCBNYXJrVHlwZSwgTWFyayB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcblxuLy8gUmVjb3ZlcnkgdmFsdWVzIGVuY29kZSBhIHJhbmdlIGluZGV4IGFuZCBhbiBvZmZzZXQuIFRoZXkgYXJlXG4vLyByZXByZXNlbnRlZCBhcyBudW1iZXJzLCBiZWNhdXNlIHRvbnMgb2YgdGhlbSB3aWxsIGJlIGNyZWF0ZWQgd2hlblxuLy8gbWFwcGluZywgZm9yIGV4YW1wbGUsIGEgbGFyZ2UgbnVtYmVyIG9mIGRlY29yYXRpb25zLiBUaGUgbnVtYmVyJ3Ncbi8vIGxvd2VyIDE2IGJpdHMgcHJvdmlkZSB0aGUgaW5kZXgsIHRoZSByZW1haW5pbmcgYml0cyB0aGUgb2Zmc2V0LlxuLy9cbi8vIE5vdGU6IFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGJpdCBzaGlmdCBvcGVyYXRvcnMgdG8gZW4tIGFuZFxuLy8gZGVjb2RlIHRoZXNlLCBzaW5jZSB0aG9zZSBjbGlwIHRvIDMyIGJpdHMsIHdoaWNoIHdlIG1pZ2h0IGluIHJhcmVcbi8vIGNhc2VzIHdhbnQgdG8gb3ZlcmZsb3cuIEEgNjQtYml0IGZsb2F0IGNhbiByZXByZXNlbnQgNDgtYml0XG4vLyBpbnRlZ2VycyBwcmVjaXNlbHkuXG5jb25zdCBsb3dlcjE2ID0gMHhmZmZmO1xuY29uc3QgZmFjdG9yMTYgPSBNYXRoLnBvdygyLCAxNik7XG5mdW5jdGlvbiBtYWtlUmVjb3ZlcihpbmRleCwgb2Zmc2V0KSB7IHJldHVybiBpbmRleCArIG9mZnNldCAqIGZhY3RvcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVySW5kZXgodmFsdWUpIHsgcmV0dXJuIHZhbHVlICYgbG93ZXIxNjsgfVxuZnVuY3Rpb24gcmVjb3Zlck9mZnNldCh2YWx1ZSkgeyByZXR1cm4gKHZhbHVlIC0gKHZhbHVlICYgbG93ZXIxNikpIC8gZmFjdG9yMTY7IH1cbmNvbnN0IERFTF9CRUZPUkUgPSAxLCBERUxfQUZURVIgPSAyLCBERUxfQUNST1NTID0gNCwgREVMX1NJREUgPSA4O1xuLyoqXG5BbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgbWFwcGVkIHBvc2l0aW9uIHdpdGggZXh0cmFcbmluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE1hcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbWFwcGVkIHZlcnNpb24gb2YgdGhlIHBvc2l0aW9uLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRlbEluZm8sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3Zlcikge1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5kZWxJbmZvID0gZGVsSW5mbztcbiAgICAgICAgdGhpcy5yZWNvdmVyID0gcmVjb3ZlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHBvc2l0aW9uIHdhcyBkZWxldGVkLCB0aGF0IGlzLCB3aGV0aGVyIHRoZVxuICAgIHN0ZXAgcmVtb3ZlZCB0aGUgdG9rZW4gb24gdGhlIHNpZGUgcXVlcmllZCAodmlhIHRoZSBgYXNzb2NgKVxuICAgIGFyZ3VtZW50IGZyb20gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWQoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX1NJREUpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSB0b2tlbiBiZWZvcmUgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQmVmb3JlKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIChERUxfQkVGT1JFIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgdG9rZW4gYWZ0ZXIgdGhlIG1hcHBlZCBwb3NpdGlvbiB3YXMgZGVsZXRlZC5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWZ0ZXIoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9BRlRFUiB8IERFTF9BQ1JPU1MpKSA+IDA7IH1cbiAgICAvKipcbiAgICBUZWxscyB3aGV0aGVyIGFueSBvZiB0aGUgc3RlcHMgbWFwcGVkIHRocm91Z2ggZGVsZXRlcyBhY3Jvc3MgdGhlXG4gICAgcG9zaXRpb24gKGluY2x1ZGluZyBib3RoIHRoZSB0b2tlbiBiZWZvcmUgYW5kIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uKS5cbiAgICAqL1xuICAgIGdldCBkZWxldGVkQWNyb3NzKCkgeyByZXR1cm4gKHRoaXMuZGVsSW5mbyAmIERFTF9BQ1JPU1MpID4gMDsgfVxufVxuLyoqXG5BIG1hcCBkZXNjcmliaW5nIHRoZSBkZWxldGlvbnMgYW5kIGluc2VydGlvbnMgbWFkZSBieSBhIHN0ZXAsIHdoaWNoXG5jYW4gYmUgdXNlZCB0byBmaW5kIHRoZSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBvc2l0aW9ucyBpbiB0aGVcbnByZS1zdGVwIHZlcnNpb24gb2YgYSBkb2N1bWVudCBhbmQgdGhlIHNhbWUgcG9zaXRpb24gaW4gdGhlXG5wb3N0LXN0ZXAgdmVyc2lvbi5cbiovXG5jbGFzcyBTdGVwTWFwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwb3NpdGlvbiBtYXAuIFRoZSBtb2RpZmljYXRpb25zIHRvIHRoZSBkb2N1bWVudCBhcmVcbiAgICByZXByZXNlbnRlZCBhcyBhbiBhcnJheSBvZiBudW1iZXJzLCBpbiB3aGljaCBlYWNoIGdyb3VwIG9mIHRocmVlXG4gICAgcmVwcmVzZW50cyBhIG1vZGlmaWVkIGNodW5rIGFzIGBbc3RhcnQsIG9sZFNpemUsIG5ld1NpemVdYC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuZ2VzLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGludmVydGVkID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuaW52ZXJ0ZWQgPSBpbnZlcnRlZDtcbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoICYmIFN0ZXBNYXAuZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKHZhbHVlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgodmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuaW52ZXJ0ZWQpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICogMyArIDJdIC0gdGhpcy5yYW5nZXNbaSAqIDMgKyAxXTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzW2luZGV4ICogM10gKyBkaWZmICsgcmVjb3Zlck9mZnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIG1hcChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGlmZiA9IDAsIG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNpZGUgPSAhb2xkU2l6ZSA/IGFzc29jIDogcG9zID09IHN0YXJ0ID8gLTEgOiBwb3MgPT0gZW5kID8gMSA6IGFzc29jO1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBzdGFydCArIGRpZmYgKyAoc2lkZSA8IDAgPyAwIDogbmV3U2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpbXBsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsZXQgcmVjb3ZlciA9IHBvcyA9PSAoYXNzb2MgPCAwID8gc3RhcnQgOiBlbmQpID8gbnVsbCA6IG1ha2VSZWNvdmVyKGkgLyAzLCBwb3MgLSBzdGFydCk7XG4gICAgICAgICAgICAgICAgbGV0IGRlbCA9IHBvcyA9PSBzdGFydCA/IERFTF9BRlRFUiA6IHBvcyA9PSBlbmQgPyBERUxfQkVGT1JFIDogREVMX0FDUk9TUztcbiAgICAgICAgICAgICAgICBpZiAoYXNzb2MgPCAwID8gcG9zICE9IHN0YXJ0IDogcG9zICE9IGVuZClcbiAgICAgICAgICAgICAgICAgICAgZGVsIHw9IERFTF9TSURFO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwUmVzdWx0KHJlc3VsdCwgZGVsLCByZWNvdmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZSA/IHBvcyArIGRpZmYgOiBuZXcgTWFwUmVzdWx0KHBvcyArIGRpZmYsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvdWNoZXMocG9zLCByZWNvdmVyKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgaW5kZXggPSByZWNvdmVySW5kZXgocmVjb3Zlcik7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldIC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPiBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIGVuZCA9IHN0YXJ0ICsgb2xkU2l6ZTtcbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kICYmIGkgPT0gaW5kZXggKiAzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGlmZiArPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBvbiBlYWNoIG9mIHRoZSBjaGFuZ2VkIHJhbmdlcyBpbmNsdWRlZCBpblxuICAgIHRoaXMgbWFwLlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7XG4gICAgICAgIGxldCBvbGRJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAyIDogMSwgbmV3SW5kZXggPSB0aGlzLmludmVydGVkID8gMSA6IDI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBkaWZmID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSwgb2xkU3RhcnQgPSBzdGFydCAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApLCBuZXdTdGFydCA9IHN0YXJ0ICsgKHRoaXMuaW52ZXJ0ZWQgPyAwIDogZGlmZik7XG4gICAgICAgICAgICBsZXQgb2xkU2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBvbGRJbmRleF0sIG5ld1NpemUgPSB0aGlzLnJhbmdlc1tpICsgbmV3SW5kZXhdO1xuICAgICAgICAgICAgZihvbGRTdGFydCwgb2xkU3RhcnQgKyBvbGRTaXplLCBuZXdTdGFydCwgbmV3U3RhcnQgKyBuZXdTaXplKTtcbiAgICAgICAgICAgIGRpZmYgKz0gbmV3U2l6ZSAtIG9sZFNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGludmVydGVkIHZlcnNpb24gb2YgdGhpcyBtYXAuIFRoZSByZXN1bHQgY2FuIGJlIHVzZWQgdG9cbiAgICBtYXAgcG9zaXRpb25zIGluIHRoZSBwb3N0LXN0ZXAgZG9jdW1lbnQgdG8gdGhlIHByZS1zdGVwIGRvY3VtZW50LlxuICAgICovXG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAodGhpcy5yYW5nZXMsICF0aGlzLmludmVydGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmludmVydGVkID8gXCItXCIgOiBcIlwiKSArIEpTT04uc3RyaW5naWZ5KHRoaXMucmFuZ2VzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwIHRoYXQgbW92ZXMgYWxsIHBvc2l0aW9ucyBieSBvZmZzZXQgYG5gICh3aGljaCBtYXkgYmVcbiAgICBuZWdhdGl2ZSkuIFRoaXMgY2FuIGJlIHVzZWZ1bCB3aGVuIGFwcGx5aW5nIHN0ZXBzIG1lYW50IGZvciBhXG4gICAgc3ViLWRvY3VtZW50IHRvIGEgbGFyZ2VyIGRvY3VtZW50LCBvciB2aWNlLXZlcnNhLlxuICAgICovXG4gICAgc3RhdGljIG9mZnNldChuKSB7XG4gICAgICAgIHJldHVybiBuID09IDAgPyBTdGVwTWFwLmVtcHR5IDogbmV3IFN0ZXBNYXAobiA8IDAgPyBbMCwgLW4sIDBdIDogWzAsIDAsIG5dKTtcbiAgICB9XG59XG4vKipcbkEgU3RlcE1hcCB0aGF0IGNvbnRhaW5zIG5vIGNoYW5nZWQgcmFuZ2VzLlxuKi9cblN0ZXBNYXAuZW1wdHkgPSBuZXcgU3RlcE1hcChbXSk7XG4vKipcbkEgbWFwcGluZyByZXByZXNlbnRzIGEgcGlwZWxpbmUgb2YgemVybyBvciBtb3JlIFtzdGVwXG5tYXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBNYXApLiBJdCBoYXMgc3BlY2lhbCBwcm92aXNpb25zIGZvciBsb3NzbGVzc2x5XG5oYW5kbGluZyBtYXBwaW5nIHBvc2l0aW9ucyB0aHJvdWdoIGEgc2VyaWVzIG9mIHN0ZXBzIGluIHdoaWNoIHNvbWVcbnN0ZXBzIGFyZSBpbnZlcnRlZCB2ZXJzaW9ucyBvZiBlYXJsaWVyIHN0ZXBzLiAoVGhpcyBjb21lcyB1cCB3aGVuXG7igJhbcmViYXNpbmddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI3RyYW5zZm9ybS5yZWJhc2luZynigJkgc3RlcHMgZm9yXG5jb2xsYWJvcmF0aW9uIG9yIGhpc3RvcnkgbWFuYWdlbWVudC4pXG4qL1xuY2xhc3MgTWFwcGluZyB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG1hcHBpbmcgd2l0aCB0aGUgZ2l2ZW4gcG9zaXRpb24gbWFwcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG1hcHMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWlycm9yLCBcbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgcG9zaXRpb24gaW4gdGhlIGBtYXBzYCBhcnJheSwgdXNlZCB3aGVuIGBtYXBgIG9yXG4gICAgYG1hcFJlc3VsdGAgaXMgY2FsbGVkLlxuICAgICovXG4gICAgZnJvbSA9IDAsIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24gaW4gdGhlIGBtYXBzYCBhcnJheS5cbiAgICAqL1xuICAgIHRvID0gbWFwcyA/IG1hcHMubGVuZ3RoIDogMCkge1xuICAgICAgICB0aGlzLm1pcnJvciA9IG1pcnJvcjtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLl9tYXBzID0gbWFwcyB8fCBbXTtcbiAgICAgICAgdGhpcy5vd25EYXRhID0gIShtYXBzIHx8IG1pcnJvcik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzdGVwIG1hcHMgaW4gdGhpcyBtYXBwaW5nLlxuICAgICovXG4gICAgZ2V0IG1hcHMoKSB7IHJldHVybiB0aGlzLl9tYXBzOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFwcGluZyB0aGF0IG1hcHMgb25seSB0aHJvdWdoIGEgcGFydCBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIHNsaWNlKGZyb20gPSAwLCB0byA9IHRoaXMubWFwcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBwaW5nKHRoaXMuX21hcHMsIHRoaXMubWlycm9yLCBmcm9tLCB0byk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIHN0ZXAgbWFwIHRvIHRoZSBlbmQgb2YgdGhpcyBtYXBwaW5nLiBJZiBgbWlycm9yc2AgaXNcbiAgICBnaXZlbiwgaXQgc2hvdWxkIGJlIHRoZSBpbmRleCBvZiB0aGUgc3RlcCBtYXAgdGhhdCBpcyB0aGUgbWlycm9yXG4gICAgaW1hZ2Ugb2YgdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXAobWFwLCBtaXJyb3JzKSB7XG4gICAgICAgIGlmICghdGhpcy5vd25EYXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXBzID0gdGhpcy5fbWFwcy5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5taXJyb3IgPSB0aGlzLm1pcnJvciAmJiB0aGlzLm1pcnJvci5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5vd25EYXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvID0gdGhpcy5fbWFwcy5wdXNoKG1hcCk7XG4gICAgICAgIGlmIChtaXJyb3JzICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnNldE1pcnJvcih0aGlzLl9tYXBzLmxlbmd0aCAtIDEsIG1pcnJvcnMpO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgYWxsIHRoZSBzdGVwIG1hcHMgaW4gYSBnaXZlbiBtYXBwaW5nIHRvIHRoaXMgb25lIChwcmVzZXJ2aW5nXG4gICAgbWlycm9yaW5nIGluZm9ybWF0aW9uKS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcHBpbmcobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgc3RhcnRTaXplID0gdGhpcy5fbWFwcy5sZW5ndGg7IGkgPCBtYXBwaW5nLl9tYXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5fbWFwc1tpXSwgbWlyciAhPSBudWxsICYmIG1pcnIgPCBpID8gc3RhcnRTaXplICsgbWlyciA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZHMgdGhlIG9mZnNldCBvZiB0aGUgc3RlcCBtYXAgdGhhdCBtaXJyb3JzIHRoZSBtYXAgYXQgdGhlXG4gICAgZ2l2ZW4gb2Zmc2V0LCBpbiB0aGlzIG1hcHBpbmcgKGFzIHBlciB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvXG4gICAgYGFwcGVuZE1hcGApLlxuICAgICovXG4gICAgZ2V0TWlycm9yKG4pIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1pcnJvci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5taXJyb3JbaV0gPT0gbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlycm9yW2kgKyAoaSAlIDIgPyAtMSA6IDEpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRNaXJyb3IobiwgbSkge1xuICAgICAgICBpZiAoIXRoaXMubWlycm9yKVxuICAgICAgICAgICAgdGhpcy5taXJyb3IgPSBbXTtcbiAgICAgICAgdGhpcy5taXJyb3IucHVzaChuLCBtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwZW5kIHRoZSBpbnZlcnNlIG9mIHRoZSBnaXZlbiBtYXBwaW5nIHRvIHRoaXMgb25lLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZ0ludmVydGVkKG1hcHBpbmcpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IG1hcHBpbmcubWFwcy5sZW5ndGggLSAxLCB0b3RhbFNpemUgPSB0aGlzLl9tYXBzLmxlbmd0aCArIG1hcHBpbmcuX21hcHMubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IG1pcnIgPSBtYXBwaW5nLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kTWFwKG1hcHBpbmcuX21hcHNbaV0uaW52ZXJ0KCksIG1pcnIgIT0gbnVsbCAmJiBtaXJyID4gaSA/IHRvdGFsU2l6ZSAtIG1pcnIgLSAxIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIGxldCBpbnZlcnNlID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIGludmVyc2UuYXBwZW5kTWFwcGluZ0ludmVydGVkKHRoaXMpO1xuICAgICAgICByZXR1cm4gaW52ZXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTWFwIGEgcG9zaXRpb24gdGhyb3VnaCB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBtYXAocG9zLCBhc3NvYyA9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubWlycm9yKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcChwb3MsIGFzc29jLCB0cnVlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuZnJvbTsgaSA8IHRoaXMudG87IGkrKylcbiAgICAgICAgICAgIHBvcyA9IHRoaXMuX21hcHNbaV0ubWFwKHBvcywgYXNzb2MpO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZywgcmV0dXJuaW5nIGEgbWFwcGluZ1xuICAgIHJlc3VsdC5cbiAgICAqL1xuICAgIG1hcFJlc3VsdChwb3MsIGFzc29jID0gMSkgeyByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIGZhbHNlKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgX21hcChwb3MsIGFzc29jLCBzaW1wbGUpIHtcbiAgICAgICAgbGV0IGRlbEluZm8gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gdGhpcy5fbWFwc1tpXSwgcmVzdWx0ID0gbWFwLm1hcFJlc3VsdChwb3MsIGFzc29jKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNvcnIgPSB0aGlzLmdldE1pcnJvcihpKTtcbiAgICAgICAgICAgICAgICBpZiAoY29yciAhPSBudWxsICYmIGNvcnIgPiBpICYmIGNvcnIgPCB0aGlzLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBjb3JyO1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSB0aGlzLl9tYXBzW2NvcnJdLnJlY292ZXIocmVzdWx0LnJlY292ZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxJbmZvIHw9IHJlc3VsdC5kZWxJbmZvO1xuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zIDogbmV3IE1hcFJlc3VsdChwb3MsIGRlbEluZm8sIG51bGwpO1xuICAgIH1cbn1cblxuY29uc3Qgc3RlcHNCeUlEID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKlxuQSBzdGVwIG9iamVjdCByZXByZXNlbnRzIGFuIGF0b21pYyBjaGFuZ2UuIEl0IGdlbmVyYWxseSBhcHBsaWVzXG5vbmx5IHRvIHRoZSBkb2N1bWVudCBpdCB3YXMgY3JlYXRlZCBmb3IsIHNpbmNlIHRoZSBwb3NpdGlvbnNcbnN0b3JlZCBpbiBpdCB3aWxsIG9ubHkgbWFrZSBzZW5zZSBmb3IgdGhhdCBkb2N1bWVudC5cblxuTmV3IHN0ZXBzIGFyZSBkZWZpbmVkIGJ5IGNyZWF0aW5nIGNsYXNzZXMgdGhhdCBleHRlbmQgYFN0ZXBgLFxub3ZlcnJpZGluZyB0aGUgYGFwcGx5YCwgYGludmVydGAsIGBtYXBgLCBgZ2V0TWFwYCBhbmQgYGZyb21KU09OYFxubWV0aG9kcywgYW5kIHJlZ2lzdGVyaW5nIHlvdXIgY2xhc3Mgd2l0aCBhIHVuaXF1ZVxuSlNPTi1zZXJpYWxpemF0aW9uIGlkZW50aWZpZXIgdXNpbmdcbltgU3RlcC5qc29uSURgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXBeanNvbklEKS5cbiovXG5jbGFzcyBTdGVwIHtcbiAgICAvKipcbiAgICBHZXQgdGhlIHN0ZXAgbWFwIHRoYXQgcmVwcmVzZW50cyB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoaXMgc3RlcCxcbiAgICBhbmQgd2hpY2ggY2FuIGJlIHVzZWQgdG8gdHJhbnNmb3JtIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZSBvbGRcbiAgICBhbmQgdGhlIG5ldyBkb2N1bWVudC5cbiAgICAqL1xuICAgIGdldE1hcCgpIHsgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7IH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWVyZ2UgdGhpcyBzdGVwIHdpdGggYW5vdGhlciBvbmUsIHRvIGJlIGFwcGxpZWQgZGlyZWN0bHlcbiAgICBhZnRlciBpdC4gUmV0dXJucyB0aGUgbWVyZ2VkIHN0ZXAgd2hlbiBwb3NzaWJsZSwgbnVsbCBpZiB0aGVcbiAgICBzdGVwcyBjYW4ndCBiZSBtZXJnZWQuXG4gICAgKi9cbiAgICBtZXJnZShvdGhlcikgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgc3RlcCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBXaWxsIGNhbGxcbiAgICB0aHJvdWdoIHRvIHRoZSBzdGVwIGNsYXNzJyBvd24gaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhanNvbi5zdGVwVHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgbGV0IHR5cGUgPSBzdGVwc0J5SURbanNvbi5zdGVwVHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBzdGVwIHR5cGUgJHtqc29uLnN0ZXBUeXBlfSBkZWZpbmVkYCk7XG4gICAgICAgIHJldHVybiB0eXBlLmZyb21KU09OKHNjaGVtYSwganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gc2VyaWFsaXplIHN0ZXBzIHRvIEpTT04sIGVhY2ggc3RlcCBuZWVkcyBhIHN0cmluZ1xuICAgIElEIHRvIGF0dGFjaCB0byBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi4gVXNlIHRoaXMgbWV0aG9kIHRvXG4gICAgcmVnaXN0ZXIgYW4gSUQgZm9yIHlvdXIgc3RlcCBjbGFzc2VzLiBUcnkgdG8gcGljayBzb21ldGhpbmdcbiAgICB0aGF0J3MgdW5saWtlbHkgdG8gY2xhc2ggd2l0aCBzdGVwcyBmcm9tIG90aGVyIG1vZHVsZXMuXG4gICAgKi9cbiAgICBzdGF0aWMganNvbklEKGlkLCBzdGVwQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlkIGluIHN0ZXBzQnlJRClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBzdGVwIEpTT04gSUQgXCIgKyBpZCk7XG4gICAgICAgIHN0ZXBzQnlJRFtpZF0gPSBzdGVwQ2xhc3M7XG4gICAgICAgIHN0ZXBDbGFzcy5wcm90b3R5cGUuanNvbklEID0gaWQ7XG4gICAgICAgIHJldHVybiBzdGVwQ2xhc3M7XG4gICAgfVxufVxuLyoqXG5UaGUgcmVzdWx0IG9mIFthcHBseWluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwLmFwcGx5KSBhIHN0ZXAuIENvbnRhaW5zIGVpdGhlciBhXG5uZXcgZG9jdW1lbnQgb3IgYSBmYWlsdXJlIHZhbHVlLlxuKi9cbmNsYXNzIFN0ZXBSZXN1bHQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRyYW5zZm9ybWVkIGRvY3VtZW50LCBpZiBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgZG9jLCBcbiAgICAvKipcbiAgICBUaGUgZmFpbHVyZSBtZXNzYWdlLCBpZiB1bnN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBmYWlsZWQpIHtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gZmFpbGVkO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzdWNjZXNzZnVsIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIG9rKGRvYykgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQoZG9jLCBudWxsKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGZhaWxlZCBzdGVwIHJlc3VsdC5cbiAgICAqL1xuICAgIHN0YXRpYyBmYWlsKG1lc3NhZ2UpIHsgcmV0dXJuIG5ldyBTdGVwUmVzdWx0KG51bGwsIG1lc3NhZ2UpOyB9XG4gICAgLyoqXG4gICAgQ2FsbCBbYE5vZGUucmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdpdGggdGhlIGdpdmVuXG4gICAgYXJndW1lbnRzLiBDcmVhdGUgYSBzdWNjZXNzZnVsIHJlc3VsdCBpZiBpdCBzdWNjZWVkcywgYW5kIGFcbiAgICBmYWlsZWQgb25lIGlmIGl0IHRocm93cyBhIGBSZXBsYWNlRXJyb3JgLlxuICAgICovXG4gICAgc3RhdGljIGZyb21SZXBsYWNlKGRvYywgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayhkb2MucmVwbGFjZShmcm9tLCB0bywgc2xpY2UpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSZXBsYWNlRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbWFwRnJhZ21lbnQoZnJhZ21lbnQsIGYsIHBhcmVudCkge1xuICAgIGxldCBtYXBwZWQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYWdtZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBmcmFnbWVudC5jaGlsZChpKTtcbiAgICAgICAgaWYgKGNoaWxkLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY29weShtYXBGcmFnbWVudChjaGlsZC5jb250ZW50LCBmLCBjaGlsZCkpO1xuICAgICAgICBpZiAoY2hpbGQuaXNJbmxpbmUpXG4gICAgICAgICAgICBjaGlsZCA9IGYoY2hpbGQsIHBhcmVudCwgaSk7XG4gICAgICAgIG1hcHBlZC5wdXNoKGNoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIEZyYWdtZW50LmZyb21BcnJheShtYXBwZWQpO1xufVxuLyoqXG5BZGQgYSBtYXJrIHRvIGFsbCBpbmxpbmUgY29udGVudCBiZXR3ZWVuIHR3byBwb3NpdGlvbnMuXG4qL1xuY2xhc3MgQWRkTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXJrIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIG1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byBhZGQuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLCAkZnJvbSA9IGRvYy5yZXNvbHZlKHRoaXMuZnJvbSk7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKCRmcm9tLnNoYXJlZERlcHRoKHRoaXMudG8pKTtcbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKG1hcEZyYWdtZW50KG9sZFNsaWNlLmNvbnRlbnQsIChub2RlLCBwYXJlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZS5pc0F0b20gfHwgIXBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKHRoaXMubWFyay50eXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgfSwgcGFyZW50KSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIEFkZE1hcmtTdGVwICYmXG4gICAgICAgICAgICBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiZcbiAgICAgICAgICAgIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYWRkTWFya1wiLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE1hcmtcIiwgQWRkTWFya1N0ZXApO1xuLyoqXG5SZW1vdmUgYSBtYXJrIGZyb20gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBSZW1vdmVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmstcmVtb3Zpbmcgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgdW5tYXJrZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayB0byByZW1vdmUuXG4gICAgKi9cbiAgICBtYXJrKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBvbGRTbGljZSA9IGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgbm9kZSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS5tYXJrKHRoaXMubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgfSwgZG9jKSwgb2xkU2xpY2Uub3BlblN0YXJ0LCBvbGRTbGljZS5vcGVuRW5kKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHNsaWNlKTtcbiAgICB9XG4gICAgaW52ZXJ0KCkge1xuICAgICAgICByZXR1cm4gbmV3IEFkZE1hcmtTdGVwKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgaWYgKGZyb20uZGVsZXRlZCAmJiB0by5kZWxldGVkIHx8IGZyb20ucG9zID49IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGZyb20ucG9zLCB0by5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1lcmdlKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFJlbW92ZU1hcmtTdGVwICYmXG4gICAgICAgICAgICBvdGhlci5tYXJrLmVxKHRoaXMubWFyaykgJiZcbiAgICAgICAgICAgIHRoaXMuZnJvbSA8PSBvdGhlci50byAmJiB0aGlzLnRvID49IG90aGVyLmZyb20pXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKE1hdGgubWluKHRoaXMuZnJvbSwgb3RoZXIuZnJvbSksIE1hdGgubWF4KHRoaXMudG8sIG90aGVyLnRvKSwgdGhpcy5tYXJrKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwicmVtb3ZlTWFya1wiLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCksXG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlbW92ZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU1hcmtTdGVwKGpzb24uZnJvbSwganNvbi50bywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlbW92ZU1hcmtcIiwgUmVtb3ZlTWFya1N0ZXApO1xuLyoqXG5BZGQgYSBtYXJrIHRvIGEgc3BlY2lmaWMgbm9kZS5cbiovXG5jbGFzcyBBZGROb2RlTWFya1N0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBtYXJrIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG51bGwsIHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKSk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IHRoaXMubWFyay5hZGRUb1NldChub2RlLm1hcmtzKTtcbiAgICAgICAgICAgIGlmIChuZXdTZXQubGVuZ3RoID09IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLm1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGUubWFya3NbaV0uaXNJblNldChuZXdTZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIG5vZGUubWFya3NbaV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHRoaXMucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQWRkTm9kZU1hcmtTdGVwKHBvcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYWRkTm9kZU1hcmtcIiwgcG9zOiB0aGlzLnBvcywgbWFyazogdGhpcy5tYXJrLnRvSlNPTigpIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEFkZE5vZGVNYXJrU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAoanNvbi5wb3MsIHNjaGVtYS5tYXJrRnJvbUpTT04oanNvbi5tYXJrKSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhZGROb2RlTWFya1wiLCBBZGROb2RlTWFya1N0ZXApO1xuLyoqXG5SZW1vdmUgYSBtYXJrIGZyb20gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIFJlbW92ZU5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmstcmVtb3Zpbmcgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBtYXJrIHN0ZXAncyBwb3NpdGlvblwiKTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBub2RlLnR5cGUuY3JlYXRlKG5vZGUuYXR0cnMsIG51bGwsIHRoaXMubWFyay5yZW1vdmVGcm9tU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSB8fCAhdGhpcy5tYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVOb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlbW92ZU5vZGVNYXJrXCIsIFJlbW92ZU5vZGVNYXJrU3RlcCk7XG5cbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBuZXcgY29udGVudC5cbiovXG5jbGFzcyBSZXBsYWNlU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIFRoZSBnaXZlbiBgc2xpY2VgIHNob3VsZCBmaXQgdGhlICdnYXAnIGJldHdlZW4gYGZyb21gIGFuZFxuICAgIGB0b2DigJR0aGUgZGVwdGhzIG11c3QgbGluZSB1cCwgYW5kIHRoZSBzdXJyb3VuZGluZyBub2RlcyBtdXN0IGJlXG4gICAgYWJsZSB0byBiZSBqb2luZWQgd2l0aCB0aGUgb3BlbiBzaWRlcyBvZiB0aGUgc2xpY2UuIFdoZW5cbiAgICBgc3RydWN0dXJlYCBpcyB0cnVlLCB0aGUgc3RlcCB3aWxsIGZhaWwgaWYgdGhlIGNvbnRlbnQgYmV0d2VlblxuICAgIGZyb20gYW5kIHRvIGlzIG5vdCBqdXN0IGEgc2VxdWVuY2Ugb2YgY2xvc2luZyBhbmQgdGhlbiBvcGVuaW5nXG4gICAgdG9rZW5zICh0aGlzIGlzIHRvIGd1YXJkIGFnYWluc3QgcmViYXNlZCByZXBsYWNlIHN0ZXBzXG4gICAgb3ZlcndyaXRpbmcgc29tZXRoaW5nIHRoZXkgd2VyZW4ndCBzdXBwb3NlZCB0bykuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICAqL1xuICAgIHNsaWNlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlO1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiBjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy50bykpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIHJlcGxhY2Ugd291bGQgb3ZlcndyaXRlIGNvbnRlbnRcIik7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLnNsaWNlKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy50byAtIHRoaXMuZnJvbSwgdGhpcy5zbGljZS5zaXplXSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykpO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLnBvcywgTWF0aC5tYXgoZnJvbS5wb3MsIHRvLnBvcyksIHRoaXMuc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCkgfHwgb3RoZXIuc3RydWN0dXJlIHx8IHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICh0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgPT0gb3RoZXIuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuRW5kICYmICFvdGhlci5zbGljZS5vcGVuU3RhcnQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2UodGhpcy5zbGljZS5jb250ZW50LmFwcGVuZChvdGhlci5zbGljZS5jb250ZW50KSwgdGhpcy5zbGljZS5vcGVuU3RhcnQsIG90aGVyLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCh0aGlzLmZyb20sIHRoaXMudG8gKyAob3RoZXIudG8gLSBvdGhlci5mcm9tKSwgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdGhlci50byA9PSB0aGlzLmZyb20gJiYgIXRoaXMuc2xpY2Uub3BlblN0YXJ0ICYmICFvdGhlci5zbGljZS5vcGVuRW5kKSB7XG4gICAgICAgICAgICBsZXQgc2xpY2UgPSB0aGlzLnNsaWNlLnNpemUgKyBvdGhlci5zbGljZS5zaXplID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKG90aGVyLnNsaWNlLmNvbnRlbnQuYXBwZW5kKHRoaXMuc2xpY2UuY29udGVudCksIG90aGVyLnNsaWNlLm9wZW5TdGFydCwgdGhpcy5zbGljZS5vcGVuRW5kKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAob3RoZXIuZnJvbSwgdGhpcy50bywgc2xpY2UsIHRoaXMuc3RydWN0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGpzb24gPSB7IHN0ZXBUeXBlOiBcInJlcGxhY2VcIiwgZnJvbTogdGhpcy5mcm9tLCB0bzogdGhpcy50byB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGpzb24uZnJvbSwganNvbi50bywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlXCIsIFJlcGxhY2VTdGVwKTtcbi8qKlxuUmVwbGFjZSBhIHBhcnQgb2YgdGhlIGRvY3VtZW50IHdpdGggYSBzbGljZSBvZiBjb250ZW50LCBidXRcbnByZXNlcnZlIGEgcmFuZ2Ugb2YgdGhlIHJlcGxhY2VkIGNvbnRlbnQgYnkgbW92aW5nIGl0IGludG8gdGhlXG5zbGljZS5cbiovXG5jbGFzcyBSZXBsYWNlQXJvdW5kU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHJlcGxhY2UtYXJvdW5kIHN0ZXAgd2l0aCB0aGUgZ2l2ZW4gcmFuZ2UgYW5kIGdhcC5cbiAgICBgaW5zZXJ0YCBzaG91bGQgYmUgdGhlIHBvaW50IGluIHRoZSBzbGljZSBpbnRvIHdoaWNoIHRoZSBjb250ZW50XG4gICAgb2YgdGhlIGdhcCBzaG91bGQgYmUgbW92ZWQuIGBzdHJ1Y3R1cmVgIGhhcyB0aGUgc2FtZSBtZWFuaW5nIGFzXG4gICAgaXQgaGFzIGluIHRoZSBbYFJlcGxhY2VTdGVwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5SZXBsYWNlU3RlcCkgY2xhc3MuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlcGxhY2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHByZXNlcnZlZCByYW5nZS5cbiAgICAqL1xuICAgIGdhcEZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwVG8sIFxuICAgIC8qKlxuICAgIFRoZSBzbGljZSB0byBpbnNlcnQuXG4gICAgKi9cbiAgICBzbGljZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGluIHRoZSBzbGljZSB3aGVyZSB0aGUgcHJlc2VydmVkIHJhbmdlIHNob3VsZCBiZVxuICAgIGluc2VydGVkLlxuICAgICovXG4gICAgaW5zZXJ0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0cnVjdHVyZSA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy5nYXBGcm9tID0gZ2FwRnJvbTtcbiAgICAgICAgdGhpcy5nYXBUbyA9IGdhcFRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuaW5zZXJ0ID0gaW5zZXJ0O1xuICAgICAgICB0aGlzLnN0cnVjdHVyZSA9IHN0cnVjdHVyZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSAmJiAoY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmZyb20sIHRoaXMuZ2FwRnJvbSkgfHxcbiAgICAgICAgICAgIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5nYXBUbywgdGhpcy50bykpKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIlN0cnVjdHVyZSBnYXAtcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgbGV0IGdhcCA9IGRvYy5zbGljZSh0aGlzLmdhcEZyb20sIHRoaXMuZ2FwVG8pO1xuICAgICAgICBpZiAoZ2FwLm9wZW5TdGFydCB8fCBnYXAub3BlbkVuZClcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJHYXAgaXMgbm90IGEgZmxhdCByYW5nZVwiKTtcbiAgICAgICAgbGV0IGluc2VydGVkID0gdGhpcy5zbGljZS5pbnNlcnRBdCh0aGlzLmluc2VydCwgZ2FwLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIWluc2VydGVkKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkNvbnRlbnQgZG9lcyBub3QgZml0IGluIGdhcFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIGluc2VydGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFN0ZXBNYXAoW3RoaXMuZnJvbSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmluc2VydCxcbiAgICAgICAgICAgIHRoaXMuZ2FwVG8sIHRoaXMudG8gLSB0aGlzLmdhcFRvLCB0aGlzLnNsaWNlLnNpemUgLSB0aGlzLmluc2VydF0pO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBnYXAgPSB0aGlzLmdhcFRvIC0gdGhpcy5nYXBGcm9tO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplICsgZ2FwLCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCwgdGhpcy5mcm9tICsgdGhpcy5pbnNlcnQgKyBnYXAsIGRvYy5zbGljZSh0aGlzLmZyb20sIHRoaXMudG8pLnJlbW92ZUJldHdlZW4odGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLmdhcFRvIC0gdGhpcy5mcm9tKSwgdGhpcy5nYXBGcm9tIC0gdGhpcy5mcm9tLCB0aGlzLnN0cnVjdHVyZSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGxldCBnYXBGcm9tID0gdGhpcy5mcm9tID09IHRoaXMuZ2FwRnJvbSA/IGZyb20ucG9zIDogbWFwcGluZy5tYXAodGhpcy5nYXBGcm9tLCAtMSk7XG4gICAgICAgIGxldCBnYXBUbyA9IHRoaXMudG8gPT0gdGhpcy5nYXBUbyA/IHRvLnBvcyA6IG1hcHBpbmcubWFwKHRoaXMuZ2FwVG8sIDEpO1xuICAgICAgICBpZiAoKGZyb20uZGVsZXRlZEFjcm9zcyAmJiB0by5kZWxldGVkQWNyb3NzKSB8fCBnYXBGcm9tIDwgZnJvbS5wb3MgfHwgZ2FwVG8gPiB0by5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChmcm9tLnBvcywgdG8ucG9zLCBnYXBGcm9tLCBnYXBUbywgdGhpcy5zbGljZSwgdGhpcy5pbnNlcnQsIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZUFyb3VuZFwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvLFxuICAgICAgICAgICAgZ2FwRnJvbTogdGhpcy5nYXBGcm9tLCBnYXBUbzogdGhpcy5nYXBUbywgaW5zZXJ0OiB0aGlzLmluc2VydCB9O1xuICAgICAgICBpZiAodGhpcy5zbGljZS5zaXplKVxuICAgICAgICAgICAganNvbi5zbGljZSA9IHRoaXMuc2xpY2UudG9KU09OKCk7XG4gICAgICAgIGlmICh0aGlzLnN0cnVjdHVyZSlcbiAgICAgICAgICAgIGpzb24uc3RydWN0dXJlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGpzb247XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLnRvICE9IFwibnVtYmVyXCIgfHxcbiAgICAgICAgICAgIHR5cGVvZiBqc29uLmdhcEZyb20gIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5nYXBUbyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmluc2VydCAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZXBsYWNlQXJvdW5kU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlQXJvdW5kU3RlcChqc29uLmZyb20sIGpzb24udG8sIGpzb24uZ2FwRnJvbSwganNvbi5nYXBUbywgU2xpY2UuZnJvbUpTT04oc2NoZW1hLCBqc29uLnNsaWNlKSwganNvbi5pbnNlcnQsICEhanNvbi5zdHJ1Y3R1cmUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVwbGFjZUFyb3VuZFwiLCBSZXBsYWNlQXJvdW5kU3RlcCk7XG5mdW5jdGlvbiBjb250ZW50QmV0d2Vlbihkb2MsIGZyb20sIHRvKSB7XG4gICAgbGV0ICRmcm9tID0gZG9jLnJlc29sdmUoZnJvbSksIGRpc3QgPSB0byAtIGZyb20sIGRlcHRoID0gJGZyb20uZGVwdGg7XG4gICAgd2hpbGUgKGRpc3QgPiAwICYmIGRlcHRoID4gMCAmJiAkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSA9PSAkZnJvbS5ub2RlKGRlcHRoKS5jaGlsZENvdW50KSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGRpc3QtLTtcbiAgICB9XG4gICAgaWYgKGRpc3QgPiAwKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJGZyb20ubm9kZShkZXB0aCkubWF5YmVDaGlsZCgkZnJvbS5pbmRleEFmdGVyKGRlcHRoKSk7XG4gICAgICAgIHdoaWxlIChkaXN0ID4gMCkge1xuICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGRpc3QtLTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZE1hcmsodHIsIGZyb20sIHRvLCBtYXJrKSB7XG4gICAgbGV0IHJlbW92ZWQgPSBbXSwgYWRkZWQgPSBbXTtcbiAgICBsZXQgcmVtb3ZpbmcsIGFkZGluZztcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgbWFya3MgPSBub2RlLm1hcmtzO1xuICAgICAgICBpZiAoIW1hcmsuaXNJblNldChtYXJrcykgJiYgcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUobWFyay50eXBlKSkge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gTWF0aC5tYXgocG9zLCBmcm9tKSwgZW5kID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgbGV0IG5ld1NldCA9IG1hcmsuYWRkVG9TZXQobWFya3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghbWFya3NbaV0uaXNJblNldChuZXdTZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZW1vdmluZyAmJiByZW1vdmluZy50byA9PSBzdGFydCAmJiByZW1vdmluZy5tYXJrLmVxKG1hcmtzW2ldKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92aW5nLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkLnB1c2gocmVtb3ZpbmcgPSBuZXcgUmVtb3ZlTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFya3NbaV0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWRkaW5nICYmIGFkZGluZy50byA9PSBzdGFydClcbiAgICAgICAgICAgICAgICBhZGRpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYWRkZWQucHVzaChhZGRpbmcgPSBuZXcgQWRkTWFya1N0ZXAoc3RhcnQsIGVuZCwgbWFyaykpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmVtb3ZlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG4gICAgYWRkZWQuZm9yRWFjaChzID0+IHRyLnN0ZXAocykpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgbWF0Y2hlZCA9IFtdLCBzdGVwID0gMDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RlcCsrO1xuICAgICAgICBsZXQgdG9SZW1vdmUgPSBudWxsO1xuICAgICAgICBpZiAobWFyayBpbnN0YW5jZW9mIE1hcmtUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbm9kZS5tYXJrcywgZm91bmQ7XG4gICAgICAgICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuICAgICAgICAgICAgICAgICh0b1JlbW92ZSB8fCAodG9SZW1vdmUgPSBbXSkpLnB1c2goZm91bmQpO1xuICAgICAgICAgICAgICAgIHNldCA9IGZvdW5kLnJlbW92ZUZyb21TZXQoc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXJrKSB7XG4gICAgICAgICAgICBpZiAobWFyay5pc0luU2V0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIHRvUmVtb3ZlID0gW21hcmtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9SZW1vdmUgPSBub2RlLm1hcmtzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1JlbW92ZSAmJiB0b1JlbW92ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvUmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlID0gdG9SZW1vdmVbaV0sIGZvdW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0Y2hlZC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IG1hdGNoZWRbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChtLnN0ZXAgPT0gc3RlcCAtIDEgJiYgc3R5bGUuZXEobWF0Y2hlZFtqXS5zdHlsZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IG07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC50byA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQuc3RlcCA9IHN0ZXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLnB1c2goeyBzdHlsZSwgZnJvbTogTWF0aC5tYXgocG9zLCBmcm9tKSwgdG86IGVuZCwgc3RlcCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBtYXRjaGVkLmZvckVhY2gobSA9PiB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChtLmZyb20sIG0udG8sIG0uc3R5bGUpKSk7XG59XG5mdW5jdGlvbiBjbGVhckluY29tcGF0aWJsZSh0ciwgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCA9IHBhcmVudFR5cGUuY29udGVudE1hdGNoLCBjbGVhck5ld2xpbmVzID0gdHJ1ZSkge1xuICAgIGxldCBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICAgIGxldCByZXBsU3RlcHMgPSBbXSwgY3VyID0gcG9zICsgMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGQoaSksIGVuZCA9IGN1ciArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBsZXQgYWxsb3dlZCA9IG1hdGNoLm1hdGNoVHlwZShjaGlsZC50eXBlKTtcbiAgICAgICAgaWYgKCFhbGxvd2VkKSB7XG4gICAgICAgICAgICByZXBsU3RlcHMucHVzaChuZXcgUmVwbGFjZVN0ZXAoY3VyLCBlbmQsIFNsaWNlLmVtcHR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IGFsbG93ZWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkLm1hcmtzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmICghcGFyZW50VHlwZS5hbGxvd3NNYXJrVHlwZShjaGlsZC5tYXJrc1tqXS50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVtb3ZlTWFya1N0ZXAoY3VyLCBlbmQsIGNoaWxkLm1hcmtzW2pdKSk7XG4gICAgICAgICAgICBpZiAoY2xlYXJOZXdsaW5lcyAmJiBjaGlsZC5pc1RleHQgJiYgcGFyZW50VHlwZS53aGl0ZXNwYWNlICE9IFwicHJlXCIpIHtcbiAgICAgICAgICAgICAgICBsZXQgbSwgbmV3bGluZSA9IC9cXHI/XFxufFxcci9nLCBzbGljZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobSA9IG5ld2xpbmUuZXhlYyhjaGlsZC50ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNsaWNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShwYXJlbnRUeXBlLnNjaGVtYS50ZXh0KFwiIFwiLCBwYXJlbnRUeXBlLmFsbG93ZWRNYXJrcyhjaGlsZC5tYXJrcykpKSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIgKyBtLmluZGV4LCBjdXIgKyBtLmluZGV4ICsgbVswXS5sZW5ndGgsIHNsaWNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGVuZDtcbiAgICB9XG4gICAgaWYgKCFtYXRjaC52YWxpZEVuZCkge1xuICAgICAgICBsZXQgZmlsbCA9IG1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICB0ci5yZXBsYWNlKGN1ciwgY3VyLCBuZXcgU2xpY2UoZmlsbCwgMCwgMCkpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gcmVwbFN0ZXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB0ci5zdGVwKHJlcGxTdGVwc1tpXSk7XG59XG5cbmZ1bmN0aW9uIGNhbkN1dChub2RlLCBzdGFydCwgZW5kKSB7XG4gICAgcmV0dXJuIChzdGFydCA9PSAwIHx8IG5vZGUuY2FuUmVwbGFjZShzdGFydCwgbm9kZS5jaGlsZENvdW50KSkgJiZcbiAgICAgICAgKGVuZCA9PSBub2RlLmNoaWxkQ291bnQgfHwgbm9kZS5jYW5SZXBsYWNlKDAsIGVuZCkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHRhcmdldCBkZXB0aCB0byB3aGljaCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2VcbmNhbiBiZSBsaWZ0ZWQuIFdpbGwgbm90IGdvIGFjcm9zc1xuW2lzb2xhdGluZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmlzb2xhdGluZykgcGFyZW50IG5vZGVzLlxuKi9cbmZ1bmN0aW9uIGxpZnRUYXJnZXQocmFuZ2UpIHtcbiAgICBsZXQgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGxldCBjb250ZW50ID0gcGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleChyYW5nZS5zdGFydEluZGV4LCByYW5nZS5lbmRJbmRleCk7XG4gICAgZm9yIChsZXQgZGVwdGggPSByYW5nZS5kZXB0aCwgY29udGVudEJlZm9yZSA9IDAsIGNvbnRlbnRBZnRlciA9IDA7OyAtLWRlcHRoKSB7XG4gICAgICAgIGxldCBub2RlID0gcmFuZ2UuJGZyb20ubm9kZShkZXB0aCk7XG4gICAgICAgIGxldCBpbmRleCA9IHJhbmdlLiRmcm9tLmluZGV4KGRlcHRoKSArIGNvbnRlbnRCZWZvcmUsIGVuZEluZGV4ID0gcmFuZ2UuJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIC0gY29udGVudEFmdGVyO1xuICAgICAgICBpZiAoZGVwdGggPCByYW5nZS5kZXB0aCAmJiBub2RlLmNhblJlcGxhY2UoaW5kZXgsIGVuZEluZGV4LCBjb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoID09IDAgfHwgbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICFjYW5DdXQobm9kZSwgaW5kZXgsIGVuZEluZGV4KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoaW5kZXgpXG4gICAgICAgICAgICBjb250ZW50QmVmb3JlID0gMTtcbiAgICAgICAgaWYgKGVuZEluZGV4IDwgbm9kZS5jaGlsZENvdW50KVxuICAgICAgICAgICAgY29udGVudEFmdGVyID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBsaWZ0KHRyLCByYW5nZSwgdGFyZ2V0KSB7XG4gICAgbGV0IHsgJGZyb20sICR0bywgZGVwdGggfSA9IHJhbmdlO1xuICAgIGxldCBnYXBTdGFydCA9ICRmcm9tLmJlZm9yZShkZXB0aCArIDEpLCBnYXBFbmQgPSAkdG8uYWZ0ZXIoZGVwdGggKyAxKTtcbiAgICBsZXQgc3RhcnQgPSBnYXBTdGFydCwgZW5kID0gZ2FwRW5kO1xuICAgIGxldCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgb3BlblN0YXJ0ID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJGZyb20uaW5kZXgoZCkgPiAwKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eSwgb3BlbkVuZCA9IDA7XG4gICAgZm9yIChsZXQgZCA9IGRlcHRoLCBzcGxpdHRpbmcgPSBmYWxzZTsgZCA+IHRhcmdldDsgZC0tKVxuICAgICAgICBpZiAoc3BsaXR0aW5nIHx8ICR0by5hZnRlcihkICsgMSkgPCAkdG8uZW5kKGQpKSB7XG4gICAgICAgICAgICBzcGxpdHRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKCR0by5ub2RlKGQpLmNvcHkoYWZ0ZXIpKTtcbiAgICAgICAgICAgIG9wZW5FbmQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVuZCsrO1xuICAgICAgICB9XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgZ2FwU3RhcnQsIGdhcEVuZCwgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBvcGVuU3RhcnQsIG9wZW5FbmQpLCBiZWZvcmUuc2l6ZSAtIG9wZW5TdGFydCwgdHJ1ZSkpO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHZhbGlkIHdheSB0byB3cmFwIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBpbiBhXG5ub2RlIG9mIHRoZSBnaXZlbiB0eXBlLiBNYXkgaW50cm9kdWNlIGV4dHJhIG5vZGVzIGFyb3VuZCBhbmQgaW5zaWRlXG50aGUgd3JhcHBlciBub2RlLCBpZiBuZWNlc3NhcnkuIFJldHVybnMgbnVsbCBpZiBubyB2YWxpZCB3cmFwcGluZ1xuY291bGQgYmUgZm91bmQuIFdoZW4gYGlubmVyUmFuZ2VgIGlzIGdpdmVuLCB0aGF0IHJhbmdlJ3MgY29udGVudCBpc1xudXNlZCBhcyB0aGUgY29udGVudCB0byBmaXQgaW50byB0aGUgd3JhcHBpbmcsIGluc3RlYWQgb2YgdGhlXG5jb250ZW50IG9mIGByYW5nZWAuXG4qL1xuZnVuY3Rpb24gZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMgPSBudWxsLCBpbm5lclJhbmdlID0gcmFuZ2UpIHtcbiAgICBsZXQgYXJvdW5kID0gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgbm9kZVR5cGUpO1xuICAgIGxldCBpbm5lciA9IGFyb3VuZCAmJiBmaW5kV3JhcHBpbmdJbnNpZGUoaW5uZXJSYW5nZSwgbm9kZVR5cGUpO1xuICAgIGlmICghaW5uZXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBhcm91bmQubWFwKHdpdGhBdHRycylcbiAgICAgICAgLmNvbmNhdCh7IHR5cGU6IG5vZGVUeXBlLCBhdHRycyB9KS5jb25jYXQoaW5uZXIubWFwKHdpdGhBdHRycykpO1xufVxuZnVuY3Rpb24gd2l0aEF0dHJzKHR5cGUpIHsgcmV0dXJuIHsgdHlwZSwgYXR0cnM6IG51bGwgfTsgfVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nT3V0c2lkZShyYW5nZSwgdHlwZSkge1xuICAgIGxldCB7IHBhcmVudCwgc3RhcnRJbmRleCwgZW5kSW5kZXggfSA9IHJhbmdlO1xuICAgIGxldCBhcm91bmQgPSBwYXJlbnQuY29udGVudE1hdGNoQXQoc3RhcnRJbmRleCkuZmluZFdyYXBwaW5nKHR5cGUpO1xuICAgIGlmICghYXJvdW5kKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgb3V0ZXIgPSBhcm91bmQubGVuZ3RoID8gYXJvdW5kWzBdIDogdHlwZTtcbiAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBvdXRlcikgPyBhcm91bmQgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZFdyYXBwaW5nSW5zaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGlubmVyID0gcGFyZW50LmNoaWxkKHN0YXJ0SW5kZXgpO1xuICAgIGxldCBpbnNpZGUgPSB0eXBlLmNvbnRlbnRNYXRjaC5maW5kV3JhcHBpbmcoaW5uZXIudHlwZSk7XG4gICAgaWYgKCFpbnNpZGUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBsYXN0VHlwZSA9IGluc2lkZS5sZW5ndGggPyBpbnNpZGVbaW5zaWRlLmxlbmd0aCAtIDFdIDogdHlwZTtcbiAgICBsZXQgaW5uZXJNYXRjaCA9IGxhc3RUeXBlLmNvbnRlbnRNYXRjaDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaW5uZXJNYXRjaCAmJiBpIDwgZW5kSW5kZXg7IGkrKylcbiAgICAgICAgaW5uZXJNYXRjaCA9IGlubmVyTWF0Y2gubWF0Y2hUeXBlKHBhcmVudC5jaGlsZChpKS50eXBlKTtcbiAgICBpZiAoIWlubmVyTWF0Y2ggfHwgIWlubmVyTWF0Y2gudmFsaWRFbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBpbnNpZGU7XG59XG5mdW5jdGlvbiB3cmFwKHRyLCByYW5nZSwgd3JhcHBlcnMpIHtcbiAgICBsZXQgY29udGVudCA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGkgPSB3cmFwcGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAoY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgbWF0Y2ggPSB3cmFwcGVyc1tpXS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKCFtYXRjaCB8fCAhbWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJXcmFwcGVyIHR5cGUgZ2l2ZW4gdG8gVHJhbnNmb3JtLndyYXAgZG9lcyBub3QgZm9ybSB2YWxpZCBjb250ZW50IG9mIGl0cyBwYXJlbnQgd3JhcHBlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh3cmFwcGVyc1tpXS50eXBlLmNyZWF0ZSh3cmFwcGVyc1tpXS5hdHRycywgY29udGVudCkpO1xuICAgIH1cbiAgICBsZXQgc3RhcnQgPSByYW5nZS5zdGFydCwgZW5kID0gcmFuZ2UuZW5kO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHN0YXJ0LCBlbmQsIHN0YXJ0LCBlbmQsIG5ldyBTbGljZShjb250ZW50LCAwLCAwKSwgd3JhcHBlcnMubGVuZ3RoLCB0cnVlKSk7XG59XG5mdW5jdGlvbiBzZXRCbG9ja1R5cGUodHIsIGZyb20sIHRvLCB0eXBlLCBhdHRycykge1xuICAgIGlmICghdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUeXBlIGdpdmVuIHRvIHNldEJsb2NrVHlwZSBzaG91bGQgYmUgYSB0ZXh0YmxvY2tcIik7XG4gICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgdHIuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICBsZXQgYXR0cnNIZXJlID0gdHlwZW9mIGF0dHJzID09IFwiZnVuY3Rpb25cIiA/IGF0dHJzKG5vZGUpIDogYXR0cnM7XG4gICAgICAgIGlmIChub2RlLmlzVGV4dGJsb2NrICYmICFub2RlLmhhc01hcmt1cCh0eXBlLCBhdHRyc0hlcmUpICYmXG4gICAgICAgICAgICBjYW5DaGFuZ2VUeXBlKHRyLmRvYywgdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zKSwgdHlwZSkpIHtcbiAgICAgICAgICAgIGxldCBjb252ZXJ0TmV3bGluZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZSA9IHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiLCBzdXBwb3J0TGluZWJyZWFrID0gISF0eXBlLmNvbnRlbnRNYXRjaC5tYXRjaFR5cGUodHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwcmUgJiYgIXN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFwcmUgJiYgc3VwcG9ydExpbmVicmVhaylcbiAgICAgICAgICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSBhbGwgbWFya3VwIHRoYXQgaXNuJ3QgYWxsb3dlZCBpbiB0aGUgbmV3IG5vZGUgdHlwZSBpcyBjbGVhcmVkXG4gICAgICAgICAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXBsYWNlTGluZWJyZWFrcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRyLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MsIDEpLCB0eXBlLCB1bmRlZmluZWQsIGNvbnZlcnROZXdsaW5lcyA9PT0gbnVsbCk7XG4gICAgICAgICAgICBsZXQgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICBsZXQgc3RhcnRNID0gbWFwcGluZy5tYXAocG9zLCAxKSwgZW5kTSA9IG1hcHBpbmcubWFwKHBvcyArIG5vZGUubm9kZVNpemUsIDEpO1xuICAgICAgICAgICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnRNLCBlbmRNLCBzdGFydE0gKyAxLCBlbmRNIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnNIZXJlLCBudWxsLCBub2RlLm1hcmtzKSksIDAsIDApLCAxLCB0cnVlKSk7XG4gICAgICAgICAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSB0cnVlKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VOZXdsaW5lcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcmVwbGFjZU5ld2xpbmVzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pIHtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgbGV0IG0sIG5ld2xpbmUgPSAvXFxyP1xcbnxcXHIvZztcbiAgICAgICAgICAgIHdoaWxlIChtID0gbmV3bGluZS5leGVjKGNoaWxkLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKS5tYXAocG9zICsgMSArIG9mZnNldCArIG0uaW5kZXgpO1xuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0LCBzdGFydCArIDEsIG5vZGUudHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQuY3JlYXRlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlTGluZWJyZWFrcyh0ciwgbm9kZSwgcG9zLCBtYXBGcm9tKSB7XG4gICAgbm9kZS5mb3JFYWNoKChjaGlsZCwgb2Zmc2V0KSA9PiB7XG4gICAgICAgIGlmIChjaGlsZC50eXBlID09IGNoaWxkLnR5cGUuc2NoZW1hLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyAxICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHN0YXJ0LCBzdGFydCArIDEsIG5vZGUudHlwZS5zY2hlbWEudGV4dChcIlxcblwiKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNhbkNoYW5nZVR5cGUoZG9jLCBwb3MsIHR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiAkcG9zLnBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXggKyAxLCB0eXBlKTtcbn1cbi8qKlxuQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG5XaGVuIGB0eXBlYCBpc24ndCBnaXZlbiwgdGhlIGV4aXN0aW5nIG5vZGUgdHlwZSBpcyBwcmVzZXJ2ZWQsXG4qL1xuZnVuY3Rpb24gc2V0Tm9kZU1hcmt1cCh0ciwgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpIHtcbiAgICBsZXQgbm9kZSA9IHRyLmRvYy5ub2RlQXQocG9zKTtcbiAgICBpZiAoIW5vZGUpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBnaXZlbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoIXR5cGUpXG4gICAgICAgIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgbGV0IG5ld05vZGUgPSB0eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbWFya3MgfHwgbm9kZS5tYXJrcyk7XG4gICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICByZXR1cm4gdHIucmVwbGFjZVdpdGgocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBuZXdOb2RlKTtcbiAgICBpZiAoIXR5cGUudmFsaWRDb250ZW50KG5vZGUuY29udGVudCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBjb250ZW50IGZvciBub2RlIHR5cGUgXCIgKyB0eXBlLm5hbWUpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKHBvcywgcG9zICsgbm9kZS5ub2RlU2l6ZSwgcG9zICsgMSwgcG9zICsgbm9kZS5ub2RlU2l6ZSAtIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5ld05vZGUpLCAwLCAwKSwgMSwgdHJ1ZSkpO1xufVxuLyoqXG5DaGVjayB3aGV0aGVyIHNwbGl0dGluZyBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgYWxsb3dlZC5cbiovXG5mdW5jdGlvbiBjYW5TcGxpdChkb2MsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBiYXNlID0gJHBvcy5kZXB0aCAtIGRlcHRoO1xuICAgIGxldCBpbm5lclR5cGUgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW3R5cGVzQWZ0ZXIubGVuZ3RoIC0gMV0pIHx8ICRwb3MucGFyZW50O1xuICAgIGlmIChiYXNlIDwgMCB8fCAkcG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICEkcG9zLnBhcmVudC5jYW5SZXBsYWNlKCRwb3MuaW5kZXgoKSwgJHBvcy5wYXJlbnQuY2hpbGRDb3VudCkgfHxcbiAgICAgICAgIWlubmVyVHlwZS50eXBlLnZhbGlkQ29udGVudCgkcG9zLnBhcmVudC5jb250ZW50LmN1dEJ5SW5kZXgoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDEsIGkgPSBkZXB0aCAtIDI7IGQgPiBiYXNlOyBkLS0sIGktLSkge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZShkKSwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgcmVzdCA9IG5vZGUuY29udGVudC5jdXRCeUluZGV4KGluZGV4LCBub2RlLmNoaWxkQ291bnQpO1xuICAgICAgICBsZXQgb3ZlcnJpZGVDaGlsZCA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpICsgMV07XG4gICAgICAgIGlmIChvdmVycmlkZUNoaWxkKVxuICAgICAgICAgICAgcmVzdCA9IHJlc3QucmVwbGFjZUNoaWxkKDAsIG92ZXJyaWRlQ2hpbGQudHlwZS5jcmVhdGUob3ZlcnJpZGVDaGlsZC5hdHRycykpO1xuICAgICAgICBsZXQgYWZ0ZXIgPSAodHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2ldKSB8fCBub2RlO1xuICAgICAgICBpZiAoIW5vZGUuY2FuUmVwbGFjZShpbmRleCArIDEsIG5vZGUuY2hpbGRDb3VudCkgfHwgIWFmdGVyLnR5cGUudmFsaWRDb250ZW50KHJlc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoYmFzZSk7XG4gICAgbGV0IGJhc2VUeXBlID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyWzBdO1xuICAgIHJldHVybiAkcG9zLm5vZGUoYmFzZSkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBiYXNlVHlwZSA/IGJhc2VUeXBlLnR5cGUgOiAkcG9zLm5vZGUoYmFzZSArIDEpLnR5cGUpO1xufVxuZnVuY3Rpb24gc3BsaXQodHIsIHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpLCBiZWZvcmUgPSBGcmFnbWVudC5lbXB0eSwgYWZ0ZXIgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCwgZSA9ICRwb3MuZGVwdGggLSBkZXB0aCwgaSA9IGRlcHRoIC0gMTsgZCA+IGU7IGQtLSwgaS0tKSB7XG4gICAgICAgIGJlZm9yZSA9IEZyYWdtZW50LmZyb20oJHBvcy5ub2RlKGQpLmNvcHkoYmVmb3JlKSk7XG4gICAgICAgIGxldCB0eXBlQWZ0ZXIgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV07XG4gICAgICAgIGFmdGVyID0gRnJhZ21lbnQuZnJvbSh0eXBlQWZ0ZXIgPyB0eXBlQWZ0ZXIudHlwZS5jcmVhdGUodHlwZUFmdGVyLmF0dHJzLCBhZnRlcikgOiAkcG9zLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChwb3MsIHBvcywgbmV3IFNsaWNlKGJlZm9yZS5hcHBlbmQoYWZ0ZXIpLCBkZXB0aCwgZGVwdGgpLCB0cnVlKSk7XG59XG4vKipcblRlc3Qgd2hldGhlciB0aGUgYmxvY2tzIGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBwb3NpdGlvbiBjYW4gYmVcbmpvaW5lZC5cbiovXG5mdW5jdGlvbiBjYW5Kb2luKGRvYywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICByZXR1cm4gam9pbmFibGUoJHBvcy5ub2RlQmVmb3JlLCAkcG9zLm5vZGVBZnRlcikgJiZcbiAgICAgICAgJHBvcy5wYXJlbnQuY2FuUmVwbGFjZShpbmRleCwgaW5kZXggKyAxKTtcbn1cbmZ1bmN0aW9uIGNhbkFwcGVuZFdpdGhTdWJzdGl0dXRlZExpbmVicmVha3MoYSwgYikge1xuICAgIGlmICghYi5jb250ZW50LnNpemUpXG4gICAgICAgIGEudHlwZS5jb21wYXRpYmxlQ29udGVudChiLnR5cGUpO1xuICAgIGxldCBtYXRjaCA9IGEuY29udGVudE1hdGNoQXQoYS5jaGlsZENvdW50KTtcbiAgICBsZXQgeyBsaW5lYnJlYWtSZXBsYWNlbWVudCB9ID0gYS50eXBlLnNjaGVtYTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGIuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGIuY2hpbGQoaSk7XG4gICAgICAgIGxldCB0eXBlID0gY2hpbGQudHlwZSA9PSBsaW5lYnJlYWtSZXBsYWNlbWVudCA/IGEudHlwZS5zY2hlbWEubm9kZXMudGV4dCA6IGNoaWxkLnR5cGU7XG4gICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWEudHlwZS5hbGxvd3NNYXJrcyhjaGlsZC5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaC52YWxpZEVuZDtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKGEsIGIpIHtcbiAgICByZXR1cm4gISEoYSAmJiBiICYmICFhLmlzTGVhZiAmJiBjYW5BcHBlbmRXaXRoU3Vic3RpdHV0ZWRMaW5lYnJlYWtzKGEsIGIpKTtcbn1cbi8qKlxuRmluZCBhbiBhbmNlc3RvciBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gdGhhdCBjYW4gYmUgam9pbmVkIHRvIHRoZVxuYmxvY2sgYmVmb3JlIChvciBhZnRlciBpZiBgZGlyYCBpcyBwb3NpdGl2ZSkuIFJldHVybnMgdGhlIGpvaW5hYmxlXG5wb2ludCwgaWYgYW55LlxuKi9cbmZ1bmN0aW9uIGpvaW5Qb2ludChkb2MsIHBvcywgZGlyID0gLTEpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXIsIGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgaWYgKGQgPT0gJHBvcy5kZXB0aCkge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGVBZnRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlID0gJHBvcy5ub2RlKGQpLm1heWJlQ2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgIGFmdGVyID0gJHBvcy5ub2RlKGQgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmVmb3JlICYmICFiZWZvcmUuaXNUZXh0YmxvY2sgJiYgam9pbmFibGUoYmVmb3JlLCBhZnRlcikgJiZcbiAgICAgICAgICAgICRwb3Mubm9kZShkKS5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGQgPT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBwb3MgPSBkaXIgPCAwID8gJHBvcy5iZWZvcmUoZCkgOiAkcG9zLmFmdGVyKGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGpvaW4odHIsIHBvcywgZGVwdGgpIHtcbiAgICBsZXQgY29udmVydE5ld2xpbmVzID0gbnVsbDtcbiAgICBsZXQgeyBsaW5lYnJlYWtSZXBsYWNlbWVudCB9ID0gdHIuZG9jLnR5cGUuc2NoZW1hO1xuICAgIGxldCAkYmVmb3JlID0gdHIuZG9jLnJlc29sdmUocG9zIC0gZGVwdGgpLCBiZWZvcmVUeXBlID0gJGJlZm9yZS5ub2RlKCkudHlwZTtcbiAgICBpZiAobGluZWJyZWFrUmVwbGFjZW1lbnQgJiYgYmVmb3JlVHlwZS5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIGxldCBwcmUgPSBiZWZvcmVUeXBlLndoaXRlc3BhY2UgPT0gXCJwcmVcIjtcbiAgICAgICAgbGV0IHN1cHBvcnRMaW5lYnJlYWsgPSAhIWJlZm9yZVR5cGUuY29udGVudE1hdGNoLm1hdGNoVHlwZShsaW5lYnJlYWtSZXBsYWNlbWVudCk7XG4gICAgICAgIGlmIChwcmUgJiYgIXN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICBjb252ZXJ0TmV3bGluZXMgPSBmYWxzZTtcbiAgICAgICAgZWxzZSBpZiAoIXByZSAmJiBzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgbGV0ICRhZnRlciA9IHRyLmRvYy5yZXNvbHZlKHBvcyArIGRlcHRoKTtcbiAgICAgICAgcmVwbGFjZUxpbmVicmVha3ModHIsICRhZnRlci5ub2RlKCksICRhZnRlci5iZWZvcmUoKSwgbWFwRnJvbSk7XG4gICAgfVxuICAgIGlmIChiZWZvcmVUeXBlLmlubGluZUNvbnRlbnQpXG4gICAgICAgIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MgKyBkZXB0aCAtIDEsIGJlZm9yZVR5cGUsICRiZWZvcmUubm9kZSgpLmNvbnRlbnRNYXRjaEF0KCRiZWZvcmUuaW5kZXgoKSksIGNvbnZlcnROZXdsaW5lcyA9PSBudWxsKTtcbiAgICBsZXQgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSksIHN0YXJ0ID0gbWFwcGluZy5tYXAocG9zIC0gZGVwdGgpO1xuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHN0YXJ0LCBtYXBwaW5nLm1hcChwb3MgKyBkZXB0aCwgLTEpLCBTbGljZS5lbXB0eSwgdHJ1ZSkpO1xuICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IHRydWUpIHtcbiAgICAgICAgbGV0ICRmdWxsID0gdHIuZG9jLnJlc29sdmUoc3RhcnQpO1xuICAgICAgICByZXBsYWNlTmV3bGluZXModHIsICRmdWxsLm5vZGUoKSwgJGZ1bGwuYmVmb3JlKCksIHRyLnN0ZXBzLmxlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuVHJ5IHRvIGZpbmQgYSBwb2ludCB3aGVyZSBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgY2FuIGJlIGluc2VydGVkXG5uZWFyIGBwb3NgLCBieSBzZWFyY2hpbmcgdXAgdGhlIG5vZGUgaGllcmFyY2h5IHdoZW4gYHBvc2AgaXRzZWxmXG5pc24ndCBhIHZhbGlkIHBsYWNlIGJ1dCBpcyBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgbm9kZS4gUmV0dXJuXG5udWxsIGlmIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBpbnNlcnRQb2ludChkb2MsIHBvcywgbm9kZVR5cGUpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKCRwb3MuaW5kZXgoKSwgJHBvcy5pbmRleCgpLCBub2RlVHlwZSkpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09IDApXG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmJlZm9yZShkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgaWYgKCRwb3MucGFyZW50T2Zmc2V0ID09ICRwb3MucGFyZW50LmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpO1xuICAgICAgICAgICAgaWYgKCRwb3Mubm9kZShkKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIG5vZGVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5hZnRlcihkICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPCAkcG9zLm5vZGUoZCkuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLyoqXG5GaW5kcyBhIHBvc2l0aW9uIGF0IG9yIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24gd2hlcmUgdGhlIGdpdmVuXG5zbGljZSBjYW4gYmUgaW5zZXJ0ZWQuIFdpbGwgbG9vayBhdCBwYXJlbnQgbm9kZXMnIG5lYXJlc3QgYm91bmRhcnlcbmFuZCB0cnkgdGhlcmUsIGV2ZW4gaWYgdGhlIG9yaWdpbmFsIHBvc2l0aW9uIHdhc24ndCBkaXJlY3RseSBhdCB0aGVcbnN0YXJ0IG9yIGVuZCBvZiB0aGF0IG5vZGUuIFJldHVybnMgbnVsbCB3aGVuIG5vIHBvc2l0aW9uIHdhcyBmb3VuZC5cbiovXG5mdW5jdGlvbiBkcm9wUG9pbnQoZG9jLCBwb3MsIHNsaWNlKSB7XG4gICAgbGV0ICRwb3MgPSBkb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmICghc2xpY2UuY29udGVudC5zaXplKVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIGxldCBjb250ZW50ID0gc2xpY2UuY29udGVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWNlLm9wZW5TdGFydDsgaSsrKVxuICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gKHNsaWNlLm9wZW5TdGFydCA9PSAwICYmIHNsaWNlLnNpemUgPyAyIDogMSk7IHBhc3MrKykge1xuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBiaWFzID0gZCA9PSAkcG9zLmRlcHRoID8gMCA6ICRwb3MucG9zIDw9ICgkcG9zLnN0YXJ0KGQgKyAxKSArICRwb3MuZW5kKGQgKyAxKSkgLyAyID8gLTEgOiAxO1xuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICRwb3MuaW5kZXgoZCkgKyAoYmlhcyA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gJHBvcy5ub2RlKGQpLCBmaXRzID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAocGFzcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgZml0cyA9IHBhcmVudC5jYW5SZXBsYWNlKGluc2VydFBvcywgaW5zZXJ0UG9zLCBjb250ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCB3cmFwcGluZyA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChpbnNlcnRQb3MpLmZpbmRXcmFwcGluZyhjb250ZW50LmZpcnN0Q2hpbGQudHlwZSk7XG4gICAgICAgICAgICAgICAgZml0cyA9IHdyYXBwaW5nICYmIHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbnNlcnRQb3MsIGluc2VydFBvcywgd3JhcHBpbmdbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZpdHMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJpYXMgPT0gMCA/ICRwb3MucG9zIDogYmlhcyA8IDAgPyAkcG9zLmJlZm9yZShkICsgMSkgOiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG7igJhGaXTigJkgYSBzbGljZSBpbnRvIGEgZ2l2ZW4gcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LCBwcm9kdWNpbmcgYVxuW3N0ZXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcCkgdGhhdCBpbnNlcnRzIGl0LiBXaWxsIHJldHVybiBudWxsIGlmXG50aGVyZSdzIG5vIG1lYW5pbmdmdWwgd2F5IHRvIGluc2VydCB0aGUgc2xpY2UgaGVyZSwgb3IgaW5zZXJ0aW5nIGl0XG53b3VsZCBiZSBhIG5vLW9wIChhbiBlbXB0eSBzbGljZSBvdmVyIGFuIGVtcHR5IHJhbmdlKS5cbiovXG5mdW5jdGlvbiByZXBsYWNlU3RlcChkb2MsIGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgIGlmIChmcm9tID09IHRvICYmICFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gZG9jLnJlc29sdmUodG8pO1xuICAgIC8vIE9wdGltaXphdGlvbiAtLSBhdm9pZCB3b3JrIGlmIGl0J3Mgb2J2aW91cyB0aGF0IGl0J3Mgbm90IG5lZWRlZC5cbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICByZXR1cm4gbmV3IEZpdHRlcigkZnJvbSwgJHRvLCBzbGljZSkuZml0KCk7XG59XG5mdW5jdGlvbiBmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSB7XG4gICAgcmV0dXJuICFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uc3RhcnQoKSA9PSAkdG8uc3RhcnQoKSAmJlxuICAgICAgICAkZnJvbS5wYXJlbnQuY2FuUmVwbGFjZSgkZnJvbS5pbmRleCgpLCAkdG8uaW5kZXgoKSwgc2xpY2UuY29udGVudCk7XG59XG4vLyBBbGdvcml0aG0gZm9yICdwbGFjaW5nJyB0aGUgZWxlbWVudHMgb2YgYSBzbGljZSBpbnRvIGEgZ2FwOlxuLy9cbi8vIFdlIGNvbnNpZGVyIHRoZSBjb250ZW50IG9mIGVhY2ggbm9kZSB0aGF0IGlzIG9wZW4gdG8gdGhlIGxlZnQgdG8gYmVcbi8vIGluZGVwZW5kZW50bHkgcGxhY2VhYmxlLiBJLmUuIGluIDxwKFwiZm9vXCIpLCBwKFwiYmFyXCIpPiwgd2hlbiB0aGVcbi8vIHBhcmFncmFwaCBvbiB0aGUgbGVmdCBpcyBvcGVuLCBcImZvb1wiIGNhbiBiZSBwbGFjZWQgKHNvbWV3aGVyZSBvblxuLy8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQgZ2FwKSBpbmRlcGVuZGVudGx5IGZyb20gcChcImJhclwiKS5cbi8vXG4vLyBUaGlzIGNsYXNzIHRyYWNrcyB0aGUgc3RhdGUgb2YgdGhlIHBsYWNlbWVudCBwcm9ncmVzcyBpbiB0aGVcbi8vIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuLy9cbi8vICAtIGBmcm9udGllcmAgaG9sZHMgYSBzdGFjayBvZiBge3R5cGUsIG1hdGNofWAgb2JqZWN0cyB0aGF0XG4vLyAgICByZXByZXNlbnQgdGhlIG9wZW4gc2lkZSBvZiB0aGUgcmVwbGFjZW1lbnQuIEl0IHN0YXJ0cyBhdFxuLy8gICAgYCRmcm9tYCwgdGhlbiBtb3ZlcyBmb3J3YXJkIGFzIGNvbnRlbnQgaXMgcGxhY2VkLCBhbmQgaXMgZmluYWxseVxuLy8gICAgcmVjb25jaWxlZCB3aXRoIGAkdG9gLlxuLy9cbi8vICAtIGB1bnBsYWNlZGAgaXMgYSBzbGljZSB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRlbnQgdGhhdCBoYXNuJ3Rcbi8vICAgIGJlZW4gcGxhY2VkIHlldC5cbi8vXG4vLyAgLSBgcGxhY2VkYCBpcyBhIGZyYWdtZW50IG9mIHBsYWNlZCBjb250ZW50LiBJdHMgb3Blbi1zdGFydCB2YWx1ZVxuLy8gICAgaXMgaW1wbGljaXQgaW4gYCRmcm9tYCwgYW5kIGl0cyBvcGVuLWVuZCB2YWx1ZSBpbiBgZnJvbnRpZXJgLlxuY2xhc3MgRml0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigkZnJvbSwgJHRvLCB1bnBsYWNlZCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gdW5wbGFjZWQ7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gJGZyb20uZGVwdGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSAkZnJvbS5ub2RlKGkpO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgbWF0Y2g6IG5vZGUuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcihpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAkZnJvbS5kZXB0aDsgaSA+IDA7IGktLSlcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gRnJhZ21lbnQuZnJvbSgkZnJvbS5ub2RlKGkpLmNvcHkodGhpcy5wbGFjZWQpKTtcbiAgICB9XG4gICAgZ2V0IGRlcHRoKCkgeyByZXR1cm4gdGhpcy5mcm9udGllci5sZW5ndGggLSAxOyB9XG4gICAgZml0KCkge1xuICAgICAgICAvLyBBcyBsb25nIGFzIHRoZXJlJ3MgdW5wbGFjZWQgY29udGVudCwgdHJ5IHRvIHBsYWNlIHNvbWUgb2YgaXQuXG4gICAgICAgIC8vIElmIHRoYXQgZmFpbHMsIGVpdGhlciBpbmNyZWFzZSB0aGUgb3BlbiBzY29yZSBvZiB0aGUgdW5wbGFjZWRcbiAgICAgICAgLy8gc2xpY2UsIG9yIGRyb3Agbm9kZXMgZnJvbSBpdCwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgICB3aGlsZSAodGhpcy51bnBsYWNlZC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgZml0ID0gdGhpcy5maW5kRml0dGFibGUoKTtcbiAgICAgICAgICAgIGlmIChmaXQpXG4gICAgICAgICAgICAgICAgdGhpcy5wbGFjZU5vZGVzKGZpdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuTW9yZSgpIHx8IHRoaXMuZHJvcE5vZGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHRoZXJlJ3MgaW5saW5lIGNvbnRlbnQgZGlyZWN0bHkgYWZ0ZXIgdGhlIGZyb250aWVyIF9hbmRfXG4gICAgICAgIC8vIGRpcmVjdGx5IGFmdGVyIGB0aGlzLiR0b2AsIHdlIG11c3QgZ2VuZXJhdGUgYSBgUmVwbGFjZUFyb3VuZGBcbiAgICAgICAgLy8gc3RlcCB0aGF0IHB1bGxzIHRoYXQgY29udGVudCBpbnRvIHRoZSBub2RlIGFmdGVyIHRoZSBmcm9udGllci5cbiAgICAgICAgLy8gVGhhdCBtZWFucyB0aGUgZml0dGluZyBtdXN0IGJlIGRvbmUgdG8gdGhlIGVuZCBvZiB0aGUgdGV4dGJsb2NrXG4gICAgICAgIC8vIG5vZGUgYWZ0ZXIgYHRoaXMuJHRvYCwgbm90IGB0aGlzLiR0b2AgaXRzZWxmLlxuICAgICAgICBsZXQgbW92ZUlubGluZSA9IHRoaXMubXVzdE1vdmVJbmxpbmUoKSwgcGxhY2VkU2l6ZSA9IHRoaXMucGxhY2VkLnNpemUgLSB0aGlzLmRlcHRoIC0gdGhpcy4kZnJvbS5kZXB0aDtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy4kZnJvbSwgJHRvID0gdGhpcy5jbG9zZShtb3ZlSW5saW5lIDwgMCA/IHRoaXMuJHRvIDogJGZyb20uZG9jLnJlc29sdmUobW92ZUlubGluZSkpO1xuICAgICAgICBpZiAoISR0bylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyBJZiBjbG9zaW5nIHRvIGAkdG9gIHN1Y2NlZWRlZCwgY3JlYXRlIGEgc3RlcFxuICAgICAgICBsZXQgY29udGVudCA9IHRoaXMucGxhY2VkLCBvcGVuU3RhcnQgPSAkZnJvbS5kZXB0aCwgb3BlbkVuZCA9ICR0by5kZXB0aDtcbiAgICAgICAgd2hpbGUgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmIGNvbnRlbnQuY2hpbGRDb3VudCA9PSAxKSB7IC8vIE5vcm1hbGl6ZSBieSBkcm9wcGluZyBvcGVuIHBhcmVudCBub2Rlc1xuICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgICAgICAgICAgb3BlblN0YXJ0LS07XG4gICAgICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGlmIChtb3ZlSW5saW5lID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKCRmcm9tLnBvcywgbW92ZUlubGluZSwgdGhpcy4kdG8ucG9zLCB0aGlzLiR0by5lbmQoKSwgc2xpY2UsIHBsYWNlZFNpemUpO1xuICAgICAgICBpZiAoc2xpY2Uuc2l6ZSB8fCAkZnJvbS5wb3MgIT0gdGhpcy4kdG8ucG9zKSAvLyBEb24ndCBnZW5lcmF0ZSBuby1vcCBzdGVwc1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcCgkZnJvbS5wb3MsICR0by5wb3MsIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBwb3NpdGlvbiBvbiB0aGUgc3RhcnQgc3BpbmUgb2YgYHRoaXMudW5wbGFjZWRgIHRoYXQgaGFzXG4gICAgLy8gY29udGVudCB0aGF0IGNhbiBiZSBtb3ZlZCBzb21ld2hlcmUgb24gdGhlIGZyb250aWVyLiBSZXR1cm5zIHR3b1xuICAgIC8vIGRlcHRocywgb25lIGZvciB0aGUgc2xpY2UgYW5kIG9uZSBmb3IgdGhlIGZyb250aWVyLlxuICAgIGZpbmRGaXR0YWJsZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0RGVwdGggPSB0aGlzLnVucGxhY2VkLm9wZW5TdGFydDtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gdGhpcy51bnBsYWNlZC5jb250ZW50LCBkID0gMCwgb3BlbkVuZCA9IHRoaXMudW5wbGFjZWQub3BlbkVuZDsgZCA8IHN0YXJ0RGVwdGg7IGQrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGlmIChjdXIuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgb3BlbkVuZCA9IDA7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nICYmIG9wZW5FbmQgPD0gZCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIE9ubHkgdHJ5IHdyYXBwaW5nIG5vZGVzIChwYXNzIDIpIGFmdGVyIGZpbmRpbmcgYSBwbGFjZSB3aXRob3V0XG4gICAgICAgIC8vIHdyYXBwaW5nIGZhaWxlZC5cbiAgICAgICAgZm9yIChsZXQgcGFzcyA9IDE7IHBhc3MgPD0gMjsgcGFzcysrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBzbGljZURlcHRoID0gcGFzcyA9PSAxID8gc3RhcnREZXB0aCA6IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0OyBzbGljZURlcHRoID49IDA7IHNsaWNlRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgIGxldCBmcmFnbWVudCwgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoc2xpY2VEZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBjb250ZW50QXQodGhpcy51bnBsYWNlZC5jb250ZW50LCBzbGljZURlcHRoIC0gMSkuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy51bnBsYWNlZC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGZyb250aWVyRGVwdGggPSB0aGlzLmRlcHRoOyBmcm9udGllckRlcHRoID49IDA7IGZyb250aWVyRGVwdGgtLSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB0eXBlLCBtYXRjaCB9ID0gdGhpcy5mcm9udGllcltmcm9udGllckRlcHRoXSwgd3JhcCwgaW5qZWN0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAxLCBpZiB0aGUgbmV4dCBub2RlIG1hdGNoZXMsIG9yIHRoZXJlIGlzIG5vIG5leHRcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9kZSBidXQgdGhlIHBhcmVudHMgbG9vayBjb21wYXRpYmxlLCB3ZSd2ZSBmb3VuZCBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFzcyA9PSAxICYmIChmaXJzdCA/IG1hdGNoLm1hdGNoVHlwZShmaXJzdC50eXBlKSB8fCAoaW5qZWN0ID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKGZpcnN0KSwgZmFsc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJlbnQgJiYgdHlwZS5jb21wYXRpYmxlQ29udGVudChwYXJlbnQudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QgfTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gcGFzcyAyLCBsb29rIGZvciBhIHNldCBvZiB3cmFwcGluZyBub2RlcyB0aGF0IG1ha2VcbiAgICAgICAgICAgICAgICAgICAgLy8gYGZpcnN0YCBmaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzcyA9PSAyICYmIGZpcnN0ICYmICh3cmFwID0gbWF0Y2guZmluZFdyYXBwaW5nKGZpcnN0LnR5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgd3JhcCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBjb250aW51ZSBsb29raW5nIGZ1cnRoZXIgdXAgaWYgdGhlIHBhcmVudCBub2RlXG4gICAgICAgICAgICAgICAgICAgIC8vIHdvdWxkIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIG1hdGNoLm1hdGNoVHlwZShwYXJlbnQudHlwZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgb3Blbk1vcmUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmICghaW5uZXIuY2hpbGRDb3VudCB8fCBpbm5lci5maXJzdENoaWxkLmlzTGVhZilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShjb250ZW50LCBvcGVuU3RhcnQgKyAxLCBNYXRoLm1heChvcGVuRW5kLCBpbm5lci5zaXplICsgb3BlblN0YXJ0ID49IGNvbnRlbnQuc2l6ZSAtIG9wZW5FbmQgPyBvcGVuU3RhcnQgKyAxIDogMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZHJvcE5vZGUoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gdGhpcy51bnBsYWNlZDtcbiAgICAgICAgbGV0IGlubmVyID0gY29udGVudEF0KGNvbnRlbnQsIG9wZW5TdGFydCk7XG4gICAgICAgIGlmIChpbm5lci5jaGlsZENvdW50IDw9IDEgJiYgb3BlblN0YXJ0ID4gMCkge1xuICAgICAgICAgICAgbGV0IG9wZW5BdEVuZCA9IGNvbnRlbnQuc2l6ZSAtIG9wZW5TdGFydCA8PSBvcGVuU3RhcnQgKyBpbm5lci5zaXplO1xuICAgICAgICAgICAgdGhpcy51bnBsYWNlZCA9IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KGNvbnRlbnQsIG9wZW5TdGFydCAtIDEsIDEpLCBvcGVuU3RhcnQgLSAxLCBvcGVuQXRFbmQgPyBvcGVuU3RhcnQgLSAxIDogb3BlbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0LCAxKSwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSB0aGUgdW5wbGFjZWQgc2xpY2UgYXQgYHNsaWNlRGVwdGhgIHRvIHRoZVxuICAgIC8vIGZyb250aWVyIG5vZGUgYXQgYGZyb250aWVyRGVwdGhgLiBDbG9zZSB0aGF0IGZyb250aWVyIG5vZGUgd2hlblxuICAgIC8vIGFwcGxpY2FibGUuXG4gICAgcGxhY2VOb2Rlcyh7IHNsaWNlRGVwdGgsIGZyb250aWVyRGVwdGgsIHBhcmVudCwgaW5qZWN0LCB3cmFwIH0pIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuZGVwdGggPiBmcm9udGllckRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAod3JhcClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd3JhcC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUod3JhcFtpXSk7XG4gICAgICAgIGxldCBzbGljZSA9IHRoaXMudW5wbGFjZWQsIGZyYWdtZW50ID0gcGFyZW50ID8gcGFyZW50LmNvbnRlbnQgOiBzbGljZS5jb250ZW50O1xuICAgICAgICBsZXQgb3BlblN0YXJ0ID0gc2xpY2Uub3BlblN0YXJ0IC0gc2xpY2VEZXB0aDtcbiAgICAgICAgbGV0IHRha2VuID0gMCwgYWRkID0gW107XG4gICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdO1xuICAgICAgICBpZiAoaW5qZWN0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluamVjdC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICAgICAgYWRkLnB1c2goaW5qZWN0LmNoaWxkKGkpKTtcbiAgICAgICAgICAgIG1hdGNoID0gbWF0Y2gubWF0Y2hGcmFnbWVudChpbmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXB1dGVzIHRoZSBhbW91bnQgb2YgKGVuZCkgb3BlbiBub2RlcyBhdCB0aGUgZW5kIG9mIHRoZVxuICAgICAgICAvLyBmcmFnbWVudC4gV2hlbiAwLCB0aGUgcGFyZW50IGlzIG9wZW4sIGJ1dCBubyBtb3JlLiBXaGVuXG4gICAgICAgIC8vIG5lZ2F0aXZlLCBub3RoaW5nIGlzIG9wZW4uXG4gICAgICAgIGxldCBvcGVuRW5kQ291bnQgPSAoZnJhZ21lbnQuc2l6ZSArIHNsaWNlRGVwdGgpIC0gKHNsaWNlLmNvbnRlbnQuc2l6ZSAtIHNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAvLyBTY2FuIG92ZXIgdGhlIGZyYWdtZW50LCBmaXR0aW5nIGFzIG1hbnkgY2hpbGQgbm9kZXMgYXNcbiAgICAgICAgLy8gcG9zc2libGUuXG4gICAgICAgIHdoaWxlICh0YWtlbiA8IGZyYWdtZW50LmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZ21lbnQuY2hpbGQodGFrZW4pLCBtYXRjaGVzID0gbWF0Y2gubWF0Y2hUeXBlKG5leHQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB0YWtlbisrO1xuICAgICAgICAgICAgaWYgKHRha2VuID4gMSB8fCBvcGVuU3RhcnQgPT0gMCB8fCBuZXh0LmNvbnRlbnQuc2l6ZSkgeyAvLyBEcm9wIGVtcHR5IG9wZW4gbm9kZXNcbiAgICAgICAgICAgICAgICBtYXRjaCA9IG1hdGNoZXM7XG4gICAgICAgICAgICAgICAgYWRkLnB1c2goY2xvc2VOb2RlU3RhcnQobmV4dC5tYXJrKHR5cGUuYWxsb3dlZE1hcmtzKG5leHQubWFya3MpKSwgdGFrZW4gPT0gMSA/IG9wZW5TdGFydCA6IDAsIHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQgPyBvcGVuRW5kQ291bnQgOiAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCB0b0VuZCA9IHRha2VuID09IGZyYWdtZW50LmNoaWxkQ291bnQ7XG4gICAgICAgIGlmICghdG9FbmQpXG4gICAgICAgICAgICBvcGVuRW5kQ291bnQgPSAtMTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCBmcm9udGllckRlcHRoLCBGcmFnbWVudC5mcm9tKGFkZCkpO1xuICAgICAgICB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLm1hdGNoID0gbWF0Y2g7XG4gICAgICAgIC8vIElmIHRoZSBwYXJlbnQgdHlwZXMgbWF0Y2gsIGFuZCB0aGUgZW50aXJlIG5vZGUgd2FzIG1vdmVkLCBhbmRcbiAgICAgICAgLy8gaXQncyBub3Qgb3BlbiwgY2xvc2UgdGhpcyBmcm9udGllciBub2RlIHJpZ2h0IGF3YXkuXG4gICAgICAgIGlmICh0b0VuZCAmJiBvcGVuRW5kQ291bnQgPCAwICYmIHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLnR5cGUgJiYgdGhpcy5mcm9udGllci5sZW5ndGggPiAxKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICAvLyBBZGQgbmV3IGZyb250aWVyIG5vZGVzIGZvciBhbnkgb3BlbiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgY3VyID0gZnJhZ21lbnQ7IGkgPCBvcGVuRW5kQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBjdXIubGFzdENoaWxkO1xuICAgICAgICAgICAgdGhpcy5mcm9udGllci5wdXNoKHsgdHlwZTogbm9kZS50eXBlLCBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpIH0pO1xuICAgICAgICAgICAgY3VyID0gbm9kZS5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBgdGhpcy51bnBsYWNlZGAuIERyb3AgdGhlIGVudGlyZSBub2RlIGZyb20gd2hpY2ggd2VcbiAgICAgICAgLy8gcGxhY2VkIGl0IHdlIGdvdCB0byBpdHMgZW5kLCBvdGhlcndpc2UganVzdCBkcm9wIHRoZSBwbGFjZWRcbiAgICAgICAgLy8gbm9kZXMuXG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSAhdG9FbmQgPyBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChzbGljZS5jb250ZW50LCBzbGljZURlcHRoLCB0YWtlbiksIHNsaWNlLm9wZW5TdGFydCwgc2xpY2Uub3BlbkVuZClcbiAgICAgICAgICAgIDogc2xpY2VEZXB0aCA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxLCAxKSwgc2xpY2VEZXB0aCAtIDEsIG9wZW5FbmRDb3VudCA8IDAgPyBzbGljZS5vcGVuRW5kIDogc2xpY2VEZXB0aCAtIDEpO1xuICAgIH1cbiAgICBtdXN0TW92ZUlubGluZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLiR0by5wYXJlbnQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdLCBsZXZlbDtcbiAgICAgICAgaWYgKCF0b3AudHlwZS5pc1RleHRibG9jayB8fCAhY29udGVudEFmdGVyRml0cyh0aGlzLiR0bywgdGhpcy4kdG8uZGVwdGgsIHRvcC50eXBlLCB0b3AubWF0Y2gsIGZhbHNlKSB8fFxuICAgICAgICAgICAgKHRoaXMuJHRvLmRlcHRoID09IHRoaXMuZGVwdGggJiYgKGxldmVsID0gdGhpcy5maW5kQ2xvc2VMZXZlbCh0aGlzLiR0bykpICYmIGxldmVsLmRlcHRoID09IHRoaXMuZGVwdGgpKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBsZXQgeyBkZXB0aCB9ID0gdGhpcy4kdG8sIGFmdGVyID0gdGhpcy4kdG8uYWZ0ZXIoZGVwdGgpO1xuICAgICAgICB3aGlsZSAoZGVwdGggPiAxICYmIGFmdGVyID09IHRoaXMuJHRvLmVuZCgtLWRlcHRoKSlcbiAgICAgICAgICAgICsrYWZ0ZXI7XG4gICAgICAgIHJldHVybiBhZnRlcjtcbiAgICB9XG4gICAgZmluZENsb3NlTGV2ZWwoJHRvKSB7XG4gICAgICAgIHNjYW46IGZvciAobGV0IGkgPSBNYXRoLm1pbih0aGlzLmRlcHRoLCAkdG8uZGVwdGgpOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbaV07XG4gICAgICAgICAgICBsZXQgZHJvcElubmVyID0gaSA8ICR0by5kZXB0aCAmJiAkdG8uZW5kKGkgKyAxKSA9PSAkdG8ucG9zICsgKCR0by5kZXB0aCAtIChpICsgMSkpO1xuICAgICAgICAgICAgbGV0IGZpdCA9IGNvbnRlbnRBZnRlckZpdHMoJHRvLCBpLCB0eXBlLCBtYXRjaCwgZHJvcElubmVyKTtcbiAgICAgICAgICAgIGlmICghZml0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgZCA9IGkgLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCB7IG1hdGNoLCB0eXBlIH0gPSB0aGlzLmZyb250aWVyW2RdO1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVzID0gY29udGVudEFmdGVyRml0cygkdG8sIGQsIHR5cGUsIG1hdGNoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlcy5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgZGVwdGg6IGksIGZpdCwgbW92ZTogZHJvcElubmVyID8gJHRvLmRvYy5yZXNvbHZlKCR0by5hZnRlcihpICsgMSkpIDogJHRvIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xvc2UoJHRvKSB7XG4gICAgICAgIGxldCBjbG9zZSA9IHRoaXMuZmluZENsb3NlTGV2ZWwoJHRvKTtcbiAgICAgICAgaWYgKCFjbG9zZSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGNsb3NlLmRlcHRoKVxuICAgICAgICAgICAgdGhpcy5jbG9zZUZyb250aWVyTm9kZSgpO1xuICAgICAgICBpZiAoY2xvc2UuZml0LmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGNsb3NlLmRlcHRoLCBjbG9zZS5maXQpO1xuICAgICAgICAkdG8gPSBjbG9zZS5tb3ZlO1xuICAgICAgICBmb3IgKGxldCBkID0gY2xvc2UuZGVwdGggKyAxOyBkIDw9ICR0by5kZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGQpLCBhZGQgPSBub2RlLnR5cGUuY29udGVudE1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCAkdG8uaW5kZXgoZCkpO1xuICAgICAgICAgICAgdGhpcy5vcGVuRnJvbnRpZXJOb2RlKG5vZGUudHlwZSwgbm9kZS5hdHRycywgYWRkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJHRvO1xuICAgIH1cbiAgICBvcGVuRnJvbnRpZXJOb2RlKHR5cGUsIGF0dHJzID0gbnVsbCwgY29udGVudCkge1xuICAgICAgICBsZXQgdG9wID0gdGhpcy5mcm9udGllclt0aGlzLmRlcHRoXTtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoLm1hdGNoVHlwZSh0eXBlKTtcbiAgICAgICAgdGhpcy5wbGFjZWQgPSBhZGRUb0ZyYWdtZW50KHRoaXMucGxhY2VkLCB0aGlzLmRlcHRoLCBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGF0dHJzLCBjb250ZW50KSkpO1xuICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlLCBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2ggfSk7XG4gICAgfVxuICAgIGNsb3NlRnJvbnRpZXJOb2RlKCkge1xuICAgICAgICBsZXQgb3BlbiA9IHRoaXMuZnJvbnRpZXIucG9wKCk7XG4gICAgICAgIGxldCBhZGQgPSBvcGVuLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoYWRkLmNoaWxkQ291bnQpXG4gICAgICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZnJvbnRpZXIubGVuZ3RoLCBhZGQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyb3BGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb3VudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuY3V0QnlJbmRleChjb3VudCwgZnJhZ21lbnQuY2hpbGRDb3VudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZCgwLCBmcmFnbWVudC5maXJzdENoaWxkLmNvcHkoZHJvcEZyb21GcmFnbWVudChmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY291bnQpKSk7XG59XG5mdW5jdGlvbiBhZGRUb0ZyYWdtZW50KGZyYWdtZW50LCBkZXB0aCwgY29udGVudCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQuYXBwZW5kKGNvbnRlbnQpO1xuICAgIHJldHVybiBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoZnJhZ21lbnQuY2hpbGRDb3VudCAtIDEsIGZyYWdtZW50Lmxhc3RDaGlsZC5jb3B5KGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQubGFzdENoaWxkLmNvbnRlbnQsIGRlcHRoIC0gMSwgY29udGVudCkpKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBdChmcmFnbWVudCwgZGVwdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlcHRoOyBpKyspXG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZC5jb250ZW50O1xuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIGNsb3NlTm9kZVN0YXJ0KG5vZGUsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPD0gMClcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgbGV0IGZyYWcgPSBub2RlLmNvbnRlbnQ7XG4gICAgaWYgKG9wZW5TdGFydCA+IDEpXG4gICAgICAgIGZyYWcgPSBmcmFnLnJlcGxhY2VDaGlsZCgwLCBjbG9zZU5vZGVTdGFydChmcmFnLmZpcnN0Q2hpbGQsIG9wZW5TdGFydCAtIDEsIGZyYWcuY2hpbGRDb3VudCA9PSAxID8gb3BlbkVuZCAtIDEgOiAwKSk7XG4gICAgaWYgKG9wZW5TdGFydCA+IDApIHtcbiAgICAgICAgZnJhZyA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShmcmFnKS5hcHBlbmQoZnJhZyk7XG4gICAgICAgIGlmIChvcGVuRW5kIDw9IDApXG4gICAgICAgICAgICBmcmFnID0gZnJhZy5hcHBlbmQobm9kZS50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KGZyYWcpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGUuY29weShmcmFnKTtcbn1cbmZ1bmN0aW9uIGNvbnRlbnRBZnRlckZpdHMoJHRvLCBkZXB0aCwgdHlwZSwgbWF0Y2gsIG9wZW4pIHtcbiAgICBsZXQgbm9kZSA9ICR0by5ub2RlKGRlcHRoKSwgaW5kZXggPSBvcGVuID8gJHRvLmluZGV4QWZ0ZXIoZGVwdGgpIDogJHRvLmluZGV4KGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gbm9kZS5jaGlsZENvdW50ICYmICF0eXBlLmNvbXBhdGlibGVDb250ZW50KG5vZGUudHlwZSkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBmaXQgPSBtYXRjaC5maWxsQmVmb3JlKG5vZGUuY29udGVudCwgdHJ1ZSwgaW5kZXgpO1xuICAgIHJldHVybiBmaXQgJiYgIWludmFsaWRNYXJrcyh0eXBlLCBub2RlLmNvbnRlbnQsIGluZGV4KSA/IGZpdCA6IG51bGw7XG59XG5mdW5jdGlvbiBpbnZhbGlkTWFya3ModHlwZSwgZnJhZ21lbnQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKVxuICAgICAgICBpZiAoIXR5cGUuYWxsb3dzTWFya3MoZnJhZ21lbnQuY2hpbGQoaSkubWFya3MpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZGVmaW5lc0NvbnRlbnQodHlwZSkge1xuICAgIHJldHVybiB0eXBlLnNwZWMuZGVmaW5pbmcgfHwgdHlwZS5zcGVjLmRlZmluaW5nRm9yQ29udGVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZSh0ciwgZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgaWYgKGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpKVxuICAgICAgICByZXR1cm4gdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoZnJvbSwgdG8sIHNsaWNlKSk7XG4gICAgbGV0IHRhcmdldERlcHRocyA9IGNvdmVyZWREZXB0aHMoJGZyb20sICR0byk7XG4gICAgLy8gQ2FuJ3QgcmVwbGFjZSB0aGUgd2hvbGUgZG9jdW1lbnQsIHNvIHJlbW92ZSAwIGlmIGl0J3MgcHJlc2VudFxuICAgIGlmICh0YXJnZXREZXB0aHNbdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDFdID09IDApXG4gICAgICAgIHRhcmdldERlcHRocy5wb3AoKTtcbiAgICAvLyBOZWdhdGl2ZSBudW1iZXJzIHJlcHJlc2VudCBub3QgZXhwYW5zaW9uIG92ZXIgdGhlIHdob2xlIG5vZGUgYXRcbiAgICAvLyB0aGF0IGRlcHRoLCBidXQgcmVwbGFjaW5nIGZyb20gJGZyb20uYmVmb3JlKC1EKSB0byAkdG8ucG9zLlxuICAgIGxldCBwcmVmZXJyZWRUYXJnZXQgPSAtKCRmcm9tLmRlcHRoICsgMSk7XG4gICAgdGFyZ2V0RGVwdGhzLnVuc2hpZnQocHJlZmVycmVkVGFyZ2V0KTtcbiAgICAvLyBUaGlzIGxvb3AgcGlja3MgYSBwcmVmZXJyZWQgdGFyZ2V0IGRlcHRoLCBpZiBvbmUgb2YgdGhlIGNvdmVyaW5nXG4gICAgLy8gZGVwdGhzIGlzIG5vdCBvdXRzaWRlIG9mIGEgZGVmaW5pbmcgbm9kZSwgYW5kIGFkZHMgbmVnYXRpdmVcbiAgICAvLyBkZXB0aHMgZm9yIGFueSBkZXB0aCB0aGF0IGhhcyAkZnJvbSBhdCBpdHMgc3RhcnQgYW5kIGRvZXMgbm90XG4gICAgLy8gY3Jvc3MgYSBkZWZpbmluZyBub2RlLlxuICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCwgcG9zID0gJGZyb20ucG9zIC0gMTsgZCA+IDA7IGQtLSwgcG9zLS0pIHtcbiAgICAgICAgbGV0IHNwZWMgPSAkZnJvbS5ub2RlKGQpLnR5cGUuc3BlYztcbiAgICAgICAgaWYgKHNwZWMuZGVmaW5pbmcgfHwgc3BlYy5kZWZpbmluZ0FzQ29udGV4dCB8fCBzcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAodGFyZ2V0RGVwdGhzLmluZGV4T2YoZCkgPiAtMSlcbiAgICAgICAgICAgIHByZWZlcnJlZFRhcmdldCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLmJlZm9yZShkKSA9PSBwb3MpXG4gICAgICAgICAgICB0YXJnZXREZXB0aHMuc3BsaWNlKDEsIDAsIC1kKTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpdCBlYWNoIHBvc3NpYmxlIGRlcHRoIG9mIHRoZSBzbGljZSBpbnRvIGVhY2ggcG9zc2libGVcbiAgICAvLyB0YXJnZXQgZGVwdGgsIHN0YXJ0aW5nIHdpdGggdGhlIHByZWZlcnJlZCBkZXB0aHMuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldEluZGV4ID0gdGFyZ2V0RGVwdGhzLmluZGV4T2YocHJlZmVycmVkVGFyZ2V0KTtcbiAgICBsZXQgbGVmdE5vZGVzID0gW10sIHByZWZlcnJlZERlcHRoID0gc2xpY2Uub3BlblN0YXJ0O1xuICAgIGZvciAobGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50LCBpID0gMDs7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IGNvbnRlbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgbGVmdE5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIGlmIChpID09IHNsaWNlLm9wZW5TdGFydClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjb250ZW50ID0gbm9kZS5jb250ZW50O1xuICAgIH1cbiAgICAvLyBCYWNrIHVwIHByZWZlcnJlZERlcHRoIHRvIGNvdmVyIGRlZmluaW5nIHRleHRibG9ja3MgZGlyZWN0bHlcbiAgICAvLyBhYm92ZSBpdCwgcG9zc2libHkgc2tpcHBpbmcgYSBub24tZGVmaW5pbmcgdGV4dGJsb2NrLlxuICAgIGZvciAobGV0IGQgPSBwcmVmZXJyZWREZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBsZWZ0Tm9kZSA9IGxlZnROb2Rlc1tkXSwgZGVmID0gZGVmaW5lc0NvbnRlbnQobGVmdE5vZGUudHlwZSk7XG4gICAgICAgIGlmIChkZWYgJiYgIWxlZnROb2RlLnNhbWVNYXJrdXAoJGZyb20ubm9kZShNYXRoLmFicyhwcmVmZXJyZWRUYXJnZXQpIC0gMSkpKVxuICAgICAgICAgICAgcHJlZmVycmVkRGVwdGggPSBkO1xuICAgICAgICBlbHNlIGlmIChkZWYgfHwgIWxlZnROb2RlLnR5cGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgZm9yIChsZXQgaiA9IHNsaWNlLm9wZW5TdGFydDsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgbGV0IG9wZW5EZXB0aCA9IChqICsgcHJlZmVycmVkRGVwdGggKyAxKSAlIChzbGljZS5vcGVuU3RhcnQgKyAxKTtcbiAgICAgICAgbGV0IGluc2VydCA9IGxlZnROb2Rlc1tvcGVuRGVwdGhdO1xuICAgICAgICBpZiAoIWluc2VydClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldERlcHRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgLy8gTG9vcCBvdmVyIHBvc3NpYmxlIGV4cGFuc2lvbiBsZXZlbHMsIHN0YXJ0aW5nIHdpdGggdGhlXG4gICAgICAgICAgICAvLyBwcmVmZXJyZWQgb25lXG4gICAgICAgICAgICBsZXQgdGFyZ2V0RGVwdGggPSB0YXJnZXREZXB0aHNbKGkgKyBwcmVmZXJyZWRUYXJnZXRJbmRleCkgJSB0YXJnZXREZXB0aHMubGVuZ3RoXSwgZXhwYW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0YXJnZXREZXB0aCA8IDApIHtcbiAgICAgICAgICAgICAgICBleHBhbmQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0YXJnZXREZXB0aCA9IC10YXJnZXREZXB0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5ub2RlKHRhcmdldERlcHRoIC0gMSksIGluZGV4ID0gJGZyb20uaW5kZXgodGFyZ2V0RGVwdGggLSAxKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBpbnNlcnQudHlwZSwgaW5zZXJ0Lm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHIucmVwbGFjZSgkZnJvbS5iZWZvcmUodGFyZ2V0RGVwdGgpLCBleHBhbmQgPyAkdG8uYWZ0ZXIodGFyZ2V0RGVwdGgpIDogdG8sIG5ldyBTbGljZShjbG9zZUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIDAsIHNsaWNlLm9wZW5TdGFydCwgb3BlbkRlcHRoKSwgb3BlbkRlcHRoLCBzbGljZS5vcGVuRW5kKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0YXJ0U3RlcHMgPSB0ci5zdGVwcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IHRhcmdldERlcHRocy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB0ci5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmICh0ci5zdGVwcy5sZW5ndGggPiBzdGFydFN0ZXBzKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkZXB0aCA9IHRhcmdldERlcHRoc1tpXTtcbiAgICAgICAgaWYgKGRlcHRoIDwgMClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmcm9tID0gJGZyb20uYmVmb3JlKGRlcHRoKTtcbiAgICAgICAgdG8gPSAkdG8uYWZ0ZXIoZGVwdGgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsb3NlRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBvbGRPcGVuLCBuZXdPcGVuLCBwYXJlbnQpIHtcbiAgICBpZiAoZGVwdGggPCBvbGRPcGVuKSB7XG4gICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZpcnN0LmNvcHkoY2xvc2VGcmFnbWVudChmaXJzdC5jb250ZW50LCBkZXB0aCArIDEsIG9sZE9wZW4sIG5ld09wZW4sIGZpcnN0KSkpO1xuICAgIH1cbiAgICBpZiAoZGVwdGggPiBuZXdPcGVuKSB7XG4gICAgICAgIGxldCBtYXRjaCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdCgwKTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gbWF0Y2guZmlsbEJlZm9yZShmcmFnbWVudCkuYXBwZW5kKGZyYWdtZW50KTtcbiAgICAgICAgZnJhZ21lbnQgPSBzdGFydC5hcHBlbmQobWF0Y2gubWF0Y2hGcmFnbWVudChzdGFydCkuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5mdW5jdGlvbiByZXBsYWNlUmFuZ2VXaXRoKHRyLCBmcm9tLCB0bywgbm9kZSkge1xuICAgIGlmICghbm9kZS5pc0lubGluZSAmJiBmcm9tID09IHRvICYmIHRyLmRvYy5yZXNvbHZlKGZyb20pLnBhcmVudC5jb250ZW50LnNpemUpIHtcbiAgICAgICAgbGV0IHBvaW50ID0gaW5zZXJ0UG9pbnQodHIuZG9jLCBmcm9tLCBub2RlLnR5cGUpO1xuICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgIGZyb20gPSB0byA9IHBvaW50O1xuICAgIH1cbiAgICB0ci5yZXBsYWNlUmFuZ2UoZnJvbSwgdG8sIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKG5vZGUpLCAwLCAwKSk7XG59XG5mdW5jdGlvbiBkZWxldGVSYW5nZSh0ciwgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSB0ci5kb2MucmVzb2x2ZShmcm9tKSwgJHRvID0gdHIuZG9jLnJlc29sdmUodG8pO1xuICAgIGxldCBjb3ZlcmVkID0gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdmVyZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlcHRoID0gY292ZXJlZFtpXSwgbGFzdCA9IGkgPT0gY292ZXJlZC5sZW5ndGggLSAxO1xuICAgICAgICBpZiAoKGxhc3QgJiYgZGVwdGggPT0gMCkgfHwgJGZyb20ubm9kZShkZXB0aCkudHlwZS5jb250ZW50TWF0Y2gudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gdHIuZGVsZXRlKCRmcm9tLnN0YXJ0KGRlcHRoKSwgJHRvLmVuZChkZXB0aCkpO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIChsYXN0IHx8ICRmcm9tLm5vZGUoZGVwdGggLSAxKS5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KGRlcHRoIC0gMSksICR0by5pbmRleEFmdGVyKGRlcHRoIC0gMSkpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGRlcHRoKSwgJHRvLmFmdGVyKGRlcHRoKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGQgPSAxOyBkIDw9ICRmcm9tLmRlcHRoICYmIGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgaWYgKGZyb20gLSAkZnJvbS5zdGFydChkKSA9PSAkZnJvbS5kZXB0aCAtIGQgJiYgdG8gPiAkZnJvbS5lbmQoZCkgJiYgJHRvLmVuZChkKSAtIHRvICE9ICR0by5kZXB0aCAtIGQgJiZcbiAgICAgICAgICAgICRmcm9tLnN0YXJ0KGQgLSAxKSA9PSAkdG8uc3RhcnQoZCAtIDEpICYmICRmcm9tLm5vZGUoZCAtIDEpLmNhblJlcGxhY2UoJGZyb20uaW5kZXgoZCAtIDEpLCAkdG8uaW5kZXgoZCAtIDEpKSlcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uYmVmb3JlKGQpLCB0byk7XG4gICAgfVxuICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XG59XG4vLyBSZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBkZXB0aHMgZm9yIHdoaWNoICRmcm9tIC0gJHRvIHNwYW5zIHRoZVxuLy8gd2hvbGUgY29udGVudCBvZiB0aGUgbm9kZXMgYXQgdGhhdCBkZXB0aC5cbmZ1bmN0aW9uIGNvdmVyZWREZXB0aHMoJGZyb20sICR0bykge1xuICAgIGxldCByZXN1bHQgPSBbXSwgbWluRGVwdGggPSBNYXRoLm1pbigkZnJvbS5kZXB0aCwgJHRvLmRlcHRoKTtcbiAgICBmb3IgKGxldCBkID0gbWluRGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGQpO1xuICAgICAgICBpZiAoc3RhcnQgPCAkZnJvbS5wb3MgLSAoJGZyb20uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJHRvLmVuZChkKSA+ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gZCkgfHxcbiAgICAgICAgICAgICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZyB8fFxuICAgICAgICAgICAgJHRvLm5vZGUoZCkudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoc3RhcnQgPT0gJHRvLnN0YXJ0KGQpIHx8XG4gICAgICAgICAgICAoZCA9PSAkZnJvbS5kZXB0aCAmJiBkID09ICR0by5kZXB0aCAmJiAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCAmJiAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQgJiZcbiAgICAgICAgICAgICAgICBkICYmICR0by5zdGFydChkIC0gMSkgPT0gc3RhcnQgLSAxKSlcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcblVwZGF0ZSBhbiBhdHRyaWJ1dGUgaW4gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEF0dHJTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGFuIGF0dHJpYnV0ZSBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZSB0byBzZXQuXG4gICAgKi9cbiAgICBhdHRyLCBcbiAgICAvLyBUaGUgYXR0cmlidXRlJ3MgbmV3IHZhbHVlLlxuICAgIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgbm9kZSA9IGRvYy5ub2RlQXQodGhpcy5wb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiTm8gbm9kZSBhdCBhdHRyaWJ1dGUgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIG5vZGUuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IG5vZGUuYXR0cnNbbmFtZV07XG4gICAgICAgIGF0dHJzW3RoaXMuYXR0cl0gPSB0aGlzLnZhbHVlO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUoYXR0cnMsIG51bGwsIG5vZGUubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcCh0aGlzLnBvcywgdGhpcy5hdHRyLCBkb2Mubm9kZUF0KHRoaXMucG9zKS5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IEF0dHJTdGVwKHBvcy5wb3MsIHRoaXMuYXR0ciwgdGhpcy52YWx1ZSk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiYXR0clwiLCBwb3M6IHRoaXMucG9zLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQXR0clN0ZXAoanNvbi5wb3MsIGpzb24uYXR0ciwganNvbi52YWx1ZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJhdHRyXCIsIEF0dHJTdGVwKTtcbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiB0aGUgZG9jIG5vZGUuXG4qL1xuY2xhc3MgRG9jQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5hdHRyID0gYXR0cjtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IGF0dHJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBkb2MuYXR0cnMpXG4gICAgICAgICAgICBhdHRyc1tuYW1lXSA9IGRvYy5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gZG9jLnR5cGUuY3JlYXRlKGF0dHJzLCBkb2MuY29udGVudCwgZG9jLm1hcmtzKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQub2sodXBkYXRlZCk7XG4gICAgfVxuICAgIGdldE1hcCgpIHtcbiAgICAgICAgcmV0dXJuIFN0ZXBNYXAuZW1wdHk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcCh0aGlzLmF0dHIsIGRvYy5hdHRyc1t0aGlzLmF0dHJdKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgc3RlcFR5cGU6IFwiZG9jQXR0clwiLCBhdHRyOiB0aGlzLmF0dHIsIHZhbHVlOiB0aGlzLnZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLmF0dHIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgRG9jQXR0clN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgRG9jQXR0clN0ZXAoanNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImRvY0F0dHJcIiwgRG9jQXR0clN0ZXApO1xuXG4vKipcbkBpbnRlcm5hbFxuKi9cbmxldCBUcmFuc2Zvcm1FcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xufTtcblRyYW5zZm9ybUVycm9yID0gZnVuY3Rpb24gVHJhbnNmb3JtRXJyb3IobWVzc2FnZSkge1xuICAgIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIGVyci5fX3Byb3RvX18gPSBUcmFuc2Zvcm1FcnJvci5wcm90b3R5cGU7XG4gICAgcmV0dXJuIGVycjtcbn07XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5UcmFuc2Zvcm1FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2Zvcm1FcnJvcjtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5uYW1lID0gXCJUcmFuc2Zvcm1FcnJvclwiO1xuLyoqXG5BYnN0cmFjdGlvbiB0byBidWlsZCB1cCBhbmQgdHJhY2sgYW4gYXJyYXkgb2ZcbltzdGVwc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSByZXByZXNlbnRpbmcgYSBkb2N1bWVudCB0cmFuc2Zvcm1hdGlvbi5cblxuTW9zdCB0cmFuc2Zvcm1pbmcgbWV0aG9kcyByZXR1cm4gdGhlIGBUcmFuc2Zvcm1gIG9iamVjdCBpdHNlbGYsIHNvXG50aGF0IHRoZXkgY2FuIGJlIGNoYWluZWQuXG4qL1xuY2xhc3MgVHJhbnNmb3JtIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0cmFuc2Zvcm0gdGhhdCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBkb2N1bWVudCAodGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgc3RlcHMgaW4gdGhlXG4gICAgdHJhbnNmb3JtKS5cbiAgICAqL1xuICAgIGRvYykge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBzdGVwcyBpbiB0aGlzIHRyYW5zZm9ybS5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGVwcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGRvY3VtZW50cyBiZWZvcmUgZWFjaCBvZiB0aGUgc3RlcHMuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZG9jcyA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQSBtYXBwaW5nIHdpdGggdGhlIG1hcHMgZm9yIGVhY2ggb2YgdGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0aW5nIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IGJlZm9yZSgpIHsgcmV0dXJuIHRoaXMuZG9jcy5sZW5ndGggPyB0aGlzLmRvY3NbMF0gOiB0aGlzLmRvYzsgfVxuICAgIC8qKlxuICAgIEFwcGx5IGEgbmV3IHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm0sIHNhdmluZyB0aGUgcmVzdWx0LiBUaHJvd3MgYW5cbiAgICBlcnJvciB3aGVuIHRoZSBzdGVwIGZhaWxzLlxuICAgICovXG4gICAgc3RlcChzdGVwKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzLm1heWJlU3RlcChzdGVwKTtcbiAgICAgICAgaWYgKHJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNmb3JtRXJyb3IocmVzdWx0LmZhaWxlZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gYXBwbHkgYSBzdGVwIGluIHRoaXMgdHJhbnNmb3JtYXRpb24sIGlnbm9yaW5nIGl0IGlmIGl0XG4gICAgZmFpbHMuIFJldHVybnMgdGhlIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgbWF5YmVTdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0ZXAuYXBwbHkodGhpcy5kb2MpO1xuICAgICAgICBpZiAoIXJlc3VsdC5mYWlsZWQpXG4gICAgICAgICAgICB0aGlzLmFkZFN0ZXAoc3RlcCwgcmVzdWx0LmRvYyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gY2hhbmdlZCAod2hlbiB0aGVyZSBhcmUgYW55XG4gICAgc3RlcHMpLlxuICAgICovXG4gICAgZ2V0IGRvY0NoYW5nZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZXBzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgYWRkU3RlcChzdGVwLCBkb2MpIHtcbiAgICAgICAgdGhpcy5kb2NzLnB1c2godGhpcy5kb2MpO1xuICAgICAgICB0aGlzLnN0ZXBzLnB1c2goc3RlcCk7XG4gICAgICAgIHRoaXMubWFwcGluZy5hcHBlbmRNYXAoc3RlcC5nZXRNYXAoKSk7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB3aXRoIHRoZVxuICAgIGdpdmVuIGBzbGljZWAuXG4gICAgKi9cbiAgICByZXBsYWNlKGZyb20sIHRvID0gZnJvbSwgc2xpY2UgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHRoaXMuZG9jLCBmcm9tLCB0bywgc2xpY2UpO1xuICAgICAgICBpZiAoc3RlcClcbiAgICAgICAgICAgIHRoaXMuc3RlcChzdGVwKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQsIHdoaWNoIG1heSBiZSBhXG4gICAgZnJhZ21lbnQsIG5vZGUsIG9yIGFycmF5IG9mIG5vZGVzLlxuICAgICovXG4gICAgcmVwbGFjZVdpdGgoZnJvbSwgdG8sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oY29udGVudCksIDAsIDApKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGRlbGV0ZShmcm9tLCB0bykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBTbGljZS5lbXB0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEluc2VydCB0aGUgZ2l2ZW4gY29udGVudCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBpbnNlcnQocG9zLCBjb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2VXaXRoKHBvcywgcG9zLCBjb250ZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSBhIHJhbmdlIG9mIHRoZSBkb2N1bWVudCB3aXRoIGEgZ2l2ZW4gc2xpY2UsIHVzaW5nXG4gICAgYGZyb21gLCBgdG9gLCBhbmQgdGhlIHNsaWNlJ3NcbiAgICBbYG9wZW5TdGFydGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5TbGljZS5vcGVuU3RhcnQpIHByb3BlcnR5IGFzIGhpbnRzLCByYXRoZXJcbiAgICB0aGFuIGZpeGVkIHN0YXJ0IGFuZCBlbmQgcG9pbnRzLiBUaGlzIG1ldGhvZCBtYXkgZ3JvdyB0aGVcbiAgICByZXBsYWNlZCBhcmVhIG9yIGNsb3NlIG9wZW4gbm9kZXMgaW4gdGhlIHNsaWNlIGluIG9yZGVyIHRvIGdldCBhXG4gICAgZml0IHRoYXQgaXMgbW9yZSBpbiBsaW5lIHdpdGggV1lTSVdZRyBleHBlY3RhdGlvbnMsIGJ5IGRyb3BwaW5nXG4gICAgZnVsbHkgY292ZXJlZCBwYXJlbnQgbm9kZXMgb2YgdGhlIHJlcGxhY2VkIHJlZ2lvbiB3aGVuIHRoZXkgYXJlXG4gICAgbWFya2VkIFtub24tZGVmaW5pbmcgYXNcbiAgICBjb250ZXh0XShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuZGVmaW5pbmdBc0NvbnRleHQpLCBvciBpbmNsdWRpbmcgYW5cbiAgICBvcGVuIHBhcmVudCBub2RlIGZyb20gdGhlIHNsaWNlIHRoYXQgX2lzXyBtYXJrZWQgYXMgW2RlZmluaW5nXG4gICAgaXRzIGNvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0ZvckNvbnRlbnQpLlxuICAgIFxuICAgIFRoaXMgaXMgdGhlIG1ldGhvZCwgZm9yIGV4YW1wbGUsIHRvIGhhbmRsZSBwYXN0ZS4gVGhlIHNpbWlsYXJcbiAgICBbYHJlcGxhY2VgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlRyYW5zZm9ybS5yZXBsYWNlKSBtZXRob2QgaXMgYSBtb3JlXG4gICAgcHJpbWl0aXZlIHRvb2wgd2hpY2ggd2lsbCBfbm90XyBtb3ZlIHRoZSBzdGFydCBhbmQgZW5kIG9mIGl0cyBnaXZlblxuICAgIHJhbmdlLCBhbmQgaXMgdXNlZnVsIGluIHNpdHVhdGlvbnMgd2hlcmUgeW91IG5lZWQgbW9yZSBwcmVjaXNlXG4gICAgY29udHJvbCBvdmVyIHdoYXQgaGFwcGVucy5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZShmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlKHRoaXMsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSB3aXRoIGEgbm9kZSwgYnV0IHVzZSBgZnJvbWAgYW5kIGB0b2AgYXNcbiAgICBoaW50cywgcmF0aGVyIHRoYW4gcHJlY2lzZSBwb3NpdGlvbnMuIFdoZW4gZnJvbSBhbmQgdG8gYXJlIHRoZSBzYW1lXG4gICAgYW5kIGFyZSBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGEgcGFyZW50IG5vZGUgaW4gd2hpY2ggdGhlIGdpdmVuXG4gICAgbm9kZSBkb2Vzbid0IGZpdCwgdGhpcyBtZXRob2QgbWF5IF9tb3ZlXyB0aGVtIG91dCB0b3dhcmRzIGEgcGFyZW50XG4gICAgdGhhdCBkb2VzIGFsbG93IHRoZSBnaXZlbiBub2RlIHRvIGJlIHBsYWNlZC4gV2hlbiB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICBjb21wbGV0ZWx5IGNvdmVycyBhIHBhcmVudCBub2RlLCB0aGlzIG1ldGhvZCBtYXkgY29tcGxldGVseSByZXBsYWNlXG4gICAgdGhhdCBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIHJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIG5vZGUpIHtcbiAgICAgICAgcmVwbGFjZVJhbmdlV2l0aCh0aGlzLCBmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGdpdmVuIHJhbmdlLCBleHBhbmRpbmcgaXQgdG8gY292ZXIgZnVsbHkgY292ZXJlZFxuICAgIHBhcmVudCBub2RlcyB1bnRpbCBhIHZhbGlkIHJlcGxhY2UgaXMgZm91bmQuXG4gICAgKi9cbiAgICBkZWxldGVSYW5nZShmcm9tLCB0bykge1xuICAgICAgICBkZWxldGVSYW5nZSh0aGlzLCBmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTcGxpdCB0aGUgY29udGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2Ugb2ZmIGZyb20gaXRzIHBhcmVudCwgaWYgdGhlcmVcbiAgICBpcyBzaWJsaW5nIGNvbnRlbnQgYmVmb3JlIG9yIGFmdGVyIGl0LCBhbmQgbW92ZSBpdCB1cCB0aGUgdHJlZSB0b1xuICAgIHRoZSBkZXB0aCBzcGVjaWZpZWQgYnkgYHRhcmdldGAuIFlvdSdsbCBwcm9iYWJseSB3YW50IHRvIHVzZVxuICAgIFtgbGlmdFRhcmdldGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0ubGlmdFRhcmdldCkgdG8gY29tcHV0ZSBgdGFyZ2V0YCwgdG8gbWFrZVxuICAgIHN1cmUgdGhlIGxpZnQgaXMgdmFsaWQuXG4gICAgKi9cbiAgICBsaWZ0KHJhbmdlLCB0YXJnZXQpIHtcbiAgICAgICAgbGlmdCh0aGlzLCByYW5nZSwgdGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEpvaW4gdGhlIGJsb2NrcyBhcm91bmQgdGhlIGdpdmVuIHBvc2l0aW9uLiBJZiBkZXB0aCBpcyAyLCB0aGVpclxuICAgIGxhc3QgYW5kIGZpcnN0IHNpYmxpbmdzIGFyZSBhbHNvIGpvaW5lZCwgYW5kIHNvIG9uLlxuICAgICovXG4gICAgam9pbihwb3MsIGRlcHRoID0gMSkge1xuICAgICAgICBqb2luKHRoaXMsIHBvcywgZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgV3JhcCB0aGUgZ2l2ZW4gW3JhbmdlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVJhbmdlKSBpbiB0aGUgZ2l2ZW4gc2V0IG9mIHdyYXBwZXJzLlxuICAgIFRoZSB3cmFwcGVycyBhcmUgYXNzdW1lZCB0byBiZSB2YWxpZCBpbiB0aGlzIHBvc2l0aW9uLCBhbmQgc2hvdWxkXG4gICAgcHJvYmFibHkgYmUgY29tcHV0ZWQgd2l0aCBbYGZpbmRXcmFwcGluZ2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uZmluZFdyYXBwaW5nKS5cbiAgICAqL1xuICAgIHdyYXAocmFuZ2UsIHdyYXBwZXJzKSB7XG4gICAgICAgIHdyYXAodGhpcywgcmFuZ2UsIHdyYXBwZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdHlwZSBvZiBhbGwgdGV4dGJsb2NrcyAocGFydGx5KSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCB0b1xuICAgIHRoZSBnaXZlbiBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIHNldEJsb2NrVHlwZShmcm9tLCB0byA9IGZyb20sIHR5cGUsIGF0dHJzID0gbnVsbCkge1xuICAgICAgICBzZXRCbG9ja1R5cGUodGhpcywgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIENoYW5nZSB0aGUgdHlwZSwgYXR0cmlidXRlcywgYW5kL29yIG1hcmtzIG9mIHRoZSBub2RlIGF0IGBwb3NgLlxuICAgIFdoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiAgICAqL1xuICAgIHNldE5vZGVNYXJrdXAocG9zLCB0eXBlLCBhdHRycyA9IG51bGwsIG1hcmtzKSB7XG4gICAgICAgIHNldE5vZGVNYXJrdXAodGhpcywgcG9zLCB0eXBlLCBhdHRycywgbWFya3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiBhIGdpdmVuIG5vZGUgdG8gYSBuZXcgdmFsdWUuXG4gICAgVGhlIGBwb3NgIGFkZHJlc3NlcyB0aGUgZG9jdW1lbnQgY29udGVudC4gVXNlIGBzZXREb2NBdHRyaWJ1dGVgXG4gICAgdG8gc2V0IGF0dHJpYnV0ZXMgb24gdGhlIGRvY3VtZW50IGl0c2VsZi5cbiAgICAqL1xuICAgIHNldE5vZGVBdHRyaWJ1dGUocG9zLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEF0dHJTdGVwKHBvcywgYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCBhIHNpbmdsZSBhdHRyaWJ1dGUgb24gdGhlIGRvY3VtZW50IHRvIGEgbmV3IHZhbHVlLlxuICAgICovXG4gICAgc2V0RG9jQXR0cmlidXRlKGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgRG9jQXR0clN0ZXAoYXR0ciwgdmFsdWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhIG1hcmsgdG8gdGhlIG5vZGUgYXQgcG9zaXRpb24gYHBvc2AuXG4gICAgKi9cbiAgICBhZGROb2RlTWFyayhwb3MsIG1hcmspIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIChvciBhbGwgbWFya3Mgb2YgdGhlIGdpdmVuIHR5cGUpIGZyb20gdGhlIG5vZGUgYXRcbiAgICBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIHJlbW92ZU5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuZG9jLm5vZGVBdChwb3MpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYXQgcG9zaXRpb24gXCIgKyBwb3MpO1xuICAgICAgICBpZiAobWFyayBpbnN0YW5jZW9mIE1hcmspIHtcbiAgICAgICAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwKG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAocG9zLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgc2V0ID0gbm9kZS5tYXJrcywgZm91bmQsIHN0ZXBzID0gW107XG4gICAgICAgICAgICB3aGlsZSAoZm91bmQgPSBtYXJrLmlzSW5TZXQoc2V0KSkge1xuICAgICAgICAgICAgICAgIHN0ZXBzLnB1c2gobmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MsIGZvdW5kKSk7XG4gICAgICAgICAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0ZXBzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMuc3RlcChzdGVwc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBub2RlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYW5kIG9wdGlvbmFsbHksIGlmIGBkZXB0aGAgaXNcbiAgICBncmVhdGVyIHRoYW4gb25lLCBhbnkgbnVtYmVyIG9mIG5vZGVzIGFib3ZlIHRoYXQuIEJ5IGRlZmF1bHQsIHRoZVxuICAgIHBhcnRzIHNwbGl0IG9mZiB3aWxsIGluaGVyaXQgdGhlIG5vZGUgdHlwZSBvZiB0aGUgb3JpZ2luYWwgbm9kZS5cbiAgICBUaGlzIGNhbiBiZSBjaGFuZ2VkIGJ5IHBhc3NpbmcgYW4gYXJyYXkgb2YgdHlwZXMgYW5kIGF0dHJpYnV0ZXMgdG9cbiAgICB1c2UgYWZ0ZXIgdGhlIHNwbGl0ICh3aXRoIHRoZSBvdXRlcm1vc3Qgbm9kZXMgY29taW5nIGZpcnN0KS5cbiAgICAqL1xuICAgIHNwbGl0KHBvcywgZGVwdGggPSAxLCB0eXBlc0FmdGVyKSB7XG4gICAgICAgIHNwbGl0KHRoaXMsIHBvcywgZGVwdGgsIHR5cGVzQWZ0ZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBtYXJrIHRvIHRoZSBpbmxpbmUgY29udGVudCBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC5cbiAgICAqL1xuICAgIGFkZE1hcmsoZnJvbSwgdG8sIG1hcmspIHtcbiAgICAgICAgYWRkTWFyayh0aGlzLCBmcm9tLCB0bywgbWFyayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgbWFya3MgZnJvbSBpbmxpbmUgbm9kZXMgYmV0d2VlbiBgZnJvbWAgYW5kIGB0b2AuIFdoZW5cbiAgICBgbWFya2AgaXMgYSBzaW5nbGUgbWFyaywgcmVtb3ZlIHByZWNpc2VseSB0aGF0IG1hcmsuIFdoZW4gaXQgaXNcbiAgICBhIG1hcmsgdHlwZSwgcmVtb3ZlIGFsbCBtYXJrcyBvZiB0aGF0IHR5cGUuIFdoZW4gaXQgaXMgbnVsbCxcbiAgICByZW1vdmUgYWxsIG1hcmtzIG9mIGFueSB0eXBlLlxuICAgICovXG4gICAgcmVtb3ZlTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICByZW1vdmVNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgYWxsIG1hcmtzIGFuZCBub2RlcyBmcm9tIHRoZSBjb250ZW50IG9mIHRoZSBub2RlIGF0XG4gICAgYHBvc2AgdGhhdCBkb24ndCBtYXRjaCB0aGUgZ2l2ZW4gbmV3IHBhcmVudCBub2RlIHR5cGUuIEFjY2VwdHNcbiAgICBhbiBvcHRpb25hbCBzdGFydGluZyBbY29udGVudCBtYXRjaF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkNvbnRlbnRNYXRjaCkgYXNcbiAgICB0aGlyZCBhcmd1bWVudC5cbiAgICAqL1xuICAgIGNsZWFySW5jb21wYXRpYmxlKHBvcywgcGFyZW50VHlwZSwgbWF0Y2gpIHtcbiAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodGhpcywgcG9zLCBwYXJlbnRUeXBlLCBtYXRjaCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQWRkTWFya1N0ZXAsIEFkZE5vZGVNYXJrU3RlcCwgQXR0clN0ZXAsIERvY0F0dHJTdGVwLCBNYXBSZXN1bHQsIE1hcHBpbmcsIFJlbW92ZU1hcmtTdGVwLCBSZW1vdmVOb2RlTWFya1N0ZXAsIFJlcGxhY2VBcm91bmRTdGVwLCBSZXBsYWNlU3RlcCwgU3RlcCwgU3RlcE1hcCwgU3RlcFJlc3VsdCwgVHJhbnNmb3JtLCBUcmFuc2Zvcm1FcnJvciwgY2FuSm9pbiwgY2FuU3BsaXQsIGRyb3BQb2ludCwgZmluZFdyYXBwaW5nLCBpbnNlcnRQb2ludCwgam9pblBvaW50LCBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCB9O1xuIl0sIm5hbWVzIjpbIlJlcGxhY2VFcnJvciIsIlNsaWNlIiwiRnJhZ21lbnQiLCJNYXJrVHlwZSIsIk1hcmsiLCJsb3dlcjE2IiwiZmFjdG9yMTYiLCJNYXRoIiwicG93IiwibWFrZVJlY292ZXIiLCJpbmRleCIsIm9mZnNldCIsInJlY292ZXJJbmRleCIsInZhbHVlIiwicmVjb3Zlck9mZnNldCIsIkRFTF9CRUZPUkUiLCJERUxfQUZURVIiLCJERUxfQUNST1NTIiwiREVMX1NJREUiLCJNYXBSZXN1bHQiLCJjb25zdHJ1Y3RvciIsInBvcyIsImRlbEluZm8iLCJyZWNvdmVyIiwiZGVsZXRlZCIsImRlbGV0ZWRCZWZvcmUiLCJkZWxldGVkQWZ0ZXIiLCJkZWxldGVkQWNyb3NzIiwiU3RlcE1hcCIsInJhbmdlcyIsImludmVydGVkIiwibGVuZ3RoIiwiZW1wdHkiLCJkaWZmIiwiaSIsIm1hcFJlc3VsdCIsImFzc29jIiwiX21hcCIsIm1hcCIsInNpbXBsZSIsIm9sZEluZGV4IiwibmV3SW5kZXgiLCJzdGFydCIsIm9sZFNpemUiLCJuZXdTaXplIiwiZW5kIiwic2lkZSIsInJlc3VsdCIsImRlbCIsInRvdWNoZXMiLCJmb3JFYWNoIiwiZiIsIm9sZFN0YXJ0IiwibmV3U3RhcnQiLCJpbnZlcnQiLCJ0b1N0cmluZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJuIiwiTWFwcGluZyIsIm1hcHMiLCJtaXJyb3IiLCJmcm9tIiwidG8iLCJfbWFwcyIsIm93bkRhdGEiLCJzbGljZSIsImFwcGVuZE1hcCIsIm1pcnJvcnMiLCJwdXNoIiwic2V0TWlycm9yIiwiYXBwZW5kTWFwcGluZyIsIm1hcHBpbmciLCJzdGFydFNpemUiLCJtaXJyIiwiZ2V0TWlycm9yIiwidW5kZWZpbmVkIiwibSIsImFwcGVuZE1hcHBpbmdJbnZlcnRlZCIsInRvdGFsU2l6ZSIsImludmVyc2UiLCJjb3JyIiwic3RlcHNCeUlEIiwiT2JqZWN0IiwiY3JlYXRlIiwiU3RlcCIsImdldE1hcCIsIm1lcmdlIiwib3RoZXIiLCJmcm9tSlNPTiIsInNjaGVtYSIsImpzb24iLCJzdGVwVHlwZSIsIlJhbmdlRXJyb3IiLCJ0eXBlIiwianNvbklEIiwiaWQiLCJzdGVwQ2xhc3MiLCJwcm90b3R5cGUiLCJTdGVwUmVzdWx0IiwiZG9jIiwiZmFpbGVkIiwib2siLCJmYWlsIiwibWVzc2FnZSIsImZyb21SZXBsYWNlIiwicmVwbGFjZSIsImUiLCJtYXBGcmFnbWVudCIsImZyYWdtZW50IiwicGFyZW50IiwibWFwcGVkIiwiY2hpbGRDb3VudCIsImNoaWxkIiwiY29udGVudCIsInNpemUiLCJjb3B5IiwiaXNJbmxpbmUiLCJmcm9tQXJyYXkiLCJBZGRNYXJrU3RlcCIsIm1hcmsiLCJhcHBseSIsIm9sZFNsaWNlIiwiJGZyb20iLCJyZXNvbHZlIiwibm9kZSIsInNoYXJlZERlcHRoIiwiaXNBdG9tIiwiYWxsb3dzTWFya1R5cGUiLCJhZGRUb1NldCIsIm1hcmtzIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIlJlbW92ZU1hcmtTdGVwIiwiZXEiLCJtaW4iLCJtYXgiLCJ0b0pTT04iLCJtYXJrRnJvbUpTT04iLCJyZW1vdmVGcm9tU2V0IiwiQWRkTm9kZU1hcmtTdGVwIiwibm9kZUF0IiwidXBkYXRlZCIsImF0dHJzIiwiaXNMZWFmIiwibmV3U2V0IiwiaXNJblNldCIsIlJlbW92ZU5vZGVNYXJrU3RlcCIsIlJlcGxhY2VTdGVwIiwic3RydWN0dXJlIiwiY29udGVudEJldHdlZW4iLCJhcHBlbmQiLCJSZXBsYWNlQXJvdW5kU3RlcCIsImdhcEZyb20iLCJnYXBUbyIsImluc2VydCIsImdhcCIsImluc2VydGVkIiwiaW5zZXJ0QXQiLCJyZW1vdmVCZXR3ZWVuIiwiZGlzdCIsImRlcHRoIiwiaW5kZXhBZnRlciIsIm5leHQiLCJtYXliZUNoaWxkIiwiZmlyc3RDaGlsZCIsImFkZE1hcmsiLCJ0ciIsInJlbW92ZWQiLCJhZGRlZCIsInJlbW92aW5nIiwiYWRkaW5nIiwibm9kZXNCZXR3ZWVuIiwibm9kZVNpemUiLCJzIiwic3RlcCIsInJlbW92ZU1hcmsiLCJtYXRjaGVkIiwidG9SZW1vdmUiLCJzZXQiLCJmb3VuZCIsInN0eWxlIiwiaiIsImNsZWFySW5jb21wYXRpYmxlIiwicGFyZW50VHlwZSIsIm1hdGNoIiwiY29udGVudE1hdGNoIiwiY2xlYXJOZXdsaW5lcyIsInJlcGxTdGVwcyIsImN1ciIsImFsbG93ZWQiLCJtYXRjaFR5cGUiLCJpc1RleHQiLCJ3aGl0ZXNwYWNlIiwibmV3bGluZSIsImV4ZWMiLCJ0ZXh0IiwiYWxsb3dlZE1hcmtzIiwidmFsaWRFbmQiLCJmaWxsIiwiZmlsbEJlZm9yZSIsImNhbkN1dCIsImNhblJlcGxhY2UiLCJsaWZ0VGFyZ2V0IiwicmFuZ2UiLCJjdXRCeUluZGV4Iiwic3RhcnRJbmRleCIsImVuZEluZGV4IiwiY29udGVudEJlZm9yZSIsImNvbnRlbnRBZnRlciIsIiR0byIsInNwZWMiLCJpc29sYXRpbmciLCJsaWZ0IiwidGFyZ2V0IiwiZ2FwU3RhcnQiLCJiZWZvcmUiLCJnYXBFbmQiLCJhZnRlciIsImQiLCJzcGxpdHRpbmciLCJmaW5kV3JhcHBpbmciLCJub2RlVHlwZSIsImlubmVyUmFuZ2UiLCJhcm91bmQiLCJmaW5kV3JhcHBpbmdPdXRzaWRlIiwiaW5uZXIiLCJmaW5kV3JhcHBpbmdJbnNpZGUiLCJ3aXRoQXR0cnMiLCJjb25jYXQiLCJjb250ZW50TWF0Y2hBdCIsIm91dGVyIiwiY2FuUmVwbGFjZVdpdGgiLCJpbnNpZGUiLCJsYXN0VHlwZSIsImlubmVyTWF0Y2giLCJ3cmFwIiwid3JhcHBlcnMiLCJtYXRjaEZyYWdtZW50Iiwic2V0QmxvY2tUeXBlIiwiaXNUZXh0YmxvY2siLCJtYXBGcm9tIiwic3RlcHMiLCJhdHRyc0hlcmUiLCJoYXNNYXJrdXAiLCJjYW5DaGFuZ2VUeXBlIiwiY29udmVydE5ld2xpbmVzIiwibGluZWJyZWFrUmVwbGFjZW1lbnQiLCJwcmUiLCJzdXBwb3J0TGluZWJyZWFrIiwicmVwbGFjZUxpbmVicmVha3MiLCJzdGFydE0iLCJlbmRNIiwicmVwbGFjZU5ld2xpbmVzIiwicmVwbGFjZVdpdGgiLCIkcG9zIiwic2V0Tm9kZU1hcmt1cCIsIm5ld05vZGUiLCJ2YWxpZENvbnRlbnQiLCJuYW1lIiwiY2FuU3BsaXQiLCJ0eXBlc0FmdGVyIiwiYmFzZSIsImlubmVyVHlwZSIsInJlc3QiLCJvdmVycmlkZUNoaWxkIiwicmVwbGFjZUNoaWxkIiwiYmFzZVR5cGUiLCJzcGxpdCIsInR5cGVBZnRlciIsImNhbkpvaW4iLCJqb2luYWJsZSIsIm5vZGVCZWZvcmUiLCJub2RlQWZ0ZXIiLCJjYW5BcHBlbmRXaXRoU3Vic3RpdHV0ZWRMaW5lYnJlYWtzIiwiYSIsImIiLCJjb21wYXRpYmxlQ29udGVudCIsIm5vZGVzIiwiYWxsb3dzTWFya3MiLCJqb2luUG9pbnQiLCJkaXIiLCJqb2luIiwiJGJlZm9yZSIsImJlZm9yZVR5cGUiLCJpbmxpbmVDb250ZW50IiwiJGFmdGVyIiwiJGZ1bGwiLCJpbnNlcnRQb2ludCIsInBhcmVudE9mZnNldCIsImRyb3BQb2ludCIsInBhc3MiLCJiaWFzIiwiaW5zZXJ0UG9zIiwiZml0cyIsIndyYXBwaW5nIiwicmVwbGFjZVN0ZXAiLCJmaXRzVHJpdmlhbGx5IiwiRml0dGVyIiwiZml0IiwidW5wbGFjZWQiLCJmcm9udGllciIsInBsYWNlZCIsImZpbmRGaXR0YWJsZSIsInBsYWNlTm9kZXMiLCJvcGVuTW9yZSIsImRyb3BOb2RlIiwibW92ZUlubGluZSIsIm11c3RNb3ZlSW5saW5lIiwicGxhY2VkU2l6ZSIsImNsb3NlIiwic3RhcnREZXB0aCIsInNsaWNlRGVwdGgiLCJjb250ZW50QXQiLCJmaXJzdCIsImZyb250aWVyRGVwdGgiLCJpbmplY3QiLCJvcGVuQXRFbmQiLCJkcm9wRnJvbUZyYWdtZW50IiwiY2xvc2VGcm9udGllck5vZGUiLCJvcGVuRnJvbnRpZXJOb2RlIiwidGFrZW4iLCJhZGQiLCJvcGVuRW5kQ291bnQiLCJtYXRjaGVzIiwiY2xvc2VOb2RlU3RhcnQiLCJ0b0VuZCIsImFkZFRvRnJhZ21lbnQiLCJsYXN0Q2hpbGQiLCJ0b3AiLCJsZXZlbCIsImNvbnRlbnRBZnRlckZpdHMiLCJmaW5kQ2xvc2VMZXZlbCIsInNjYW4iLCJkcm9wSW5uZXIiLCJtb3ZlIiwib3BlbiIsInBvcCIsImNvdW50IiwiZnJhZyIsImludmFsaWRNYXJrcyIsImRlZmluZXNDb250ZW50IiwiZGVmaW5pbmciLCJkZWZpbmluZ0ZvckNvbnRlbnQiLCJyZXBsYWNlUmFuZ2UiLCJkZWxldGVSYW5nZSIsInRhcmdldERlcHRocyIsImNvdmVyZWREZXB0aHMiLCJwcmVmZXJyZWRUYXJnZXQiLCJ1bnNoaWZ0IiwiZGVmaW5pbmdBc0NvbnRleHQiLCJpbmRleE9mIiwic3BsaWNlIiwicHJlZmVycmVkVGFyZ2V0SW5kZXgiLCJsZWZ0Tm9kZXMiLCJwcmVmZXJyZWREZXB0aCIsImxlZnROb2RlIiwiZGVmIiwic2FtZU1hcmt1cCIsImFicyIsIm9wZW5EZXB0aCIsInRhcmdldERlcHRoIiwiZXhwYW5kIiwiY2xvc2VGcmFnbWVudCIsInN0YXJ0U3RlcHMiLCJvbGRPcGVuIiwibmV3T3BlbiIsInJlcGxhY2VSYW5nZVdpdGgiLCJwb2ludCIsImNvdmVyZWQiLCJsYXN0IiwiZGVsZXRlIiwibWluRGVwdGgiLCJBdHRyU3RlcCIsImF0dHIiLCJEb2NBdHRyU3RlcCIsIlRyYW5zZm9ybUVycm9yIiwiRXJyb3IiLCJlcnIiLCJjYWxsIiwiX19wcm90b19fIiwiVHJhbnNmb3JtIiwiZG9jcyIsIm1heWJlU3RlcCIsImFkZFN0ZXAiLCJkb2NDaGFuZ2VkIiwic2V0Tm9kZUF0dHJpYnV0ZSIsInNldERvY0F0dHJpYnV0ZSIsImFkZE5vZGVNYXJrIiwicmVtb3ZlTm9kZU1hcmsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/prosemirror-transform/dist/index.js\n");

/***/ })

};
;